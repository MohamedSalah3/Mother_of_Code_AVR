
Mother_of_Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000527a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000082  00800060  0000527a  0000530e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000510  008000e2  008000e2  00005390  2**0
                  ALLOC
  3 .stab         00001c50  00000000  00000000  00005390  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000005e5  00000000  00000000  00006fe0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000400  00000000  00000000  000075c8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007204  00000000  00000000  000079c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002050  00000000  00000000  0000ebcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002cfd  00000000  00000000  00010c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001d50  00000000  00000000  0001391c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002885  00000000  00000000  0001566c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007d09  00000000  00000000  00017ef1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  0001fbfa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 e9 06 	jmp	0xdd2	; 0xdd2 <__vector_1>
       8:	0c 94 10 07 	jmp	0xe20	; 0xe20 <__vector_2>
       c:	0c 94 37 07 	jmp	0xe6e	; 0xe6e <__vector_3>
      10:	0c 94 5e 07 	jmp	0xebc	; 0xebc <__vector_4>
      14:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__vector_5>
      18:	0c 94 ac 07 	jmp	0xf58	; 0xf58 <__vector_6>
      1c:	0c 94 d3 07 	jmp	0xfa6	; 0xfa6 <__vector_7>
      20:	0c 94 fa 07 	jmp	0xff4	; 0xff4 <__vector_8>
      24:	0c 94 21 08 	jmp	0x1042	; 0x1042 <__vector_9>
      28:	0c 94 48 08 	jmp	0x1090	; 0x1090 <__vector_10>
      2c:	0c 94 6f 08 	jmp	0x10de	; 0x10de <__vector_11>
      30:	0c 94 96 08 	jmp	0x112c	; 0x112c <__vector_12>
      34:	0c 94 bd 08 	jmp	0x117a	; 0x117a <__vector_13>
      38:	0c 94 e4 08 	jmp	0x11c8	; 0x11c8 <__vector_14>
      3c:	0c 94 0b 09 	jmp	0x1216	; 0x1216 <__vector_15>
      40:	0c 94 32 09 	jmp	0x1264	; 0x1264 <__vector_16>
      44:	0c 94 59 09 	jmp	0x12b2	; 0x12b2 <__vector_17>
      48:	0c 94 80 09 	jmp	0x1300	; 0x1300 <__vector_18>
      4c:	0c 94 a7 09 	jmp	0x134e	; 0x134e <__vector_19>
      50:	0c 94 ce 09 	jmp	0x139c	; 0x139c <__vector_20>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e7       	ldi	r30, 0x7A	; 122
      68:	f2 e5       	ldi	r31, 0x52	; 82
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3e       	cpi	r26, 0xE2	; 226
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a2 ee       	ldi	r26, 0xE2	; 226
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 3f       	cpi	r26, 0xF2	; 242
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 39 12 	call	0x2472	; 0x2472 <main>
      8a:	0c 94 3b 29 	jmp	0x5276	; 0x5276 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Car_SM_Init>:
//extern uint16_t Distance;
static uint16_t Distance;
ERROR_STATUS Car_SM_Init(void)
{
uint8_t ret=E_OK;
Steering_Init();
      92:	0e 94 ce 01 	call	0x39c	; 0x39c <Steering_Init>
Us_Init();
      96:	0e 94 83 06 	call	0xd06	; 0xd06 <Us_Init>
return ret;
}
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	08 95       	ret

0000009e <Car_SM_Update>:


ERROR_STATUS Car_SM_Update(void)
{uint8_t ret=E_OK;
Us_Trigger();
      9e:	0e 94 8c 06 	call	0xd18	; 0xd18 <Us_Trigger>
Us_GetDistance(&Distance);
      a2:	82 ee       	ldi	r24, 0xE2	; 226
      a4:	90 e0       	ldi	r25, 0x00	; 0
      a6:	0e 94 a2 06 	call	0xd44	; 0xd44 <Us_GetDistance>

if(Distance <= 30)
      aa:	80 91 e2 00 	lds	r24, 0x00E2
      ae:	90 91 e3 00 	lds	r25, 0x00E3
      b2:	8f 31       	cpi	r24, 0x1F	; 31
      b4:	91 05       	cpc	r25, r1
      b6:	28 f4       	brcc	.+10     	; 0xc2 <Car_SM_Update+0x24>
{
	
	Steering_SteerCar(CAR_RIGHT,50);
      b8:	83 e0       	ldi	r24, 0x03	; 3
      ba:	62 e3       	ldi	r22, 0x32	; 50
      bc:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <Steering_SteerCar>
      c0:	04 c0       	rjmp	.+8      	; 0xca <Car_SM_Update+0x2c>
}else
{
	Steering_SteerCar(CAR_FORWARD,50);
      c2:	81 e0       	ldi	r24, 0x01	; 1
      c4:	62 e3       	ldi	r22, 0x32	; 50
      c6:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <Steering_SteerCar>
}

return ret;
}	
      ca:	80 e0       	ldi	r24, 0x00	; 0
      cc:	08 95       	ret

000000ce <Display_Task>:
	u8_Init_finished=0;

	
	}
*/
		LCD_goto_xy(0,0);
      ce:	80 e0       	ldi	r24, 0x00	; 0
      d0:	60 e0       	ldi	r22, 0x00	; 0
      d2:	0e 94 ed 02 	call	0x5da	; 0x5da <LCD_goto_xy>
		LCD_send_char('x');
      d6:	88 e7       	ldi	r24, 0x78	; 120
      d8:	0e 94 76 02 	call	0x4ec	; 0x4ec <LCD_send_char>



}
      dc:	08 95       	ret

000000de <Push_Task>:
		u8_Counter1=0;
	}
	

	*/
DIO_Toggle(GPIOD,BIT4);
      de:	83 e0       	ldi	r24, 0x03	; 3
      e0:	60 e1       	ldi	r22, 0x10	; 16
      e2:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>
}
      e6:	08 95       	ret

000000e8 <Push_Task1>:
void Push_Task1(void)
{
u8_flag_push = pushButtonGetStatus(BTN_0);
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <pushButtonGetStatus>
      ee:	80 93 e5 00 	sts	0x00E5, r24
if (u8_flag_push)
      f2:	88 23       	and	r24, r24
      f4:	19 f0       	breq	.+6      	; 0xfc <Push_Task1+0x14>
{
	u8_State_Machine=BUTTON_PRESSED;
      f6:	87 e0       	ldi	r24, 0x07	; 7
      f8:	80 93 e6 00 	sts	0x00E6, r24
      fc:	08 95       	ret

000000fe <Push_Task2>:
}
}
void Push_Task2(void){
	DIO_Toggle(GPIOD,BIT2);
      fe:	83 e0       	ldi	r24, 0x03	; 3
     100:	64 e0       	ldi	r22, 0x04	; 4
     102:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>
}
     106:	08 95       	ret

00000108 <Read_Time_Task>:

void Read_Time_Task(void)
{
	static uint8_t st_u16_indix=0;
	adc_read();
     108:	0e 94 c9 0a 	call	0x1592	; 0x1592 <adc_read>
//u16_ADC_readings_Channel[st_u16_indix]
if (st_u16_indix <3)
     10c:	80 91 e7 00 	lds	r24, 0x00E7
     110:	83 30       	cpi	r24, 0x03	; 3
     112:	20 f4       	brcc	.+8      	; 0x11c <Read_Time_Task+0x14>
{st_u16_indix++;}
     114:	8f 5f       	subi	r24, 0xFF	; 255
     116:	80 93 e7 00 	sts	0x00E7, r24
     11a:	02 c0       	rjmp	.+4      	; 0x120 <Read_Time_Task+0x18>
else{st_u16_indix=0;}
     11c:	10 92 e7 00 	sts	0x00E7, r1
Timing_arr[st_u16_indix]=(u16_ADC_readings_Channel[st_u16_indix])*2;
     120:	80 91 e7 00 	lds	r24, 0x00E7
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	88 0f       	add	r24, r24
     128:	99 1f       	adc	r25, r25
     12a:	fc 01       	movw	r30, r24
     12c:	e0 5a       	subi	r30, 0xA0	; 160
     12e:	ff 4f       	sbci	r31, 0xFF	; 255
     130:	86 57       	subi	r24, 0x76	; 118
     132:	9a 4f       	sbci	r25, 0xFA	; 250
     134:	dc 01       	movw	r26, r24
     136:	8d 91       	ld	r24, X+
     138:	9c 91       	ld	r25, X
     13a:	11 97       	sbiw	r26, 0x01	; 1
     13c:	88 0f       	add	r24, r24
     13e:	99 1f       	adc	r25, r25
     140:	91 83       	std	Z+1, r25	; 0x01
     142:	80 83       	st	Z, r24


}
     144:	08 95       	ret

00000146 <relay2>:
}

void relay2(void)
{
	/*************************************************************************************/
	counting_arr[2] += 1;
     146:	80 91 ec 00 	lds	r24, 0x00EC
     14a:	90 91 ed 00 	lds	r25, 0x00ED
     14e:	01 96       	adiw	r24, 0x01	; 1
     150:	90 93 ed 00 	sts	0x00ED, r25
     154:	80 93 ec 00 	sts	0x00EC, r24
	/*************************************************************************************/
	/*************************************************************************************/
	if (counting_arr[2]==Timing_arr[2])
     158:	20 91 64 00 	lds	r18, 0x0064
     15c:	30 91 65 00 	lds	r19, 0x0065
     160:	82 17       	cp	r24, r18
     162:	93 07       	cpc	r25, r19
     164:	51 f4       	brne	.+20     	; 0x17a <relay2+0x34>
	{DIO_Toggle(GPIOD,BIT4);
     166:	83 e0       	ldi	r24, 0x03	; 3
     168:	60 e1       	ldi	r22, 0x10	; 16
     16a:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>
		counting_arr[2]=0;
     16e:	10 92 ed 00 	sts	0x00ED, r1
     172:	10 92 ec 00 	sts	0x00EC, r1
		relay0();
     176:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <relay0>
     17a:	08 95       	ret

0000017c <relay1>:
}

void relay1(void)
{
	/*************************************************************************************/
	counting_arr[1] += 1;
     17c:	80 91 ea 00 	lds	r24, 0x00EA
     180:	90 91 eb 00 	lds	r25, 0x00EB
     184:	01 96       	adiw	r24, 0x01	; 1
     186:	90 93 eb 00 	sts	0x00EB, r25
     18a:	80 93 ea 00 	sts	0x00EA, r24
	/*************************************************************************************/
	/*************************************************************************************/
	if (counting_arr[1]==Timing_arr[1])
     18e:	20 91 62 00 	lds	r18, 0x0062
     192:	30 91 63 00 	lds	r19, 0x0063
     196:	82 17       	cp	r24, r18
     198:	93 07       	cpc	r25, r19
     19a:	51 f4       	brne	.+20     	; 0x1b0 <relay1+0x34>
	{DIO_Toggle(GPIOD,BIT2);
     19c:	83 e0       	ldi	r24, 0x03	; 3
     19e:	64 e0       	ldi	r22, 0x04	; 4
     1a0:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>
		counting_arr[1]=0;
     1a4:	10 92 eb 00 	sts	0x00EB, r1
     1a8:	10 92 ea 00 	sts	0x00EA, r1
		relay2();
     1ac:	0e 94 a3 00 	call	0x146	; 0x146 <relay2>
     1b0:	08 95       	ret

000001b2 <relay0>:
}

void relay0(void)
{
/*************************************************************************************/
counting_arr[0] += 1;
     1b2:	80 91 e8 00 	lds	r24, 0x00E8
     1b6:	90 91 e9 00 	lds	r25, 0x00E9
     1ba:	01 96       	adiw	r24, 0x01	; 1
     1bc:	90 93 e9 00 	sts	0x00E9, r25
     1c0:	80 93 e8 00 	sts	0x00E8, r24
/*************************************************************************************/
/*************************************************************************************/
if (counting_arr[0]==Timing_arr[0])
     1c4:	20 91 60 00 	lds	r18, 0x0060
     1c8:	30 91 61 00 	lds	r19, 0x0061
     1cc:	82 17       	cp	r24, r18
     1ce:	93 07       	cpc	r25, r19
     1d0:	51 f4       	brne	.+20     	; 0x1e6 <relay0+0x34>
{
	DIO_Toggle(GPIOD,BIT2);
     1d2:	83 e0       	ldi	r24, 0x03	; 3
     1d4:	64 e0       	ldi	r22, 0x04	; 4
     1d6:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>
	counting_arr[0]=0;
     1da:	10 92 e9 00 	sts	0x00E9, r1
     1de:	10 92 e8 00 	sts	0x00E8, r1
	relay1();
     1e2:	0e 94 be 00 	call	0x17c	; 0x17c <relay1>
     1e6:	08 95       	ret

000001e8 <update_timing>:
SOS_Create_Task(Push_Task1,1,4,20);
SOS_Create_Task(Push_Task2,1,5,30);
*/

/*************************************************************************************/
if (u8_State_Machine == BUTTON_PRESSED || u8_State_Machine == RELAY0_COUNTING)
     1e8:	80 91 e6 00 	lds	r24, 0x00E6
     1ec:	87 30       	cpi	r24, 0x07	; 7
     1ee:	11 f0       	breq	.+4      	; 0x1f4 <update_timing+0xc>
     1f0:	81 30       	cpi	r24, 0x01	; 1
     1f2:	91 f4       	brne	.+36     	; 0x218 <update_timing+0x30>
{
	DIO_Write(GPIOD,BIT2,HIGH);
     1f4:	83 e0       	ldi	r24, 0x03	; 3
     1f6:	64 e0       	ldi	r22, 0x04	; 4
     1f8:	4f ef       	ldi	r20, 0xFF	; 255
     1fa:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
	counting_arr[0] += 1;
     1fe:	80 91 e8 00 	lds	r24, 0x00E8
     202:	90 91 e9 00 	lds	r25, 0x00E9
     206:	01 96       	adiw	r24, 0x01	; 1
     208:	90 93 e9 00 	sts	0x00E9, r25
     20c:	80 93 e8 00 	sts	0x00E8, r24
	
	u8_State_Machine=RELAY0_COUNTING;
     210:	81 e0       	ldi	r24, 0x01	; 1
     212:	80 93 e6 00 	sts	0x00E6, r24
     216:	22 c0       	rjmp	.+68     	; 0x25c <update_timing+0x74>
}
	    
/*************************************************************************************/
   if (u8_State_Machine==RELAY0_ACTION_DONE)// || u8_State_Machine == RELAY1_COUNTING)
     218:	84 30       	cpi	r24, 0x04	; 4
     21a:	71 f4       	brne	.+28     	; 0x238 <update_timing+0x50>
   {
	DIO_Write(GPIOD,BIT3,HIGH);   
     21c:	83 e0       	ldi	r24, 0x03	; 3
     21e:	68 e0       	ldi	r22, 0x08	; 8
     220:	4f ef       	ldi	r20, 0xFF	; 255
     222:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
	    counting_arr[1] += 1;
     226:	80 91 ea 00 	lds	r24, 0x00EA
     22a:	90 91 eb 00 	lds	r25, 0x00EB
     22e:	01 96       	adiw	r24, 0x01	; 1
     230:	90 93 eb 00 	sts	0x00EB, r25
     234:	80 93 ea 00 	sts	0x00EA, r24
	//	u8_State_Machine=RELAY1_COUNTING;
   }
   
/*************************************************************************************/
if (u8_State_Machine == RELAY1_ACTION_DONE )//|| u8_State_Machine == RELAY2_COUNTING)
     238:	80 91 e6 00 	lds	r24, 0x00E6
     23c:	85 30       	cpi	r24, 0x05	; 5
     23e:	71 f4       	brne	.+28     	; 0x25c <update_timing+0x74>
{
	DIO_Write(GPIOD,BIT4,HIGH);
     240:	83 e0       	ldi	r24, 0x03	; 3
     242:	60 e1       	ldi	r22, 0x10	; 16
     244:	4f ef       	ldi	r20, 0xFF	; 255
     246:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
     counting_arr[2] += 1;
     24a:	80 91 ec 00 	lds	r24, 0x00EC
     24e:	90 91 ed 00 	lds	r25, 0x00ED
     252:	01 96       	adiw	r24, 0x01	; 1
     254:	90 93 ed 00 	sts	0x00ED, r25
     258:	80 93 ec 00 	sts	0x00EC, r24
//	 u8_State_Machine=RELAY2_COUNTING;
}

	
/*************************************************************************************/
if (counting_arr[0]==Timing_arr[0])
     25c:	20 91 e8 00 	lds	r18, 0x00E8
     260:	30 91 e9 00 	lds	r19, 0x00E9
     264:	80 91 60 00 	lds	r24, 0x0060
     268:	90 91 61 00 	lds	r25, 0x0061
     26c:	28 17       	cp	r18, r24
     26e:	39 07       	cpc	r19, r25
     270:	09 f5       	brne	.+66     	; 0x2b4 <update_timing+0xcc>
{
	DIO_Write(GPIOD,BIT2,LOW);
     272:	83 e0       	ldi	r24, 0x03	; 3
     274:	64 e0       	ldi	r22, 0x04	; 4
     276:	40 e0       	ldi	r20, 0x00	; 0
     278:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
	UartTransmitPooling('A');
     27c:	81 e4       	ldi	r24, 0x41	; 65
     27e:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('D');
     282:	84 e4       	ldi	r24, 0x44	; 68
     284:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('C');
     288:	83 e4       	ldi	r24, 0x43	; 67
     28a:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('0');
     28e:	80 e3       	ldi	r24, 0x30	; 48
     290:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('=');
     294:	8d e3       	ldi	r24, 0x3D	; 61
     296:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[0]);
     29a:	80 91 e8 00 	lds	r24, 0x00E8
     29e:	90 91 e9 00 	lds	r25, 0x00E9
     2a2:	0e 94 06 12 	call	0x240c	; 0x240c <uart_transmit_u16>
counting_arr[0]=0;
     2a6:	10 92 e9 00 	sts	0x00E9, r1
     2aa:	10 92 e8 00 	sts	0x00E8, r1
u8_State_Machine=RELAY0_ACTION_DONE;
     2ae:	84 e0       	ldi	r24, 0x04	; 4
     2b0:	80 93 e6 00 	sts	0x00E6, r24
}
/**************************************************************************************/
if (counting_arr[1]==Timing_arr[1] && u8_State_Machine==RELAY0_ACTION_DONE)
     2b4:	20 91 ea 00 	lds	r18, 0x00EA
     2b8:	30 91 eb 00 	lds	r19, 0x00EB
     2bc:	80 91 62 00 	lds	r24, 0x0062
     2c0:	90 91 63 00 	lds	r25, 0x0063
     2c4:	28 17       	cp	r18, r24
     2c6:	39 07       	cpc	r19, r25
     2c8:	61 f5       	brne	.+88     	; 0x322 <update_timing+0x13a>
     2ca:	80 91 e6 00 	lds	r24, 0x00E6
     2ce:	84 30       	cpi	r24, 0x04	; 4
     2d0:	41 f5       	brne	.+80     	; 0x322 <update_timing+0x13a>
{
	DIO_Write(GPIOD,BIT2,LOW);
     2d2:	83 e0       	ldi	r24, 0x03	; 3
     2d4:	64 e0       	ldi	r22, 0x04	; 4
     2d6:	40 e0       	ldi	r20, 0x00	; 0
     2d8:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
DIO_Toggle(GPIOD,BIT3);
     2dc:	83 e0       	ldi	r24, 0x03	; 3
     2de:	68 e0       	ldi	r22, 0x08	; 8
     2e0:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>
UartTransmitPooling(' ');
     2e4:	80 e2       	ldi	r24, 0x20	; 32
     2e6:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('A');
     2ea:	81 e4       	ldi	r24, 0x41	; 65
     2ec:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('D');
     2f0:	84 e4       	ldi	r24, 0x44	; 68
     2f2:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('C');
     2f6:	83 e4       	ldi	r24, 0x43	; 67
     2f8:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('1');
     2fc:	81 e3       	ldi	r24, 0x31	; 49
     2fe:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	UartTransmitPooling('=');
     302:	8d e3       	ldi	r24, 0x3D	; 61
     304:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
uart_transmit_u16(counting_arr[1]);
     308:	80 91 ea 00 	lds	r24, 0x00EA
     30c:	90 91 eb 00 	lds	r25, 0x00EB
     310:	0e 94 06 12 	call	0x240c	; 0x240c <uart_transmit_u16>
counting_arr[1]=0;
     314:	10 92 eb 00 	sts	0x00EB, r1
     318:	10 92 ea 00 	sts	0x00EA, r1
u8_State_Machine=RELAY1_ACTION_DONE;
     31c:	85 e0       	ldi	r24, 0x05	; 5
     31e:	80 93 e6 00 	sts	0x00E6, r24
}
/**************************************************************************************/
if (counting_arr[2]==Timing_arr[2]&& u8_State_Machine==RELAY1_ACTION_DONE)
     322:	20 91 ec 00 	lds	r18, 0x00EC
     326:	30 91 ed 00 	lds	r19, 0x00ED
     32a:	80 91 64 00 	lds	r24, 0x0064
     32e:	90 91 65 00 	lds	r25, 0x0065
     332:	28 17       	cp	r18, r24
     334:	39 07       	cpc	r19, r25
     336:	51 f5       	brne	.+84     	; 0x38c <update_timing+0x1a4>
     338:	80 91 e6 00 	lds	r24, 0x00E6
     33c:	85 30       	cpi	r24, 0x05	; 5
     33e:	31 f5       	brne	.+76     	; 0x38c <update_timing+0x1a4>
{
	DIO_Write(GPIOD,BIT3,LOW);
     340:	83 e0       	ldi	r24, 0x03	; 3
     342:	68 e0       	ldi	r22, 0x08	; 8
     344:	40 e0       	ldi	r20, 0x00	; 0
     346:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
DIO_Toggle(GPIOD,BIT4);
     34a:	83 e0       	ldi	r24, 0x03	; 3
     34c:	60 e1       	ldi	r22, 0x10	; 16
     34e:	0e 94 a4 0b 	call	0x1748	; 0x1748 <DIO_Toggle>

UartTransmitPooling(' ');
     352:	80 e2       	ldi	r24, 0x20	; 32
     354:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
UartTransmitPooling('A');
     358:	81 e4       	ldi	r24, 0x41	; 65
     35a:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
UartTransmitPooling('D');
     35e:	84 e4       	ldi	r24, 0x44	; 68
     360:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
UartTransmitPooling('C');
     364:	83 e4       	ldi	r24, 0x43	; 67
     366:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
UartTransmitPooling('2');
     36a:	82 e3       	ldi	r24, 0x32	; 50
     36c:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
UartTransmitPooling('=');
     370:	8d e3       	ldi	r24, 0x3D	; 61
     372:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
uart_transmit_u16(counting_arr[2]);
     376:	80 91 ec 00 	lds	r24, 0x00EC
     37a:	90 91 ed 00 	lds	r25, 0x00ED
     37e:	0e 94 06 12 	call	0x240c	; 0x240c <uart_transmit_u16>
counting_arr[2]=0;
     382:	10 92 ed 00 	sts	0x00ED, r1
     386:	10 92 ec 00 	sts	0x00EC, r1
     38a:	04 c0       	rjmp	.+8      	; 0x394 <update_timing+0x1ac>
u8_State_Machine=RELAY2_ACTION_DONE;
}
if (u8_State_Machine == RELAY2_ACTION_DONE)
     38c:	80 91 e6 00 	lds	r24, 0x00E6
     390:	86 30       	cpi	r24, 0x06	; 6
     392:	11 f4       	brne	.+4      	; 0x398 <update_timing+0x1b0>
{
	u8_State_Machine=NO_ACTION;
     394:	10 92 e6 00 	sts	0x00E6, r1
     398:	08 95       	ret

0000039a <uart_send_sos>:
{
	
	
	
	
}
     39a:	08 95       	ret

0000039c <Steering_Init>:


ERROR_STATUS Steering_Init(void)
{
	uint8_t ret=0;
	ret=Motor_Init(MOTOR_1|MOTOR_2);
     39c:	83 e0       	ldi	r24, 0x03	; 3
     39e:	0e 94 1a 05 	call	0xa34	; 0xa34 <Motor_Init>
	return ret;
}
     3a2:	08 95       	ret

000003a4 <Steering_SteerCar>:


ERROR_STATUS Steering_SteerCar(uint8_t Steering_CarCmd, uint8_t speed)
{
     3a4:	cf 93       	push	r28
     3a6:	c6 2f       	mov	r28, r22
	uint8_t ret=0;
		switch(Steering_CarCmd)
     3a8:	82 30       	cpi	r24, 0x02	; 2
     3aa:	a1 f0       	breq	.+40     	; 0x3d4 <Steering_SteerCar+0x30>
     3ac:	83 30       	cpi	r24, 0x03	; 3
     3ae:	20 f4       	brcc	.+8      	; 0x3b8 <Steering_SteerCar+0x14>
     3b0:	81 30       	cpi	r24, 0x01	; 1
     3b2:	09 f0       	breq	.+2      	; 0x3b6 <Steering_SteerCar+0x12>
     3b4:	42 c0       	rjmp	.+132    	; 0x43a <Steering_SteerCar+0x96>
     3b6:	05 c0       	rjmp	.+10     	; 0x3c2 <Steering_SteerCar+0x1e>
     3b8:	83 30       	cpi	r24, 0x03	; 3
     3ba:	51 f1       	breq	.+84     	; 0x410 <Steering_SteerCar+0x6c>
     3bc:	84 30       	cpi	r24, 0x04	; 4
     3be:	e9 f5       	brne	.+122    	; 0x43a <Steering_SteerCar+0x96>
     3c0:	12 c0       	rjmp	.+36     	; 0x3e6 <Steering_SteerCar+0x42>
	{
		case CAR_FORWARD:
			ret= Motor_Direction(MOTOR_1|MOTOR_2, CAR_FORWARD);
     3c2:	83 e0       	ldi	r24, 0x03	; 3
     3c4:	61 e0       	ldi	r22, 0x01	; 1
     3c6:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     3ca:	83 e0       	ldi	r24, 0x03	; 3
     3cc:	6c 2f       	mov	r22, r28
     3ce:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <Motor_Start>
			break;
     3d2:	34 c0       	rjmp	.+104    	; 0x43c <Steering_SteerCar+0x98>
			case CAR_BACKWARD:
			ret= Motor_Direction(MOTOR_1|MOTOR_2,CAR_BACKWARD);
     3d4:	83 e0       	ldi	r24, 0x03	; 3
     3d6:	62 e0       	ldi	r22, 0x02	; 2
     3d8:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     3dc:	83 e0       	ldi	r24, 0x03	; 3
     3de:	6c 2f       	mov	r22, r28
     3e0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <Motor_Start>
			break;
     3e4:	2b c0       	rjmp	.+86     	; 0x43c <Steering_SteerCar+0x98>
			case CAR_LEFT:
			ret= Motor_Direction(MOTOR_1, CAR_FORWARD);
     3e6:	81 e0       	ldi	r24, 0x01	; 1
     3e8:	61 e0       	ldi	r22, 0x01	; 1
     3ea:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_BACKWARD);
     3ee:	82 e0       	ldi	r24, 0x02	; 2
     3f0:	62 e0       	ldi	r22, 0x02	; 2
     3f2:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     3f6:	83 e0       	ldi	r24, 0x03	; 3
     3f8:	6c 2f       	mov	r22, r28
     3fa:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <Motor_Start>

/*************************************************************/
			ret= Motor_Direction(MOTOR_1, CAR_STOP);
     3fe:	81 e0       	ldi	r24, 0x01	; 1
     400:	60 e0       	ldi	r22, 0x00	; 0
     402:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_STOP);
     406:	82 e0       	ldi	r24, 0x02	; 2
     408:	60 e0       	ldi	r22, 0x00	; 0
     40a:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			break;
     40e:	16 c0       	rjmp	.+44     	; 0x43c <Steering_SteerCar+0x98>
			case CAR_RIGHT:
			ret= Motor_Direction(MOTOR_1, CAR_BACKWARD);
     410:	81 e0       	ldi	r24, 0x01	; 1
     412:	62 e0       	ldi	r22, 0x02	; 2
     414:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_FORWARD);
     418:	82 e0       	ldi	r24, 0x02	; 2
     41a:	61 e0       	ldi	r22, 0x01	; 1
     41c:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     420:	83 e0       	ldi	r24, 0x03	; 3
     422:	6c 2f       	mov	r22, r28
     424:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <Motor_Start>
		/*	timer2Start();
			timer2DelayMs(100);
*//***********************************************************/
			ret= Motor_Direction(MOTOR_1, CAR_STOP);
     428:	81 e0       	ldi	r24, 0x01	; 1
     42a:	60 e0       	ldi	r22, 0x00	; 0
     42c:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_STOP);
     430:	82 e0       	ldi	r24, 0x02	; 2
     432:	60 e0       	ldi	r22, 0x00	; 0
     434:	0e 94 49 05 	call	0xa92	; 0xa92 <Motor_Direction>
			break;
     438:	01 c0       	rjmp	.+2      	; 0x43c <Steering_SteerCar+0x98>
}


ERROR_STATUS Steering_SteerCar(uint8_t Steering_CarCmd, uint8_t speed)
{
	uint8_t ret=0;
     43a:	80 e0       	ldi	r24, 0x00	; 0
			break;
	}
	
	
return ret;
     43c:	cf 91       	pop	r28
     43e:	08 95       	ret

00000440 <LCD_EN_pulse>:
 #include <stdlib.h>
extern uint8_t u8_Init_finished;
 static uint8_t U8_index=0;
 void LCD_EN_pulse(void)
 {
	 DIO_Write(LCD_EN_PORT, LCD_EN_PIN, HIGH);
     440:	81 e0       	ldi	r24, 0x01	; 1
     442:	68 e0       	ldi	r22, 0x08	; 8
     444:	4f ef       	ldi	r20, 0xFF	; 255
     446:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
/***********************************************************/
	 SwDelay_us(10);
     44a:	6a e0       	ldi	r22, 0x0A	; 10
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 e0       	ldi	r24, 0x00	; 0
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	0e 94 78 06 	call	0xcf0	; 0xcf0 <SwDelay_us>
	 DIO_Write(LCD_EN_PORT, LCD_EN_PIN, LOW);
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	68 e0       	ldi	r22, 0x08	; 8
     45a:	40 e0       	ldi	r20, 0x00	; 0
     45c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
/*************************************************************/	 
	 SwDelay_us(10);
     460:	6a e0       	ldi	r22, 0x0A	; 10
     462:	70 e0       	ldi	r23, 0x00	; 0
     464:	80 e0       	ldi	r24, 0x00	; 0
     466:	90 e0       	ldi	r25, 0x00	; 0
     468:	0e 94 78 06 	call	0xcf0	; 0xcf0 <SwDelay_us>
 }
     46c:	08 95       	ret

0000046e <LCD_config_pins>:

 void LCD_config_pins(void){

	 /* set LCD pins as outputs */
	DIO_init(&Dio_configurationB);
     46e:	88 eb       	ldi	r24, 0xB8	; 184
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
}
     476:	08 95       	ret

00000478 <LCD_send_nibble>:

 void LCD_send_nibble(uint8_t data){
     478:	cf 93       	push	r28
	 uint8_t mask = 1;
	 data >>= 4;
     47a:	c8 2f       	mov	r28, r24
     47c:	c2 95       	swap	r28
     47e:	cf 70       	andi	r28, 0x0F	; 15
	 if(data & mask)
     480:	c0 ff       	sbrs	r28, 0
     482:	06 c0       	rjmp	.+12     	; 0x490 <LCD_send_nibble+0x18>
	 DIO_Write(LCD_D4_PORT, LCD_D4_PIN, HIGH);
     484:	81 e0       	ldi	r24, 0x01	; 1
     486:	60 e1       	ldi	r22, 0x10	; 16
     488:	4f ef       	ldi	r20, 0xFF	; 255
     48a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
     48e:	05 c0       	rjmp	.+10     	; 0x49a <LCD_send_nibble+0x22>
	 else
	 DIO_Write(LCD_D4_PORT, LCD_D4_PIN, LOW);
     490:	81 e0       	ldi	r24, 0x01	; 1
     492:	60 e1       	ldi	r22, 0x10	; 16
     494:	40 e0       	ldi	r20, 0x00	; 0
     496:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     49a:	c1 ff       	sbrs	r28, 1
     49c:	06 c0       	rjmp	.+12     	; 0x4aa <LCD_send_nibble+0x32>
	 DIO_Write(LCD_D5_PORT, LCD_D5_PIN, HIGH);
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	60 e2       	ldi	r22, 0x20	; 32
     4a2:	4f ef       	ldi	r20, 0xFF	; 255
     4a4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
     4a8:	05 c0       	rjmp	.+10     	; 0x4b4 <LCD_send_nibble+0x3c>
	 else
	 DIO_Write(LCD_D5_PORT, LCD_D5_PIN, LOW);
     4aa:	81 e0       	ldi	r24, 0x01	; 1
     4ac:	60 e2       	ldi	r22, 0x20	; 32
     4ae:	40 e0       	ldi	r20, 0x00	; 0
     4b0:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     4b4:	c2 ff       	sbrs	r28, 2
     4b6:	06 c0       	rjmp	.+12     	; 0x4c4 <LCD_send_nibble+0x4c>
	 DIO_Write(LCD_D6_PORT, LCD_D6_PIN, HIGH);
     4b8:	81 e0       	ldi	r24, 0x01	; 1
     4ba:	60 e4       	ldi	r22, 0x40	; 64
     4bc:	4f ef       	ldi	r20, 0xFF	; 255
     4be:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
     4c2:	05 c0       	rjmp	.+10     	; 0x4ce <LCD_send_nibble+0x56>
	 else
	 DIO_Write(LCD_D6_PORT, LCD_D6_PIN, LOW);
     4c4:	81 e0       	ldi	r24, 0x01	; 1
     4c6:	60 e4       	ldi	r22, 0x40	; 64
     4c8:	40 e0       	ldi	r20, 0x00	; 0
     4ca:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     4ce:	c8 70       	andi	r28, 0x08	; 8
     4d0:	31 f0       	breq	.+12     	; 0x4de <LCD_send_nibble+0x66>
	 DIO_Write(LCD_D7_PORT, LCD_D7_PIN, HIGH);
     4d2:	81 e0       	ldi	r24, 0x01	; 1
     4d4:	60 e8       	ldi	r22, 0x80	; 128
     4d6:	4f ef       	ldi	r20, 0xFF	; 255
     4d8:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
     4dc:	05 c0       	rjmp	.+10     	; 0x4e8 <LCD_send_nibble+0x70>
	 else
	 DIO_Write(LCD_D7_PORT, LCD_D7_PIN, LOW);
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	60 e8       	ldi	r22, 0x80	; 128
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
 }
     4e8:	cf 91       	pop	r28
     4ea:	08 95       	ret

000004ec <LCD_send_char>:
/***************************************************************************/
 void LCD_send_char(char data)		//Sends Char to LCD
 {
     4ec:	cf 93       	push	r28
     4ee:	c8 2f       	mov	r28, r24
	 DIO_Write(LCD_RS_PORT, LCD_RS_PIN, HIGH);
     4f0:	81 e0       	ldi	r24, 0x01	; 1
     4f2:	62 e0       	ldi	r22, 0x02	; 2
     4f4:	4f ef       	ldi	r20, 0xFF	; 255
     4f6:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
	 LCD_send_nibble(data); // Higher nibble first
     4fa:	8c 2f       	mov	r24, r28
     4fc:	0e 94 3c 02 	call	0x478	; 0x478 <LCD_send_nibble>
	 LCD_EN_pulse();
     500:	0e 94 20 02 	call	0x440	; 0x440 <LCD_EN_pulse>

	 LCD_send_nibble(data<<4);
     504:	8c 2f       	mov	r24, r28
     506:	82 95       	swap	r24
     508:	80 7f       	andi	r24, 0xF0	; 240
     50a:	0e 94 3c 02 	call	0x478	; 0x478 <LCD_send_nibble>
	 LCD_EN_pulse();
     50e:	0e 94 20 02 	call	0x440	; 0x440 <LCD_EN_pulse>
 }
     512:	cf 91       	pop	r28
     514:	08 95       	ret

00000516 <LCD_send_command>:
 /**************************************************************************/
 void LCD_send_command(uint8_t data)	//Sends Command to LCD
 {
     516:	cf 93       	push	r28
     518:	c8 2f       	mov	r28, r24
	 DIO_Write(LCD_RS_PORT, LCD_RS_PIN, LOW);
     51a:	81 e0       	ldi	r24, 0x01	; 1
     51c:	62 e0       	ldi	r22, 0x02	; 2
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
	 LCD_send_nibble(data); // Higher nibble first
     524:	8c 2f       	mov	r24, r28
     526:	0e 94 3c 02 	call	0x478	; 0x478 <LCD_send_nibble>
	 LCD_EN_pulse();
     52a:	0e 94 20 02 	call	0x440	; 0x440 <LCD_EN_pulse>

	 LCD_send_nibble(data<<4);
     52e:	8c 2f       	mov	r24, r28
     530:	82 95       	swap	r24
     532:	80 7f       	andi	r24, 0xF0	; 240
     534:	0e 94 3c 02 	call	0x478	; 0x478 <LCD_send_nibble>
	 LCD_EN_pulse();
     538:	0e 94 20 02 	call	0x440	; 0x440 <LCD_EN_pulse>
	 SwDelay_ms(1);
     53c:	61 e0       	ldi	r22, 0x01	; 1
     53e:	70 e0       	ldi	r23, 0x00	; 0
     540:	80 e0       	ldi	r24, 0x00	; 0
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	0e 94 62 06 	call	0xcc4	; 0xcc4 <SwDelay_ms>
 }
     548:	cf 91       	pop	r28
     54a:	08 95       	ret

0000054c <LCD_init>:
	/*
	uint8_t commands[9]={0x33,0x32,Four_bit,Cursor_on,Lcd_clear,Increment_cursor,Cursor_off,0};
	 LCD_config_pins();
	 */
	/*******************************************************************/
	 SwDelay_ms(20);
     54c:	64 e1       	ldi	r22, 0x14	; 20
     54e:	70 e0       	ldi	r23, 0x00	; 0
     550:	80 e0       	ldi	r24, 0x00	; 0
     552:	90 e0       	ldi	r25, 0x00	; 0
     554:	0e 94 62 06 	call	0xcc4	; 0xcc4 <SwDelay_ms>
	LCD_send_nibble(0x00);
     558:	80 e0       	ldi	r24, 0x00	; 0
     55a:	0e 94 3c 02 	call	0x478	; 0x478 <LCD_send_nibble>
	
		DIO_Write(LCD_RS_PORT, LCD_RS_PIN, LOW);
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	62 e0       	ldi	r22, 0x02	; 2
     562:	40 e0       	ldi	r20, 0x00	; 0
     564:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
		DIO_Write(LCD_RW_PORT, LCD_RW_PIN, LOW);
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	64 e0       	ldi	r22, 0x04	; 4
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
		DIO_Write(LCD_EN_PORT, LCD_EN_PIN, LOW);
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	68 e0       	ldi	r22, 0x08	; 8
     576:	40 e0       	ldi	r20, 0x00	; 0
     578:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

	 LCD_send_command(Four_bit); // 4-bit
     57c:	88 e2       	ldi	r24, 0x28	; 40
     57e:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
	 LCD_send_command(0x38);
     582:	88 e3       	ldi	r24, 0x38	; 56
     584:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
	 LCD_send_command(0x32);
     588:	82 e3       	ldi	r24, 0x32	; 50
     58a:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
	 
	 LCD_send_command(Cursor_on);
     58e:	8e e0       	ldi	r24, 0x0E	; 14
     590:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
	 LCD_send_command(Lcd_clear);
     594:	81 e0       	ldi	r24, 0x01	; 1
     596:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
	 
	SwDelay_ms(10);
     59a:	6a e0       	ldi	r22, 0x0A	; 10
     59c:	70 e0       	ldi	r23, 0x00	; 0
     59e:	80 e0       	ldi	r24, 0x00	; 0
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	0e 94 62 06 	call	0xcc4	; 0xcc4 <SwDelay_ms>
	 LCD_send_command(Increment_cursor);
     5a6:	86 e0       	ldi	r24, 0x06	; 6
     5a8:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
	 LCD_send_command(Cursor_off); // Cursor off
     5ac:	8c e0       	ldi	r24, 0x0C	; 12
     5ae:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
}else
{
	u8_Init_finished=1;
}
 */
}
     5b2:	08 95       	ret

000005b4 <LCD_clear>:
 void LCD_clear(void)				//Clears LCD
 {
	 LCD_send_command(Lcd_clear);
     5b4:	81 e0       	ldi	r24, 0x01	; 1
     5b6:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>
 }
     5ba:	08 95       	ret

000005bc <LCD_send_string>:

 void LCD_send_string(char* data)	//Outputs string to LCD
 {
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	ec 01       	movw	r28, r24
	while(*data)
     5c2:	88 81       	ld	r24, Y
     5c4:	88 23       	and	r24, r24
     5c6:	31 f0       	breq	.+12     	; 0x5d4 <LCD_send_string+0x18>
 void LCD_clear(void)				//Clears LCD
 {
	 LCD_send_command(Lcd_clear);
 }

 void LCD_send_string(char* data)	//Outputs string to LCD
     5c8:	21 96       	adiw	r28, 0x01	; 1
 {
	while(*data)
	 {
		 LCD_send_char(*data++);
     5ca:	0e 94 76 02 	call	0x4ec	; 0x4ec <LCD_send_char>
	 LCD_send_command(Lcd_clear);
 }

 void LCD_send_string(char* data)	//Outputs string to LCD
 {
	while(*data)
     5ce:	89 91       	ld	r24, Y+
     5d0:	88 23       	and	r24, r24
     5d2:	d9 f7       	brne	.-10     	; 0x5ca <LCD_send_string+0xe>
	 {
		 LCD_send_char(*data++);
	 }
	 
 }
     5d4:	df 91       	pop	r29
     5d6:	cf 91       	pop	r28
     5d8:	08 95       	ret

000005da <LCD_goto_xy>:

 void LCD_goto_xy(uint8_t x, uint8_t y)	//Cursor to X Y position
 {
	 uint8_t DDRAMAddr;
	 // remap lines into proper order
	 switch(y)
     5da:	62 30       	cpi	r22, 0x02	; 2
     5dc:	31 f0       	breq	.+12     	; 0x5ea <LCD_goto_xy+0x10>
     5de:	63 30       	cpi	r22, 0x03	; 3
     5e0:	31 f0       	breq	.+12     	; 0x5ee <LCD_goto_xy+0x14>
     5e2:	61 30       	cpi	r22, 0x01	; 1
     5e4:	29 f4       	brne	.+10     	; 0x5f0 <LCD_goto_xy+0x16>
	 {
		 case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
		 case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
     5e6:	80 5c       	subi	r24, 0xC0	; 192
     5e8:	03 c0       	rjmp	.+6      	; 0x5f0 <LCD_goto_xy+0x16>
		 case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
     5ea:	8c 5e       	subi	r24, 0xEC	; 236
     5ec:	01 c0       	rjmp	.+2      	; 0x5f0 <LCD_goto_xy+0x16>
		 case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
     5ee:	8c 5a       	subi	r24, 0xAC	; 172
		 default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	 }
	 // set data address
	 LCD_send_command(1<<LCD_DDRAM | DDRAMAddr);
     5f0:	80 68       	ori	r24, 0x80	; 128
     5f2:	0e 94 8b 02 	call	0x516	; 0x516 <LCD_send_command>

 }
     5f6:	08 95       	ret

000005f8 <reverse>:
	 char t = *x; *x = *y; *y = t;
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
 {
     5f8:	0f 93       	push	r16
     5fa:	1f 93       	push	r17
     5fc:	cf 93       	push	r28
     5fe:	df 93       	push	r29
	 while (i < j)
     600:	40 17       	cp	r20, r16
     602:	51 07       	cpc	r21, r17
     604:	62 07       	cpc	r22, r18
     606:	73 07       	cpc	r23, r19
     608:	c0 f4       	brcc	.+48     	; 0x63a <reverse+0x42>
 inline void swap(char *x, char *y) {
	 char t = *x; *x = *y; *y = t;
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
     60a:	d8 01       	movw	r26, r16
     60c:	11 96       	adiw	r26, 0x01	; 1
     60e:	a8 0f       	add	r26, r24
     610:	b9 1f       	adc	r27, r25
     612:	fc 01       	movw	r30, r24
     614:	e4 0f       	add	r30, r20
     616:	f5 1f       	adc	r31, r21
 {
	 while (i < j)
	 swap(&buffer[i++], &buffer[j--]);
     618:	4f 5f       	subi	r20, 0xFF	; 255
     61a:	5f 4f       	sbci	r21, 0xFF	; 255
     61c:	6f 4f       	sbci	r22, 0xFF	; 255
     61e:	7f 4f       	sbci	r23, 0xFF	; 255
     620:	01 50       	subi	r16, 0x01	; 1
     622:	10 40       	sbci	r17, 0x00	; 0
     624:	20 40       	sbci	r18, 0x00	; 0
     626:	30 40       	sbci	r19, 0x00	; 0

 /*---Modification----------------------------------------------------------------------------------------------*/

 // inline function to swap two numbers
 inline void swap(char *x, char *y) {
	 char t = *x; *x = *y; *y = t;
     628:	c0 81       	ld	r28, Z
     62a:	de 91       	ld	r29, -X
     62c:	d1 93       	st	Z+, r29
     62e:	cc 93       	st	X, r28
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
 {
	 while (i < j)
     630:	40 17       	cp	r20, r16
     632:	51 07       	cpc	r21, r17
     634:	62 07       	cpc	r22, r18
     636:	73 07       	cpc	r23, r19
     638:	78 f3       	brcs	.-34     	; 0x618 <reverse+0x20>
	 swap(&buffer[i++], &buffer[j--]);

	 return buffer;
 }
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	1f 91       	pop	r17
     640:	0f 91       	pop	r16
     642:	08 95       	ret

00000644 <itoa_>:

 // Iterative function to implement itoa() function in C
 char* itoa_(uint32_t value, char* buffer, uint32_t base)
 {
     644:	4f 92       	push	r4
     646:	5f 92       	push	r5
     648:	6f 92       	push	r6
     64a:	7f 92       	push	r7
     64c:	8f 92       	push	r8
     64e:	9f 92       	push	r9
     650:	af 92       	push	r10
     652:	bf 92       	push	r11
     654:	cf 92       	push	r12
     656:	df 92       	push	r13
     658:	ef 92       	push	r14
     65a:	ff 92       	push	r15
     65c:	0f 93       	push	r16
     65e:	1f 93       	push	r17
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	6b 01       	movw	r12, r22
     666:	7c 01       	movw	r14, r24
     668:	2a 01       	movw	r4, r20
     66a:	48 01       	movw	r8, r16
     66c:	59 01       	movw	r10, r18
	 // invalid input
	 if (base < 2 || base > 32)
     66e:	d9 01       	movw	r26, r18
     670:	c8 01       	movw	r24, r16
     672:	02 97       	sbiw	r24, 0x02	; 2
     674:	a1 09       	sbc	r26, r1
     676:	b1 09       	sbc	r27, r1
     678:	8f 31       	cpi	r24, 0x1F	; 31
     67a:	91 05       	cpc	r25, r1
     67c:	a1 05       	cpc	r26, r1
     67e:	b1 05       	cpc	r27, r1
     680:	08 f0       	brcs	.+2      	; 0x684 <itoa_+0x40>
     682:	49 c0       	rjmp	.+146    	; 0x716 <itoa_+0xd2>
	 return buffer;

	 // consider absolute value of number
	 int n = abs(value);
     684:	96 01       	movw	r18, r12
     686:	dd 20       	and	r13, r13
     688:	1c f4       	brge	.+6      	; 0x690 <itoa_+0x4c>
     68a:	30 95       	com	r19
     68c:	21 95       	neg	r18
     68e:	3f 4f       	sbci	r19, 0xFF	; 255

	 int i = 0;
	 while (n)
     690:	21 15       	cp	r18, r1
     692:	31 05       	cpc	r19, r1
     694:	39 f1       	breq	.+78     	; 0x6e4 <itoa_+0xa0>
     696:	e2 01       	movw	r28, r4
     698:	01 e0       	ldi	r16, 0x01	; 1
     69a:	10 e0       	ldi	r17, 0x00	; 0
	 {
		 int r = n % base;
     69c:	69 01       	movw	r12, r18
     69e:	ee 24       	eor	r14, r14
     6a0:	d7 fc       	sbrc	r13, 7
     6a2:	e0 94       	com	r14
     6a4:	fe 2c       	mov	r15, r14
     6a6:	c7 01       	movw	r24, r14
     6a8:	b6 01       	movw	r22, r12
     6aa:	a5 01       	movw	r20, r10
     6ac:	94 01       	movw	r18, r8
     6ae:	0e 94 10 29 	call	0x5220	; 0x5220 <__udivmodsi4>

		 if (r >= 10)
     6b2:	6a 30       	cpi	r22, 0x0A	; 10
     6b4:	71 05       	cpc	r23, r1
     6b6:	24 f0       	brlt	.+8      	; 0x6c0 <itoa_+0x7c>
		 buffer[i++] = 65 + (r - 10);
     6b8:	69 5c       	subi	r22, 0xC9	; 201
     6ba:	68 83       	st	Y, r22
     6bc:	38 01       	movw	r6, r16
     6be:	03 c0       	rjmp	.+6      	; 0x6c6 <itoa_+0x82>
		 else
		 buffer[i++] = 48 + r;
     6c0:	60 5d       	subi	r22, 0xD0	; 208
     6c2:	68 83       	st	Y, r22
     6c4:	38 01       	movw	r6, r16

		 n = n / base;
     6c6:	c7 01       	movw	r24, r14
     6c8:	b6 01       	movw	r22, r12
     6ca:	a5 01       	movw	r20, r10
     6cc:	94 01       	movw	r18, r8
     6ce:	0e 94 10 29 	call	0x5220	; 0x5220 <__udivmodsi4>
     6d2:	0f 5f       	subi	r16, 0xFF	; 255
     6d4:	1f 4f       	sbci	r17, 0xFF	; 255
     6d6:	21 96       	adiw	r28, 0x01	; 1

	 // consider absolute value of number
	 int n = abs(value);

	 int i = 0;
	 while (n)
     6d8:	21 15       	cp	r18, r1
     6da:	31 05       	cpc	r19, r1
     6dc:	f9 f6       	brne	.-66     	; 0x69c <itoa_+0x58>

		 n = n / base;
	 }

	 // if number is 0
	 if (i == 0)
     6de:	61 14       	cp	r6, r1
     6e0:	71 04       	cpc	r7, r1
     6e2:	31 f4       	brne	.+12     	; 0x6f0 <itoa_+0xac>
	 buffer[i++] = '0';
     6e4:	80 e3       	ldi	r24, 0x30	; 48
     6e6:	f2 01       	movw	r30, r4
     6e8:	80 83       	st	Z, r24
     6ea:	66 24       	eor	r6, r6
     6ec:	77 24       	eor	r7, r7
     6ee:	63 94       	inc	r6
	 // is preceded with a minus sign (-)
	 // With any other base, value is always considered unsigned
	 if (value < 0 && base == 10)
	 buffer[i++] = '-';

	 buffer[i] = '\0'; // null terminate string
     6f0:	f2 01       	movw	r30, r4
     6f2:	e6 0d       	add	r30, r6
     6f4:	f7 1d       	adc	r31, r7
     6f6:	10 82       	st	Z, r1

	 // reverse the string and return it
	 return reverse(buffer, 0, i - 1);
     6f8:	08 94       	sec
     6fa:	61 08       	sbc	r6, r1
     6fc:	71 08       	sbc	r7, r1
     6fe:	83 01       	movw	r16, r6
     700:	22 27       	eor	r18, r18
     702:	17 fd       	sbrc	r17, 7
     704:	20 95       	com	r18
     706:	32 2f       	mov	r19, r18
     708:	c2 01       	movw	r24, r4
     70a:	40 e0       	ldi	r20, 0x00	; 0
     70c:	50 e0       	ldi	r21, 0x00	; 0
     70e:	ba 01       	movw	r22, r20
     710:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <reverse>
     714:	2c 01       	movw	r4, r24
 }
     716:	84 2d       	mov	r24, r4
     718:	95 2d       	mov	r25, r5
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	ff 90       	pop	r15
     724:	ef 90       	pop	r14
     726:	df 90       	pop	r13
     728:	cf 90       	pop	r12
     72a:	bf 90       	pop	r11
     72c:	af 90       	pop	r10
     72e:	9f 90       	pop	r9
     730:	8f 90       	pop	r8
     732:	7f 90       	pop	r7
     734:	6f 90       	pop	r6
     736:	5f 90       	pop	r5
     738:	4f 90       	pop	r4
     73a:	08 95       	ret

0000073c <gpioPortDirection>:
 * @param value: set the port value and takes the following values
 * 				- 0x00 -> Low
 * 				- 0xff -> High
 */

switch (u8_port)	
     73c:	81 30       	cpi	r24, 0x01	; 1
     73e:	49 f0       	breq	.+18     	; 0x752 <gpioPortDirection+0x16>
     740:	81 30       	cpi	r24, 0x01	; 1
     742:	28 f0       	brcs	.+10     	; 0x74e <gpioPortDirection+0x12>
     744:	82 30       	cpi	r24, 0x02	; 2
     746:	39 f0       	breq	.+14     	; 0x756 <gpioPortDirection+0x1a>
     748:	83 30       	cpi	r24, 0x03	; 3
     74a:	41 f4       	brne	.+16     	; 0x75c <gpioPortDirection+0x20>
     74c:	06 c0       	rjmp	.+12     	; 0x75a <gpioPortDirection+0x1e>
{	case GPIOA:
	PORTA_DIR = u8_direction;
     74e:	6a bb       	out	0x1a, r22	; 26
	break;
     750:	08 95       	ret
	case GPIOB:
	PORTB_DIR = u8_direction;
     752:	67 bb       	out	0x17, r22	; 23
	break;
     754:	08 95       	ret
	case GPIOC:
	PORTC_DIR = u8_direction;
     756:	64 bb       	out	0x14, r22	; 20
	break;
     758:	08 95       	ret
	case GPIOD:
	PORTD_DIR = u8_direction;
     75a:	61 bb       	out	0x11, r22	; 17
     75c:	08 95       	ret

0000075e <gpioPortWrite>:
}

void gpioPortWrite(uint8_t u8_port, uint8_t u8_value)
{
	
switch (u8_port)	
     75e:	81 30       	cpi	r24, 0x01	; 1
     760:	49 f0       	breq	.+18     	; 0x774 <gpioPortWrite+0x16>
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	28 f0       	brcs	.+10     	; 0x770 <gpioPortWrite+0x12>
     766:	82 30       	cpi	r24, 0x02	; 2
     768:	39 f0       	breq	.+14     	; 0x778 <gpioPortWrite+0x1a>
     76a:	83 30       	cpi	r24, 0x03	; 3
     76c:	41 f4       	brne	.+16     	; 0x77e <gpioPortWrite+0x20>
     76e:	06 c0       	rjmp	.+12     	; 0x77c <gpioPortWrite+0x1e>
{	case GPIOA:
	PORTA_DATA = u8_value;
     770:	6b bb       	out	0x1b, r22	; 27
	break;
     772:	08 95       	ret
	case GPIOB:
	PORTB_DATA = u8_value;
     774:	68 bb       	out	0x18, r22	; 24
	break;
     776:	08 95       	ret
	case GPIOC:
	PORTC_DATA = u8_value;
     778:	65 bb       	out	0x15, r22	; 21
	break;
     77a:	08 95       	ret
	case GPIOD:
	PORTD_DATA = u8_value;
     77c:	62 bb       	out	0x12, r22	; 18
     77e:	08 95       	ret

00000780 <gpioPortToggle>:
	
}
void gpioPortToggle(uint8_t u8_port)
{
	
switch (u8_port)	
     780:	81 30       	cpi	r24, 0x01	; 1
     782:	59 f0       	breq	.+22     	; 0x79a <gpioPortToggle+0x1a>
     784:	81 30       	cpi	r24, 0x01	; 1
     786:	28 f0       	brcs	.+10     	; 0x792 <gpioPortToggle+0x12>
     788:	82 30       	cpi	r24, 0x02	; 2
     78a:	59 f0       	breq	.+22     	; 0x7a2 <gpioPortToggle+0x22>
     78c:	83 30       	cpi	r24, 0x03	; 3
     78e:	81 f4       	brne	.+32     	; 0x7b0 <gpioPortToggle+0x30>
     790:	0c c0       	rjmp	.+24     	; 0x7aa <gpioPortToggle+0x2a>
{	case GPIOA:
	PORTA_DATA ^= HIGH;
     792:	8b b3       	in	r24, 0x1b	; 27
     794:	80 95       	com	r24
     796:	8b bb       	out	0x1b, r24	; 27
	break;
     798:	08 95       	ret
	case GPIOB:
	PORTB_DATA ^= HIGH;
     79a:	88 b3       	in	r24, 0x18	; 24
     79c:	80 95       	com	r24
     79e:	88 bb       	out	0x18, r24	; 24
	break;
     7a0:	08 95       	ret
	case GPIOC:
	PORTC_DATA ^= HIGH;
     7a2:	85 b3       	in	r24, 0x15	; 21
     7a4:	80 95       	com	r24
     7a6:	85 bb       	out	0x15, r24	; 21
	break;
     7a8:	08 95       	ret
	case GPIOD:
	PORTD_DATA ^= HIGH;
     7aa:	82 b3       	in	r24, 0x12	; 18
     7ac:	80 95       	com	r24
     7ae:	82 bb       	out	0x12, r24	; 18
     7b0:	08 95       	ret

000007b2 <gpioPortRead>:

uint8_t gpioPortRead(uint8_t u8_port)
{
	uint8_t U8_ret_Port_data=0;
	
switch (u8_port)	
     7b2:	81 30       	cpi	r24, 0x01	; 1
     7b4:	49 f0       	breq	.+18     	; 0x7c8 <gpioPortRead+0x16>
     7b6:	81 30       	cpi	r24, 0x01	; 1
     7b8:	28 f0       	brcs	.+10     	; 0x7c4 <gpioPortRead+0x12>
     7ba:	82 30       	cpi	r24, 0x02	; 2
     7bc:	39 f0       	breq	.+14     	; 0x7cc <gpioPortRead+0x1a>
     7be:	83 30       	cpi	r24, 0x03	; 3
     7c0:	49 f4       	brne	.+18     	; 0x7d4 <gpioPortRead+0x22>
     7c2:	06 c0       	rjmp	.+12     	; 0x7d0 <gpioPortRead+0x1e>
{	case GPIOA:
	U8_ret_Port_data=PORTA_DATA & HIGH;
     7c4:	8b b3       	in	r24, 0x1b	; 27
	break;
     7c6:	08 95       	ret
	case GPIOB:
	U8_ret_Port_data=PORTB_DATA & HIGH;
     7c8:	88 b3       	in	r24, 0x18	; 24
	break;
     7ca:	08 95       	ret
	case GPIOC:
	U8_ret_Port_data=PORTC_DATA & HIGH;
     7cc:	85 b3       	in	r24, 0x15	; 21
	break;
     7ce:	08 95       	ret
	case GPIOD:
	U8_ret_Port_data=PORTD_DATA & HIGH;
     7d0:	82 b3       	in	r24, 0x12	; 18
	break;
     7d2:	08 95       	ret
	
}

uint8_t gpioPortRead(uint8_t u8_port)
{
	uint8_t U8_ret_Port_data=0;
     7d4:	80 e0       	ldi	r24, 0x00	; 0
	break;
	
}

return 	U8_ret_Port_data;
}
     7d6:	08 95       	ret

000007d8 <gpioPinDirection>:
 * 				- 0x00 -> Input
 * 				- 0xff -> Output
 */
void gpioPinDirection(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_direction)
{
switch(u8_direction){
     7d8:	44 23       	and	r20, r20
     7da:	19 f0       	breq	.+6      	; 0x7e2 <gpioPinDirection+0xa>
     7dc:	4f 3f       	cpi	r20, 0xFF	; 255
     7de:	d1 f5       	brne	.+116    	; 0x854 <gpioPinDirection+0x7c>
     7e0:	21 c0       	rjmp	.+66     	; 0x824 <gpioPinDirection+0x4c>
case INPUT:
{
switch (u8_port)	
     7e2:	81 30       	cpi	r24, 0x01	; 1
     7e4:	69 f0       	breq	.+26     	; 0x800 <gpioPinDirection+0x28>
     7e6:	81 30       	cpi	r24, 0x01	; 1
     7e8:	28 f0       	brcs	.+10     	; 0x7f4 <gpioPinDirection+0x1c>
     7ea:	82 30       	cpi	r24, 0x02	; 2
     7ec:	79 f0       	breq	.+30     	; 0x80c <gpioPinDirection+0x34>
     7ee:	83 30       	cpi	r24, 0x03	; 3
     7f0:	c9 f4       	brne	.+50     	; 0x824 <gpioPinDirection+0x4c>
     7f2:	12 c0       	rjmp	.+36     	; 0x818 <gpioPinDirection+0x40>
{	case GPIOA:
	PORTA_DIR &=(~u8_pins);   // 0b01111111
     7f4:	8a b3       	in	r24, 0x1a	; 26
     7f6:	96 2f       	mov	r25, r22
     7f8:	90 95       	com	r25
     7fa:	89 23       	and	r24, r25
     7fc:	8a bb       	out	0x1a, r24	; 26
     7fe:	1b c0       	rjmp	.+54     	; 0x836 <gpioPinDirection+0x5e>
	break;
	case GPIOB:
	PORTB_DIR &=(~u8_pins);
     800:	87 b3       	in	r24, 0x17	; 23
     802:	96 2f       	mov	r25, r22
     804:	90 95       	com	r25
     806:	89 23       	and	r24, r25
     808:	87 bb       	out	0x17, r24	; 23
     80a:	19 c0       	rjmp	.+50     	; 0x83e <gpioPinDirection+0x66>
	break;
	case GPIOC:
	PORTC_DIR &=(~u8_pins);
     80c:	84 b3       	in	r24, 0x14	; 20
     80e:	96 2f       	mov	r25, r22
     810:	90 95       	com	r25
     812:	89 23       	and	r24, r25
     814:	84 bb       	out	0x14, r24	; 20
     816:	17 c0       	rjmp	.+46     	; 0x846 <gpioPinDirection+0x6e>
	break;
	case GPIOD:
	PORTD_DIR &=(~u8_pins);
     818:	81 b3       	in	r24, 0x11	; 17
     81a:	96 2f       	mov	r25, r22
     81c:	90 95       	com	r25
     81e:	89 23       	and	r24, r25
     820:	81 bb       	out	0x11, r24	; 17
     822:	15 c0       	rjmp	.+42     	; 0x84e <gpioPinDirection+0x76>
	break;
	
}
}
case OUTPUT:{
switch (u8_port)	
     824:	81 30       	cpi	r24, 0x01	; 1
     826:	59 f0       	breq	.+22     	; 0x83e <gpioPinDirection+0x66>
     828:	81 30       	cpi	r24, 0x01	; 1
     82a:	28 f0       	brcs	.+10     	; 0x836 <gpioPinDirection+0x5e>
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	59 f0       	breq	.+22     	; 0x846 <gpioPinDirection+0x6e>
     830:	83 30       	cpi	r24, 0x03	; 3
     832:	81 f4       	brne	.+32     	; 0x854 <gpioPinDirection+0x7c>
     834:	0c c0       	rjmp	.+24     	; 0x84e <gpioPinDirection+0x76>
{	case GPIOA:
	PORTA_DIR |=(u8_pins);
     836:	8a b3       	in	r24, 0x1a	; 26
     838:	68 2b       	or	r22, r24
     83a:	6a bb       	out	0x1a, r22	; 26
	break;
     83c:	08 95       	ret
	case GPIOB:
	PORTB_DIR |=(u8_pins);
     83e:	87 b3       	in	r24, 0x17	; 23
     840:	68 2b       	or	r22, r24
     842:	67 bb       	out	0x17, r22	; 23
	break;
     844:	08 95       	ret
	case GPIOC:
	PORTC_DIR |=(u8_pins);
     846:	84 b3       	in	r24, 0x14	; 20
     848:	68 2b       	or	r22, r24
     84a:	64 bb       	out	0x14, r22	; 20
	break;
     84c:	08 95       	ret
	case GPIOD:
	PORTD_DIR |=(u8_pins);
     84e:	81 b3       	in	r24, 0x11	; 17
     850:	68 2b       	or	r22, r24
     852:	61 bb       	out	0x11, r22	; 17
     854:	08 95       	ret

00000856 <gpioPinWrite>:
	
	
}

void gpioPinWrite(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_value)
{switch(u8_value){
     856:	44 23       	and	r20, r20
     858:	19 f0       	breq	.+6      	; 0x860 <__stack+0x1>
     85a:	4f 3f       	cpi	r20, 0xFF	; 255
     85c:	b1 f5       	brne	.+108    	; 0x8ca <__stack+0x6b>
     85e:	1d c0       	rjmp	.+58     	; 0x89a <__stack+0x3b>
case LOW:
{
switch (u8_port)	
     860:	81 30       	cpi	r24, 0x01	; 1
     862:	61 f0       	breq	.+24     	; 0x87c <__stack+0x1d>
     864:	81 30       	cpi	r24, 0x01	; 1
     866:	28 f0       	brcs	.+10     	; 0x872 <__stack+0x13>
     868:	82 30       	cpi	r24, 0x02	; 2
     86a:	69 f0       	breq	.+26     	; 0x886 <__stack+0x27>
     86c:	83 30       	cpi	r24, 0x03	; 3
     86e:	69 f5       	brne	.+90     	; 0x8ca <__stack+0x6b>
     870:	0f c0       	rjmp	.+30     	; 0x890 <__stack+0x31>
{	case GPIOA:
	PORTA_DATA &= ~(u8_pins);   // 0b01111111
     872:	8b b3       	in	r24, 0x1b	; 27
     874:	60 95       	com	r22
     876:	68 23       	and	r22, r24
     878:	6b bb       	out	0x1b, r22	; 27
	break;
     87a:	08 95       	ret
	case GPIOB:
	PORTB_DATA &= ~(u8_pins);
     87c:	88 b3       	in	r24, 0x18	; 24
     87e:	60 95       	com	r22
     880:	68 23       	and	r22, r24
     882:	68 bb       	out	0x18, r22	; 24
	break;
     884:	08 95       	ret
	case GPIOC:
	PORTC_DATA &= ~(u8_pins);
     886:	85 b3       	in	r24, 0x15	; 21
     888:	60 95       	com	r22
     88a:	68 23       	and	r22, r24
     88c:	65 bb       	out	0x15, r22	; 21
	break;
     88e:	08 95       	ret
	case GPIOD:
	PORTD_DATA &= ~(u8_pins);
     890:	82 b3       	in	r24, 0x12	; 18
     892:	60 95       	com	r22
     894:	68 23       	and	r22, r24
     896:	62 bb       	out	0x12, r22	; 18
	break;
     898:	08 95       	ret
	
}
break;
}
case HIGH:{
switch (u8_port)	
     89a:	81 30       	cpi	r24, 0x01	; 1
     89c:	59 f0       	breq	.+22     	; 0x8b4 <__stack+0x55>
     89e:	81 30       	cpi	r24, 0x01	; 1
     8a0:	28 f0       	brcs	.+10     	; 0x8ac <__stack+0x4d>
     8a2:	82 30       	cpi	r24, 0x02	; 2
     8a4:	59 f0       	breq	.+22     	; 0x8bc <__stack+0x5d>
     8a6:	83 30       	cpi	r24, 0x03	; 3
     8a8:	81 f4       	brne	.+32     	; 0x8ca <__stack+0x6b>
     8aa:	0c c0       	rjmp	.+24     	; 0x8c4 <__stack+0x65>
{	case GPIOA:
	PORTA_DATA |=(u8_pins);
     8ac:	8b b3       	in	r24, 0x1b	; 27
     8ae:	68 2b       	or	r22, r24
     8b0:	6b bb       	out	0x1b, r22	; 27
	break;
     8b2:	08 95       	ret
	case GPIOB:
	PORTB_DATA |=(u8_pins);
     8b4:	88 b3       	in	r24, 0x18	; 24
     8b6:	68 2b       	or	r22, r24
     8b8:	68 bb       	out	0x18, r22	; 24
	break;
     8ba:	08 95       	ret
	case GPIOC:
	PORTC_DATA |=(u8_pins);
     8bc:	85 b3       	in	r24, 0x15	; 21
     8be:	68 2b       	or	r22, r24
     8c0:	65 bb       	out	0x15, r22	; 21
	break;
     8c2:	08 95       	ret
	case GPIOD:
	PORTD_DATA |=(u8_pins);
     8c4:	82 b3       	in	r24, 0x12	; 18
     8c6:	68 2b       	or	r22, r24
     8c8:	62 bb       	out	0x12, r22	; 18
     8ca:	08 95       	ret

000008cc <gpioPinToggle>:
}

}
void gpioPinToggle(uint8_t u8_port, uint8_t u8_pins)
{
switch (u8_port)	
     8cc:	81 30       	cpi	r24, 0x01	; 1
     8ce:	59 f0       	breq	.+22     	; 0x8e6 <gpioPinToggle+0x1a>
     8d0:	81 30       	cpi	r24, 0x01	; 1
     8d2:	28 f0       	brcs	.+10     	; 0x8de <gpioPinToggle+0x12>
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	59 f0       	breq	.+22     	; 0x8ee <gpioPinToggle+0x22>
     8d8:	83 30       	cpi	r24, 0x03	; 3
     8da:	81 f4       	brne	.+32     	; 0x8fc <gpioPinToggle+0x30>
     8dc:	0c c0       	rjmp	.+24     	; 0x8f6 <gpioPinToggle+0x2a>
{	case GPIOA:
	PORTA_DATA ^=(u8_pins);
     8de:	8b b3       	in	r24, 0x1b	; 27
     8e0:	68 27       	eor	r22, r24
     8e2:	6b bb       	out	0x1b, r22	; 27
	break;
     8e4:	08 95       	ret
	case GPIOB:
	PORTB_DATA ^=(u8_pins);
     8e6:	88 b3       	in	r24, 0x18	; 24
     8e8:	68 27       	eor	r22, r24
     8ea:	68 bb       	out	0x18, r22	; 24
	break;
     8ec:	08 95       	ret
	case GPIOC:
	PORTC_DATA ^=(u8_pins);
     8ee:	85 b3       	in	r24, 0x15	; 21
     8f0:	68 27       	eor	r22, r24
     8f2:	65 bb       	out	0x15, r22	; 21
	break;
     8f4:	08 95       	ret
	case GPIOD:
	PORTD_DATA ^=(u8_pins);
     8f6:	82 b3       	in	r24, 0x12	; 18
     8f8:	68 27       	eor	r22, r24
     8fa:	62 bb       	out	0x12, r22	; 18
     8fc:	08 95       	ret

000008fe <gpioPinRead>:
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
{
	uint8_t U8_ret_BIT_data = 0;
switch (u8_port)	
     8fe:	81 30       	cpi	r24, 0x01	; 1
     900:	51 f0       	breq	.+20     	; 0x916 <gpioPinRead+0x18>
     902:	81 30       	cpi	r24, 0x01	; 1
     904:	28 f0       	brcs	.+10     	; 0x910 <gpioPinRead+0x12>
     906:	82 30       	cpi	r24, 0x02	; 2
     908:	49 f0       	breq	.+18     	; 0x91c <gpioPinRead+0x1e>
     90a:	83 30       	cpi	r24, 0x03	; 3
     90c:	69 f4       	brne	.+26     	; 0x928 <gpioPinRead+0x2a>
     90e:	09 c0       	rjmp	.+18     	; 0x922 <gpioPinRead+0x24>
{	case GPIOA:
	U8_ret_BIT_data=(PORTA_PIN & u8_pin);
     910:	89 b3       	in	r24, 0x19	; 25
     912:	68 23       	and	r22, r24
	break;
     914:	0a c0       	rjmp	.+20     	; 0x92a <gpioPinRead+0x2c>
	case GPIOB:
	U8_ret_BIT_data=(PORTB_PIN & u8_pin);
     916:	86 b3       	in	r24, 0x16	; 22
     918:	68 23       	and	r22, r24
	break;
     91a:	07 c0       	rjmp	.+14     	; 0x92a <gpioPinRead+0x2c>
	case GPIOC:
	U8_ret_BIT_data=(PORTC_PIN & u8_pin);
     91c:	83 b3       	in	r24, 0x13	; 19
     91e:	68 23       	and	r22, r24
	break;
     920:	04 c0       	rjmp	.+8      	; 0x92a <gpioPinRead+0x2c>
	case GPIOD:
	U8_ret_BIT_data=(PORTD_PIN & u8_pin);
     922:	80 b3       	in	r24, 0x10	; 16
     924:	68 23       	and	r22, r24
	break;
     926:	01 c0       	rjmp	.+2      	; 0x92a <gpioPinRead+0x2c>
	
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
{
	uint8_t U8_ret_BIT_data = 0;
     928:	60 e0       	ldi	r22, 0x00	; 0
}
	
	
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	66 23       	and	r22, r22
     92e:	09 f4       	brne	.+2      	; 0x932 <gpioPinRead+0x34>
     930:	80 e0       	ldi	r24, 0x00	; 0
if(U8_ret_BIT_data > 0)
{
	U8_ret_BIT_data = 1;
}
return U8_ret_BIT_data;
     932:	08 95       	ret

00000934 <Led_Init>:
	LED_3

*/
void Led_Init(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     934:	81 30       	cpi	r24, 0x01	; 1
     936:	69 f0       	breq	.+26     	; 0x952 <Led_Init+0x1e>
     938:	81 30       	cpi	r24, 0x01	; 1
     93a:	28 f0       	brcs	.+10     	; 0x946 <Led_Init+0x12>
     93c:	82 30       	cpi	r24, 0x02	; 2
     93e:	79 f0       	breq	.+30     	; 0x95e <Led_Init+0x2a>
     940:	83 30       	cpi	r24, 0x03	; 3
     942:	c1 f4       	brne	.+48     	; 0x974 <Led_Init+0x40>
     944:	12 c0       	rjmp	.+36     	; 0x96a <Led_Init+0x36>
{
case LED_0:
gpioPinDirection(LED_0_GPIO,LED_0_BIT,HIGH);
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	60 e1       	ldi	r22, 0x10	; 16
     94a:	4f ef       	ldi	r20, 0xFF	; 255
     94c:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <gpioPinDirection>
break;
     950:	08 95       	ret

case LED_1:
gpioPinDirection(LED_1_GPIO,LED_1_BIT,HIGH);
     952:	81 e0       	ldi	r24, 0x01	; 1
     954:	60 e2       	ldi	r22, 0x20	; 32
     956:	4f ef       	ldi	r20, 0xFF	; 255
     958:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <gpioPinDirection>
break;
     95c:	08 95       	ret

case LED_2:
gpioPinDirection(LED_2_GPIO,LED_2_BIT,HIGH);
     95e:	81 e0       	ldi	r24, 0x01	; 1
     960:	60 e4       	ldi	r22, 0x40	; 64
     962:	4f ef       	ldi	r20, 0xFF	; 255
     964:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <gpioPinDirection>
break;
     968:	08 95       	ret

case LED_3:
gpioPinDirection(LED_3_GPIO,LED_3_BIT,HIGH);
     96a:	81 e0       	ldi	r24, 0x01	; 1
     96c:	60 e8       	ldi	r22, 0x80	; 128
     96e:	4f ef       	ldi	r20, 0xFF	; 255
     970:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <gpioPinDirection>
     974:	08 95       	ret

00000976 <Led_On>:
}


void Led_On(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     976:	81 30       	cpi	r24, 0x01	; 1
     978:	69 f0       	breq	.+26     	; 0x994 <Led_On+0x1e>
     97a:	81 30       	cpi	r24, 0x01	; 1
     97c:	28 f0       	brcs	.+10     	; 0x988 <Led_On+0x12>
     97e:	82 30       	cpi	r24, 0x02	; 2
     980:	79 f0       	breq	.+30     	; 0x9a0 <Led_On+0x2a>
     982:	83 30       	cpi	r24, 0x03	; 3
     984:	c1 f4       	brne	.+48     	; 0x9b6 <Led_On+0x40>
     986:	12 c0       	rjmp	.+36     	; 0x9ac <Led_On+0x36>
{
case LED_0:
gpioPinWrite(LED_0_GPIO,LED_0_BIT,HIGH);
     988:	81 e0       	ldi	r24, 0x01	; 1
     98a:	60 e1       	ldi	r22, 0x10	; 16
     98c:	4f ef       	ldi	r20, 0xFF	; 255
     98e:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
break;
     992:	08 95       	ret

case LED_1:
gpioPinWrite(LED_1_GPIO,LED_1_BIT,HIGH);
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	60 e2       	ldi	r22, 0x20	; 32
     998:	4f ef       	ldi	r20, 0xFF	; 255
     99a:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
break;
     99e:	08 95       	ret

case LED_2:
gpioPinWrite(LED_2_GPIO,LED_2_BIT,HIGH);
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	60 e4       	ldi	r22, 0x40	; 64
     9a4:	4f ef       	ldi	r20, 0xFF	; 255
     9a6:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
break;
     9aa:	08 95       	ret

case LED_3:
gpioPinWrite(LED_3_GPIO,LED_3_BIT,HIGH);
     9ac:	81 e0       	ldi	r24, 0x01	; 1
     9ae:	60 e8       	ldi	r22, 0x80	; 128
     9b0:	4f ef       	ldi	r20, 0xFF	; 255
     9b2:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
     9b6:	08 95       	ret

000009b8 <Led_Off>:
}

void Led_Off(En_LedNumber_t en_led_id)
{

switch(en_led_id)
     9b8:	81 30       	cpi	r24, 0x01	; 1
     9ba:	69 f0       	breq	.+26     	; 0x9d6 <Led_Off+0x1e>
     9bc:	81 30       	cpi	r24, 0x01	; 1
     9be:	28 f0       	brcs	.+10     	; 0x9ca <Led_Off+0x12>
     9c0:	82 30       	cpi	r24, 0x02	; 2
     9c2:	79 f0       	breq	.+30     	; 0x9e2 <Led_Off+0x2a>
     9c4:	83 30       	cpi	r24, 0x03	; 3
     9c6:	c1 f4       	brne	.+48     	; 0x9f8 <Led_Off+0x40>
     9c8:	12 c0       	rjmp	.+36     	; 0x9ee <Led_Off+0x36>
{
case LED_0:
gpioPinWrite(LED_0_GPIO,LED_0_BIT,LOW);
     9ca:	81 e0       	ldi	r24, 0x01	; 1
     9cc:	60 e1       	ldi	r22, 0x10	; 16
     9ce:	40 e0       	ldi	r20, 0x00	; 0
     9d0:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
break;
     9d4:	08 95       	ret

case LED_1:
gpioPinWrite(LED_1_GPIO,LED_1_BIT,LOW);
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	60 e2       	ldi	r22, 0x20	; 32
     9da:	40 e0       	ldi	r20, 0x00	; 0
     9dc:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
break;
     9e0:	08 95       	ret

case LED_2:
gpioPinWrite(LED_2_GPIO,LED_2_BIT,LOW);
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	60 e4       	ldi	r22, 0x40	; 64
     9e6:	40 e0       	ldi	r20, 0x00	; 0
     9e8:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
break;
     9ec:	08 95       	ret

case LED_3:
gpioPinWrite(LED_3_GPIO,LED_3_BIT,LOW);
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	60 e8       	ldi	r22, 0x80	; 128
     9f2:	40 e0       	ldi	r20, 0x00	; 0
     9f4:	0e 94 2b 04 	call	0x856	; 0x856 <gpioPinWrite>
     9f8:	08 95       	ret

000009fa <Led_Toggle>:


}
void Led_Toggle(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     9fa:	81 30       	cpi	r24, 0x01	; 1
     9fc:	61 f0       	breq	.+24     	; 0xa16 <Led_Toggle+0x1c>
     9fe:	81 30       	cpi	r24, 0x01	; 1
     a00:	28 f0       	brcs	.+10     	; 0xa0c <Led_Toggle+0x12>
     a02:	82 30       	cpi	r24, 0x02	; 2
     a04:	69 f0       	breq	.+26     	; 0xa20 <Led_Toggle+0x26>
     a06:	83 30       	cpi	r24, 0x03	; 3
     a08:	a1 f4       	brne	.+40     	; 0xa32 <Led_Toggle+0x38>
     a0a:	0f c0       	rjmp	.+30     	; 0xa2a <Led_Toggle+0x30>
{
case LED_0:
gpioPinToggle(LED_0_GPIO,LED_0_BIT);
     a0c:	81 e0       	ldi	r24, 0x01	; 1
     a0e:	60 e1       	ldi	r22, 0x10	; 16
     a10:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinToggle>
break;
     a14:	08 95       	ret

case LED_1:
gpioPinToggle(LED_1_GPIO,LED_1_BIT);
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	60 e2       	ldi	r22, 0x20	; 32
     a1a:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinToggle>
break;
     a1e:	08 95       	ret

case LED_2:
gpioPinToggle(LED_2_GPIO,LED_2_BIT);
     a20:	81 e0       	ldi	r24, 0x01	; 1
     a22:	60 e4       	ldi	r22, 0x40	; 64
     a24:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinToggle>
break;
     a28:	08 95       	ret

case LED_3:
gpioPinToggle(LED_3_GPIO,LED_3_BIT);
     a2a:	81 e0       	ldi	r24, 0x01	; 1
     a2c:	60 e8       	ldi	r22, 0x80	; 128
     a2e:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinToggle>
     a32:	08 95       	ret

00000a34 <Motor_Init>:
#include "motor.h"
static uint8_t gsv_is_Started=0;
static uint8_t gsv_is_intialized=0;
ERROR_STATUS Motor_Init(uint8_t Motor_Number)
{uint8_t Ret=0;
    switch(Motor_Number)
     a34:	82 30       	cpi	r24, 0x02	; 2
     a36:	79 f0       	breq	.+30     	; 0xa56 <Motor_Init+0x22>
     a38:	83 30       	cpi	r24, 0x03	; 3
     a3a:	c9 f0       	breq	.+50     	; 0xa6e <Motor_Init+0x3a>
     a3c:	81 30       	cpi	r24, 0x01	; 1
     a3e:	39 f5       	brne	.+78     	; 0xa8e <Motor_Init+0x5a>
    {
        case MOTOR_1:
        /*Enable PWM Bit...output*/
        /*IN1*/
        /*IN2*/
			gsv_is_intialized=MOTOR_1;
     a40:	80 93 ee 00 	sts	0x00EE, r24
			Ret=Pwm_Init(&PWM_Configuration_1A);
     a44:	86 ec       	ldi	r24, 0xC6	; 198
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <Pwm_Init>
			Ret=DIO_init(&Motorone);
     a4c:	8c e6       	ldi	r24, 0x6C	; 108
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>

			  break;
     a54:	08 95       	ret

          case MOTOR_2:
				gsv_is_intialized=MOTOR_2;
     a56:	82 e0       	ldi	r24, 0x02	; 2
     a58:	80 93 ee 00 	sts	0x00EE, r24
				Ret=Pwm_Init(&PWM_Configuration_1B);
     a5c:	84 ec       	ldi	r24, 0xC4	; 196
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <Pwm_Init>
				Ret=DIO_init(&Motortwo);
     a64:	89 e6       	ldi	r24, 0x69	; 105
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
				break;
     a6c:	08 95       	ret
				/*IN1*/
				/*IN2*/
				/*ENABLE PWM BIT FOR MOTOR 2*/
				/*IN3*/
				/*IN4*/
				gsv_is_intialized=ALL_MOTOR;
     a6e:	83 e0       	ldi	r24, 0x03	; 3
     a70:	80 93 ee 00 	sts	0x00EE, r24
			Ret=Pwm_Init(&PWM_Configuration_1A);
     a74:	86 ec       	ldi	r24, 0xC6	; 198
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <Pwm_Init>
			Ret=Pwm_Init(&PWM_Configuration_1B);
     a7c:	84 ec       	ldi	r24, 0xC4	; 196
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <Pwm_Init>
			Ret=DIO_init(&ALL_Motor);
     a84:	86 e6       	ldi	r24, 0x66	; 102
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
				break;
     a8c:	08 95       	ret
			   }
      default:
      Ret=E_NOK;
     a8e:	81 e0       	ldi	r24, 0x01	; 1
      break;
    }
return Ret;
}
     a90:	08 95       	ret

00000a92 <Motor_Direction>:

ERROR_STATUS Motor_Direction(uint8_t Motor_Number, uint8_t Motor_Direction)
{uint8_t Ret=0;

  switch(Motor_Number)
     a92:	82 30       	cpi	r24, 0x02	; 2
     a94:	79 f1       	breq	.+94     	; 0xaf4 <Motor_Direction+0x62>
     a96:	83 30       	cpi	r24, 0x03	; 3
     a98:	09 f4       	brne	.+2      	; 0xa9c <Motor_Direction+0xa>
     a9a:	55 c0       	rjmp	.+170    	; 0xb46 <Motor_Direction+0xb4>
     a9c:	81 30       	cpi	r24, 0x01	; 1
     a9e:	09 f0       	breq	.+2      	; 0xaa2 <Motor_Direction+0x10>
     aa0:	99 c0       	rjmp	.+306    	; 0xbd4 <Motor_Direction+0x142>
  {
  	case MOTOR_1:{
  	switch(Motor_Direction)
     aa2:	61 30       	cpi	r22, 0x01	; 1
     aa4:	31 f0       	breq	.+12     	; 0xab2 <Motor_Direction+0x20>
     aa6:	61 30       	cpi	r22, 0x01	; 1
     aa8:	d0 f0       	brcs	.+52     	; 0xade <Motor_Direction+0x4c>
     aaa:	62 30       	cpi	r22, 0x02	; 2
     aac:	09 f0       	breq	.+2      	; 0xab0 <Motor_Direction+0x1e>
     aae:	94 c0       	rjmp	.+296    	; 0xbd8 <Motor_Direction+0x146>
     ab0:	0b c0       	rjmp	.+22     	; 0xac8 <Motor_Direction+0x36>
  	{
  		case MOTOR_FORWARD:
  		{
  			Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,HIGH);
     ab2:	83 e0       	ldi	r24, 0x03	; 3
     ab4:	64 e0       	ldi	r22, 0x04	; 4
     ab6:	4f ef       	ldi	r20, 0xFF	; 255
     ab8:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  			Ret=DIO_Write (MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     abc:	83 e0       	ldi	r24, 0x03	; 3
     abe:	68 e0       	ldi	r22, 0x08	; 8
     ac0:	40 e0       	ldi	r20, 0x00	; 0
     ac2:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  			break;
     ac6:	08 95       	ret
  		}
  		case MOTOR_BACKWARD:
  		{
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,HIGH);
     ac8:	83 e0       	ldi	r24, 0x03	; 3
     aca:	68 e0       	ldi	r22, 0x08	; 8
     acc:	4f ef       	ldi	r20, 0xFF	; 255
     ace:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
        Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     ad2:	83 e0       	ldi	r24, 0x03	; 3
     ad4:	64 e0       	ldi	r22, 0x04	; 4
     ad6:	40 e0       	ldi	r20, 0x00	; 0
     ad8:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  			break;
     adc:	08 95       	ret
  		}
  		case MOTOR_STOP:{Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     ade:	83 e0       	ldi	r24, 0x03	; 3
     ae0:	64 e0       	ldi	r22, 0x04	; 4
     ae2:	40 e0       	ldi	r20, 0x00	; 0
     ae4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     ae8:	83 e0       	ldi	r24, 0x03	; 3
     aea:	68 e0       	ldi	r22, 0x08	; 8
     aec:	40 e0       	ldi	r20, 0x00	; 0
     aee:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  		break;}
     af2:	08 95       	ret
  	}
  		break;
  	}
  	case MOTOR_2:
  	{
  		switch(Motor_Direction)
     af4:	61 30       	cpi	r22, 0x01	; 1
     af6:	31 f0       	breq	.+12     	; 0xb04 <Motor_Direction+0x72>
     af8:	61 30       	cpi	r22, 0x01	; 1
     afa:	d0 f0       	brcs	.+52     	; 0xb30 <Motor_Direction+0x9e>
     afc:	62 30       	cpi	r22, 0x02	; 2
     afe:	09 f0       	breq	.+2      	; 0xb02 <Motor_Direction+0x70>
     b00:	6d c0       	rjmp	.+218    	; 0xbdc <Motor_Direction+0x14a>
     b02:	0b c0       	rjmp	.+22     	; 0xb1a <Motor_Direction+0x88>
  		{
  			case MOTOR_FORWARD:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,HIGH);
     b04:	83 e0       	ldi	r24, 0x03	; 3
     b06:	60 e8       	ldi	r22, 0x80	; 128
     b08:	4f ef       	ldi	r20, 0xFF	; 255
     b0a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
          Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     b0e:	83 e0       	ldi	r24, 0x03	; 3
     b10:	60 e4       	ldi	r22, 0x40	; 64
     b12:	40 e0       	ldi	r20, 0x00	; 0
     b14:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  				break;
     b18:	08 95       	ret
  			}
  			case MOTOR_BACKWARD:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,HIGH);
     b1a:	83 e0       	ldi	r24, 0x03	; 3
     b1c:	60 e4       	ldi	r22, 0x40	; 64
     b1e:	4f ef       	ldi	r20, 0xFF	; 255
     b20:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     b24:	83 e0       	ldi	r24, 0x03	; 3
     b26:	60 e8       	ldi	r22, 0x80	; 128
     b28:	40 e0       	ldi	r20, 0x00	; 0
     b2a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  				break;
     b2e:	08 95       	ret
  			}
  			case MOTOR_STOP:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     b30:	83 e0       	ldi	r24, 0x03	; 3
     b32:	60 e4       	ldi	r22, 0x40	; 64
     b34:	40 e0       	ldi	r20, 0x00	; 0
     b36:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  				Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     b3a:	83 e0       	ldi	r24, 0x03	; 3
     b3c:	60 e8       	ldi	r22, 0x80	; 128
     b3e:	40 e0       	ldi	r20, 0x00	; 0
     b40:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  				break;
     b44:	08 95       	ret

  		break;
  	}
  	case ALL_MOTOR:
  	{
  switch(Motor_Direction)
     b46:	61 30       	cpi	r22, 0x01	; 1
     b48:	31 f0       	breq	.+12     	; 0xb56 <Motor_Direction+0xc4>
     b4a:	61 30       	cpi	r22, 0x01	; 1
     b4c:	70 f1       	brcs	.+92     	; 0xbaa <Motor_Direction+0x118>
     b4e:	62 30       	cpi	r22, 0x02	; 2
     b50:	09 f0       	breq	.+2      	; 0xb54 <Motor_Direction+0xc2>
     b52:	46 c0       	rjmp	.+140    	; 0xbe0 <Motor_Direction+0x14e>
     b54:	15 c0       	rjmp	.+42     	; 0xb80 <Motor_Direction+0xee>
  {
  	case MOTOR_FORWARD:
  	{
  		Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,HIGH);
     b56:	83 e0       	ldi	r24, 0x03	; 3
     b58:	64 e0       	ldi	r22, 0x04	; 4
     b5a:	4f ef       	ldi	r20, 0xFF	; 255
     b5c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     b60:	83 e0       	ldi	r24, 0x03	; 3
     b62:	68 e0       	ldi	r22, 0x08	; 8
     b64:	40 e0       	ldi	r20, 0x00	; 0
     b66:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  	Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     b6a:	83 e0       	ldi	r24, 0x03	; 3
     b6c:	60 e4       	ldi	r22, 0x40	; 64
     b6e:	40 e0       	ldi	r20, 0x00	; 0
     b70:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,HIGH);
     b74:	83 e0       	ldi	r24, 0x03	; 3
     b76:	60 e8       	ldi	r22, 0x80	; 128
     b78:	4f ef       	ldi	r20, 0xFF	; 255
     b7a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  		break;
     b7e:	08 95       	ret
  	}
  	case MOTOR_BACKWARD:
  	{

  		Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     b80:	83 e0       	ldi	r24, 0x03	; 3
     b82:	64 e0       	ldi	r22, 0x04	; 4
     b84:	40 e0       	ldi	r20, 0x00	; 0
     b86:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
      Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,HIGH);
     b8a:	83 e0       	ldi	r24, 0x03	; 3
     b8c:	68 e0       	ldi	r22, 0x08	; 8
     b8e:	4f ef       	ldi	r20, 0xFF	; 255
     b90:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,HIGH);
     b94:	83 e0       	ldi	r24, 0x03	; 3
     b96:	60 e4       	ldi	r22, 0x40	; 64
     b98:	4f ef       	ldi	r20, 0xFF	; 255
     b9a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     b9e:	83 e0       	ldi	r24, 0x03	; 3
     ba0:	60 e8       	ldi	r22, 0x80	; 128
     ba2:	40 e0       	ldi	r20, 0x00	; 0
     ba4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  		break;	}
     ba8:	08 95       	ret
  	case MOTOR_STOP:
  	{
  			Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     baa:	83 e0       	ldi	r24, 0x03	; 3
     bac:	64 e0       	ldi	r22, 0x04	; 4
     bae:	40 e0       	ldi	r20, 0x00	; 0
     bb0:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     bb4:	83 e0       	ldi	r24, 0x03	; 3
     bb6:	60 e4       	ldi	r22, 0x40	; 64
     bb8:	40 e0       	ldi	r20, 0x00	; 0
     bba:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  			Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     bbe:	83 e0       	ldi	r24, 0x03	; 3
     bc0:	68 e0       	ldi	r22, 0x08	; 8
     bc2:	40 e0       	ldi	r20, 0x00	; 0
     bc4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     bc8:	83 e0       	ldi	r24, 0x03	; 3
     bca:	60 e8       	ldi	r22, 0x80	; 128
     bcc:	40 e0       	ldi	r20, 0x00	; 0
     bce:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>

  		break;
     bd2:	08 95       	ret
    }
return Ret;
}

ERROR_STATUS Motor_Direction(uint8_t Motor_Number, uint8_t Motor_Direction)
{uint8_t Ret=0;
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	08 95       	ret
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	08 95       	ret
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	08 95       	ret
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);

  		break;
  	}
    default:
    Ret=E_NOK;
     be0:	81 e0       	ldi	r24, 0x01	; 1



    }
return Ret;
}
     be2:	08 95       	ret

00000be4 <Motor_Start>:


ERROR_STATUS Motor_Start(uint8_t Motor_Number, uint8_t Mot_Speed)
{
  uint8_t Ret=0;
switch (Motor_Number) {
     be4:	82 30       	cpi	r24, 0x02	; 2
     be6:	69 f0       	breq	.+26     	; 0xc02 <Motor_Start+0x1e>
     be8:	83 30       	cpi	r24, 0x03	; 3
     bea:	a9 f0       	breq	.+42     	; 0xc16 <Motor_Start+0x32>
     bec:	81 30       	cpi	r24, 0x01	; 1
     bee:	f1 f4       	brne	.+60     	; 0xc2c <Motor_Start+0x48>
  case MOTOR_1:
  {gsv_is_Started=MOTOR_1;
     bf0:	80 93 ef 00 	sts	0x00EF, r24
    Ret=Pwm_Start(PWM_CH1A,Mot_Speed,30);
     bf4:	2e e1       	ldi	r18, 0x1E	; 30
     bf6:	30 e0       	ldi	r19, 0x00	; 0
     bf8:	40 e0       	ldi	r20, 0x00	; 0
     bfa:	50 e0       	ldi	r21, 0x00	; 0
     bfc:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
    break;
     c00:	08 95       	ret
  }
  case MOTOR_2:
  {
    gsv_is_Started=MOTOR_2;
     c02:	82 e0       	ldi	r24, 0x02	; 2
     c04:	80 93 ef 00 	sts	0x00EF, r24
    Ret=Pwm_Start(PWM_CH1B,Mot_Speed,30);
     c08:	2e e1       	ldi	r18, 0x1E	; 30
     c0a:	30 e0       	ldi	r19, 0x00	; 0
     c0c:	40 e0       	ldi	r20, 0x00	; 0
     c0e:	50 e0       	ldi	r21, 0x00	; 0
     c10:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
    break;
     c14:	08 95       	ret
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    gsv_is_Started=MOTOR_1 | MOTOR_2;
     c16:	83 e0       	ldi	r24, 0x03	; 3
     c18:	80 93 ef 00 	sts	0x00EF, r24
    Ret=Pwm_Start(PWM_CH1B,Mot_Speed,30);
     c1c:	82 e0       	ldi	r24, 0x02	; 2
     c1e:	2e e1       	ldi	r18, 0x1E	; 30
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	40 e0       	ldi	r20, 0x00	; 0
     c24:	50 e0       	ldi	r21, 0x00	; 0
     c26:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
    break;
     c2a:	08 95       	ret
  }
  default:
  Ret=E_NOK;
     c2c:	81 e0       	ldi	r24, 0x01	; 1
  break;
}


return Ret;
}
     c2e:	08 95       	ret

00000c30 <Motor_SpeedUpdate>:
ERROR_STATUS Motor_SpeedUpdate(uint8_t Motor_Number, uint8_t Speed)
{
  uint8_t Ret=0;

switch (Motor_Number) {
     c30:	82 30       	cpi	r24, 0x02	; 2
     c32:	79 f0       	breq	.+30     	; 0xc52 <Motor_SpeedUpdate+0x22>
     c34:	83 30       	cpi	r24, 0x03	; 3
     c36:	c1 f0       	breq	.+48     	; 0xc68 <Motor_SpeedUpdate+0x38>
     c38:	81 30       	cpi	r24, 0x01	; 1
     c3a:	11 f5       	brne	.+68     	; 0xc80 <Motor_SpeedUpdate+0x50>
  case MOTOR_1:
  { if(gsv_is_intialized == Motor_Number)
     c3c:	80 91 ee 00 	lds	r24, 0x00EE
     c40:	81 30       	cpi	r24, 0x01	; 1
     c42:	01 f5       	brne	.+64     	; 0xc84 <Motor_SpeedUpdate+0x54>
    Ret=Pwm_Start(PWM_CH1A,Speed,30);
     c44:	2e e1       	ldi	r18, 0x1E	; 30
     c46:	30 e0       	ldi	r19, 0x00	; 0
     c48:	40 e0       	ldi	r20, 0x00	; 0
     c4a:	50 e0       	ldi	r21, 0x00	; 0
     c4c:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
     c50:	08 95       	ret
    else{Ret=E_NOK;}
    break;
  }
  case MOTOR_2:
  {
    if(gsv_is_intialized == Motor_Number)
     c52:	80 91 ee 00 	lds	r24, 0x00EE
     c56:	82 30       	cpi	r24, 0x02	; 2
     c58:	b9 f4       	brne	.+46     	; 0xc88 <Motor_SpeedUpdate+0x58>
      Ret=Pwm_Start(PWM_CH1B,Speed,30);
     c5a:	2e e1       	ldi	r18, 0x1E	; 30
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	40 e0       	ldi	r20, 0x00	; 0
     c60:	50 e0       	ldi	r21, 0x00	; 0
     c62:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
     c66:	08 95       	ret
      else{Ret=E_NOK;}
    break;
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    if(gsv_is_intialized == Motor_Number)
     c68:	80 91 ee 00 	lds	r24, 0x00EE
     c6c:	83 30       	cpi	r24, 0x03	; 3
     c6e:	71 f4       	brne	.+28     	; 0xc8c <Motor_SpeedUpdate+0x5c>
        Ret=Pwm_Start(PWM_CH1B,Speed,30);
     c70:	82 e0       	ldi	r24, 0x02	; 2
     c72:	2e e1       	ldi	r18, 0x1E	; 30
     c74:	30 e0       	ldi	r19, 0x00	; 0
     c76:	40 e0       	ldi	r20, 0x00	; 0
     c78:	50 e0       	ldi	r21, 0x00	; 0
     c7a:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
     c7e:	08 95       	ret
        else{Ret=E_NOK;}
    break;
  }
  default:
  Ret=E_NOK;
     c80:	81 e0       	ldi	r24, 0x01	; 1
     c82:	08 95       	ret

switch (Motor_Number) {
  case MOTOR_1:
  { if(gsv_is_intialized == Motor_Number)
    Ret=Pwm_Start(PWM_CH1A,Speed,30);
    else{Ret=E_NOK;}
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	08 95       	ret
  }
  case MOTOR_2:
  {
    if(gsv_is_intialized == Motor_Number)
      Ret=Pwm_Start(PWM_CH1B,Speed,30);
      else{Ret=E_NOK;}
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	08 95       	ret
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    if(gsv_is_intialized == Motor_Number)
        Ret=Pwm_Start(PWM_CH1B,Speed,30);
        else{Ret=E_NOK;}
     c8c:	81 e0       	ldi	r24, 0x01	; 1
  Ret=E_NOK;
  break;
}

return Ret;
}
     c8e:	08 95       	ret

00000c90 <Motor_Stop>:

ERROR_STATUS Motor_Stop(uint8_t Motor_Number)
{
	uint8_t Ret=0;
	switch(Motor_Number)
     c90:	81 30       	cpi	r24, 0x01	; 1
     c92:	19 f0       	breq	.+6      	; 0xc9a <Motor_Stop+0xa>
     c94:	82 30       	cpi	r24, 0x02	; 2
     c96:	49 f4       	brne	.+18     	; 0xcaa <Motor_Stop+0x1a>
     c98:	04 c0       	rjmp	.+8      	; 0xca2 <Motor_Stop+0x12>
	{
		case MOTOR_1 :
		Ret=Pwm_Stop(PWM_CH1A);
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <Pwm_Stop>
		break;
     ca0:	08 95       	ret
		case MOTOR_2:
		Ret=Pwm_Stop(PWM_CH1B);
     ca2:	82 e0       	ldi	r24, 0x02	; 2
     ca4:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <Pwm_Stop>
		break;
     ca8:	08 95       	ret
		default:
		Ret=E_NOK;
     caa:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}


	return Ret;
}
     cac:	08 95       	ret

00000cae <Motor_GetStatus>:

 ERROR_STATUS Motor_GetStatus(uint8_t Motor_Number, uint8_t* Mot_status)
 {
	 if(gsv_is_intialized == Motor_Number)
     cae:	90 91 ee 00 	lds	r25, 0x00EE
     cb2:	98 17       	cp	r25, r24
     cb4:	21 f4       	brne	.+8      	; 0xcbe <Motor_GetStatus+0x10>
		*Mot_status=1;
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	fb 01       	movw	r30, r22
     cba:	80 83       	st	Z, r24
     cbc:	08 95       	ret
	 else
	 {
		*Mot_status=0;
     cbe:	fb 01       	movw	r30, r22
     cc0:	10 82       	st	Z, r1
	 }
	 
 }
     cc2:	08 95       	ret

00000cc4 <SwDelay_ms>:
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     cc4:	dc 01       	movw	r26, r24
     cc6:	cb 01       	movw	r24, r22
	uint8_t counter_256;
	uint8_t counter_21;
	while (n)
     cc8:	00 97       	sbiw	r24, 0x00	; 0
     cca:	a1 05       	cpc	r26, r1
     ccc:	b1 05       	cpc	r27, r1
     cce:	61 f4       	brne	.+24     	; 0xce8 <SwDelay_ms+0x24>
     cd0:	08 95       	ret
     cd2:	21 50       	subi	r18, 0x01	; 1
		counter_21 = 21;
		while (counter_21)
		{
			/* every 256 branch costs 48 micro seconds */
			counter_256 = 255;
			while (counter_256)
     cd4:	f1 f7       	brne	.-4      	; 0xcd2 <SwDelay_ms+0xe>
     cd6:	31 50       	subi	r19, 0x01	; 1
	uint8_t counter_21;
	while (n)
	{
		/* every 21 repetition of the 256 branches costs almost 1 milli second as: 48 micro x 21 = 1.008 milli second*/
		counter_21 = 21;
		while (counter_21)
     cd8:	11 f0       	breq	.+4      	; 0xcde <SwDelay_ms+0x1a>
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     cda:	24 2f       	mov	r18, r20
     cdc:	fa cf       	rjmp	.-12     	; 0xcd2 <SwDelay_ms+0xe>
			{
				counter_256--;
			}
			counter_21--;
		}
		n--;
     cde:	01 97       	sbiw	r24, 0x01	; 1
     ce0:	a1 09       	sbc	r26, r1
     ce2:	b1 09       	sbc	r27, r1
 */
void SwDelay_ms(uint32_t n)
{
	uint8_t counter_256;
	uint8_t counter_21;
	while (n)
     ce4:	19 f4       	brne	.+6      	; 0xcec <SwDelay_ms+0x28>
     ce6:	08 95       	ret
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     ce8:	55 e1       	ldi	r21, 0x15	; 21
     cea:	4f ef       	ldi	r20, 0xFF	; 255
     cec:	35 2f       	mov	r19, r21
     cee:	f5 cf       	rjmp	.-22     	; 0xcda <SwDelay_ms+0x16>

00000cf0 <SwDelay_us>:
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32_t n)
{
     cf0:	dc 01       	movw	r26, r24
     cf2:	cb 01       	movw	r24, r22
	while (n)
     cf4:	00 97       	sbiw	r24, 0x00	; 0
     cf6:	a1 05       	cpc	r26, r1
     cf8:	b1 05       	cpc	r27, r1
     cfa:	21 f0       	breq	.+8      	; 0xd04 <SwDelay_us+0x14>
	{
		n--;
     cfc:	01 97       	sbiw	r24, 0x01	; 1
     cfe:	a1 09       	sbc	r26, r1
     d00:	b1 09       	sbc	r27, r1
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32_t n)
{
	while (n)
     d02:	e1 f7       	brne	.-8      	; 0xcfc <SwDelay_us+0xc>
     d04:	08 95       	ret

00000d06 <Us_Init>:
 *                                                                                                  *
 ***************************************************************************************************/

ERROR_STATUS Us_Init(void)
{uint8_t Ret;
Ret=DIO_init(&US_Configuration);
     d06:	8f e6       	ldi	r24, 0x6F	; 111
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
Ret=Icu_Init(&ICU_Configuration);
     d0e:	8e eb       	ldi	r24, 0xBE	; 190
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	0e 94 c3 0b 	call	0x1786	; 0x1786 <Icu_Init>
return Ret;
}
     d16:	08 95       	ret

00000d18 <Us_Trigger>:
ERROR_STATUS Us_Trigger(void)
{uint8_t Ret=0;
Ret=DIO_Write(GPIOC,BIT4,HIGH);
     d18:	82 e0       	ldi	r24, 0x02	; 2
     d1a:	90 e0       	ldi	r25, 0x00	; 0
     d1c:	60 e1       	ldi	r22, 0x10	; 16
     d1e:	70 e0       	ldi	r23, 0x00	; 0
     d20:	4f ef       	ldi	r20, 0xFF	; 255
     d22:	50 e0       	ldi	r21, 0x00	; 0
     d24:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
/***********************************************/
Timer_Start(TIMER_CH0,10);
     d28:	80 e0       	ldi	r24, 0x00	; 0
     d2a:	6a e0       	ldi	r22, 0x0A	; 10
     d2c:	70 e0       	ldi	r23, 0x00	; 0
     d2e:	0e 94 20 10 	call	0x2040	; 0x2040 <Timer_Start>
/**********************************************/
Ret=DIO_Write(GPIOC,BIT4,LOW);
     d32:	82 e0       	ldi	r24, 0x02	; 2
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	60 e1       	ldi	r22, 0x10	; 16
     d38:	70 e0       	ldi	r23, 0x00	; 0
     d3a:	40 e0       	ldi	r20, 0x00	; 0
     d3c:	50 e0       	ldi	r21, 0x00	; 0
     d3e:	0e 94 3b 0b 	call	0x1676	; 0x1676 <DIO_Write>
return Ret;	
}
     d42:	08 95       	ret

00000d44 <Us_GetDistance>:


ERROR_STATUS Us_GetDistance(uint16_t *Distance)
{uint8_t Ret=0;
     d44:	0f 93       	push	r16
     d46:	1f 93       	push	r17
     d48:	cf 93       	push	r28
     d4a:	df 93       	push	r29
     d4c:	00 d0       	rcall	.+0      	; 0xd4e <Us_GetDistance+0xa>
     d4e:	00 d0       	rcall	.+0      	; 0xd50 <Us_GetDistance+0xc>
     d50:	cd b7       	in	r28, 0x3d	; 61
     d52:	de b7       	in	r29, 0x3e	; 62
     d54:	8c 01       	movw	r16, r24
	uint32_t u32l_Time;
	Ret=Icu_ReadTime(ICU_CH2,ICU_RISE_TO_FALL,&u32l_Time);
     d56:	82 e0       	ldi	r24, 0x02	; 2
     d58:	61 e0       	ldi	r22, 0x01	; 1
     d5a:	ae 01       	movw	r20, r28
     d5c:	4f 5f       	subi	r20, 0xFF	; 255
     d5e:	5f 4f       	sbci	r21, 0xFF	; 255
     d60:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <Icu_ReadTime>
	*Distance=u32l_Time;
     d64:	29 81       	ldd	r18, Y+1	; 0x01
     d66:	3a 81       	ldd	r19, Y+2	; 0x02
     d68:	f8 01       	movw	r30, r16
     d6a:	31 83       	std	Z+1, r19	; 0x01
     d6c:	20 83       	st	Z, r18
	return Ret;
}
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	08 95       	ret

00000d80 <G_interrupt_Enable>:
ptr_to_Fun TWI_I2C;
ptr_to_Fun SPM_RDY;

void G_interrupt_Enable(void)
{
 SREG |=(0x80);
     d80:	8f b7       	in	r24, 0x3f	; 63
     d82:	80 68       	ori	r24, 0x80	; 128
     d84:	8f bf       	out	0x3f, r24	; 63
}
     d86:	08 95       	ret

00000d88 <EX_interrupt_enable2>:
void EX_interrupt_enable2(void)
{
CLEAR_BIT(PORTB_DIR,2);/*Input*/
     d88:	ba 98       	cbi	0x17, 2	; 23
SET_BIT(PORTB_DATA,2);/*Pullup*/
     d8a:	c2 9a       	sbi	0x18, 2	; 24
SET_BIT(GICR,INT2);/*EXT2*/
     d8c:	8b b7       	in	r24, 0x3b	; 59
     d8e:	80 62       	ori	r24, 0x20	; 32
     d90:	8b bf       	out	0x3b, r24	; 59
SET_BIT(MCUCSR,6);/*Rising*/
     d92:	84 b7       	in	r24, 0x34	; 52
     d94:	80 64       	ori	r24, 0x40	; 64
     d96:	84 bf       	out	0x34, r24	; 52
}
     d98:	08 95       	ret

00000d9a <EX_interrupt_enable1>:
void EX_interrupt_enable1(void)
{
	CLEAR_BIT(PORTD_DIR,3);
     d9a:	8b 98       	cbi	0x11, 3	; 17
	SET_BIT(PORTD_DATA,3);
     d9c:	93 9a       	sbi	0x12, 3	; 18
	SET_BIT(GICR,INT1);
     d9e:	8b b7       	in	r24, 0x3b	; 59
     da0:	80 68       	ori	r24, 0x80	; 128
     da2:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(MCUCR,2);/*Any logical change*/
     da4:	85 b7       	in	r24, 0x35	; 53
     da6:	84 60       	ori	r24, 0x04	; 4
     da8:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR,3);
     daa:	85 b7       	in	r24, 0x35	; 53
     dac:	87 7f       	andi	r24, 0xF7	; 247
     dae:	85 bf       	out	0x35, r24	; 53
	
}
     db0:	08 95       	ret

00000db2 <EX_interrupt_enable0>:
void EX_interrupt_enable0(void)
{
	CLEAR_BIT(PORTD_DIR,2);
     db2:	8a 98       	cbi	0x11, 2	; 17
	SET_BIT(PORTD_DATA,2);
     db4:	92 9a       	sbi	0x12, 2	; 18
	SET_BIT(GICR,INT0);
     db6:	8b b7       	in	r24, 0x3b	; 59
     db8:	80 64       	ori	r24, 0x40	; 64
     dba:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(MCUCR,0);/*Any logical change*/
     dbc:	85 b7       	in	r24, 0x35	; 53
     dbe:	81 60       	ori	r24, 0x01	; 1
     dc0:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR,1);
     dc2:	85 b7       	in	r24, 0x35	; 53
     dc4:	8d 7f       	andi	r24, 0xFD	; 253
     dc6:	85 bf       	out	0x35, r24	; 53
	
}
     dc8:	08 95       	ret

00000dca <G_interrupt_Disable>:
void G_interrupt_Disable(void)
{
CLEAR_BIT(SREG,7);
     dca:	8f b7       	in	r24, 0x3f	; 63
     dcc:	8f 77       	andi	r24, 0x7F	; 127
     dce:	8f bf       	out	0x3f, r24	; 63
}
     dd0:	08 95       	ret

00000dd2 <__vector_1>:
void __vector_1(void) __attribute__((signal));
void __vector_1(void)
{
     dd2:	1f 92       	push	r1
     dd4:	0f 92       	push	r0
     dd6:	0f b6       	in	r0, 0x3f	; 63
     dd8:	0f 92       	push	r0
     dda:	11 24       	eor	r1, r1
     ddc:	2f 93       	push	r18
     dde:	3f 93       	push	r19
     de0:	4f 93       	push	r20
     de2:	5f 93       	push	r21
     de4:	6f 93       	push	r22
     de6:	7f 93       	push	r23
     de8:	8f 93       	push	r24
     dea:	9f 93       	push	r25
     dec:	af 93       	push	r26
     dee:	bf 93       	push	r27
     df0:	ef 93       	push	r30
     df2:	ff 93       	push	r31
  INT0_external_interrupt();
     df4:	e0 91 7a 05 	lds	r30, 0x057A
     df8:	f0 91 7b 05 	lds	r31, 0x057B
     dfc:	09 95       	icall
}
     dfe:	ff 91       	pop	r31
     e00:	ef 91       	pop	r30
     e02:	bf 91       	pop	r27
     e04:	af 91       	pop	r26
     e06:	9f 91       	pop	r25
     e08:	8f 91       	pop	r24
     e0a:	7f 91       	pop	r23
     e0c:	6f 91       	pop	r22
     e0e:	5f 91       	pop	r21
     e10:	4f 91       	pop	r20
     e12:	3f 91       	pop	r19
     e14:	2f 91       	pop	r18
     e16:	0f 90       	pop	r0
     e18:	0f be       	out	0x3f, r0	; 63
     e1a:	0f 90       	pop	r0
     e1c:	1f 90       	pop	r1
     e1e:	18 95       	reti

00000e20 <__vector_2>:


void __vector_2(void) __attribute__((signal));
void __vector_2(void)
{
     e20:	1f 92       	push	r1
     e22:	0f 92       	push	r0
     e24:	0f b6       	in	r0, 0x3f	; 63
     e26:	0f 92       	push	r0
     e28:	11 24       	eor	r1, r1
     e2a:	2f 93       	push	r18
     e2c:	3f 93       	push	r19
     e2e:	4f 93       	push	r20
     e30:	5f 93       	push	r21
     e32:	6f 93       	push	r22
     e34:	7f 93       	push	r23
     e36:	8f 93       	push	r24
     e38:	9f 93       	push	r25
     e3a:	af 93       	push	r26
     e3c:	bf 93       	push	r27
     e3e:	ef 93       	push	r30
     e40:	ff 93       	push	r31
  INT1_external_interrupt();
     e42:	e0 91 82 05 	lds	r30, 0x0582
     e46:	f0 91 83 05 	lds	r31, 0x0583
     e4a:	09 95       	icall
}
     e4c:	ff 91       	pop	r31
     e4e:	ef 91       	pop	r30
     e50:	bf 91       	pop	r27
     e52:	af 91       	pop	r26
     e54:	9f 91       	pop	r25
     e56:	8f 91       	pop	r24
     e58:	7f 91       	pop	r23
     e5a:	6f 91       	pop	r22
     e5c:	5f 91       	pop	r21
     e5e:	4f 91       	pop	r20
     e60:	3f 91       	pop	r19
     e62:	2f 91       	pop	r18
     e64:	0f 90       	pop	r0
     e66:	0f be       	out	0x3f, r0	; 63
     e68:	0f 90       	pop	r0
     e6a:	1f 90       	pop	r1
     e6c:	18 95       	reti

00000e6e <__vector_3>:


void __vector_3(void) __attribute__((signal));
void __vector_3(void)
{
     e6e:	1f 92       	push	r1
     e70:	0f 92       	push	r0
     e72:	0f b6       	in	r0, 0x3f	; 63
     e74:	0f 92       	push	r0
     e76:	11 24       	eor	r1, r1
     e78:	2f 93       	push	r18
     e7a:	3f 93       	push	r19
     e7c:	4f 93       	push	r20
     e7e:	5f 93       	push	r21
     e80:	6f 93       	push	r22
     e82:	7f 93       	push	r23
     e84:	8f 93       	push	r24
     e86:	9f 93       	push	r25
     e88:	af 93       	push	r26
     e8a:	bf 93       	push	r27
     e8c:	ef 93       	push	r30
     e8e:	ff 93       	push	r31
  INT2_external_interrupt();
     e90:	e0 91 72 05 	lds	r30, 0x0572
     e94:	f0 91 73 05 	lds	r31, 0x0573
     e98:	09 95       	icall
}
     e9a:	ff 91       	pop	r31
     e9c:	ef 91       	pop	r30
     e9e:	bf 91       	pop	r27
     ea0:	af 91       	pop	r26
     ea2:	9f 91       	pop	r25
     ea4:	8f 91       	pop	r24
     ea6:	7f 91       	pop	r23
     ea8:	6f 91       	pop	r22
     eaa:	5f 91       	pop	r21
     eac:	4f 91       	pop	r20
     eae:	3f 91       	pop	r19
     eb0:	2f 91       	pop	r18
     eb2:	0f 90       	pop	r0
     eb4:	0f be       	out	0x3f, r0	; 63
     eb6:	0f 90       	pop	r0
     eb8:	1f 90       	pop	r1
     eba:	18 95       	reti

00000ebc <__vector_4>:


void __vector_4(void) __attribute__((signal));
void __vector_4(void)
{
     ebc:	1f 92       	push	r1
     ebe:	0f 92       	push	r0
     ec0:	0f b6       	in	r0, 0x3f	; 63
     ec2:	0f 92       	push	r0
     ec4:	11 24       	eor	r1, r1
     ec6:	2f 93       	push	r18
     ec8:	3f 93       	push	r19
     eca:	4f 93       	push	r20
     ecc:	5f 93       	push	r21
     ece:	6f 93       	push	r22
     ed0:	7f 93       	push	r23
     ed2:	8f 93       	push	r24
     ed4:	9f 93       	push	r25
     ed6:	af 93       	push	r26
     ed8:	bf 93       	push	r27
     eda:	ef 93       	push	r30
     edc:	ff 93       	push	r31
TIMER2COMP();
     ede:	e0 91 88 05 	lds	r30, 0x0588
     ee2:	f0 91 89 05 	lds	r31, 0x0589
     ee6:	09 95       	icall
}
     ee8:	ff 91       	pop	r31
     eea:	ef 91       	pop	r30
     eec:	bf 91       	pop	r27
     eee:	af 91       	pop	r26
     ef0:	9f 91       	pop	r25
     ef2:	8f 91       	pop	r24
     ef4:	7f 91       	pop	r23
     ef6:	6f 91       	pop	r22
     ef8:	5f 91       	pop	r21
     efa:	4f 91       	pop	r20
     efc:	3f 91       	pop	r19
     efe:	2f 91       	pop	r18
     f00:	0f 90       	pop	r0
     f02:	0f be       	out	0x3f, r0	; 63
     f04:	0f 90       	pop	r0
     f06:	1f 90       	pop	r1
     f08:	18 95       	reti

00000f0a <__vector_5>:


void __vector_5(void) __attribute__((signal));
void __vector_5(void)
{
     f0a:	1f 92       	push	r1
     f0c:	0f 92       	push	r0
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	0f 92       	push	r0
     f12:	11 24       	eor	r1, r1
     f14:	2f 93       	push	r18
     f16:	3f 93       	push	r19
     f18:	4f 93       	push	r20
     f1a:	5f 93       	push	r21
     f1c:	6f 93       	push	r22
     f1e:	7f 93       	push	r23
     f20:	8f 93       	push	r24
     f22:	9f 93       	push	r25
     f24:	af 93       	push	r26
     f26:	bf 93       	push	r27
     f28:	ef 93       	push	r30
     f2a:	ff 93       	push	r31
  TIMER2OVF();
     f2c:	e0 91 68 05 	lds	r30, 0x0568
     f30:	f0 91 69 05 	lds	r31, 0x0569
     f34:	09 95       	icall
}
     f36:	ff 91       	pop	r31
     f38:	ef 91       	pop	r30
     f3a:	bf 91       	pop	r27
     f3c:	af 91       	pop	r26
     f3e:	9f 91       	pop	r25
     f40:	8f 91       	pop	r24
     f42:	7f 91       	pop	r23
     f44:	6f 91       	pop	r22
     f46:	5f 91       	pop	r21
     f48:	4f 91       	pop	r20
     f4a:	3f 91       	pop	r19
     f4c:	2f 91       	pop	r18
     f4e:	0f 90       	pop	r0
     f50:	0f be       	out	0x3f, r0	; 63
     f52:	0f 90       	pop	r0
     f54:	1f 90       	pop	r1
     f56:	18 95       	reti

00000f58 <__vector_6>:

void __vector_6(void) __attribute__((signal));
void __vector_6(void)
{
     f58:	1f 92       	push	r1
     f5a:	0f 92       	push	r0
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	0f 92       	push	r0
     f60:	11 24       	eor	r1, r1
     f62:	2f 93       	push	r18
     f64:	3f 93       	push	r19
     f66:	4f 93       	push	r20
     f68:	5f 93       	push	r21
     f6a:	6f 93       	push	r22
     f6c:	7f 93       	push	r23
     f6e:	8f 93       	push	r24
     f70:	9f 93       	push	r25
     f72:	af 93       	push	r26
     f74:	bf 93       	push	r27
     f76:	ef 93       	push	r30
     f78:	ff 93       	push	r31
  TIMER1CAPT();
     f7a:	e0 91 84 05 	lds	r30, 0x0584
     f7e:	f0 91 85 05 	lds	r31, 0x0585
     f82:	09 95       	icall
}
     f84:	ff 91       	pop	r31
     f86:	ef 91       	pop	r30
     f88:	bf 91       	pop	r27
     f8a:	af 91       	pop	r26
     f8c:	9f 91       	pop	r25
     f8e:	8f 91       	pop	r24
     f90:	7f 91       	pop	r23
     f92:	6f 91       	pop	r22
     f94:	5f 91       	pop	r21
     f96:	4f 91       	pop	r20
     f98:	3f 91       	pop	r19
     f9a:	2f 91       	pop	r18
     f9c:	0f 90       	pop	r0
     f9e:	0f be       	out	0x3f, r0	; 63
     fa0:	0f 90       	pop	r0
     fa2:	1f 90       	pop	r1
     fa4:	18 95       	reti

00000fa6 <__vector_7>:

void __vector_7(void) __attribute__((signal));
void __vector_7(void)
{
     fa6:	1f 92       	push	r1
     fa8:	0f 92       	push	r0
     faa:	0f b6       	in	r0, 0x3f	; 63
     fac:	0f 92       	push	r0
     fae:	11 24       	eor	r1, r1
     fb0:	2f 93       	push	r18
     fb2:	3f 93       	push	r19
     fb4:	4f 93       	push	r20
     fb6:	5f 93       	push	r21
     fb8:	6f 93       	push	r22
     fba:	7f 93       	push	r23
     fbc:	8f 93       	push	r24
     fbe:	9f 93       	push	r25
     fc0:	af 93       	push	r26
     fc2:	bf 93       	push	r27
     fc4:	ef 93       	push	r30
     fc6:	ff 93       	push	r31
TIMER1COMPA();
     fc8:	e0 91 6e 05 	lds	r30, 0x056E
     fcc:	f0 91 6f 05 	lds	r31, 0x056F
     fd0:	09 95       	icall
}
     fd2:	ff 91       	pop	r31
     fd4:	ef 91       	pop	r30
     fd6:	bf 91       	pop	r27
     fd8:	af 91       	pop	r26
     fda:	9f 91       	pop	r25
     fdc:	8f 91       	pop	r24
     fde:	7f 91       	pop	r23
     fe0:	6f 91       	pop	r22
     fe2:	5f 91       	pop	r21
     fe4:	4f 91       	pop	r20
     fe6:	3f 91       	pop	r19
     fe8:	2f 91       	pop	r18
     fea:	0f 90       	pop	r0
     fec:	0f be       	out	0x3f, r0	; 63
     fee:	0f 90       	pop	r0
     ff0:	1f 90       	pop	r1
     ff2:	18 95       	reti

00000ff4 <__vector_8>:

void __vector_8(void) __attribute__((signal));
void __vector_8(void)
{
     ff4:	1f 92       	push	r1
     ff6:	0f 92       	push	r0
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	0f 92       	push	r0
     ffc:	11 24       	eor	r1, r1
     ffe:	2f 93       	push	r18
    1000:	3f 93       	push	r19
    1002:	4f 93       	push	r20
    1004:	5f 93       	push	r21
    1006:	6f 93       	push	r22
    1008:	7f 93       	push	r23
    100a:	8f 93       	push	r24
    100c:	9f 93       	push	r25
    100e:	af 93       	push	r26
    1010:	bf 93       	push	r27
    1012:	ef 93       	push	r30
    1014:	ff 93       	push	r31
  TIMER1COMPB();
    1016:	e0 91 6c 05 	lds	r30, 0x056C
    101a:	f0 91 6d 05 	lds	r31, 0x056D
    101e:	09 95       	icall
}
    1020:	ff 91       	pop	r31
    1022:	ef 91       	pop	r30
    1024:	bf 91       	pop	r27
    1026:	af 91       	pop	r26
    1028:	9f 91       	pop	r25
    102a:	8f 91       	pop	r24
    102c:	7f 91       	pop	r23
    102e:	6f 91       	pop	r22
    1030:	5f 91       	pop	r21
    1032:	4f 91       	pop	r20
    1034:	3f 91       	pop	r19
    1036:	2f 91       	pop	r18
    1038:	0f 90       	pop	r0
    103a:	0f be       	out	0x3f, r0	; 63
    103c:	0f 90       	pop	r0
    103e:	1f 90       	pop	r1
    1040:	18 95       	reti

00001042 <__vector_9>:

void __vector_9(void) __attribute__((signal));
void __vector_9(void)
{
    1042:	1f 92       	push	r1
    1044:	0f 92       	push	r0
    1046:	0f b6       	in	r0, 0x3f	; 63
    1048:	0f 92       	push	r0
    104a:	11 24       	eor	r1, r1
    104c:	2f 93       	push	r18
    104e:	3f 93       	push	r19
    1050:	4f 93       	push	r20
    1052:	5f 93       	push	r21
    1054:	6f 93       	push	r22
    1056:	7f 93       	push	r23
    1058:	8f 93       	push	r24
    105a:	9f 93       	push	r25
    105c:	af 93       	push	r26
    105e:	bf 93       	push	r27
    1060:	ef 93       	push	r30
    1062:	ff 93       	push	r31
  TIMER1OVF();
    1064:	e0 91 86 05 	lds	r30, 0x0586
    1068:	f0 91 87 05 	lds	r31, 0x0587
    106c:	09 95       	icall
}
    106e:	ff 91       	pop	r31
    1070:	ef 91       	pop	r30
    1072:	bf 91       	pop	r27
    1074:	af 91       	pop	r26
    1076:	9f 91       	pop	r25
    1078:	8f 91       	pop	r24
    107a:	7f 91       	pop	r23
    107c:	6f 91       	pop	r22
    107e:	5f 91       	pop	r21
    1080:	4f 91       	pop	r20
    1082:	3f 91       	pop	r19
    1084:	2f 91       	pop	r18
    1086:	0f 90       	pop	r0
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	0f 90       	pop	r0
    108c:	1f 90       	pop	r1
    108e:	18 95       	reti

00001090 <__vector_10>:

void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
    1090:	1f 92       	push	r1
    1092:	0f 92       	push	r0
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	0f 92       	push	r0
    1098:	11 24       	eor	r1, r1
    109a:	2f 93       	push	r18
    109c:	3f 93       	push	r19
    109e:	4f 93       	push	r20
    10a0:	5f 93       	push	r21
    10a2:	6f 93       	push	r22
    10a4:	7f 93       	push	r23
    10a6:	8f 93       	push	r24
    10a8:	9f 93       	push	r25
    10aa:	af 93       	push	r26
    10ac:	bf 93       	push	r27
    10ae:	ef 93       	push	r30
    10b0:	ff 93       	push	r31

  TIMER0COMP();
    10b2:	e0 91 7e 05 	lds	r30, 0x057E
    10b6:	f0 91 7f 05 	lds	r31, 0x057F
    10ba:	09 95       	icall
}
    10bc:	ff 91       	pop	r31
    10be:	ef 91       	pop	r30
    10c0:	bf 91       	pop	r27
    10c2:	af 91       	pop	r26
    10c4:	9f 91       	pop	r25
    10c6:	8f 91       	pop	r24
    10c8:	7f 91       	pop	r23
    10ca:	6f 91       	pop	r22
    10cc:	5f 91       	pop	r21
    10ce:	4f 91       	pop	r20
    10d0:	3f 91       	pop	r19
    10d2:	2f 91       	pop	r18
    10d4:	0f 90       	pop	r0
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	0f 90       	pop	r0
    10da:	1f 90       	pop	r1
    10dc:	18 95       	reti

000010de <__vector_11>:

void __vector_11(void) __attribute__((signal));
void __vector_11(void)
{
    10de:	1f 92       	push	r1
    10e0:	0f 92       	push	r0
    10e2:	0f b6       	in	r0, 0x3f	; 63
    10e4:	0f 92       	push	r0
    10e6:	11 24       	eor	r1, r1
    10e8:	2f 93       	push	r18
    10ea:	3f 93       	push	r19
    10ec:	4f 93       	push	r20
    10ee:	5f 93       	push	r21
    10f0:	6f 93       	push	r22
    10f2:	7f 93       	push	r23
    10f4:	8f 93       	push	r24
    10f6:	9f 93       	push	r25
    10f8:	af 93       	push	r26
    10fa:	bf 93       	push	r27
    10fc:	ef 93       	push	r30
    10fe:	ff 93       	push	r31

  TIMER0OVF_INT();
    1100:	e0 91 72 00 	lds	r30, 0x0072
    1104:	f0 91 73 00 	lds	r31, 0x0073
    1108:	09 95       	icall
}
    110a:	ff 91       	pop	r31
    110c:	ef 91       	pop	r30
    110e:	bf 91       	pop	r27
    1110:	af 91       	pop	r26
    1112:	9f 91       	pop	r25
    1114:	8f 91       	pop	r24
    1116:	7f 91       	pop	r23
    1118:	6f 91       	pop	r22
    111a:	5f 91       	pop	r21
    111c:	4f 91       	pop	r20
    111e:	3f 91       	pop	r19
    1120:	2f 91       	pop	r18
    1122:	0f 90       	pop	r0
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	0f 90       	pop	r0
    1128:	1f 90       	pop	r1
    112a:	18 95       	reti

0000112c <__vector_12>:

void __vector_12(void) __attribute__((signal));
void __vector_12(void)
{
    112c:	1f 92       	push	r1
    112e:	0f 92       	push	r0
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	0f 92       	push	r0
    1134:	11 24       	eor	r1, r1
    1136:	2f 93       	push	r18
    1138:	3f 93       	push	r19
    113a:	4f 93       	push	r20
    113c:	5f 93       	push	r21
    113e:	6f 93       	push	r22
    1140:	7f 93       	push	r23
    1142:	8f 93       	push	r24
    1144:	9f 93       	push	r25
    1146:	af 93       	push	r26
    1148:	bf 93       	push	r27
    114a:	ef 93       	push	r30
    114c:	ff 93       	push	r31
  SPI_STC();
    114e:	e0 91 70 05 	lds	r30, 0x0570
    1152:	f0 91 71 05 	lds	r31, 0x0571
    1156:	09 95       	icall
}
    1158:	ff 91       	pop	r31
    115a:	ef 91       	pop	r30
    115c:	bf 91       	pop	r27
    115e:	af 91       	pop	r26
    1160:	9f 91       	pop	r25
    1162:	8f 91       	pop	r24
    1164:	7f 91       	pop	r23
    1166:	6f 91       	pop	r22
    1168:	5f 91       	pop	r21
    116a:	4f 91       	pop	r20
    116c:	3f 91       	pop	r19
    116e:	2f 91       	pop	r18
    1170:	0f 90       	pop	r0
    1172:	0f be       	out	0x3f, r0	; 63
    1174:	0f 90       	pop	r0
    1176:	1f 90       	pop	r1
    1178:	18 95       	reti

0000117a <__vector_13>:

void __vector_13(void) __attribute__((signal));
void __vector_13(void)
{
    117a:	1f 92       	push	r1
    117c:	0f 92       	push	r0
    117e:	0f b6       	in	r0, 0x3f	; 63
    1180:	0f 92       	push	r0
    1182:	11 24       	eor	r1, r1
    1184:	2f 93       	push	r18
    1186:	3f 93       	push	r19
    1188:	4f 93       	push	r20
    118a:	5f 93       	push	r21
    118c:	6f 93       	push	r22
    118e:	7f 93       	push	r23
    1190:	8f 93       	push	r24
    1192:	9f 93       	push	r25
    1194:	af 93       	push	r26
    1196:	bf 93       	push	r27
    1198:	ef 93       	push	r30
    119a:	ff 93       	push	r31
  USART_RXC();
    119c:	e0 91 66 05 	lds	r30, 0x0566
    11a0:	f0 91 67 05 	lds	r31, 0x0567
    11a4:	09 95       	icall
}
    11a6:	ff 91       	pop	r31
    11a8:	ef 91       	pop	r30
    11aa:	bf 91       	pop	r27
    11ac:	af 91       	pop	r26
    11ae:	9f 91       	pop	r25
    11b0:	8f 91       	pop	r24
    11b2:	7f 91       	pop	r23
    11b4:	6f 91       	pop	r22
    11b6:	5f 91       	pop	r21
    11b8:	4f 91       	pop	r20
    11ba:	3f 91       	pop	r19
    11bc:	2f 91       	pop	r18
    11be:	0f 90       	pop	r0
    11c0:	0f be       	out	0x3f, r0	; 63
    11c2:	0f 90       	pop	r0
    11c4:	1f 90       	pop	r1
    11c6:	18 95       	reti

000011c8 <__vector_14>:

void __vector_14(void) __attribute__((signal));
void __vector_14(void)
{
    11c8:	1f 92       	push	r1
    11ca:	0f 92       	push	r0
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	0f 92       	push	r0
    11d0:	11 24       	eor	r1, r1
    11d2:	2f 93       	push	r18
    11d4:	3f 93       	push	r19
    11d6:	4f 93       	push	r20
    11d8:	5f 93       	push	r21
    11da:	6f 93       	push	r22
    11dc:	7f 93       	push	r23
    11de:	8f 93       	push	r24
    11e0:	9f 93       	push	r25
    11e2:	af 93       	push	r26
    11e4:	bf 93       	push	r27
    11e6:	ef 93       	push	r30
    11e8:	ff 93       	push	r31
  USART_UDRE();
    11ea:	e0 91 80 05 	lds	r30, 0x0580
    11ee:	f0 91 81 05 	lds	r31, 0x0581
    11f2:	09 95       	icall
}
    11f4:	ff 91       	pop	r31
    11f6:	ef 91       	pop	r30
    11f8:	bf 91       	pop	r27
    11fa:	af 91       	pop	r26
    11fc:	9f 91       	pop	r25
    11fe:	8f 91       	pop	r24
    1200:	7f 91       	pop	r23
    1202:	6f 91       	pop	r22
    1204:	5f 91       	pop	r21
    1206:	4f 91       	pop	r20
    1208:	3f 91       	pop	r19
    120a:	2f 91       	pop	r18
    120c:	0f 90       	pop	r0
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	0f 90       	pop	r0
    1212:	1f 90       	pop	r1
    1214:	18 95       	reti

00001216 <__vector_15>:

void __vector_15(void) __attribute__((signal));
void __vector_15(void)
{
    1216:	1f 92       	push	r1
    1218:	0f 92       	push	r0
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	0f 92       	push	r0
    121e:	11 24       	eor	r1, r1
    1220:	2f 93       	push	r18
    1222:	3f 93       	push	r19
    1224:	4f 93       	push	r20
    1226:	5f 93       	push	r21
    1228:	6f 93       	push	r22
    122a:	7f 93       	push	r23
    122c:	8f 93       	push	r24
    122e:	9f 93       	push	r25
    1230:	af 93       	push	r26
    1232:	bf 93       	push	r27
    1234:	ef 93       	push	r30
    1236:	ff 93       	push	r31
  USART_TXC();
    1238:	e0 91 7c 05 	lds	r30, 0x057C
    123c:	f0 91 7d 05 	lds	r31, 0x057D
    1240:	09 95       	icall
}
    1242:	ff 91       	pop	r31
    1244:	ef 91       	pop	r30
    1246:	bf 91       	pop	r27
    1248:	af 91       	pop	r26
    124a:	9f 91       	pop	r25
    124c:	8f 91       	pop	r24
    124e:	7f 91       	pop	r23
    1250:	6f 91       	pop	r22
    1252:	5f 91       	pop	r21
    1254:	4f 91       	pop	r20
    1256:	3f 91       	pop	r19
    1258:	2f 91       	pop	r18
    125a:	0f 90       	pop	r0
    125c:	0f be       	out	0x3f, r0	; 63
    125e:	0f 90       	pop	r0
    1260:	1f 90       	pop	r1
    1262:	18 95       	reti

00001264 <__vector_16>:

void __vector_16(void) __attribute__((signal));
void __vector_16(void)
{
    1264:	1f 92       	push	r1
    1266:	0f 92       	push	r0
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	0f 92       	push	r0
    126c:	11 24       	eor	r1, r1
    126e:	2f 93       	push	r18
    1270:	3f 93       	push	r19
    1272:	4f 93       	push	r20
    1274:	5f 93       	push	r21
    1276:	6f 93       	push	r22
    1278:	7f 93       	push	r23
    127a:	8f 93       	push	r24
    127c:	9f 93       	push	r25
    127e:	af 93       	push	r26
    1280:	bf 93       	push	r27
    1282:	ef 93       	push	r30
    1284:	ff 93       	push	r31
  ADC_INT();
    1286:	e0 91 76 05 	lds	r30, 0x0576
    128a:	f0 91 77 05 	lds	r31, 0x0577
    128e:	09 95       	icall
}
    1290:	ff 91       	pop	r31
    1292:	ef 91       	pop	r30
    1294:	bf 91       	pop	r27
    1296:	af 91       	pop	r26
    1298:	9f 91       	pop	r25
    129a:	8f 91       	pop	r24
    129c:	7f 91       	pop	r23
    129e:	6f 91       	pop	r22
    12a0:	5f 91       	pop	r21
    12a2:	4f 91       	pop	r20
    12a4:	3f 91       	pop	r19
    12a6:	2f 91       	pop	r18
    12a8:	0f 90       	pop	r0
    12aa:	0f be       	out	0x3f, r0	; 63
    12ac:	0f 90       	pop	r0
    12ae:	1f 90       	pop	r1
    12b0:	18 95       	reti

000012b2 <__vector_17>:

void __vector_17(void) __attribute__((signal));
void __vector_17(void)
{
    12b2:	1f 92       	push	r1
    12b4:	0f 92       	push	r0
    12b6:	0f b6       	in	r0, 0x3f	; 63
    12b8:	0f 92       	push	r0
    12ba:	11 24       	eor	r1, r1
    12bc:	2f 93       	push	r18
    12be:	3f 93       	push	r19
    12c0:	4f 93       	push	r20
    12c2:	5f 93       	push	r21
    12c4:	6f 93       	push	r22
    12c6:	7f 93       	push	r23
    12c8:	8f 93       	push	r24
    12ca:	9f 93       	push	r25
    12cc:	af 93       	push	r26
    12ce:	bf 93       	push	r27
    12d0:	ef 93       	push	r30
    12d2:	ff 93       	push	r31
  EE_RDY();
    12d4:	e0 91 78 05 	lds	r30, 0x0578
    12d8:	f0 91 79 05 	lds	r31, 0x0579
    12dc:	09 95       	icall
}
    12de:	ff 91       	pop	r31
    12e0:	ef 91       	pop	r30
    12e2:	bf 91       	pop	r27
    12e4:	af 91       	pop	r26
    12e6:	9f 91       	pop	r25
    12e8:	8f 91       	pop	r24
    12ea:	7f 91       	pop	r23
    12ec:	6f 91       	pop	r22
    12ee:	5f 91       	pop	r21
    12f0:	4f 91       	pop	r20
    12f2:	3f 91       	pop	r19
    12f4:	2f 91       	pop	r18
    12f6:	0f 90       	pop	r0
    12f8:	0f be       	out	0x3f, r0	; 63
    12fa:	0f 90       	pop	r0
    12fc:	1f 90       	pop	r1
    12fe:	18 95       	reti

00001300 <__vector_18>:

void __vector_18(void) __attribute__((signal));
void __vector_18(void)
{
    1300:	1f 92       	push	r1
    1302:	0f 92       	push	r0
    1304:	0f b6       	in	r0, 0x3f	; 63
    1306:	0f 92       	push	r0
    1308:	11 24       	eor	r1, r1
    130a:	2f 93       	push	r18
    130c:	3f 93       	push	r19
    130e:	4f 93       	push	r20
    1310:	5f 93       	push	r21
    1312:	6f 93       	push	r22
    1314:	7f 93       	push	r23
    1316:	8f 93       	push	r24
    1318:	9f 93       	push	r25
    131a:	af 93       	push	r26
    131c:	bf 93       	push	r27
    131e:	ef 93       	push	r30
    1320:	ff 93       	push	r31
  ANA_COMP();
    1322:	e0 91 74 05 	lds	r30, 0x0574
    1326:	f0 91 75 05 	lds	r31, 0x0575
    132a:	09 95       	icall
}
    132c:	ff 91       	pop	r31
    132e:	ef 91       	pop	r30
    1330:	bf 91       	pop	r27
    1332:	af 91       	pop	r26
    1334:	9f 91       	pop	r25
    1336:	8f 91       	pop	r24
    1338:	7f 91       	pop	r23
    133a:	6f 91       	pop	r22
    133c:	5f 91       	pop	r21
    133e:	4f 91       	pop	r20
    1340:	3f 91       	pop	r19
    1342:	2f 91       	pop	r18
    1344:	0f 90       	pop	r0
    1346:	0f be       	out	0x3f, r0	; 63
    1348:	0f 90       	pop	r0
    134a:	1f 90       	pop	r1
    134c:	18 95       	reti

0000134e <__vector_19>:

void __vector_19(void) __attribute__((signal));
void __vector_19(void)
{
    134e:	1f 92       	push	r1
    1350:	0f 92       	push	r0
    1352:	0f b6       	in	r0, 0x3f	; 63
    1354:	0f 92       	push	r0
    1356:	11 24       	eor	r1, r1
    1358:	2f 93       	push	r18
    135a:	3f 93       	push	r19
    135c:	4f 93       	push	r20
    135e:	5f 93       	push	r21
    1360:	6f 93       	push	r22
    1362:	7f 93       	push	r23
    1364:	8f 93       	push	r24
    1366:	9f 93       	push	r25
    1368:	af 93       	push	r26
    136a:	bf 93       	push	r27
    136c:	ef 93       	push	r30
    136e:	ff 93       	push	r31
  TWI_I2C();
    1370:	e0 91 64 05 	lds	r30, 0x0564
    1374:	f0 91 65 05 	lds	r31, 0x0565
    1378:	09 95       	icall
}
    137a:	ff 91       	pop	r31
    137c:	ef 91       	pop	r30
    137e:	bf 91       	pop	r27
    1380:	af 91       	pop	r26
    1382:	9f 91       	pop	r25
    1384:	8f 91       	pop	r24
    1386:	7f 91       	pop	r23
    1388:	6f 91       	pop	r22
    138a:	5f 91       	pop	r21
    138c:	4f 91       	pop	r20
    138e:	3f 91       	pop	r19
    1390:	2f 91       	pop	r18
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63
    1396:	0f 90       	pop	r0
    1398:	1f 90       	pop	r1
    139a:	18 95       	reti

0000139c <__vector_20>:

void __vector_20(void) __attribute__((signal));
void __vector_20(void)
{
    139c:	1f 92       	push	r1
    139e:	0f 92       	push	r0
    13a0:	0f b6       	in	r0, 0x3f	; 63
    13a2:	0f 92       	push	r0
    13a4:	11 24       	eor	r1, r1
    13a6:	2f 93       	push	r18
    13a8:	3f 93       	push	r19
    13aa:	4f 93       	push	r20
    13ac:	5f 93       	push	r21
    13ae:	6f 93       	push	r22
    13b0:	7f 93       	push	r23
    13b2:	8f 93       	push	r24
    13b4:	9f 93       	push	r25
    13b6:	af 93       	push	r26
    13b8:	bf 93       	push	r27
    13ba:	ef 93       	push	r30
    13bc:	ff 93       	push	r31
  SPM_RDY();
    13be:	e0 91 6a 05 	lds	r30, 0x056A
    13c2:	f0 91 6b 05 	lds	r31, 0x056B
    13c6:	09 95       	icall
}
    13c8:	ff 91       	pop	r31
    13ca:	ef 91       	pop	r30
    13cc:	bf 91       	pop	r27
    13ce:	af 91       	pop	r26
    13d0:	9f 91       	pop	r25
    13d2:	8f 91       	pop	r24
    13d4:	7f 91       	pop	r23
    13d6:	6f 91       	pop	r22
    13d8:	5f 91       	pop	r21
    13da:	4f 91       	pop	r20
    13dc:	3f 91       	pop	r19
    13de:	2f 91       	pop	r18
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63
    13e4:	0f 90       	pop	r0
    13e6:	1f 90       	pop	r1
    13e8:	18 95       	reti

000013ea <ADC_read_int>:
}
void ADC_read_int(void)
{


    13ea:	08 95       	ret

000013ec <ADC_INIT>:
#include "ADC.h"
static uint8_t arr_counter_of_ptr=0;
static ptr_to_Fun ADC_R[8]={ADC_Read0,ADC_Read1,ADC_Read2,ADC_Read3,ADC_Read4,ADC_Read5,ADC_Read6,ADC_Read7};
uint16_t u16_ADC_readings_Channel[8];
ERROR_STATUS ADC_INIT(ADC_Cfg_s *ADC_info)
{
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	ec 01       	movw	r28, r24
	uint8_t ret_error=E_OK;
	
	ADMUX |= (ADC_info->u8_voltage_refrences) ;
    13f2:	97 b1       	in	r25, 0x07	; 7
    13f4:	8a 81       	ldd	r24, Y+2	; 0x02
    13f6:	89 2b       	or	r24, r25
    13f8:	87 b9       	out	0x07, r24	; 7
	if ((ADC_info ->u8_Channel_Number) != ADC_MULTIPLE_CHANNELS)
    13fa:	88 81       	ld	r24, Y
    13fc:	8f 3f       	cpi	r24, 0xFF	; 255
    13fe:	39 f0       	breq	.+14     	; 0x140e <ADC_INIT+0x22>
	{
		ADMUX &= 0xf0;
    1400:	87 b1       	in	r24, 0x07	; 7
    1402:	80 7f       	andi	r24, 0xF0	; 240
    1404:	87 b9       	out	0x07, r24	; 7
		ADMUX |=(ADC_info ->u8_Channel_Number);
    1406:	97 b1       	in	r25, 0x07	; 7
    1408:	88 81       	ld	r24, Y
    140a:	89 2b       	or	r24, r25
    140c:	87 b9       	out	0x07, r24	; 7
	}
	ADMUX |= (ADC_info->u8_ten_bit_arrangment);
    140e:	97 b1       	in	r25, 0x07	; 7
    1410:	8b 81       	ldd	r24, Y+3	; 0x03
    1412:	89 2b       	or	r24, r25
    1414:	87 b9       	out	0x07, r24	; 7
	G_interrupt_Enable();
    1416:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
	ADCSRA |= (ADC_info ->u8_polling_interrupt);
    141a:	96 b1       	in	r25, 0x06	; 6
    141c:	8c 81       	ldd	r24, Y+4	; 0x04
    141e:	89 2b       	or	r24, r25
    1420:	86 b9       	out	0x06, r24	; 6
	ADC_INT = ADC_read_int;
    1422:	85 ef       	ldi	r24, 0xF5	; 245
    1424:	99 e0       	ldi	r25, 0x09	; 9
    1426:	90 93 77 05 	sts	0x0577, r25
    142a:	80 93 76 05 	sts	0x0576, r24
	ADCSRA |=(ADC_info->u8_Prescaler);
    142e:	96 b1       	in	r25, 0x06	; 6
    1430:	89 81       	ldd	r24, Y+1	; 0x01
    1432:	89 2b       	or	r24, r25
    1434:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 0x80;/*ADC ENABLE*/
    1436:	37 9a       	sbi	0x06, 7	; 6
	ADCSRA |= 0x40;//start conversion
    1438:	36 9a       	sbi	0x06, 6	; 6
	return ret_error;
}
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	08 95       	ret

00001442 <ADC_Read7>:
	while (!(READBIT(ADCSRA,ADIF)));
	u16_ADC_readings_Channel[6]  = (ADCL + (ADCH << 8));
}
void ADC_Read7(void)
{
ADC_INIT(&ADC_Cnfiguration7);
    1442:	84 e8       	ldi	r24, 0x84	; 132
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
ADCSRA |= 0x40;
    144a:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    144c:	86 b1       	in	r24, 0x06	; 6
    144e:	84 ff       	sbrs	r24, 4
    1450:	fd cf       	rjmp	.-6      	; 0x144c <ADC_Read7+0xa>
u16_ADC_readings_Channel[7]  = (ADCL + (ADCH << 8));
    1452:	24 b1       	in	r18, 0x04	; 4
    1454:	35 b1       	in	r19, 0x05	; 5
    1456:	85 b1       	in	r24, 0x05	; 5
    1458:	96 b1       	in	r25, 0x06	; 6
    145a:	98 2f       	mov	r25, r24
    145c:	88 27       	eor	r24, r24
    145e:	82 0f       	add	r24, r18
    1460:	93 1f       	adc	r25, r19
    1462:	90 93 99 05 	sts	0x0599, r25
    1466:	80 93 98 05 	sts	0x0598, r24
}
    146a:	08 95       	ret

0000146c <ADC_Read6>:
u16_ADC_readings_Channel[5]  = (ADCL + (ADCH << 8));
}

void ADC_Read6(void)
{
	ADC_INIT(&ADC_Cnfiguration6);
    146c:	89 e8       	ldi	r24, 0x89	; 137
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
	ADCSRA |= 0x40;
    1474:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1476:	86 b1       	in	r24, 0x06	; 6
    1478:	84 ff       	sbrs	r24, 4
    147a:	fd cf       	rjmp	.-6      	; 0x1476 <ADC_Read6+0xa>
	u16_ADC_readings_Channel[6]  = (ADCL + (ADCH << 8));
    147c:	24 b1       	in	r18, 0x04	; 4
    147e:	35 b1       	in	r19, 0x05	; 5
    1480:	85 b1       	in	r24, 0x05	; 5
    1482:	96 b1       	in	r25, 0x06	; 6
    1484:	98 2f       	mov	r25, r24
    1486:	88 27       	eor	r24, r24
    1488:	82 0f       	add	r24, r18
    148a:	93 1f       	adc	r25, r19
    148c:	90 93 97 05 	sts	0x0597, r25
    1490:	80 93 96 05 	sts	0x0596, r24
}
    1494:	08 95       	ret

00001496 <ADC_Read5>:
	u16_ADC_readings_Channel[4]  =(ADCL + (ADCH << 8));

}
void ADC_Read5(void)
{
ADC_INIT(&ADC_Cnfiguration5);
    1496:	8e e8       	ldi	r24, 0x8E	; 142
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
ADCSRA |= 0x40;
    149e:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    14a0:	86 b1       	in	r24, 0x06	; 6
    14a2:	84 ff       	sbrs	r24, 4
    14a4:	fd cf       	rjmp	.-6      	; 0x14a0 <ADC_Read5+0xa>
u16_ADC_readings_Channel[5]  = (ADCL + (ADCH << 8));
    14a6:	24 b1       	in	r18, 0x04	; 4
    14a8:	35 b1       	in	r19, 0x05	; 5
    14aa:	85 b1       	in	r24, 0x05	; 5
    14ac:	96 b1       	in	r25, 0x06	; 6
    14ae:	98 2f       	mov	r25, r24
    14b0:	88 27       	eor	r24, r24
    14b2:	82 0f       	add	r24, r18
    14b4:	93 1f       	adc	r25, r19
    14b6:	90 93 95 05 	sts	0x0595, r25
    14ba:	80 93 94 05 	sts	0x0594, r24
}
    14be:	08 95       	ret

000014c0 <ADC_Read4>:
while (!(READBIT(ADCSRA,ADIF)));
u16_ADC_readings_Channel[3]  = (ADCL + (ADCH << 8));
}
void ADC_Read4(void)
{
	ADC_INIT(&ADC_Cnfiguration4);
    14c0:	83 e9       	ldi	r24, 0x93	; 147
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
	ADCSRA |= 0x40;
    14c8:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    14ca:	86 b1       	in	r24, 0x06	; 6
    14cc:	84 ff       	sbrs	r24, 4
    14ce:	fd cf       	rjmp	.-6      	; 0x14ca <ADC_Read4+0xa>
	u16_ADC_readings_Channel[4]  =(ADCL + (ADCH << 8));
    14d0:	24 b1       	in	r18, 0x04	; 4
    14d2:	35 b1       	in	r19, 0x05	; 5
    14d4:	85 b1       	in	r24, 0x05	; 5
    14d6:	96 b1       	in	r25, 0x06	; 6
    14d8:	98 2f       	mov	r25, r24
    14da:	88 27       	eor	r24, r24
    14dc:	82 0f       	add	r24, r18
    14de:	93 1f       	adc	r25, r19
    14e0:	90 93 93 05 	sts	0x0593, r25
    14e4:	80 93 92 05 	sts	0x0592, r24

}
    14e8:	08 95       	ret

000014ea <ADC_Read3>:
	while (!(READBIT(ADCSRA,ADIF)));
	u16_ADC_readings_Channel[2]  = (ADCL + (ADCH << 8));
}
void ADC_Read3(void)
{
ADC_INIT(&ADC_Cnfiguration3);
    14ea:	88 e9       	ldi	r24, 0x98	; 152
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
ADCSRA |= 0x40;
    14f2:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    14f4:	86 b1       	in	r24, 0x06	; 6
    14f6:	84 ff       	sbrs	r24, 4
    14f8:	fd cf       	rjmp	.-6      	; 0x14f4 <ADC_Read3+0xa>
u16_ADC_readings_Channel[3]  = (ADCL + (ADCH << 8));
    14fa:	24 b1       	in	r18, 0x04	; 4
    14fc:	35 b1       	in	r19, 0x05	; 5
    14fe:	85 b1       	in	r24, 0x05	; 5
    1500:	96 b1       	in	r25, 0x06	; 6
    1502:	98 2f       	mov	r25, r24
    1504:	88 27       	eor	r24, r24
    1506:	82 0f       	add	r24, r18
    1508:	93 1f       	adc	r25, r19
    150a:	90 93 91 05 	sts	0x0591, r25
    150e:	80 93 90 05 	sts	0x0590, r24
}
    1512:	08 95       	ret

00001514 <ADC_Read2>:
	ADCSRA |= 0x40;
	while (!(READBIT(ADCSRA,ADIF)));
	u16_ADC_readings_Channel[1]  =(ADCL + (ADCH << 8));
}
void ADC_Read2(void){
	ADC_INIT(&ADC_Cnfiguration2);
    1514:	8d e9       	ldi	r24, 0x9D	; 157
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
	ADCSRA |= 0x40;
    151c:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    151e:	86 b1       	in	r24, 0x06	; 6
    1520:	84 ff       	sbrs	r24, 4
    1522:	fd cf       	rjmp	.-6      	; 0x151e <ADC_Read2+0xa>
	u16_ADC_readings_Channel[2]  = (ADCL + (ADCH << 8));
    1524:	24 b1       	in	r18, 0x04	; 4
    1526:	35 b1       	in	r19, 0x05	; 5
    1528:	85 b1       	in	r24, 0x05	; 5
    152a:	96 b1       	in	r25, 0x06	; 6
    152c:	98 2f       	mov	r25, r24
    152e:	88 27       	eor	r24, r24
    1530:	82 0f       	add	r24, r18
    1532:	93 1f       	adc	r25, r19
    1534:	90 93 8f 05 	sts	0x058F, r25
    1538:	80 93 8e 05 	sts	0x058E, r24
}
    153c:	08 95       	ret

0000153e <ADC_Read1>:
	while (!(READBIT(ADCSRA,ADIF)));
	u16_ADC_readings_Channel[0]  = (ADCL + (ADCH << 8));

}
void ADC_Read1(void){
	ADC_INIT(&ADC_Cnfiguration1);
    153e:	82 ea       	ldi	r24, 0xA2	; 162
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
	ADCSRA |= 0x40;
    1546:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1548:	86 b1       	in	r24, 0x06	; 6
    154a:	84 ff       	sbrs	r24, 4
    154c:	fd cf       	rjmp	.-6      	; 0x1548 <ADC_Read1+0xa>
	u16_ADC_readings_Channel[1]  =(ADCL + (ADCH << 8));
    154e:	24 b1       	in	r18, 0x04	; 4
    1550:	35 b1       	in	r19, 0x05	; 5
    1552:	85 b1       	in	r24, 0x05	; 5
    1554:	96 b1       	in	r25, 0x06	; 6
    1556:	98 2f       	mov	r25, r24
    1558:	88 27       	eor	r24, r24
    155a:	82 0f       	add	r24, r18
    155c:	93 1f       	adc	r25, r19
    155e:	90 93 8d 05 	sts	0x058D, r25
    1562:	80 93 8c 05 	sts	0x058C, r24
}
    1566:	08 95       	ret

00001568 <ADC_Read0>:
	ADCSRA |= 0x40;//start conversion
	return ret_error;
}
void ADC_Read0(void)
{
	ADC_INIT(&ADC_Cnfiguration0);
    1568:	87 ea       	ldi	r24, 0xA7	; 167
    156a:	90 e0       	ldi	r25, 0x00	; 0
    156c:	0e 94 f6 09 	call	0x13ec	; 0x13ec <ADC_INIT>
	ADCSRA |= 0x40;
    1570:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1572:	86 b1       	in	r24, 0x06	; 6
    1574:	84 ff       	sbrs	r24, 4
    1576:	fd cf       	rjmp	.-6      	; 0x1572 <ADC_Read0+0xa>
	u16_ADC_readings_Channel[0]  = (ADCL + (ADCH << 8));
    1578:	24 b1       	in	r18, 0x04	; 4
    157a:	35 b1       	in	r19, 0x05	; 5
    157c:	85 b1       	in	r24, 0x05	; 5
    157e:	96 b1       	in	r25, 0x06	; 6
    1580:	98 2f       	mov	r25, r24
    1582:	88 27       	eor	r24, r24
    1584:	82 0f       	add	r24, r18
    1586:	93 1f       	adc	r25, r19
    1588:	90 93 8b 05 	sts	0x058B, r25
    158c:	80 93 8a 05 	sts	0x058A, r24

}
    1590:	08 95       	ret

00001592 <adc_read>:
ADCSRA |= 0x40;
while (!(READBIT(ADCSRA,ADIF)));
u16_ADC_readings_Channel[7]  = (ADCL + (ADCH << 8));
}
void adc_read(void){
	if (arr_counter_of_ptr < 8)
    1592:	e0 91 f0 00 	lds	r30, 0x00F0
    1596:	e8 30       	cpi	r30, 0x08	; 8
    1598:	78 f4       	brcc	.+30     	; 0x15b8 <adc_read+0x26>
	{
		ADC_R[arr_counter_of_ptr]();
    159a:	f0 e0       	ldi	r31, 0x00	; 0
    159c:	ee 0f       	add	r30, r30
    159e:	ff 1f       	adc	r31, r31
    15a0:	ec 58       	subi	r30, 0x8C	; 140
    15a2:	ff 4f       	sbci	r31, 0xFF	; 255
    15a4:	01 90       	ld	r0, Z+
    15a6:	f0 81       	ld	r31, Z
    15a8:	e0 2d       	mov	r30, r0
    15aa:	09 95       	icall
			arr_counter_of_ptr++;
    15ac:	80 91 f0 00 	lds	r24, 0x00F0
    15b0:	8f 5f       	subi	r24, 0xFF	; 255
    15b2:	80 93 f0 00 	sts	0x00F0, r24
    15b6:	08 95       	ret
	}else{arr_counter_of_ptr=0;}
    15b8:	10 92 f0 00 	sts	0x00F0, r1
    15bc:	08 95       	ret

000015be <DIO_init>:
*Description: This function can set the direction of a full port, a nibble
* 			  or even one pin.
*/

ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{	
    15be:	fc 01       	movw	r30, r24
	uint8_t RET=0;
	if (DIO_info== NULL)
    15c0:	00 97       	sbiw	r24, 0x00	; 0
    15c2:	09 f4       	brne	.+2      	; 0x15c6 <DIO_init+0x8>
    15c4:	50 c0       	rjmp	.+160    	; 0x1666 <DIO_init+0xa8>
	{
		RET=NULL_PTR+DIO_MODULE;
		
	}else{
		switch(DIO_info->dir)
    15c6:	82 81       	ldd	r24, Z+2	; 0x02
    15c8:	88 23       	and	r24, r24
    15ca:	21 f0       	breq	.+8      	; 0x15d4 <DIO_init+0x16>
    15cc:	8f 3f       	cpi	r24, 0xFF	; 255
    15ce:	09 f0       	breq	.+2      	; 0x15d2 <DIO_init+0x14>
    15d0:	4c c0       	rjmp	.+152    	; 0x166a <DIO_init+0xac>
    15d2:	27 c0       	rjmp	.+78     	; 0x1622 <DIO_init+0x64>
			{	
		case INPUT:
		     	switch(DIO_info ->GPIO)
    15d4:	80 81       	ld	r24, Z
    15d6:	81 30       	cpi	r24, 0x01	; 1
    15d8:	79 f0       	breq	.+30     	; 0x15f8 <DIO_init+0x3a>
    15da:	81 30       	cpi	r24, 0x01	; 1
    15dc:	30 f0       	brcs	.+12     	; 0x15ea <DIO_init+0x2c>
    15de:	82 30       	cpi	r24, 0x02	; 2
    15e0:	91 f0       	breq	.+36     	; 0x1606 <DIO_init+0x48>
    15e2:	83 30       	cpi	r24, 0x03	; 3
    15e4:	09 f0       	breq	.+2      	; 0x15e8 <DIO_init+0x2a>
    15e6:	43 c0       	rjmp	.+134    	; 0x166e <DIO_init+0xb0>
    15e8:	15 c0       	rjmp	.+42     	; 0x1614 <DIO_init+0x56>
		 		{
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
    15ea:	9a b3       	in	r25, 0x1a	; 26
    15ec:	81 81       	ldd	r24, Z+1	; 0x01
    15ee:	80 95       	com	r24
    15f0:	89 23       	and	r24, r25
    15f2:	8a bb       	out	0x1a, r24	; 26
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    15f4:	80 e0       	ldi	r24, 0x00	; 0
		case INPUT:
		     	switch(DIO_info ->GPIO)
		 		{
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
					break;
    15f6:	08 95       	ret
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
    15f8:	97 b3       	in	r25, 0x17	; 23
    15fa:	81 81       	ldd	r24, Z+1	; 0x01
    15fc:	80 95       	com	r24
    15fe:	89 23       	and	r24, r25
    1600:	87 bb       	out	0x17, r24	; 23
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    1602:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
					break;
    1604:	08 95       	ret
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
    1606:	94 b3       	in	r25, 0x14	; 20
    1608:	81 81       	ldd	r24, Z+1	; 0x01
    160a:	80 95       	com	r24
    160c:	89 23       	and	r24, r25
    160e:	84 bb       	out	0x14, r24	; 20
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    1610:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
					break;
    1612:	08 95       	ret
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
    1614:	91 b3       	in	r25, 0x11	; 17
    1616:	81 81       	ldd	r24, Z+1	; 0x01
    1618:	80 95       	com	r24
    161a:	89 23       	and	r24, r25
    161c:	81 bb       	out	0x11, r24	; 17
					break;
					RET=E_OK;
				}
				RET=E_OK;
    161e:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
    1620:	08 95       	ret
				}
				RET=E_OK;
				break;

		case OUTPUT:
			  switch(DIO_info ->GPIO)
    1622:	80 81       	ld	r24, Z
    1624:	81 30       	cpi	r24, 0x01	; 1
    1626:	69 f0       	breq	.+26     	; 0x1642 <DIO_init+0x84>
    1628:	81 30       	cpi	r24, 0x01	; 1
    162a:	28 f0       	brcs	.+10     	; 0x1636 <DIO_init+0x78>
    162c:	82 30       	cpi	r24, 0x02	; 2
    162e:	79 f0       	breq	.+30     	; 0x164e <DIO_init+0x90>
    1630:	83 30       	cpi	r24, 0x03	; 3
    1632:	f9 f4       	brne	.+62     	; 0x1672 <DIO_init+0xb4>
    1634:	12 c0       	rjmp	.+36     	; 0x165a <DIO_init+0x9c>
			  {
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
    1636:	9a b3       	in	r25, 0x1a	; 26
    1638:	81 81       	ldd	r24, Z+1	; 0x01
    163a:	89 2b       	or	r24, r25
    163c:	8a bb       	out	0x1a, r24	; 26
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    163e:	80 e0       	ldi	r24, 0x00	; 0
		case OUTPUT:
			  switch(DIO_info ->GPIO)
			  {
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
				  break;
    1640:	08 95       	ret
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
    1642:	97 b3       	in	r25, 0x17	; 23
    1644:	81 81       	ldd	r24, Z+1	; 0x01
    1646:	89 2b       	or	r24, r25
    1648:	87 bb       	out	0x17, r24	; 23
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    164a:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
				  break;
    164c:	08 95       	ret
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
    164e:	94 b3       	in	r25, 0x14	; 20
    1650:	81 81       	ldd	r24, Z+1	; 0x01
    1652:	89 2b       	or	r24, r25
    1654:	84 bb       	out	0x14, r24	; 20
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1656:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
				  break;
    1658:	08 95       	ret
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
    165a:	91 b3       	in	r25, 0x11	; 17
    165c:	81 81       	ldd	r24, Z+1	; 0x01
    165e:	89 2b       	or	r24, r25
    1660:	81 bb       	out	0x11, r24	; 17
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1662:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
    1664:	08 95       	ret
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{	
	uint8_t RET=0;
	if (DIO_info== NULL)
	{
		RET=NULL_PTR+DIO_MODULE;
    1666:	86 e1       	ldi	r24, 0x16	; 22
    1668:	08 95       	ret
			  }
			  RET=E_OK;
			  break;

			default:
			RET=E_NOK;
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	08 95       	ret
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    166e:	80 e0       	ldi	r24, 0x00	; 0
    1670:	08 95       	ret
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1672:	80 e0       	ldi	r24, 0x00	; 0
			RET=E_NOK;
	}
	
}	
return RET;
}
    1674:	08 95       	ret

00001676 <DIO_Write>:

ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{uint8_t Ret=0;
switch(value){
    1676:	44 23       	and	r20, r20
    1678:	21 f0       	breq	.+8      	; 0x1682 <DIO_Write+0xc>
    167a:	4f 3f       	cpi	r20, 0xFF	; 255
    167c:	09 f0       	breq	.+2      	; 0x1680 <DIO_Write+0xa>
    167e:	3f c0       	rjmp	.+126    	; 0x16fe <DIO_Write+0x88>
    1680:	21 c0       	rjmp	.+66     	; 0x16c4 <DIO_Write+0x4e>
case LOW:
{
switch (GPIO)
    1682:	81 30       	cpi	r24, 0x01	; 1
    1684:	69 f0       	breq	.+26     	; 0x16a0 <DIO_Write+0x2a>
    1686:	81 30       	cpi	r24, 0x01	; 1
    1688:	28 f0       	brcs	.+10     	; 0x1694 <DIO_Write+0x1e>
    168a:	82 30       	cpi	r24, 0x02	; 2
    168c:	79 f0       	breq	.+30     	; 0x16ac <DIO_Write+0x36>
    168e:	83 30       	cpi	r24, 0x03	; 3
    1690:	c1 f5       	brne	.+112    	; 0x1702 <DIO_Write+0x8c>
    1692:	12 c0       	rjmp	.+36     	; 0x16b8 <DIO_Write+0x42>
{	case GPIOA:
	PORTA_DATA &= ~(pins);   // 0b01111111
    1694:	8b b3       	in	r24, 0x1b	; 27
    1696:	60 95       	com	r22
    1698:	68 23       	and	r22, r24
    169a:	6b bb       	out	0x1b, r22	; 27
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    169c:	80 e0       	ldi	r24, 0x00	; 0
{
switch (GPIO)
{	case GPIOA:
	PORTA_DATA &= ~(pins);   // 0b01111111
Ret=E_OK;
	break;
    169e:	08 95       	ret
	case GPIOB:
	PORTB_DATA &= ~(pins);
    16a0:	88 b3       	in	r24, 0x18	; 24
    16a2:	60 95       	com	r22
    16a4:	68 23       	and	r22, r24
    16a6:	68 bb       	out	0x18, r22	; 24
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    16a8:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOB:
	PORTB_DATA &= ~(pins);
Ret=E_OK;
	break;
    16aa:	08 95       	ret
	case GPIOC:
	PORTC_DATA &= ~(pins);
    16ac:	85 b3       	in	r24, 0x15	; 21
    16ae:	60 95       	com	r22
    16b0:	68 23       	and	r22, r24
    16b2:	65 bb       	out	0x15, r22	; 21
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    16b4:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOC:
	PORTC_DATA &= ~(pins);
Ret=E_OK;
	break;
    16b6:	08 95       	ret
	case GPIOD:
	PORTD_DATA &= ~(pins);
    16b8:	82 b3       	in	r24, 0x12	; 18
    16ba:	60 95       	com	r22
    16bc:	68 23       	and	r22, r24
    16be:	62 bb       	out	0x12, r22	; 18
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    16c0:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOD:
	PORTD_DATA &= ~(pins);
	Ret=E_OK;
	break;
    16c2:	08 95       	ret
	}
Ret=E_OK;
break;
}
case HIGH:{
switch (GPIO)
    16c4:	81 30       	cpi	r24, 0x01	; 1
    16c6:	61 f0       	breq	.+24     	; 0x16e0 <DIO_Write+0x6a>
    16c8:	81 30       	cpi	r24, 0x01	; 1
    16ca:	28 f0       	brcs	.+10     	; 0x16d6 <DIO_Write+0x60>
    16cc:	82 30       	cpi	r24, 0x02	; 2
    16ce:	69 f0       	breq	.+26     	; 0x16ea <DIO_Write+0x74>
    16d0:	83 30       	cpi	r24, 0x03	; 3
    16d2:	c9 f4       	brne	.+50     	; 0x1706 <DIO_Write+0x90>
    16d4:	0f c0       	rjmp	.+30     	; 0x16f4 <DIO_Write+0x7e>
{	case GPIOA:
	PORTA_DATA |=(pins);
    16d6:	8b b3       	in	r24, 0x1b	; 27
    16d8:	68 2b       	or	r22, r24
    16da:	6b bb       	out	0x1b, r22	; 27
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    16dc:	80 e0       	ldi	r24, 0x00	; 0
case HIGH:{
switch (GPIO)
{	case GPIOA:
	PORTA_DATA |=(pins);
Ret=E_OK;
	break;
    16de:	08 95       	ret
	case GPIOB:
	PORTB_DATA |=(pins);
    16e0:	88 b3       	in	r24, 0x18	; 24
    16e2:	68 2b       	or	r22, r24
    16e4:	68 bb       	out	0x18, r22	; 24
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    16e6:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOB:
	PORTB_DATA |=(pins);
Ret=E_OK;
	break;
    16e8:	08 95       	ret
	case GPIOC:
	PORTC_DATA |=(pins);
    16ea:	85 b3       	in	r24, 0x15	; 21
    16ec:	68 2b       	or	r22, r24
    16ee:	65 bb       	out	0x15, r22	; 21
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    16f0:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOC:
	PORTC_DATA |=(pins);
Ret=E_OK;
	break;
    16f2:	08 95       	ret
	case GPIOD:
	PORTD_DATA |=(pins);
    16f4:	82 b3       	in	r24, 0x12	; 18
    16f6:	68 2b       	or	r22, r24
    16f8:	62 bb       	out	0x12, r22	; 18
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    16fa:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOD:
	PORTD_DATA |=(pins);
Ret=E_OK;
	break;
    16fc:	08 95       	ret
}
Ret=E_OK;
break;
}
default:
Ret=E_NOK;
    16fe:	81 e0       	ldi	r24, 0x01	; 1
    1700:	08 95       	ret
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    1702:	80 e0       	ldi	r24, 0x00	; 0
    1704:	08 95       	ret
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    1706:	80 e0       	ldi	r24, 0x00	; 0
default:
Ret=E_NOK;
break;
}
return Ret;
}
    1708:	08 95       	ret

0000170a <DIO_Read>:


ERROR_STATUS DIO_Read (uint8_t GPIO,uint8_t pins, uint8_t *data)
{
    170a:	fa 01       	movw	r30, r20

switch (GPIO)
    170c:	81 30       	cpi	r24, 0x01	; 1
    170e:	59 f0       	breq	.+22     	; 0x1726 <DIO_Read+0x1c>
    1710:	81 30       	cpi	r24, 0x01	; 1
    1712:	28 f0       	brcs	.+10     	; 0x171e <DIO_Read+0x14>
    1714:	82 30       	cpi	r24, 0x02	; 2
    1716:	59 f0       	breq	.+22     	; 0x172e <DIO_Read+0x24>
    1718:	83 30       	cpi	r24, 0x03	; 3
    171a:	81 f4       	brne	.+32     	; 0x173c <DIO_Read+0x32>
    171c:	0c c0       	rjmp	.+24     	; 0x1736 <DIO_Read+0x2c>
{	case GPIOA:
	*data=(PORTA_PIN & pins);
    171e:	89 b3       	in	r24, 0x19	; 25
    1720:	68 23       	and	r22, r24
    1722:	60 83       	st	Z, r22
	break;
    1724:	0b c0       	rjmp	.+22     	; 0x173c <DIO_Read+0x32>
	case GPIOB:
	*data=(PORTB_PIN & pins);
    1726:	86 b3       	in	r24, 0x16	; 22
    1728:	68 23       	and	r22, r24
    172a:	60 83       	st	Z, r22
	break;
    172c:	07 c0       	rjmp	.+14     	; 0x173c <DIO_Read+0x32>
	case GPIOC:
	*data=(PORTC_PIN & pins);
    172e:	83 b3       	in	r24, 0x13	; 19
    1730:	68 23       	and	r22, r24
    1732:	60 83       	st	Z, r22
	break;
    1734:	03 c0       	rjmp	.+6      	; 0x173c <DIO_Read+0x32>
	case GPIOD:
	*data=(PORTD_PIN & pins);
    1736:	80 b3       	in	r24, 0x10	; 16
    1738:	68 23       	and	r22, r24
    173a:	60 83       	st	Z, r22
	break;
}
if(*data > 0)
    173c:	80 81       	ld	r24, Z
    173e:	88 23       	and	r24, r24
    1740:	11 f0       	breq	.+4      	; 0x1746 <DIO_Read+0x3c>
{
	*data = 1;
    1742:	81 e0       	ldi	r24, 0x01	; 1
    1744:	80 83       	st	Z, r24
}


}
    1746:	08 95       	ret

00001748 <DIO_Toggle>:
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{
uint8_t ret=0;
	switch (GPIO)
    1748:	81 30       	cpi	r24, 0x01	; 1
    174a:	61 f0       	breq	.+24     	; 0x1764 <DIO_Toggle+0x1c>
    174c:	81 30       	cpi	r24, 0x01	; 1
    174e:	28 f0       	brcs	.+10     	; 0x175a <DIO_Toggle+0x12>
    1750:	82 30       	cpi	r24, 0x02	; 2
    1752:	69 f0       	breq	.+26     	; 0x176e <DIO_Toggle+0x26>
    1754:	83 30       	cpi	r24, 0x03	; 3
    1756:	a9 f4       	brne	.+42     	; 0x1782 <DIO_Toggle+0x3a>
    1758:	0f c0       	rjmp	.+30     	; 0x1778 <DIO_Toggle+0x30>
	{	case GPIOA:
		PORTA_DATA ^=(pins);
    175a:	8b b3       	in	r24, 0x1b	; 27
    175c:	68 27       	eor	r22, r24
    175e:	6b bb       	out	0x1b, r22	; 27
		ret=E_OK;
    1760:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1762:	08 95       	ret
		case GPIOB:
		PORTB_DATA ^=(pins);
    1764:	88 b3       	in	r24, 0x18	; 24
    1766:	68 27       	eor	r22, r24
    1768:	68 bb       	out	0x18, r22	; 24
ret=E_OK;
    176a:	80 e0       	ldi	r24, 0x00	; 0
		break;
    176c:	08 95       	ret
		case GPIOC:
		PORTC_DATA ^=(pins);
    176e:	85 b3       	in	r24, 0x15	; 21
    1770:	68 27       	eor	r22, r24
    1772:	65 bb       	out	0x15, r22	; 21
ret=E_OK;
    1774:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1776:	08 95       	ret
		case GPIOD:
		PORTD_DATA ^=(pins);
    1778:	82 b3       	in	r24, 0x12	; 18
    177a:	68 27       	eor	r22, r24
    177c:	62 bb       	out	0x12, r22	; 18
ret=E_OK;
    177e:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1780:	08 95       	ret
		default:
		ret=E_NOK;
    1782:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}

return ret;
}
    1784:	08 95       	ret

00001786 <Icu_Init>:
static volatile uint32_t u32_Time_rising_edge=0;
static volatile uint32_t u32_Time_faling_edge=0;
static volatile uint32_t Timer_High=0;
static volatile uint32_t Timer_Low=0;
ERROR_STATUS Icu_Init(Icu_cfg_s * Icu_Cfg)
{
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
    178a:	ec 01       	movw	r28, r24
	uint8_t Ret=0;
//Enable Global int
G_interrupt_Enable();
    178c:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
//Enable EXTI
switch(Icu_Cfg->ICU_Ch_No)
    1790:	88 81       	ld	r24, Y
    1792:	81 30       	cpi	r24, 0x01	; 1
    1794:	41 f0       	breq	.+16     	; 0x17a6 <Icu_Init+0x20>
    1796:	81 30       	cpi	r24, 0x01	; 1
    1798:	18 f0       	brcs	.+6      	; 0x17a0 <Icu_Init+0x1a>
    179a:	82 30       	cpi	r24, 0x02	; 2
    179c:	49 f4       	brne	.+18     	; 0x17b0 <Icu_Init+0x2a>
    179e:	06 c0       	rjmp	.+12     	; 0x17ac <Icu_Init+0x26>
{
case ICU_CH0:
EX_interrupt_enable0();
    17a0:	0e 94 d9 06 	call	0xdb2	; 0xdb2 <EX_interrupt_enable0>
break;
    17a4:	05 c0       	rjmp	.+10     	; 0x17b0 <Icu_Init+0x2a>
case ICU_CH1:
EX_interrupt_enable1();
    17a6:	0e 94 cd 06 	call	0xd9a	; 0xd9a <EX_interrupt_enable1>
break;
    17aa:	02 c0       	rjmp	.+4      	; 0x17b0 <Icu_Init+0x2a>
case ICU_CH2:
EX_interrupt_enable2();
    17ac:	0e 94 c4 06 	call	0xd88	; 0xd88 <EX_interrupt_enable2>
break;
}

switch(Icu_Cfg->ICU_Ch_Timer)
    17b0:	89 81       	ldd	r24, Y+1	; 0x01
    17b2:	81 30       	cpi	r24, 0x01	; 1
    17b4:	51 f0       	breq	.+20     	; 0x17ca <Icu_Init+0x44>
    17b6:	81 30       	cpi	r24, 0x01	; 1
    17b8:	18 f0       	brcs	.+6      	; 0x17c0 <Icu_Init+0x3a>
    17ba:	82 30       	cpi	r24, 0x02	; 2
    17bc:	89 f4       	brne	.+34     	; 0x17e0 <Icu_Init+0x5a>
    17be:	0c c0       	rjmp	.+24     	; 0x17d8 <Icu_Init+0x52>
{
	case ICU_TIMER_CH0:
		//Enable Timer0
		TCCR0=0x05;
    17c0:	85 e0       	ldi	r24, 0x05	; 5
    17c2:	83 bf       	out	0x33, r24	; 51
		TIMSK=0x01;
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	89 bf       	out	0x39, r24	; 57
		break;
    17c8:	0b c0       	rjmp	.+22     	; 0x17e0 <Icu_Init+0x5a>
	case ICU_TIMER_CH1:
		TCCR1=0x0005;
    17ca:	85 e0       	ldi	r24, 0x05	; 5
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	9f bd       	out	0x2f, r25	; 47
    17d0:	8e bd       	out	0x2e, r24	; 46
		TIMSK=0x04;
    17d2:	84 e0       	ldi	r24, 0x04	; 4
    17d4:	89 bf       	out	0x39, r24	; 57
		break;
    17d6:	04 c0       	rjmp	.+8      	; 0x17e0 <Icu_Init+0x5a>
	case ICU_TIMER_CH2:
		TCCR2=0x07;
    17d8:	87 e0       	ldi	r24, 0x07	; 7
    17da:	85 bd       	out	0x25, r24	; 37
		TIMSK=0x04;
    17dc:	84 e0       	ldi	r24, 0x04	; 4
    17de:	89 bf       	out	0x39, r24	; 57
		break;
}

return Ret;
}
    17e0:	80 e0       	ldi	r24, 0x00	; 0
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	08 95       	ret

000017e8 <Icu_ReadTime>:
 * 				  - E_OK : successful									   *
 *				  - E_NOK : not successful								   *
 * Description	: calculates the time between 2 edges				       *
 ***************************************************************************/
ERROR_STATUS Icu_ReadTime(uint8_t Icu_Channel, uint8_t Icu_EdgeToEdge, uint32_t * Icu_Time)
{
    17e8:	0f 93       	push	r16
    17ea:	1f 93       	push	r17
uint8_t Ret=0;
switch(Icu_Channel)
    17ec:	81 30       	cpi	r24, 0x01	; 1
    17ee:	49 f0       	breq	.+18     	; 0x1802 <Icu_ReadTime+0x1a>
    17f0:	81 30       	cpi	r24, 0x01	; 1
    17f2:	18 f0       	brcs	.+6      	; 0x17fa <Icu_ReadTime+0x12>
    17f4:	82 30       	cpi	r24, 0x02	; 2
    17f6:	71 f4       	brne	.+28     	; 0x1814 <Icu_ReadTime+0x2c>
    17f8:	0a c0       	rjmp	.+20     	; 0x180e <Icu_ReadTime+0x26>
{
	case ICU_TIMER_CH0:
	TCCR0|=0x03;
    17fa:	83 b7       	in	r24, 0x33	; 51
    17fc:	83 60       	ori	r24, 0x03	; 3
    17fe:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
	break;
    1800:	09 c0       	rjmp	.+18     	; 0x1814 <Icu_ReadTime+0x2c>
	case ICU_TIMER_CH1:
	TCCR1|=0x0005;
    1802:	8e b5       	in	r24, 0x2e	; 46
    1804:	9f b5       	in	r25, 0x2f	; 47
    1806:	85 60       	ori	r24, 0x05	; 5
    1808:	9f bd       	out	0x2f, r25	; 47
    180a:	8e bd       	out	0x2e, r24	; 46
	Ret=E_OK;	
	break;
    180c:	03 c0       	rjmp	.+6      	; 0x1814 <Icu_ReadTime+0x2c>
	case ICU_TIMER_CH2:
	TCCR2|=0x07;
    180e:	85 b5       	in	r24, 0x25	; 37
    1810:	87 60       	ori	r24, 0x07	; 7
    1812:	85 bd       	out	0x25, r24	; 37
	default:
	Ret=E_NOK;
	break;
}  

switch(Icu_EdgeToEdge)
    1814:	61 30       	cpi	r22, 0x01	; 1
    1816:	01 f1       	breq	.+64     	; 0x1858 <Icu_ReadTime+0x70>
    1818:	61 30       	cpi	r22, 0x01	; 1
    181a:	18 f0       	brcs	.+6      	; 0x1822 <Icu_ReadTime+0x3a>
    181c:	62 30       	cpi	r22, 0x02	; 2
    181e:	d1 f5       	brne	.+116    	; 0x1894 <Icu_ReadTime+0xac>
    1820:	2a c0       	rjmp	.+84     	; 0x1876 <Icu_ReadTime+0x8e>
{
	case ICU_RISE_TO_RISE:
	*Icu_Time=Timer_High+Timer_Low;
    1822:	80 91 f5 00 	lds	r24, 0x00F5
    1826:	90 91 f6 00 	lds	r25, 0x00F6
    182a:	a0 91 f7 00 	lds	r26, 0x00F7
    182e:	b0 91 f8 00 	lds	r27, 0x00F8
    1832:	00 91 f1 00 	lds	r16, 0x00F1
    1836:	10 91 f2 00 	lds	r17, 0x00F2
    183a:	20 91 f3 00 	lds	r18, 0x00F3
    183e:	30 91 f4 00 	lds	r19, 0x00F4
    1842:	80 0f       	add	r24, r16
    1844:	91 1f       	adc	r25, r17
    1846:	a2 1f       	adc	r26, r18
    1848:	b3 1f       	adc	r27, r19
    184a:	fa 01       	movw	r30, r20
    184c:	80 83       	st	Z, r24
    184e:	91 83       	std	Z+1, r25	; 0x01
    1850:	a2 83       	std	Z+2, r26	; 0x02
    1852:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    1854:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1856:	1f c0       	rjmp	.+62     	; 0x1896 <Icu_ReadTime+0xae>
	case ICU_RISE_TO_FALL:
	*Icu_Time=Timer_High;
    1858:	80 91 f5 00 	lds	r24, 0x00F5
    185c:	90 91 f6 00 	lds	r25, 0x00F6
    1860:	a0 91 f7 00 	lds	r26, 0x00F7
    1864:	b0 91 f8 00 	lds	r27, 0x00F8
    1868:	fa 01       	movw	r30, r20
    186a:	80 83       	st	Z, r24
    186c:	91 83       	std	Z+1, r25	; 0x01
    186e:	a2 83       	std	Z+2, r26	; 0x02
    1870:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    1872:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1874:	10 c0       	rjmp	.+32     	; 0x1896 <Icu_ReadTime+0xae>
	case ICU_FALE_TO_RISE:
	*Icu_Time=Timer_Low;
    1876:	80 91 f1 00 	lds	r24, 0x00F1
    187a:	90 91 f2 00 	lds	r25, 0x00F2
    187e:	a0 91 f3 00 	lds	r26, 0x00F3
    1882:	b0 91 f4 00 	lds	r27, 0x00F4
    1886:	fa 01       	movw	r30, r20
    1888:	80 83       	st	Z, r24
    188a:	91 83       	std	Z+1, r25	; 0x01
    188c:	a2 83       	std	Z+2, r26	; 0x02
    188e:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    1890:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1892:	01 c0       	rjmp	.+2      	; 0x1896 <Icu_ReadTime+0xae>
	
	default:
	Ret=E_NOK;
    1894:	81 e0       	ldi	r24, 0x01	; 1
	break;
}

return Ret;
}
    1896:	1f 91       	pop	r17
    1898:	0f 91       	pop	r16
    189a:	08 95       	ret

0000189c <EXTI>:
void EXTI(void)
{	u32_sgv_TimerVal=(uint32_t)TCNT0+((uint32_t)u8_ovf_happend*255);
    189c:	cf 93       	push	r28
    189e:	c2 b7       	in	r28, 0x32	; 50
    18a0:	60 91 01 01 	lds	r22, 0x0101
    18a4:	70 e0       	ldi	r23, 0x00	; 0
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	2f ef       	ldi	r18, 0xFF	; 255
    18ac:	30 e0       	ldi	r19, 0x00	; 0
    18ae:	40 e0       	ldi	r20, 0x00	; 0
    18b0:	50 e0       	ldi	r21, 0x00	; 0
    18b2:	0e 94 dd 28 	call	0x51ba	; 0x51ba <__mulsi3>
    18b6:	dc 01       	movw	r26, r24
    18b8:	cb 01       	movw	r24, r22
    18ba:	8c 0f       	add	r24, r28
    18bc:	91 1d       	adc	r25, r1
    18be:	a1 1d       	adc	r26, r1
    18c0:	b1 1d       	adc	r27, r1
    18c2:	80 93 02 01 	sts	0x0102, r24
    18c6:	90 93 03 01 	sts	0x0103, r25
    18ca:	a0 93 04 01 	sts	0x0104, r26
    18ce:	b0 93 05 01 	sts	0x0105, r27
	u8_ovf_happend=0;
    18d2:	10 92 01 01 	sts	0x0101, r1
		if(READBIT(MCUCSR,6))
    18d6:	84 b7       	in	r24, 0x34	; 52
    18d8:	82 95       	swap	r24
    18da:	86 95       	lsr	r24
    18dc:	86 95       	lsr	r24
    18de:	83 70       	andi	r24, 0x03	; 3
    18e0:	80 ff       	sbrs	r24, 0
    18e2:	30 c0       	rjmp	.+96     	; 0x1944 <EXTI+0xa8>
		{
		u32_Time_rising_edge=u32_sgv_TimerVal;
    18e4:	80 91 02 01 	lds	r24, 0x0102
    18e8:	90 91 03 01 	lds	r25, 0x0103
    18ec:	a0 91 04 01 	lds	r26, 0x0104
    18f0:	b0 91 05 01 	lds	r27, 0x0105
    18f4:	80 93 fd 00 	sts	0x00FD, r24
    18f8:	90 93 fe 00 	sts	0x00FE, r25
    18fc:	a0 93 ff 00 	sts	0x00FF, r26
    1900:	b0 93 00 01 	sts	0x0100, r27
		Timer_Low = u32_Time_rising_edge - u32_Time_faling_edge;
    1904:	80 91 fd 00 	lds	r24, 0x00FD
    1908:	90 91 fe 00 	lds	r25, 0x00FE
    190c:	a0 91 ff 00 	lds	r26, 0x00FF
    1910:	b0 91 00 01 	lds	r27, 0x0100
    1914:	40 91 f9 00 	lds	r20, 0x00F9
    1918:	50 91 fa 00 	lds	r21, 0x00FA
    191c:	60 91 fb 00 	lds	r22, 0x00FB
    1920:	70 91 fc 00 	lds	r23, 0x00FC
    1924:	84 1b       	sub	r24, r20
    1926:	95 0b       	sbc	r25, r21
    1928:	a6 0b       	sbc	r26, r22
    192a:	b7 0b       	sbc	r27, r23
    192c:	80 93 f1 00 	sts	0x00F1, r24
    1930:	90 93 f2 00 	sts	0x00F2, r25
    1934:	a0 93 f3 00 	sts	0x00F3, r26
    1938:	b0 93 f4 00 	sts	0x00F4, r27
		/*****************************************/	
		CLEAR_BIT(MCUCSR,6);   /*Make it falling*/
    193c:	84 b7       	in	r24, 0x34	; 52
    193e:	8f 7b       	andi	r24, 0xBF	; 191
    1940:	84 bf       	out	0x34, r24	; 52
    1942:	2f c0       	rjmp	.+94     	; 0x19a2 <EXTI+0x106>
		/***************************************/
		}else{
			u32_Time_faling_edge=u32_sgv_TimerVal;
    1944:	80 91 02 01 	lds	r24, 0x0102
    1948:	90 91 03 01 	lds	r25, 0x0103
    194c:	a0 91 04 01 	lds	r26, 0x0104
    1950:	b0 91 05 01 	lds	r27, 0x0105
    1954:	80 93 f9 00 	sts	0x00F9, r24
    1958:	90 93 fa 00 	sts	0x00FA, r25
    195c:	a0 93 fb 00 	sts	0x00FB, r26
    1960:	b0 93 fc 00 	sts	0x00FC, r27
			Timer_High =u32_Time_faling_edge - u32_Time_rising_edge;
    1964:	80 91 f9 00 	lds	r24, 0x00F9
    1968:	90 91 fa 00 	lds	r25, 0x00FA
    196c:	a0 91 fb 00 	lds	r26, 0x00FB
    1970:	b0 91 fc 00 	lds	r27, 0x00FC
    1974:	40 91 fd 00 	lds	r20, 0x00FD
    1978:	50 91 fe 00 	lds	r21, 0x00FE
    197c:	60 91 ff 00 	lds	r22, 0x00FF
    1980:	70 91 00 01 	lds	r23, 0x0100
    1984:	84 1b       	sub	r24, r20
    1986:	95 0b       	sbc	r25, r21
    1988:	a6 0b       	sbc	r26, r22
    198a:	b7 0b       	sbc	r27, r23
    198c:	80 93 f5 00 	sts	0x00F5, r24
    1990:	90 93 f6 00 	sts	0x00F6, r25
    1994:	a0 93 f7 00 	sts	0x00F7, r26
    1998:	b0 93 f8 00 	sts	0x00F8, r27
			/*********************************/	
			SET_BIT(MCUCSR,6);		/*Make it Rising*/
    199c:	84 b7       	in	r24, 0x34	; 52
    199e:	80 64       	ori	r24, 0x40	; 64
    19a0:	84 bf       	out	0x34, r24	; 52
			/********************************/
			}	

//UDR=Timer_High;
}/*
    19a2:	cf 91       	pop	r28
    19a4:	08 95       	ret

000019a6 <pushButtonGetStatus>:

En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id)
{
	static uint8_t u8_Button_press[3];
static uint8_t u8_S_button_status[3];
switch(en_butotn_id)
    19a6:	81 30       	cpi	r24, 0x01	; 1
    19a8:	c1 f0       	breq	.+48     	; 0x19da <pushButtonGetStatus+0x34>
    19aa:	81 30       	cpi	r24, 0x01	; 1
    19ac:	18 f0       	brcs	.+6      	; 0x19b4 <pushButtonGetStatus+0xe>
    19ae:	82 30       	cpi	r24, 0x02	; 2
    19b0:	d1 f5       	brne	.+116    	; 0x1a26 <pushButtonGetStatus+0x80>
    19b2:	26 c0       	rjmp	.+76     	; 0x1a00 <pushButtonGetStatus+0x5a>
{
case BTN_0:
{DIO_Read(BTN_0_GPIO,BTN_0_BIT,&(u8_Button_press[0]));
    19b4:	82 e0       	ldi	r24, 0x02	; 2
    19b6:	61 e0       	ldi	r22, 0x01	; 1
    19b8:	46 e0       	ldi	r20, 0x06	; 6
    19ba:	51 e0       	ldi	r21, 0x01	; 1
    19bc:	0e 94 85 0b 	call	0x170a	; 0x170a <DIO_Read>
if( u8_Button_press[0]== Pressed)
    19c0:	80 91 06 01 	lds	r24, 0x0106
    19c4:	81 30       	cpi	r24, 0x01	; 1
    19c6:	81 f5       	brne	.+96     	; 0x1a28 <pushButtonGetStatus+0x82>
{ 
	(u8_S_button_status[0])++;
    19c8:	90 91 09 01 	lds	r25, 0x0109
    19cc:	9f 5f       	subi	r25, 0xFF	; 255
    19ce:	90 93 09 01 	sts	0x0109, r25
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    19d2:	93 33       	cpi	r25, 0x33	; 51
    19d4:	70 f5       	brcc	.+92     	; 0x1a32 <pushButtonGetStatus+0x8c>
    19d6:	80 e0       	ldi	r24, 0x00	; 0
    19d8:	08 95       	ret
	else {return Released;}
}else{return Released;}
break;
}
case BTN_1:
{DIO_Read(BTN_1_GPIO,BTN_1_BIT,&(u8_Button_press[1]));
    19da:	81 e0       	ldi	r24, 0x01	; 1
    19dc:	64 e0       	ldi	r22, 0x04	; 4
    19de:	47 e0       	ldi	r20, 0x07	; 7
    19e0:	51 e0       	ldi	r21, 0x01	; 1
    19e2:	0e 94 85 0b 	call	0x170a	; 0x170a <DIO_Read>
if( u8_Button_press[1] == Pressed)
    19e6:	80 91 07 01 	lds	r24, 0x0107
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	f9 f4       	brne	.+62     	; 0x1a2c <pushButtonGetStatus+0x86>
{
	(u8_S_button_status[0])++;
    19ee:	90 91 09 01 	lds	r25, 0x0109
    19f2:	9f 5f       	subi	r25, 0xFF	; 255
    19f4:	90 93 09 01 	sts	0x0109, r25
	(u8_S_button_status[0])++;
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    19f8:	93 33       	cpi	r25, 0x33	; 51
    19fa:	d8 f4       	brcc	.+54     	; 0x1a32 <pushButtonGetStatus+0x8c>
    19fc:	80 e0       	ldi	r24, 0x00	; 0
    19fe:	08 95       	ret
	else {return Released;}
}else{return Released;}
break;
}
case BTN_2:
{DIO_Read(BTN_2_GPIO,BTN_2_BIT,&(u8_Button_press[2]));
    1a00:	80 e0       	ldi	r24, 0x00	; 0
    1a02:	64 e0       	ldi	r22, 0x04	; 4
    1a04:	48 e0       	ldi	r20, 0x08	; 8
    1a06:	51 e0       	ldi	r21, 0x01	; 1
    1a08:	0e 94 85 0b 	call	0x170a	; 0x170a <DIO_Read>
if((u8_Button_press[2])== Pressed)
    1a0c:	80 91 08 01 	lds	r24, 0x0108
    1a10:	81 30       	cpi	r24, 0x01	; 1
    1a12:	71 f4       	brne	.+28     	; 0x1a30 <pushButtonGetStatus+0x8a>
{	(u8_S_button_status[1])++;
    1a14:	90 91 0a 01 	lds	r25, 0x010A
    1a18:	9f 5f       	subi	r25, 0xFF	; 255
    1a1a:	90 93 0a 01 	sts	0x010A, r25
	(u8_S_button_status[0])++;
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1a1e:	95 31       	cpi	r25, 0x15	; 21
    1a20:	40 f4       	brcc	.+16     	; 0x1a32 <pushButtonGetStatus+0x8c>
    1a22:	80 e0       	ldi	r24, 0x00	; 0
    1a24:	08 95       	ret
    1a26:	08 95       	ret
	else {return Released;}
}else{return Released;}
    1a28:	80 e0       	ldi	r24, 0x00	; 0
    1a2a:	08 95       	ret
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
return Pressed;
	else {return Released;}
}else{return Released;}
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
    1a2e:	08 95       	ret
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[1]) > 20)
	return Pressed;
else {return Released;}
}else{return Released;}
    1a30:	80 e0       	ldi	r24, 0x00	; 0


	}


}
    1a32:	08 95       	ret

00001a34 <Pwm_Init>:
/*                                                                               */
/* Description: initialize the PWM configuration                                 */
/*********************************************************************************/

ERROR_STATUS Pwm_Init(Pwm_Cfg_s *Pwm_Cfg)
{uint8_t Ret=0;
    1a34:	fc 01       	movw	r30, r24
	switch(Pwm_Cfg->Channel)
    1a36:	80 81       	ld	r24, Z
    1a38:	81 30       	cpi	r24, 0x01	; 1
    1a3a:	61 f0       	breq	.+24     	; 0x1a54 <Pwm_Init+0x20>
    1a3c:	81 30       	cpi	r24, 0x01	; 1
    1a3e:	28 f0       	brcs	.+10     	; 0x1a4a <Pwm_Init+0x16>
    1a40:	82 30       	cpi	r24, 0x02	; 2
    1a42:	81 f0       	breq	.+32     	; 0x1a64 <Pwm_Init+0x30>
    1a44:	83 30       	cpi	r24, 0x03	; 3
    1a46:	d9 f4       	brne	.+54     	; 0x1a7e <Pwm_Init+0x4a>
    1a48:	15 c0       	rjmp	.+42     	; 0x1a74 <Pwm_Init+0x40>
		{
			case PWM_CH0:
			TCCR0|=T0_PWM_FAST |T0_NON_INVERTING;
    1a4a:	83 b7       	in	r24, 0x33	; 51
    1a4c:	88 66       	ori	r24, 0x68	; 104
    1a4e:	83 bf       	out	0x33, r24	; 51
			Ret=E_OK;
    1a50:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1a52:	16 c0       	rjmp	.+44     	; 0x1a80 <Pwm_Init+0x4c>

			case PWM_CH1A:
			TCCR1 |= T1_PWM_Phase_8 | T1_OC1A_OC1B|0x0020;
    1a54:	8e b5       	in	r24, 0x2e	; 46
    1a56:	9f b5       	in	r25, 0x2f	; 47
    1a58:	80 62       	ori	r24, 0x20	; 32
    1a5a:	91 6a       	ori	r25, 0xA1	; 161
    1a5c:	9f bd       	out	0x2f, r25	; 47
    1a5e:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
    1a60:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1a62:	0e c0       	rjmp	.+28     	; 0x1a80 <Pwm_Init+0x4c>

			case PWM_CH1B:
			TCCR1 |= T1_PWM_Phase_8 | T1_OC1A_OC1B;
    1a64:	8e b5       	in	r24, 0x2e	; 46
    1a66:	9f b5       	in	r25, 0x2f	; 47
    1a68:	80 62       	ori	r24, 0x20	; 32
    1a6a:	91 6a       	ori	r25, 0xA1	; 161
    1a6c:	9f bd       	out	0x2f, r25	; 47
    1a6e:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
    1a70:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1a72:	06 c0       	rjmp	.+12     	; 0x1a80 <Pwm_Init+0x4c>


			case PWM_CH2:
			TCCR2 |=T2_PWM_FAST |T2_NON_INVERTING;
    1a74:	85 b5       	in	r24, 0x25	; 37
    1a76:	88 66       	ori	r24, 0x68	; 104
    1a78:	85 bd       	out	0x25, r24	; 37
			Ret=E_OK;
    1a7a:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1a7c:	01 c0       	rjmp	.+2      	; 0x1a80 <Pwm_Init+0x4c>
			default:
			Ret=E_NOK;
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
	sgl_Prescaler=Pwm_Cfg->Prescaler;
    1a80:	91 81       	ldd	r25, Z+1	; 0x01
    1a82:	90 93 0c 01 	sts	0x010C, r25
	u32g_T1_Prescaler=en_prescal;
	OCR1A =u16_outputCompareA;
	OCR1B =u16_outputCompareB;
	TCNT1=u16_initialValue;
	*/
}
    1a86:	08 95       	ret

00001a88 <Pwm_Start>:
/*-------------------------------------------------------                        */
/*((all this calculations are for phase correct mode))                           */
/*all this calculation for F_CPU 16MHz                                           */
/*********************************************************************************/
ERROR_STATUS Pwm_Start(uint8_t Channel,uint8_t Duty,uint32_t Frequncy)
{uint8_t Ret=0;
    1a88:	cf 92       	push	r12
    1a8a:	df 92       	push	r13
    1a8c:	ef 92       	push	r14
    1a8e:	ff 92       	push	r15
    1a90:	0f 93       	push	r16
    1a92:	1f 93       	push	r17
    1a94:	89 01       	movw	r16, r18
    1a96:	9a 01       	movw	r18, r20
	float dutyReal;
uint32_t pwm_time_on = MAX_HOLD;

if(Frequncy <= 31372 && Frequncy > 3921 )
    1a98:	0f 2e       	mov	r0, r31
    1a9a:	fe ea       	ldi	r31, 0xAE	; 174
    1a9c:	cf 2e       	mov	r12, r31
    1a9e:	f0 ef       	ldi	r31, 0xF0	; 240
    1aa0:	df 2e       	mov	r13, r31
    1aa2:	ff ef       	ldi	r31, 0xFF	; 255
    1aa4:	ef 2e       	mov	r14, r31
    1aa6:	ff ef       	ldi	r31, 0xFF	; 255
    1aa8:	ff 2e       	mov	r15, r31
    1aaa:	f0 2d       	mov	r31, r0
    1aac:	c0 0e       	add	r12, r16
    1aae:	d1 1e       	adc	r13, r17
    1ab0:	e2 1e       	adc	r14, r18
    1ab2:	f3 1e       	adc	r15, r19
    1ab4:	9b e3       	ldi	r25, 0x3B	; 59
    1ab6:	c9 16       	cp	r12, r25
    1ab8:	9b e6       	ldi	r25, 0x6B	; 107
    1aba:	d9 06       	cpc	r13, r25
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	e9 06       	cpc	r14, r25
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	f9 06       	cpc	r15, r25
    1ac4:	18 f4       	brcc	.+6      	; 0x1acc <Pwm_Start+0x44>
	sgl_Prescaler=PWM_PRESCALER_NO;
    1ac6:	10 92 0c 01 	sts	0x010C, r1
    1aca:	a2 c0       	rjmp	.+324    	; 0x1c10 <Pwm_Start+0x188>
else if(Frequncy <= 3921 && Frequncy > 980)
    1acc:	0f 2e       	mov	r0, r31
    1ace:	fb e2       	ldi	r31, 0x2B	; 43
    1ad0:	cf 2e       	mov	r12, r31
    1ad2:	fc ef       	ldi	r31, 0xFC	; 252
    1ad4:	df 2e       	mov	r13, r31
    1ad6:	ff ef       	ldi	r31, 0xFF	; 255
    1ad8:	ef 2e       	mov	r14, r31
    1ada:	ff ef       	ldi	r31, 0xFF	; 255
    1adc:	ff 2e       	mov	r15, r31
    1ade:	f0 2d       	mov	r31, r0
    1ae0:	c0 0e       	add	r12, r16
    1ae2:	d1 1e       	adc	r13, r17
    1ae4:	e2 1e       	adc	r14, r18
    1ae6:	f3 1e       	adc	r15, r19
    1ae8:	9d e7       	ldi	r25, 0x7D	; 125
    1aea:	c9 16       	cp	r12, r25
    1aec:	9b e0       	ldi	r25, 0x0B	; 11
    1aee:	d9 06       	cpc	r13, r25
    1af0:	90 e0       	ldi	r25, 0x00	; 0
    1af2:	e9 06       	cpc	r14, r25
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	f9 06       	cpc	r15, r25
    1af8:	20 f4       	brcc	.+8      	; 0x1b02 <Pwm_Start+0x7a>
	sgl_Prescaler=PWM_PRESCALER_8;
    1afa:	91 e0       	ldi	r25, 0x01	; 1
    1afc:	90 93 0c 01 	sts	0x010C, r25
    1b00:	a5 c0       	rjmp	.+330    	; 0x1c4c <Pwm_Start+0x1c4>
else if(Frequncy <= 980 && Frequncy > 490)
    1b02:	0f 2e       	mov	r0, r31
    1b04:	f5 e1       	ldi	r31, 0x15	; 21
    1b06:	cf 2e       	mov	r12, r31
    1b08:	fe ef       	ldi	r31, 0xFE	; 254
    1b0a:	df 2e       	mov	r13, r31
    1b0c:	ff ef       	ldi	r31, 0xFF	; 255
    1b0e:	ef 2e       	mov	r14, r31
    1b10:	ff ef       	ldi	r31, 0xFF	; 255
    1b12:	ff 2e       	mov	r15, r31
    1b14:	f0 2d       	mov	r31, r0
    1b16:	c0 0e       	add	r12, r16
    1b18:	d1 1e       	adc	r13, r17
    1b1a:	e2 1e       	adc	r14, r18
    1b1c:	f3 1e       	adc	r15, r19
    1b1e:	9a ee       	ldi	r25, 0xEA	; 234
    1b20:	c9 16       	cp	r12, r25
    1b22:	91 e0       	ldi	r25, 0x01	; 1
    1b24:	d9 06       	cpc	r13, r25
    1b26:	90 e0       	ldi	r25, 0x00	; 0
    1b28:	e9 06       	cpc	r14, r25
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	f9 06       	cpc	r15, r25
    1b2e:	20 f4       	brcc	.+8      	; 0x1b38 <Pwm_Start+0xb0>
	sgl_Prescaler=PWM_PRESCALER_32;
    1b30:	92 e0       	ldi	r25, 0x02	; 2
    1b32:	90 93 0c 01 	sts	0x010C, r25
    1b36:	a1 c0       	rjmp	.+322    	; 0x1c7a <Pwm_Start+0x1f2>
else if(Frequncy <= 490 && Frequncy > 245)
    1b38:	0f 2e       	mov	r0, r31
    1b3a:	fa e0       	ldi	r31, 0x0A	; 10
    1b3c:	cf 2e       	mov	r12, r31
    1b3e:	ff ef       	ldi	r31, 0xFF	; 255
    1b40:	df 2e       	mov	r13, r31
    1b42:	ff ef       	ldi	r31, 0xFF	; 255
    1b44:	ef 2e       	mov	r14, r31
    1b46:	ff ef       	ldi	r31, 0xFF	; 255
    1b48:	ff 2e       	mov	r15, r31
    1b4a:	f0 2d       	mov	r31, r0
    1b4c:	c0 0e       	add	r12, r16
    1b4e:	d1 1e       	adc	r13, r17
    1b50:	e2 1e       	adc	r14, r18
    1b52:	f3 1e       	adc	r15, r19
    1b54:	95 ef       	ldi	r25, 0xF5	; 245
    1b56:	c9 16       	cp	r12, r25
    1b58:	d1 04       	cpc	r13, r1
    1b5a:	e1 04       	cpc	r14, r1
    1b5c:	f1 04       	cpc	r15, r1
    1b5e:	20 f4       	brcc	.+8      	; 0x1b68 <Pwm_Start+0xe0>
	sgl_Prescaler=PWM_PRESCALER_64;
    1b60:	93 e0       	ldi	r25, 0x03	; 3
    1b62:	90 93 0c 01 	sts	0x010C, r25
    1b66:	90 c0       	rjmp	.+288    	; 0x1c88 <Pwm_Start+0x200>
else if(Frequncy <= 245 && Frequncy > 122)
    1b68:	0f 2e       	mov	r0, r31
    1b6a:	f5 e8       	ldi	r31, 0x85	; 133
    1b6c:	cf 2e       	mov	r12, r31
    1b6e:	ff ef       	ldi	r31, 0xFF	; 255
    1b70:	df 2e       	mov	r13, r31
    1b72:	ff ef       	ldi	r31, 0xFF	; 255
    1b74:	ef 2e       	mov	r14, r31
    1b76:	ff ef       	ldi	r31, 0xFF	; 255
    1b78:	ff 2e       	mov	r15, r31
    1b7a:	f0 2d       	mov	r31, r0
    1b7c:	c0 0e       	add	r12, r16
    1b7e:	d1 1e       	adc	r13, r17
    1b80:	e2 1e       	adc	r14, r18
    1b82:	f3 1e       	adc	r15, r19
    1b84:	9b e7       	ldi	r25, 0x7B	; 123
    1b86:	c9 16       	cp	r12, r25
    1b88:	d1 04       	cpc	r13, r1
    1b8a:	e1 04       	cpc	r14, r1
    1b8c:	f1 04       	cpc	r15, r1
    1b8e:	20 f4       	brcc	.+8      	; 0x1b98 <Pwm_Start+0x110>
	sgl_Prescaler=PWM_PRESCALER_128;
    1b90:	94 e0       	ldi	r25, 0x04	; 4
    1b92:	90 93 0c 01 	sts	0x010C, r25
    1b96:	a5 c0       	rjmp	.+330    	; 0x1ce2 <Pwm_Start+0x25a>
else if(Frequncy <= 122 && Frequncy > 31)
    1b98:	0f 2e       	mov	r0, r31
    1b9a:	f0 ee       	ldi	r31, 0xE0	; 224
    1b9c:	cf 2e       	mov	r12, r31
    1b9e:	ff ef       	ldi	r31, 0xFF	; 255
    1ba0:	df 2e       	mov	r13, r31
    1ba2:	ff ef       	ldi	r31, 0xFF	; 255
    1ba4:	ef 2e       	mov	r14, r31
    1ba6:	ff ef       	ldi	r31, 0xFF	; 255
    1ba8:	ff 2e       	mov	r15, r31
    1baa:	f0 2d       	mov	r31, r0
    1bac:	c0 0e       	add	r12, r16
    1bae:	d1 1e       	adc	r13, r17
    1bb0:	e2 1e       	adc	r14, r18
    1bb2:	f3 1e       	adc	r15, r19
    1bb4:	9b e5       	ldi	r25, 0x5B	; 91
    1bb6:	c9 16       	cp	r12, r25
    1bb8:	d1 04       	cpc	r13, r1
    1bba:	e1 04       	cpc	r14, r1
    1bbc:	f1 04       	cpc	r15, r1
    1bbe:	20 f4       	brcc	.+8      	; 0x1bc8 <Pwm_Start+0x140>
	sgl_Prescaler=PWM_PRESCALER_256;
    1bc0:	95 e0       	ldi	r25, 0x05	; 5
    1bc2:	90 93 0c 01 	sts	0x010C, r25
    1bc6:	77 c0       	rjmp	.+238    	; 0x1cb6 <Pwm_Start+0x22e>
else if(Frequncy <= 31 && Frequncy > 0)
    1bc8:	01 50       	subi	r16, 0x01	; 1
    1bca:	10 40       	sbci	r17, 0x00	; 0
    1bcc:	20 40       	sbci	r18, 0x00	; 0
    1bce:	30 40       	sbci	r19, 0x00	; 0
    1bd0:	0f 31       	cpi	r16, 0x1F	; 31
    1bd2:	11 05       	cpc	r17, r1
    1bd4:	21 05       	cpc	r18, r1
    1bd6:	31 05       	cpc	r19, r1
    1bd8:	20 f4       	brcc	.+8      	; 0x1be2 <Pwm_Start+0x15a>
	sgl_Prescaler=PWM_PRESCALER_1024;
    1bda:	96 e0       	ldi	r25, 0x06	; 6
    1bdc:	90 93 0c 01 	sts	0x010C, r25
    1be0:	86 c0       	rjmp	.+268    	; 0x1cee <Pwm_Start+0x266>
else{Ret=E_NOK;}
switch(sgl_Prescaler)
    1be2:	90 91 0c 01 	lds	r25, 0x010C
    1be6:	93 30       	cpi	r25, 0x03	; 3
    1be8:	09 f4       	brne	.+2      	; 0x1bec <Pwm_Start+0x164>
    1bea:	4e c0       	rjmp	.+156    	; 0x1c88 <Pwm_Start+0x200>
    1bec:	94 30       	cpi	r25, 0x04	; 4
    1bee:	30 f4       	brcc	.+12     	; 0x1bfc <Pwm_Start+0x174>
    1bf0:	91 30       	cpi	r25, 0x01	; 1
    1bf2:	61 f1       	breq	.+88     	; 0x1c4c <Pwm_Start+0x1c4>
    1bf4:	92 30       	cpi	r25, 0x02	; 2
    1bf6:	08 f0       	brcs	.+2      	; 0x1bfa <Pwm_Start+0x172>
    1bf8:	40 c0       	rjmp	.+128    	; 0x1c7a <Pwm_Start+0x1f2>
    1bfa:	0a c0       	rjmp	.+20     	; 0x1c10 <Pwm_Start+0x188>
    1bfc:	95 30       	cpi	r25, 0x05	; 5
    1bfe:	09 f4       	brne	.+2      	; 0x1c02 <Pwm_Start+0x17a>
    1c00:	5a c0       	rjmp	.+180    	; 0x1cb6 <Pwm_Start+0x22e>
    1c02:	95 30       	cpi	r25, 0x05	; 5
    1c04:	08 f4       	brcc	.+2      	; 0x1c08 <Pwm_Start+0x180>
    1c06:	6d c0       	rjmp	.+218    	; 0x1ce2 <Pwm_Start+0x25a>
    1c08:	96 30       	cpi	r25, 0x06	; 6
    1c0a:	09 f0       	breq	.+2      	; 0x1c0e <Pwm_Start+0x186>
    1c0c:	8d c0       	rjmp	.+282    	; 0x1d28 <Pwm_Start+0x2a0>
    1c0e:	6f c0       	rjmp	.+222    	; 0x1cee <Pwm_Start+0x266>
{
	case PWM_PRESCALER_NO:
	{
		switch(Channel)
    1c10:	81 30       	cpi	r24, 0x01	; 1
    1c12:	61 f0       	breq	.+24     	; 0x1c2c <Pwm_Start+0x1a4>
    1c14:	81 30       	cpi	r24, 0x01	; 1
    1c16:	30 f0       	brcs	.+12     	; 0x1c24 <Pwm_Start+0x19c>
    1c18:	82 30       	cpi	r24, 0x02	; 2
    1c1a:	71 f0       	breq	.+28     	; 0x1c38 <Pwm_Start+0x1b0>
    1c1c:	83 30       	cpi	r24, 0x03	; 3
    1c1e:	09 f0       	breq	.+2      	; 0x1c22 <Pwm_Start+0x19a>
    1c20:	83 c0       	rjmp	.+262    	; 0x1d28 <Pwm_Start+0x2a0>
    1c22:	10 c0       	rjmp	.+32     	; 0x1c44 <Pwm_Start+0x1bc>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_NO_CONFIG;
    1c24:	83 b7       	in	r24, 0x33	; 51
    1c26:	81 60       	ori	r24, 0x01	; 1
    1c28:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1c2a:	88 c0       	rjmp	.+272    	; 0x1d3c <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			{
			TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1c2c:	8e b5       	in	r24, 0x2e	; 46
    1c2e:	9f b5       	in	r25, 0x2f	; 47
    1c30:	81 60       	ori	r24, 0x01	; 1
    1c32:	9f bd       	out	0x2f, r25	; 47
    1c34:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
			break;
    1c36:	98 c0       	rjmp	.+304    	; 0x1d68 <Pwm_Start+0x2e0>
			}			
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1c38:	8e b5       	in	r24, 0x2e	; 46
    1c3a:	9f b5       	in	r25, 0x2f	; 47
    1c3c:	81 60       	ori	r24, 0x01	; 1
    1c3e:	9f bd       	out	0x2f, r25	; 47
    1c40:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1c42:	ad c0       	rjmp	.+346    	; 0x1d9e <Pwm_Start+0x316>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_NO_CONFIG;
    1c44:	85 b5       	in	r24, 0x25	; 37
    1c46:	81 60       	ori	r24, 0x01	; 1
    1c48:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1c4a:	c4 c0       	rjmp	.+392    	; 0x1dd4 <Pwm_Start+0x34c>
	}

	
	case PWM_PRESCALER_8:
	{
		switch(Channel)
    1c4c:	83 30       	cpi	r24, 0x03	; 3
    1c4e:	18 f4       	brcc	.+6      	; 0x1c56 <Pwm_Start+0x1ce>
    1c50:	81 30       	cpi	r24, 0x01	; 1
    1c52:	48 f4       	brcc	.+18     	; 0x1c66 <Pwm_Start+0x1de>
    1c54:	04 c0       	rjmp	.+8      	; 0x1c5e <Pwm_Start+0x1d6>
    1c56:	83 30       	cpi	r24, 0x03	; 3
    1c58:	09 f0       	breq	.+2      	; 0x1c5c <Pwm_Start+0x1d4>
    1c5a:	66 c0       	rjmp	.+204    	; 0x1d28 <Pwm_Start+0x2a0>
    1c5c:	0a c0       	rjmp	.+20     	; 0x1c72 <Pwm_Start+0x1ea>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_8_CONFIG;
    1c5e:	83 b7       	in	r24, 0x33	; 51
    1c60:	82 60       	ori	r24, 0x02	; 2
    1c62:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1c64:	6b c0       	rjmp	.+214    	; 0x1d3c <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_8_CONFIG;
    1c66:	2e b5       	in	r18, 0x2e	; 46
    1c68:	3f b5       	in	r19, 0x2f	; 47
    1c6a:	22 60       	ori	r18, 0x02	; 2
    1c6c:	3f bd       	out	0x2f, r19	; 47
    1c6e:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1c70:	5b c0       	rjmp	.+182    	; 0x1d28 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_8_CONFIG;
    1c72:	85 b5       	in	r24, 0x25	; 37
    1c74:	82 60       	ori	r24, 0x02	; 2
    1c76:	85 bd       	out	0x25, r24	; 37
			Ret=E_OK;	
				break;
    1c78:	ad c0       	rjmp	.+346    	; 0x1dd4 <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_32:
	{
		switch(Channel)
    1c7a:	83 30       	cpi	r24, 0x03	; 3
    1c7c:	09 f0       	breq	.+2      	; 0x1c80 <Pwm_Start+0x1f8>
    1c7e:	54 c0       	rjmp	.+168    	; 0x1d28 <Pwm_Start+0x2a0>
		{
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_32_CONFIG_T2;
    1c80:	85 b5       	in	r24, 0x25	; 37
    1c82:	83 60       	ori	r24, 0x03	; 3
    1c84:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1c86:	a6 c0       	rjmp	.+332    	; 0x1dd4 <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_64:
	{
		switch(Channel)
    1c88:	83 30       	cpi	r24, 0x03	; 3
    1c8a:	18 f4       	brcc	.+6      	; 0x1c92 <Pwm_Start+0x20a>
    1c8c:	81 30       	cpi	r24, 0x01	; 1
    1c8e:	48 f4       	brcc	.+18     	; 0x1ca2 <Pwm_Start+0x21a>
    1c90:	04 c0       	rjmp	.+8      	; 0x1c9a <Pwm_Start+0x212>
    1c92:	83 30       	cpi	r24, 0x03	; 3
    1c94:	09 f0       	breq	.+2      	; 0x1c98 <Pwm_Start+0x210>
    1c96:	48 c0       	rjmp	.+144    	; 0x1d28 <Pwm_Start+0x2a0>
    1c98:	0a c0       	rjmp	.+20     	; 0x1cae <Pwm_Start+0x226>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_64_CONFIG;
    1c9a:	83 b7       	in	r24, 0x33	; 51
    1c9c:	83 60       	ori	r24, 0x03	; 3
    1c9e:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1ca0:	4d c0       	rjmp	.+154    	; 0x1d3c <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_64_CONFIG;
    1ca2:	2e b5       	in	r18, 0x2e	; 46
    1ca4:	3f b5       	in	r19, 0x2f	; 47
    1ca6:	23 60       	ori	r18, 0x03	; 3
    1ca8:	3f bd       	out	0x2f, r19	; 47
    1caa:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1cac:	3d c0       	rjmp	.+122    	; 0x1d28 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_64_CONFIG_T2;
    1cae:	85 b5       	in	r24, 0x25	; 37
    1cb0:	84 60       	ori	r24, 0x04	; 4
    1cb2:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1cb4:	8f c0       	rjmp	.+286    	; 0x1dd4 <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_256:
	{
		switch(Channel)
    1cb6:	83 30       	cpi	r24, 0x03	; 3
    1cb8:	18 f4       	brcc	.+6      	; 0x1cc0 <Pwm_Start+0x238>
    1cba:	81 30       	cpi	r24, 0x01	; 1
    1cbc:	40 f4       	brcc	.+16     	; 0x1cce <Pwm_Start+0x246>
    1cbe:	03 c0       	rjmp	.+6      	; 0x1cc6 <Pwm_Start+0x23e>
    1cc0:	83 30       	cpi	r24, 0x03	; 3
    1cc2:	91 f5       	brne	.+100    	; 0x1d28 <Pwm_Start+0x2a0>
    1cc4:	0a c0       	rjmp	.+20     	; 0x1cda <Pwm_Start+0x252>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_64_CONFIG;
    1cc6:	83 b7       	in	r24, 0x33	; 51
    1cc8:	83 60       	ori	r24, 0x03	; 3
    1cca:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1ccc:	37 c0       	rjmp	.+110    	; 0x1d3c <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_64_CONFIG;
    1cce:	2e b5       	in	r18, 0x2e	; 46
    1cd0:	3f b5       	in	r19, 0x2f	; 47
    1cd2:	23 60       	ori	r18, 0x03	; 3
    1cd4:	3f bd       	out	0x2f, r19	; 47
    1cd6:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1cd8:	27 c0       	rjmp	.+78     	; 0x1d28 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_64_CONFIG_T2;
    1cda:	85 b5       	in	r24, 0x25	; 37
    1cdc:	84 60       	ori	r24, 0x04	; 4
    1cde:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1ce0:	79 c0       	rjmp	.+242    	; 0x1dd4 <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_128:
	{
		switch(Channel)
    1ce2:	83 30       	cpi	r24, 0x03	; 3
    1ce4:	09 f5       	brne	.+66     	; 0x1d28 <Pwm_Start+0x2a0>
		{
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_128_CONFIG_T2;
    1ce6:	85 b5       	in	r24, 0x25	; 37
    1ce8:	85 60       	ori	r24, 0x05	; 5
    1cea:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1cec:	73 c0       	rjmp	.+230    	; 0x1dd4 <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_1024:
	{
		switch(Channel)
    1cee:	81 30       	cpi	r24, 0x01	; 1
    1cf0:	59 f0       	breq	.+22     	; 0x1d08 <Pwm_Start+0x280>
    1cf2:	81 30       	cpi	r24, 0x01	; 1
    1cf4:	28 f0       	brcs	.+10     	; 0x1d00 <Pwm_Start+0x278>
    1cf6:	82 30       	cpi	r24, 0x02	; 2
    1cf8:	69 f0       	breq	.+26     	; 0x1d14 <Pwm_Start+0x28c>
    1cfa:	83 30       	cpi	r24, 0x03	; 3
    1cfc:	a9 f4       	brne	.+42     	; 0x1d28 <Pwm_Start+0x2a0>
    1cfe:	10 c0       	rjmp	.+32     	; 0x1d20 <Pwm_Start+0x298>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_1024_CONFIG;
    1d00:	83 b7       	in	r24, 0x33	; 51
    1d02:	85 60       	ori	r24, 0x05	; 5
    1d04:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d06:	1a c0       	rjmp	.+52     	; 0x1d3c <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			{	TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1d08:	8e b5       	in	r24, 0x2e	; 46
    1d0a:	9f b5       	in	r25, 0x2f	; 47
    1d0c:	81 60       	ori	r24, 0x01	; 1
    1d0e:	9f bd       	out	0x2f, r25	; 47
    1d10:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1d12:	2a c0       	rjmp	.+84     	; 0x1d68 <Pwm_Start+0x2e0>
			}
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_1024_CONFIG;
    1d14:	8e b5       	in	r24, 0x2e	; 46
    1d16:	9f b5       	in	r25, 0x2f	; 47
    1d18:	85 60       	ori	r24, 0x05	; 5
    1d1a:	9f bd       	out	0x2f, r25	; 47
    1d1c:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1d1e:	3f c0       	rjmp	.+126    	; 0x1d9e <Pwm_Start+0x316>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_1024_CONFIG_T2;
    1d20:	85 b5       	in	r24, 0x25	; 37
    1d22:	87 60       	ori	r24, 0x07	; 7
    1d24:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d26:	56 c0       	rjmp	.+172    	; 0x1dd4 <Pwm_Start+0x34c>

	
	
}

switch(Channel)
    1d28:	81 30       	cpi	r24, 0x01	; 1
    1d2a:	f1 f0       	breq	.+60     	; 0x1d68 <Pwm_Start+0x2e0>
    1d2c:	81 30       	cpi	r24, 0x01	; 1
    1d2e:	30 f0       	brcs	.+12     	; 0x1d3c <Pwm_Start+0x2b4>
    1d30:	82 30       	cpi	r24, 0x02	; 2
    1d32:	a9 f1       	breq	.+106    	; 0x1d9e <Pwm_Start+0x316>
    1d34:	83 30       	cpi	r24, 0x03	; 3
    1d36:	09 f0       	breq	.+2      	; 0x1d3a <Pwm_Start+0x2b2>
    1d38:	63 c0       	rjmp	.+198    	; 0x1e00 <Pwm_Start+0x378>
    1d3a:	4c c0       	rjmp	.+152    	; 0x1dd4 <Pwm_Start+0x34c>
		{
			case PWM_CH0:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1d3c:	70 e0       	ldi	r23, 0x00	; 0
    1d3e:	80 e0       	ldi	r24, 0x00	; 0
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <__floatunsisf>
    1d46:	20 e0       	ldi	r18, 0x00	; 0
    1d48:	30 e0       	ldi	r19, 0x00	; 0
    1d4a:	48 ec       	ldi	r20, 0xC8	; 200
    1d4c:	52 e4       	ldi	r21, 0x42	; 66
    1d4e:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1d52:	20 e0       	ldi	r18, 0x00	; 0
    1d54:	30 e0       	ldi	r19, 0x00	; 0
    1d56:	4f e7       	ldi	r20, 0x7F	; 127
    1d58:	53 e4       	ldi	r21, 0x43	; 67
    1d5a:	0e 94 7a 28 	call	0x50f4	; 0x50f4 <__mulsf3>
    1d5e:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <__fixunssfsi>
			OCR0=pwm_time_on;
    1d62:	6c bf       	out	0x3c, r22	; 60
			Ret=E_OK;
    1d64:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1d66:	4d c0       	rjmp	.+154    	; 0x1e02 <Pwm_Start+0x37a>
			}			
			case PWM_CH1A:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1d68:	70 e0       	ldi	r23, 0x00	; 0
    1d6a:	80 e0       	ldi	r24, 0x00	; 0
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <__floatunsisf>
    1d72:	20 e0       	ldi	r18, 0x00	; 0
    1d74:	30 e0       	ldi	r19, 0x00	; 0
    1d76:	48 ec       	ldi	r20, 0xC8	; 200
    1d78:	52 e4       	ldi	r21, 0x42	; 66
    1d7a:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1d7e:	20 e0       	ldi	r18, 0x00	; 0
    1d80:	30 e0       	ldi	r19, 0x00	; 0
    1d82:	4f e7       	ldi	r20, 0x7F	; 127
    1d84:	53 e4       	ldi	r21, 0x43	; 67
    1d86:	0e 94 7a 28 	call	0x50f4	; 0x50f4 <__mulsf3>
    1d8a:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <__fixunssfsi>
    1d8e:	dc 01       	movw	r26, r24
    1d90:	cb 01       	movw	r24, r22
			OCR1A=pwm_time_on;
    1d92:	9b bd       	out	0x2b, r25	; 43
    1d94:	8a bd       	out	0x2a, r24	; 42
			OCR1B=pwm_time_on;
    1d96:	99 bd       	out	0x29, r25	; 41
    1d98:	88 bd       	out	0x28, r24	; 40
			Ret=E_OK;
    1d9a:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1d9c:	32 c0       	rjmp	.+100    	; 0x1e02 <Pwm_Start+0x37a>
			}			
			case PWM_CH1B:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1d9e:	70 e0       	ldi	r23, 0x00	; 0
    1da0:	80 e0       	ldi	r24, 0x00	; 0
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <__floatunsisf>
    1da8:	20 e0       	ldi	r18, 0x00	; 0
    1daa:	30 e0       	ldi	r19, 0x00	; 0
    1dac:	48 ec       	ldi	r20, 0xC8	; 200
    1dae:	52 e4       	ldi	r21, 0x42	; 66
    1db0:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1db4:	20 e0       	ldi	r18, 0x00	; 0
    1db6:	30 e0       	ldi	r19, 0x00	; 0
    1db8:	4f e7       	ldi	r20, 0x7F	; 127
    1dba:	53 e4       	ldi	r21, 0x43	; 67
    1dbc:	0e 94 7a 28 	call	0x50f4	; 0x50f4 <__mulsf3>
    1dc0:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <__fixunssfsi>
    1dc4:	dc 01       	movw	r26, r24
    1dc6:	cb 01       	movw	r24, r22
			OCR1A=pwm_time_on;
    1dc8:	9b bd       	out	0x2b, r25	; 43
    1dca:	8a bd       	out	0x2a, r24	; 42
			OCR1B=pwm_time_on;
    1dcc:	99 bd       	out	0x29, r25	; 41
    1dce:	88 bd       	out	0x28, r24	; 40
			Ret=E_OK;
    1dd0:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1dd2:	17 c0       	rjmp	.+46     	; 0x1e02 <Pwm_Start+0x37a>
			}
			case PWM_CH2:{
			pwm_time_on=MAX_HOLD;	
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1dd4:	70 e0       	ldi	r23, 0x00	; 0
    1dd6:	80 e0       	ldi	r24, 0x00	; 0
    1dd8:	90 e0       	ldi	r25, 0x00	; 0
    1dda:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <__floatunsisf>
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	30 e0       	ldi	r19, 0x00	; 0
    1de2:	48 ec       	ldi	r20, 0xC8	; 200
    1de4:	52 e4       	ldi	r21, 0x42	; 66
    1de6:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	4f e7       	ldi	r20, 0x7F	; 127
    1df0:	53 e4       	ldi	r21, 0x43	; 67
    1df2:	0e 94 7a 28 	call	0x50f4	; 0x50f4 <__mulsf3>
    1df6:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <__fixunssfsi>
			OCR2=pwm_time_on;
    1dfa:	63 bd       	out	0x23, r22	; 35
			Ret=E_OK;
    1dfc:	80 e0       	ldi	r24, 0x00	; 0
			}			
			break;
    1dfe:	01 c0       	rjmp	.+2      	; 0x1e02 <Pwm_Start+0x37a>
			default:
			Ret=E_NOK;
    1e00:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
sgl_is_started=1;
    1e02:	91 e0       	ldi	r25, 0x01	; 1
    1e04:	90 93 0d 01 	sts	0x010D, r25
return Ret;
}
    1e08:	1f 91       	pop	r17
    1e0a:	0f 91       	pop	r16
    1e0c:	ff 90       	pop	r15
    1e0e:	ef 90       	pop	r14
    1e10:	df 90       	pop	r13
    1e12:	cf 90       	pop	r12
    1e14:	08 95       	ret

00001e16 <Pwm_Update>:


ERROR_STATUS Pwm_Update(uint8_t Channel,uint8_t Duty,uint32_t Frequncy)
{
uint8_t Ret=0;
if (sgl_is_started == 1)
    1e16:	90 91 0d 01 	lds	r25, 0x010D
    1e1a:	91 30       	cpi	r25, 0x01	; 1
    1e1c:	21 f4       	brne	.+8      	; 0x1e26 <Pwm_Update+0x10>
{
	Pwm_Start( Channel,Duty,Frequncy);
    1e1e:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <Pwm_Start>
Ret=E_OK;
    1e22:	80 e0       	ldi	r24, 0x00	; 0
    1e24:	08 95       	ret
}else{Ret=E_NOK;}
    1e26:	81 e0       	ldi	r24, 0x01	; 1
	

return Ret;
}
    1e28:	08 95       	ret

00001e2a <Pwm_Stop>:
/*********************************************************************************/

ERROR_STATUS Pwm_Stop(uint8_t Channel)
{
uint8_t Ret=0;
switch(Channel)
    1e2a:	83 30       	cpi	r24, 0x03	; 3
    1e2c:	18 f4       	brcc	.+6      	; 0x1e34 <Pwm_Stop+0xa>
    1e2e:	81 30       	cpi	r24, 0x01	; 1
    1e30:	48 f4       	brcc	.+18     	; 0x1e44 <Pwm_Stop+0x1a>
    1e32:	03 c0       	rjmp	.+6      	; 0x1e3a <Pwm_Stop+0x10>
    1e34:	83 30       	cpi	r24, 0x03	; 3
    1e36:	81 f4       	brne	.+32     	; 0x1e58 <Pwm_Stop+0x2e>
    1e38:	0a c0       	rjmp	.+20     	; 0x1e4e <Pwm_Stop+0x24>
{
	case PWM_CH0:
	TCCR0 &=TIMER_STOPT02;
    1e3a:	83 b7       	in	r24, 0x33	; 51
    1e3c:	88 7f       	andi	r24, 0xF8	; 248
    1e3e:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
    1e40:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1e42:	08 95       	ret

	case PWM_CH1A:
	case PWM_CH1B:
	TCCR0 &=TIMER_STOPT1;
    1e44:	83 b7       	in	r24, 0x33	; 51
    1e46:	88 7f       	andi	r24, 0xF8	; 248
    1e48:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
    1e4a:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1e4c:	08 95       	ret


	case PWM_CH2:
	TCCR2 &=TIMER_STOPT02;
    1e4e:	85 b5       	in	r24, 0x25	; 37
    1e50:	88 7f       	andi	r24, 0xF8	; 248
    1e52:	85 bd       	out	0x25, r24	; 37
	Ret=E_OK;
    1e54:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1e56:	08 95       	ret
	default:
	Ret=E_NOK;
    1e58:	81 e0       	ldi	r24, 0x01	; 1
	break;
}

return Ret;
}
    1e5a:	08 95       	ret

00001e5c <Timer_Init>:
 *
 */
 static uint8_t prescaler_value=0;
 
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{uint8_t Ret=E_OK;
    1e5c:	1f 93       	push	r17
    1e5e:	cf 93       	push	r28
    1e60:	df 93       	push	r29
    1e62:	ec 01       	movw	r28, r24
prescaler_value=Timer_cfg->Timer_Prescaler;
    1e64:	8b 81       	ldd	r24, Y+3	; 0x03
    1e66:	80 93 0e 01 	sts	0x010E, r24
if (Timer_cfg==NULL)
    1e6a:	20 97       	sbiw	r28, 0x00	; 0
    1e6c:	11 f0       	breq	.+4      	; 0x1e72 <Timer_Init+0x16>
 *
 */
 static uint8_t prescaler_value=0;
 
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{uint8_t Ret=E_OK;
    1e6e:	10 e0       	ldi	r17, 0x00	; 0
    1e70:	01 c0       	rjmp	.+2      	; 0x1e74 <Timer_Init+0x18>
prescaler_value=Timer_cfg->Timer_Prescaler;
if (Timer_cfg==NULL)
{
	Ret=TIMER_MODULE+NULL_PTR;
    1e72:	10 e2       	ldi	r17, 0x20	; 32
}
switch (Timer_cfg->Timer_CH_NO) {
    1e74:	88 81       	ld	r24, Y
    1e76:	81 30       	cpi	r24, 0x01	; 1
    1e78:	09 f4       	brne	.+2      	; 0x1e7c <Timer_Init+0x20>
    1e7a:	4c c0       	rjmp	.+152    	; 0x1f14 <Timer_Init+0xb8>
    1e7c:	81 30       	cpi	r24, 0x01	; 1
    1e7e:	20 f0       	brcs	.+8      	; 0x1e88 <Timer_Init+0x2c>
    1e80:	82 30       	cpi	r24, 0x02	; 2
    1e82:	09 f0       	breq	.+2      	; 0x1e86 <Timer_Init+0x2a>
    1e84:	d8 c0       	rjmp	.+432    	; 0x2036 <Timer_Init+0x1da>
    1e86:	93 c0       	rjmp	.+294    	; 0x1fae <Timer_Init+0x152>
/*************************************************************************/
/*                             TIMER 0                                   */
/*************************************************************************/
    case TIMER_CH0:
        {
  TCCR0 |=T0_NORMAL_MODE;
    1e88:	83 b7       	in	r24, 0x33	; 51
    1e8a:	83 bf       	out	0x33, r24	; 51
  
          switch (Timer_cfg->Timer_Mode) {
    1e8c:	89 81       	ldd	r24, Y+1	; 0x01
    1e8e:	81 30       	cpi	r24, 0x01	; 1
    1e90:	b9 f0       	breq	.+46     	; 0x1ec0 <Timer_Init+0x64>
    1e92:	81 30       	cpi	r24, 0x01	; 1
    1e94:	18 f0       	brcs	.+6      	; 0x1e9c <Timer_Init+0x40>
    1e96:	82 30       	cpi	r24, 0x02	; 2
    1e98:	e1 f5       	brne	.+120    	; 0x1f12 <Timer_Init+0xb6>
    1e9a:	26 c0       	rjmp	.+76     	; 0x1ee8 <Timer_Init+0x8c>
          case TIMER_MODE:
              {
                switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    1e9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e9e:	88 23       	and	r24, r24
    1ea0:	19 f0       	breq	.+6      	; 0x1ea8 <Timer_Init+0x4c>
    1ea2:	81 30       	cpi	r24, 0x01	; 1
    1ea4:	59 f4       	brne	.+22     	; 0x1ebc <Timer_Init+0x60>
    1ea6:	04 c0       	rjmp	.+8      	; 0x1eb0 <Timer_Init+0x54>
				{
                    case TIMER_POLLING_MODE:
                        {/*Disable interrupts for T0 without effecting any other timer*/
                         /*without Disabling Global interrupt*/
                        TIMSK &=T0_INTERRUPT_DISABLE;
    1ea8:	89 b7       	in	r24, 0x39	; 57
    1eaa:	8c 7f       	andi	r24, 0xFC	; 252
    1eac:	89 bf       	out	0x39, r24	; 57
                            break;
    1eae:	32 c0       	rjmp	.+100    	; 0x1f14 <Timer_Init+0xb8>
                         }
                                  case TIMER_INTERRUPT_MODE:
                                  { /*Enable Global INTERRUPT
                                    Enable Timer0 interrupt
                                    */
                                    G_interrupt_Enable();
    1eb0:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                                    TIMSK |= T0_INTERRUPT_NORMAL;
    1eb4:	89 b7       	in	r24, 0x39	; 57
    1eb6:	81 60       	ori	r24, 0x01	; 1
    1eb8:	89 bf       	out	0x39, r24	; 57
                                    break;
    1eba:	2c c0       	rjmp	.+88     	; 0x1f14 <Timer_Init+0xb8>
                                  }
                                  default :
                                  Ret+=E_NOK;
    1ebc:	1f 5f       	subi	r17, 0xFF	; 255
								  break;
    1ebe:	2a c0       	rjmp	.+84     	; 0x1f14 <Timer_Init+0xb8>
/*                             TIMER 0 As a COUNTER_RISING_MODE          */
/*************************************************************************/

                          case COUNTER_RISING_MODE:
                            {
                                  TCCR0 |=T0_COUNTER_RISING_MODE_CONFIG;
    1ec0:	83 b7       	in	r24, 0x33	; 51
    1ec2:	8d 60       	ori	r24, 0x0D	; 13
    1ec4:	83 bf       	out	0x33, r24	; 51
                                    switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1ec6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec8:	88 23       	and	r24, r24
    1eca:	19 f0       	breq	.+6      	; 0x1ed2 <Timer_Init+0x76>
    1ecc:	81 30       	cpi	r24, 0x01	; 1
    1ece:	59 f4       	brne	.+22     	; 0x1ee6 <Timer_Init+0x8a>
    1ed0:	04 c0       	rjmp	.+8      	; 0x1eda <Timer_Init+0x7e>
                                        case TIMER_POLLING_MODE:
                                          {
            /*Disable interrupts for T0 without effecting any other timer*/
              /*without Disabling Global interrupt*/
                                            TIMSK &=T0_INTERRUPT_DISABLE;
    1ed2:	89 b7       	in	r24, 0x39	; 57
    1ed4:	8c 7f       	andi	r24, 0xFC	; 252
    1ed6:	89 bf       	out	0x39, r24	; 57
                                            break;
    1ed8:	07 c0       	rjmp	.+14     	; 0x1ee8 <Timer_Init+0x8c>

                                          case TIMER_INTERRUPT_MODE:
                                           /*Enable Global INTERRUPT
                                              Enable Timer0 interrupt
                                              */
                                              G_interrupt_Enable();
    1eda:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                                              TIMSK |= T0_INTERRUPT_NORMAL;
    1ede:	89 b7       	in	r24, 0x39	; 57
    1ee0:	81 60       	ori	r24, 0x01	; 1
    1ee2:	89 bf       	out	0x39, r24	; 57
                                              break;
    1ee4:	01 c0       	rjmp	.+2      	; 0x1ee8 <Timer_Init+0x8c>

                                          default :
                                          Ret+=E_NOK;
    1ee6:	1f 5f       	subi	r17, 0xFF	; 255
/*                             TIMER 0 As a COUNTER_FALLING_MODE         */
/*************************************************************************/

                                    case COUNTER_FALLING_MODE:
                                    {
                                        TCCR0 |=T0_COUNTER_FALLING_MODE_CONFIG;
    1ee8:	83 b7       	in	r24, 0x33	; 51
    1eea:	8c 60       	ori	r24, 0x0C	; 12
    1eec:	83 bf       	out	0x33, r24	; 51
                                          switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1eee:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef0:	88 23       	and	r24, r24
    1ef2:	19 f0       	breq	.+6      	; 0x1efa <Timer_Init+0x9e>
    1ef4:	81 30       	cpi	r24, 0x01	; 1
    1ef6:	59 f4       	brne	.+22     	; 0x1f0e <Timer_Init+0xb2>
    1ef8:	04 c0       	rjmp	.+8      	; 0x1f02 <Timer_Init+0xa6>
                                              case TIMER_POLLING_MODE:
                                                {

            /*Disable interrupts for T0 without effecting any other timer*/
                /*without Disabling Global interrupt*/
                                                  TIMSK &=T0_INTERRUPT_DISABLE;
    1efa:	89 b7       	in	r24, 0x39	; 57
    1efc:	8c 7f       	andi	r24, 0xFC	; 252
    1efe:	89 bf       	out	0x39, r24	; 57

                                                  break;
    1f00:	09 c0       	rjmp	.+18     	; 0x1f14 <Timer_Init+0xb8>
                                                case TIMER_INTERRUPT_MODE:
                                                  {
                                                    /*Enable Global INTERRUPT
                                                    Enable Timer0 interrupt
                                                    */
                                                    G_interrupt_Enable();
    1f02:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                                                    TIMSK |= T0_INTERRUPT_NORMAL;
    1f06:	89 b7       	in	r24, 0x39	; 57
    1f08:	81 60       	ori	r24, 0x01	; 1
    1f0a:	89 bf       	out	0x39, r24	; 57

                                                    break;
    1f0c:	03 c0       	rjmp	.+6      	; 0x1f14 <Timer_Init+0xb8>
                                                  }
                                                  default:
                                                  Ret+=E_NOK;
    1f0e:	1f 5f       	subi	r17, 0xFF	; 255
												  break;
    1f10:	01 c0       	rjmp	.+2      	; 0x1f14 <Timer_Init+0xb8>
                                                }
                                      break;
                                      }
                                      default:
                                      Ret+=E_NOK;
    1f12:	1f 5f       	subi	r17, 0xFF	; 255
/*************************************************************************/

    case TIMER_CH1:
        {

    switch (Timer_cfg->Timer_Mode)
    1f14:	89 81       	ldd	r24, Y+1	; 0x01
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	d1 f0       	breq	.+52     	; 0x1f4e <Timer_Init+0xf2>
    1f1a:	81 30       	cpi	r24, 0x01	; 1
    1f1c:	20 f0       	brcs	.+8      	; 0x1f26 <Timer_Init+0xca>
    1f1e:	82 30       	cpi	r24, 0x02	; 2
    1f20:	09 f0       	breq	.+2      	; 0x1f24 <Timer_Init+0xc8>
    1f22:	43 c0       	rjmp	.+134    	; 0x1faa <Timer_Init+0x14e>
    1f24:	2b c0       	rjmp	.+86     	; 0x1f7c <Timer_Init+0x120>
    {
      case TIMER_MODE:
      {
        TCCR1 = T1_NORMAL_MODE_CONFIG;
    1f26:	1f bc       	out	0x2f, r1	; 47
    1f28:	1e bc       	out	0x2e, r1	; 46
              switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1f2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f2c:	88 23       	and	r24, r24
    1f2e:	19 f0       	breq	.+6      	; 0x1f36 <Timer_Init+0xda>
    1f30:	81 30       	cpi	r24, 0x01	; 1
    1f32:	59 f4       	brne	.+22     	; 0x1f4a <Timer_Init+0xee>
    1f34:	04 c0       	rjmp	.+8      	; 0x1f3e <Timer_Init+0xe2>
              case TIMER_POLLING_MODE:
                {
                  /*Disable interrupts for T1 without effecting any other timer*/
                   /*without Disabling Global interrupt*/
                  TIMSK &=T1_INTERRUPT_DISABLE;
    1f36:	89 b7       	in	r24, 0x39	; 57
    1f38:	83 7c       	andi	r24, 0xC3	; 195
    1f3a:	89 bf       	out	0x39, r24	; 57

                break;
    1f3c:	7c c0       	rjmp	.+248    	; 0x2036 <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    1f3e:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    1f42:	89 b7       	in	r24, 0x39	; 57
    1f44:	84 60       	ori	r24, 0x04	; 4
    1f46:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */
                break;
    1f48:	76 c0       	rjmp	.+236    	; 0x2036 <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    1f4a:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    1f4c:	74 c0       	rjmp	.+232    	; 0x2036 <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_RISING_MODE:
      {
            TCCR1|=T1_COUNTER_RISING_MODE_CONFIG;
    1f4e:	8e b5       	in	r24, 0x2e	; 46
    1f50:	9f b5       	in	r25, 0x2f	; 47
    1f52:	87 60       	ori	r24, 0x07	; 7
    1f54:	9f bd       	out	0x2f, r25	; 47
    1f56:	8e bd       	out	0x2e, r24	; 46

            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1f58:	8a 81       	ldd	r24, Y+2	; 0x02
    1f5a:	88 23       	and	r24, r24
    1f5c:	19 f0       	breq	.+6      	; 0x1f64 <Timer_Init+0x108>
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	59 f4       	brne	.+22     	; 0x1f78 <Timer_Init+0x11c>
    1f62:	04 c0       	rjmp	.+8      	; 0x1f6c <Timer_Init+0x110>
              case TIMER_POLLING_MODE:
              {
                /*Disable interrupts for T1 without effecting any other timer*/
                 /*without Disabling Global interrupt*/
                TIMSK &=T1_INTERRUPT_DISABLE;
    1f64:	89 b7       	in	r24, 0x39	; 57
    1f66:	83 7c       	andi	r24, 0xC3	; 195
    1f68:	89 bf       	out	0x39, r24	; 57

                break;
    1f6a:	65 c0       	rjmp	.+202    	; 0x2036 <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    1f6c:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    1f70:	89 b7       	in	r24, 0x39	; 57
    1f72:	84 60       	ori	r24, 0x04	; 4
    1f74:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */
                break;
    1f76:	5f c0       	rjmp	.+190    	; 0x2036 <Timer_Init+0x1da>
              }
              default:
              Ret+=E_NOK;
    1f78:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    1f7a:	5d c0       	rjmp	.+186    	; 0x2036 <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_FALLING_MODE:
      {
            TCCR1|=T1_COUNTER_FALLING_MODE_CONFIG;
    1f7c:	8e b5       	in	r24, 0x2e	; 46
    1f7e:	9f b5       	in	r25, 0x2f	; 47
    1f80:	86 60       	ori	r24, 0x06	; 6
    1f82:	9f bd       	out	0x2f, r25	; 47
    1f84:	8e bd       	out	0x2e, r24	; 46
            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1f86:	8a 81       	ldd	r24, Y+2	; 0x02
    1f88:	88 23       	and	r24, r24
    1f8a:	19 f0       	breq	.+6      	; 0x1f92 <Timer_Init+0x136>
    1f8c:	81 30       	cpi	r24, 0x01	; 1
    1f8e:	59 f4       	brne	.+22     	; 0x1fa6 <Timer_Init+0x14a>
    1f90:	04 c0       	rjmp	.+8      	; 0x1f9a <Timer_Init+0x13e>
              case TIMER_POLLING_MODE:
              {
                /*Disable interrupts for T1 without effecting any other timer*/
                 /*without Disabling Global interrupt*/
                TIMSK &=T1_INTERRUPT_DISABLE;
    1f92:	89 b7       	in	r24, 0x39	; 57
    1f94:	83 7c       	andi	r24, 0xC3	; 195
    1f96:	89 bf       	out	0x39, r24	; 57
                break;
    1f98:	4e c0       	rjmp	.+156    	; 0x2036 <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    1f9a:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    1f9e:	89 b7       	in	r24, 0x39	; 57
    1fa0:	84 60       	ori	r24, 0x04	; 4
    1fa2:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */

                break;
    1fa4:	48 c0       	rjmp	.+144    	; 0x2036 <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    1fa6:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    1fa8:	46 c0       	rjmp	.+140    	; 0x2036 <Timer_Init+0x1da>
            }
      break;
      }
      default :
      Ret+=E_NOK;
    1faa:	1f 5f       	subi	r17, 0xFF	; 255
    break;
    1fac:	44 c0       	rjmp	.+136    	; 0x2036 <Timer_Init+0x1da>
  /*                             TIMER 2                                   */
  /*************************************************************************/

  case TIMER_CH2:
  {
TCCR2 |=T2_NORMAL_MODE_CONFIG;
    1fae:	85 b5       	in	r24, 0x25	; 37
    1fb0:	85 bd       	out	0x25, r24	; 37
    switch (Timer_cfg->Timer_Mode) {
    1fb2:	89 81       	ldd	r24, Y+1	; 0x01
    1fb4:	88 23       	and	r24, r24
    1fb6:	19 f0       	breq	.+6      	; 0x1fbe <Timer_Init+0x162>
    1fb8:	81 30       	cpi	r24, 0x01	; 1
    1fba:	e1 f5       	brne	.+120    	; 0x2034 <Timer_Init+0x1d8>
    1fbc:	12 c0       	rjmp	.+36     	; 0x1fe2 <Timer_Init+0x186>
      case TIMER_MODE:
      {
            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc0:	88 23       	and	r24, r24
    1fc2:	19 f0       	breq	.+6      	; 0x1fca <Timer_Init+0x16e>
    1fc4:	81 30       	cpi	r24, 0x01	; 1
    1fc6:	59 f4       	brne	.+22     	; 0x1fde <Timer_Init+0x182>
    1fc8:	04 c0       	rjmp	.+8      	; 0x1fd2 <Timer_Init+0x176>
              case TIMER_POLLING_MODE:
              {
                  TIMSK &= T2_INTERRUPT_DISABLE;
    1fca:	89 b7       	in	r24, 0x39	; 57
    1fcc:	8f 73       	andi	r24, 0x3F	; 63
    1fce:	89 bf       	out	0x39, r24	; 57
                break;
    1fd0:	32 c0       	rjmp	.+100    	; 0x2036 <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    1fd2:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                  TIMSK|=T2_INTERRUPT_NORMAL;
    1fd6:	89 b7       	in	r24, 0x39	; 57
    1fd8:	80 6c       	ori	r24, 0xC0	; 192
    1fda:	89 bf       	out	0x39, r24	; 57

                break;
    1fdc:	2c c0       	rjmp	.+88     	; 0x2036 <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    1fde:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    1fe0:	2a c0       	rjmp	.+84     	; 0x2036 <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_RISING_MODE:
      {
          ASSR |=0x08;
    1fe2:	82 b5       	in	r24, 0x22	; 34
    1fe4:	88 60       	ori	r24, 0x08	; 8
    1fe6:	82 bd       	out	0x22, r24	; 34
            switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    1fe8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fea:	81 30       	cpi	r24, 0x01	; 1
    1fec:	49 f0       	breq	.+18     	; 0x2000 <Timer_Init+0x1a4>
    1fee:	81 30       	cpi	r24, 0x01	; 1
    1ff0:	18 f0       	brcs	.+6      	; 0x1ff8 <Timer_Init+0x19c>
    1ff2:	82 30       	cpi	r24, 0x02	; 2
    1ff4:	f9 f4       	brne	.+62     	; 0x2034 <Timer_Init+0x1d8>
    1ff6:	0a c0       	rjmp	.+20     	; 0x200c <Timer_Init+0x1b0>
            {
              case TIMER_POLLING_MODE:
              {
                TIMSK &= T2_INTERRUPT_DISABLE;
    1ff8:	89 b7       	in	r24, 0x39	; 57
    1ffa:	8f 73       	andi	r24, 0x3F	; 63
    1ffc:	89 bf       	out	0x39, r24	; 57

                break;
    1ffe:	1a c0       	rjmp	.+52     	; 0x2034 <Timer_Init+0x1d8>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2000:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                  TIMSK|=T2_INTERRUPT_NORMAL;
    2004:	89 b7       	in	r24, 0x39	; 57
    2006:	80 6c       	ori	r24, 0xC0	; 192
    2008:	89 bf       	out	0x39, r24	; 57
                break;
    200a:	14 c0       	rjmp	.+40     	; 0x2034 <Timer_Init+0x1d8>
              }
              case COUNTER_FALLING_MODE:
              {
                  ASSR |=0x08;
    200c:	82 b5       	in	r24, 0x22	; 34
    200e:	88 60       	ori	r24, 0x08	; 8
    2010:	82 bd       	out	0x22, r24	; 34
                    switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    2012:	8a 81       	ldd	r24, Y+2	; 0x02
    2014:	88 23       	and	r24, r24
    2016:	19 f0       	breq	.+6      	; 0x201e <Timer_Init+0x1c2>
    2018:	81 30       	cpi	r24, 0x01	; 1
    201a:	59 f4       	brne	.+22     	; 0x2032 <Timer_Init+0x1d6>
    201c:	04 c0       	rjmp	.+8      	; 0x2026 <Timer_Init+0x1ca>
                    {
                      case TIMER_POLLING_MODE:
                      {
                        TIMSK &= T2_INTERRUPT_DISABLE;
    201e:	89 b7       	in	r24, 0x39	; 57
    2020:	8f 73       	andi	r24, 0x3F	; 63
    2022:	89 bf       	out	0x39, r24	; 57

                        break;
    2024:	07 c0       	rjmp	.+14     	; 0x2034 <Timer_Init+0x1d8>
                      }
                      case TIMER_INTERRUPT_MODE:
                      {
                        G_interrupt_Enable();
    2026:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
                          TIMSK|=T2_INTERRUPT_NORMAL;
    202a:	89 b7       	in	r24, 0x39	; 57
    202c:	80 6c       	ori	r24, 0xC0	; 192
    202e:	89 bf       	out	0x39, r24	; 57
                        break;
    2030:	01 c0       	rjmp	.+2      	; 0x2034 <Timer_Init+0x1d8>
                      }

              default :
              Ret+=E_NOK;
    2032:	1f 5f       	subi	r17, 0xFF	; 255
            }
        break;
            }
            }
  default:
  Ret+=E_NOK;
    2034:	1f 5f       	subi	r17, 0xFF	; 255
}
 }

}
return Ret;
}
    2036:	81 2f       	mov	r24, r17
    2038:	df 91       	pop	r29
    203a:	cf 91       	pop	r28
    203c:	1f 91       	pop	r17
    203e:	08 95       	ret

00002040 <Timer_Start>:
 * Description: This function strats the needed timer.
 *
 */
ERROR_STATUS Timer_Start(uint8_t Timer_CH_NO, uint16_t Timer_Count){
uint8_t Ret;
switch (Timer_CH_NO) {
    2040:	81 30       	cpi	r24, 0x01	; 1
    2042:	09 f4       	brne	.+2      	; 0x2046 <Timer_Start+0x6>
    2044:	4f c0       	rjmp	.+158    	; 0x20e4 <Timer_Start+0xa4>
    2046:	81 30       	cpi	r24, 0x01	; 1
    2048:	20 f0       	brcs	.+8      	; 0x2052 <Timer_Start+0x12>
    204a:	82 30       	cpi	r24, 0x02	; 2
    204c:	09 f0       	breq	.+2      	; 0x2050 <Timer_Start+0x10>
    204e:	f3 c0       	rjmp	.+486    	; 0x2236 <Timer_Start+0x1f6>
    2050:	97 c0       	rjmp	.+302    	; 0x2180 <Timer_Start+0x140>
case TIMER_CH0:{
/***********************************************************************************************************************/
switch(prescaler_value){
    2052:	80 91 0e 01 	lds	r24, 0x010E
    2056:	84 30       	cpi	r24, 0x04	; 4
    2058:	21 f1       	breq	.+72     	; 0x20a2 <Timer_Start+0x62>
    205a:	85 30       	cpi	r24, 0x05	; 5
    205c:	30 f4       	brcc	.+12     	; 0x206a <Timer_Start+0x2a>
    205e:	81 30       	cpi	r24, 0x01	; 1
    2060:	51 f0       	breq	.+20     	; 0x2076 <Timer_Start+0x36>
    2062:	82 30       	cpi	r24, 0x02	; 2
    2064:	09 f0       	breq	.+2      	; 0x2068 <Timer_Start+0x28>
    2066:	e9 c0       	rjmp	.+466    	; 0x223a <Timer_Start+0x1fa>
    2068:	11 c0       	rjmp	.+34     	; 0x208c <Timer_Start+0x4c>
    206a:	86 30       	cpi	r24, 0x06	; 6
    206c:	29 f1       	breq	.+74     	; 0x20b8 <Timer_Start+0x78>
    206e:	87 30       	cpi	r24, 0x07	; 7
    2070:	09 f0       	breq	.+2      	; 0x2074 <Timer_Start+0x34>
    2072:	e3 c0       	rjmp	.+454    	; 0x223a <Timer_Start+0x1fa>
    2074:	2c c0       	rjmp	.+88     	; 0x20ce <Timer_Start+0x8e>
case TIMER_PRESCALER_NO :{
if(Timer_Count < MAX0){
    2076:	6f 3f       	cpi	r22, 0xFF	; 255
    2078:	71 05       	cpc	r23, r1
    207a:	08 f0       	brcs	.+2      	; 0x207e <Timer_Start+0x3e>
    207c:	e0 c0       	rjmp	.+448    	; 0x223e <Timer_Start+0x1fe>
TCCR0 |=TIMER_PRESCALER_NO;
    207e:	83 b7       	in	r24, 0x33	; 51
    2080:	81 60       	ori	r24, 0x01	; 1
    2082:	83 bf       	out	0x33, r24	; 51
TCNT0 =	MAX0 - Timer_Count;
    2084:	60 95       	com	r22
    2086:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2088:	80 e0       	ldi	r24, 0x00	; 0
    208a:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_8 :{
if(Timer_Count < MAX0){
    208c:	6f 3f       	cpi	r22, 0xFF	; 255
    208e:	71 05       	cpc	r23, r1
    2090:	08 f0       	brcs	.+2      	; 0x2094 <Timer_Start+0x54>
    2092:	d7 c0       	rjmp	.+430    	; 0x2242 <Timer_Start+0x202>
TCCR0 |=TIMER0_PRESCALER_8_CONFIG;
    2094:	83 b7       	in	r24, 0x33	; 51
    2096:	82 60       	ori	r24, 0x02	; 2
    2098:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    209a:	60 95       	com	r22
    209c:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    209e:	80 e0       	ldi	r24, 0x00	; 0
    20a0:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_64 :{
if(Timer_Count < MAX0){
    20a2:	6f 3f       	cpi	r22, 0xFF	; 255
    20a4:	71 05       	cpc	r23, r1
    20a6:	08 f0       	brcs	.+2      	; 0x20aa <Timer_Start+0x6a>
    20a8:	ce c0       	rjmp	.+412    	; 0x2246 <Timer_Start+0x206>
TCCR0 |=TIMER0_PRESCALER_64_CONFIG;
    20aa:	83 b7       	in	r24, 0x33	; 51
    20ac:	83 60       	ori	r24, 0x03	; 3
    20ae:	83 bf       	out	0x33, r24	; 51
TCNT0 = MAX0 - Timer_Count;
    20b0:	60 95       	com	r22
    20b2:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    20b4:	80 e0       	ldi	r24, 0x00	; 0
    20b6:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_256 :{
if(Timer_Count < MAX0){
    20b8:	6f 3f       	cpi	r22, 0xFF	; 255
    20ba:	71 05       	cpc	r23, r1
    20bc:	08 f0       	brcs	.+2      	; 0x20c0 <Timer_Start+0x80>
    20be:	c5 c0       	rjmp	.+394    	; 0x224a <Timer_Start+0x20a>
TCCR0 |=TIMER0_PRESCALER_256_CONFIG;
    20c0:	83 b7       	in	r24, 0x33	; 51
    20c2:	84 60       	ori	r24, 0x04	; 4
    20c4:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    20c6:	60 95       	com	r22
    20c8:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    20ca:	80 e0       	ldi	r24, 0x00	; 0
    20cc:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_1024 :{
if(Timer_Count < MAX0){
    20ce:	6f 3f       	cpi	r22, 0xFF	; 255
    20d0:	71 05       	cpc	r23, r1
    20d2:	08 f0       	brcs	.+2      	; 0x20d6 <Timer_Start+0x96>
    20d4:	bc c0       	rjmp	.+376    	; 0x224e <Timer_Start+0x20e>
TCCR0 |=TIMER0_PRESCALER_1024_CONFIG;
    20d6:	83 b7       	in	r24, 0x33	; 51
    20d8:	85 60       	ori	r24, 0x05	; 5
    20da:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    20dc:	60 95       	com	r22
    20de:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    20e0:	80 e0       	ldi	r24, 0x00	; 0
    20e2:	08 95       	ret
break;
}
case TIMER_CH1:{

  switch(prescaler_value){
    20e4:	80 91 0e 01 	lds	r24, 0x010E
    20e8:	84 30       	cpi	r24, 0x04	; 4
    20ea:	31 f1       	breq	.+76     	; 0x2138 <Timer_Start+0xf8>
    20ec:	85 30       	cpi	r24, 0x05	; 5
    20ee:	30 f4       	brcc	.+12     	; 0x20fc <Timer_Start+0xbc>
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	51 f0       	breq	.+20     	; 0x2108 <Timer_Start+0xc8>
    20f4:	82 30       	cpi	r24, 0x02	; 2
    20f6:	09 f0       	breq	.+2      	; 0x20fa <Timer_Start+0xba>
    20f8:	ac c0       	rjmp	.+344    	; 0x2252 <Timer_Start+0x212>
    20fa:	12 c0       	rjmp	.+36     	; 0x2120 <Timer_Start+0xe0>
    20fc:	86 30       	cpi	r24, 0x06	; 6
    20fe:	41 f1       	breq	.+80     	; 0x2150 <Timer_Start+0x110>
    2100:	87 30       	cpi	r24, 0x07	; 7
    2102:	09 f0       	breq	.+2      	; 0x2106 <Timer_Start+0xc6>
    2104:	a6 c0       	rjmp	.+332    	; 0x2252 <Timer_Start+0x212>
    2106:	30 c0       	rjmp	.+96     	; 0x2168 <Timer_Start+0x128>
  case TIMER_PRESCALER_NO :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER_PRESCALER_NO;
    2108:	8e b5       	in	r24, 0x2e	; 46
    210a:	9f b5       	in	r25, 0x2f	; 47
    210c:	81 60       	ori	r24, 0x01	; 1
    210e:	9f bd       	out	0x2f, r25	; 47
    2110:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2112:	70 95       	com	r23
    2114:	61 95       	neg	r22
    2116:	7f 4f       	sbci	r23, 0xFF	; 255
    2118:	7d bd       	out	0x2d, r23	; 45
    211a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    211c:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret=E_NOK;
  }
  break;
    211e:	08 95       	ret
  }
  case TIMER_PRESCALER_8 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_8_CONFIG;
    2120:	8e b5       	in	r24, 0x2e	; 46
    2122:	9f b5       	in	r25, 0x2f	; 47
    2124:	82 60       	ori	r24, 0x02	; 2
    2126:	9f bd       	out	0x2f, r25	; 47
    2128:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    212a:	70 95       	com	r23
    212c:	61 95       	neg	r22
    212e:	7f 4f       	sbci	r23, 0xFF	; 255
    2130:	7d bd       	out	0x2d, r23	; 45
    2132:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2134:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret= E_NOK;
  }
  break;
    2136:	08 95       	ret
  }
  case TIMER_PRESCALER_64 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_64_CONFIG;
    2138:	8e b5       	in	r24, 0x2e	; 46
    213a:	9f b5       	in	r25, 0x2f	; 47
    213c:	83 60       	ori	r24, 0x03	; 3
    213e:	9f bd       	out	0x2f, r25	; 47
    2140:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2142:	70 95       	com	r23
    2144:	61 95       	neg	r22
    2146:	7f 4f       	sbci	r23, 0xFF	; 255
    2148:	7d bd       	out	0x2d, r23	; 45
    214a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    214c:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret= E_NOK;
  }
  break;
    214e:	08 95       	ret
  }
  case TIMER_PRESCALER_256 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_256_CONFIG;
    2150:	8e b5       	in	r24, 0x2e	; 46
    2152:	9f b5       	in	r25, 0x2f	; 47
    2154:	84 60       	ori	r24, 0x04	; 4
    2156:	9f bd       	out	0x2f, r25	; 47
    2158:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    215a:	70 95       	com	r23
    215c:	61 95       	neg	r22
    215e:	7f 4f       	sbci	r23, 0xFF	; 255
    2160:	7d bd       	out	0x2d, r23	; 45
    2162:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2164:	80 e0       	ldi	r24, 0x00	; 0
  }else
  {
  Ret= E_NOK;

  }
  break;
    2166:	08 95       	ret
  }
  case TIMER_PRESCALER_1024 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_1024_CONFIG;
    2168:	8e b5       	in	r24, 0x2e	; 46
    216a:	9f b5       	in	r25, 0x2f	; 47
    216c:	85 60       	ori	r24, 0x05	; 5
    216e:	9f bd       	out	0x2f, r25	; 47
    2170:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2172:	70 95       	com	r23
    2174:	61 95       	neg	r22
    2176:	7f 4f       	sbci	r23, 0xFF	; 255
    2178:	7d bd       	out	0x2d, r23	; 45
    217a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    217c:	80 e0       	ldi	r24, 0x00	; 0
  }else
  {
  Ret= E_NOK;

  }
  break;
    217e:	08 95       	ret
	break;
}
case TIMER_CH2:
	{
  
		switch(prescaler_value){
    2180:	80 91 0e 01 	lds	r24, 0x010E
    2184:	84 30       	cpi	r24, 0x04	; 4
    2186:	79 f1       	breq	.+94     	; 0x21e6 <Timer_Start+0x1a6>
    2188:	85 30       	cpi	r24, 0x05	; 5
    218a:	40 f4       	brcc	.+16     	; 0x219c <Timer_Start+0x15c>
    218c:	82 30       	cpi	r24, 0x02	; 2
    218e:	c9 f0       	breq	.+50     	; 0x21c2 <Timer_Start+0x182>
    2190:	83 30       	cpi	r24, 0x03	; 3
    2192:	10 f5       	brcc	.+68     	; 0x21d8 <Timer_Start+0x198>
    2194:	81 30       	cpi	r24, 0x01	; 1
    2196:	09 f0       	breq	.+2      	; 0x219a <Timer_Start+0x15a>
    2198:	5e c0       	rjmp	.+188    	; 0x2256 <Timer_Start+0x216>
    219a:	08 c0       	rjmp	.+16     	; 0x21ac <Timer_Start+0x16c>
    219c:	86 30       	cpi	r24, 0x06	; 6
    219e:	b9 f1       	breq	.+110    	; 0x220e <Timer_Start+0x1ce>
    21a0:	86 30       	cpi	r24, 0x06	; 6
    21a2:	58 f1       	brcs	.+86     	; 0x21fa <Timer_Start+0x1ba>
    21a4:	87 30       	cpi	r24, 0x07	; 7
    21a6:	09 f0       	breq	.+2      	; 0x21aa <Timer_Start+0x16a>
    21a8:	56 c0       	rjmp	.+172    	; 0x2256 <Timer_Start+0x216>
    21aa:	3b c0       	rjmp	.+118    	; 0x2222 <Timer_Start+0x1e2>
   
		  case TIMER_PRESCALER_NO :
			{
    
				if(Timer_Count < MAX0){
    21ac:	6f 3f       	cpi	r22, 0xFF	; 255
    21ae:	71 05       	cpc	r23, r1
    21b0:	08 f0       	brcs	.+2      	; 0x21b4 <Timer_Start+0x174>
    21b2:	53 c0       	rjmp	.+166    	; 0x225a <Timer_Start+0x21a>
     
			      TCCR2 |= TIMER_PRESCALER_NO;
    21b4:	85 b5       	in	r24, 0x25	; 37
    21b6:	81 60       	ori	r24, 0x01	; 1
    21b8:	85 bd       	out	0x25, r24	; 37
		      
				  TCNT2 = MAX2 - Timer_Count;
    21ba:	60 95       	com	r22
    21bc:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    21be:	80 e0       	ldi	r24, 0x00	; 0
    21c0:	08 95       	ret
			break;
			}

case TIMER_PRESCALER_8 :
  {
          if(Timer_Count < MAX0)
    21c2:	6f 3f       	cpi	r22, 0xFF	; 255
    21c4:	71 05       	cpc	r23, r1
    21c6:	08 f0       	brcs	.+2      	; 0x21ca <Timer_Start+0x18a>
    21c8:	4a c0       	rjmp	.+148    	; 0x225e <Timer_Start+0x21e>
            {
           TCCR2 |=TIMER_PRESCALER_8;
    21ca:	85 b5       	in	r24, 0x25	; 37
    21cc:	82 60       	ori	r24, 0x02	; 2
    21ce:	85 bd       	out	0x25, r24	; 37
           TCNT2 =MAX2 - Timer_Count;
    21d0:	60 95       	com	r22
    21d2:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    21d4:	80 e0       	ldi	r24, 0x00	; 0
    21d6:	08 95       	ret
  }
  case TIMER_PRESCALER_32:
  {
    if(Timer_Count < MAX1)
         {
         TCCR2 |=TIMER_PRESCALER_32;
    21d8:	85 b5       	in	r24, 0x25	; 37
    21da:	83 60       	ori	r24, 0x03	; 3
    21dc:	85 bd       	out	0x25, r24	; 37
         TCNT2 =MAX2 - Timer_Count;
    21de:	60 95       	com	r22
    21e0:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    21e2:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
    Ret=E_NOK;
  }

    break;
    21e4:	08 95       	ret
  }
  case TIMER_PRESCALER_64 :
  {
       if(Timer_Count < MAX2)
    21e6:	6f 3f       	cpi	r22, 0xFF	; 255
    21e8:	71 05       	cpc	r23, r1
    21ea:	d8 f5       	brcc	.+118    	; 0x2262 <Timer_Start+0x222>
       {
       TCCR2 |=TIMER_PRESCALER_64;
    21ec:	85 b5       	in	r24, 0x25	; 37
    21ee:	84 60       	ori	r24, 0x04	; 4
    21f0:	85 bd       	out	0x25, r24	; 37
       TCNT2 =MAX2 - Timer_Count;
    21f2:	60 95       	com	r22
    21f4:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    21f6:	80 e0       	ldi	r24, 0x00	; 0
    21f8:	08 95       	ret
  Ret=E_NOK;
  }
  break;
  }
  case TIMER_PRESCALER_128 :{
  if(Timer_Count < MAX2){
    21fa:	6f 3f       	cpi	r22, 0xFF	; 255
    21fc:	71 05       	cpc	r23, r1
    21fe:	98 f5       	brcc	.+102    	; 0x2266 <Timer_Start+0x226>
  TCCR2 |= TIMER_PRESCALER_128;
    2200:	85 b5       	in	r24, 0x25	; 37
    2202:	85 60       	ori	r24, 0x05	; 5
    2204:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    2206:	60 95       	com	r22
    2208:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    220a:	80 e0       	ldi	r24, 0x00	; 0
    220c:	08 95       	ret
  Ret= E_NOK;
    }
  break;
  }
  case TIMER_PRESCALER_256 :{
  if(Timer_Count < MAX2){
    220e:	6f 3f       	cpi	r22, 0xFF	; 255
    2210:	71 05       	cpc	r23, r1
    2212:	58 f5       	brcc	.+86     	; 0x226a <Timer_Start+0x22a>
  TCCR2 |= TIMER_PRESCALER_256;
    2214:	85 b5       	in	r24, 0x25	; 37
    2216:	86 60       	ori	r24, 0x06	; 6
    2218:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    221a:	60 95       	com	r22
    221c:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    221e:	80 e0       	ldi	r24, 0x00	; 0
    2220:	08 95       	ret

  }
  break;
  }
  case TIMER_PRESCALER_1024 :{
  if(Timer_Count < MAX2){
    2222:	6f 3f       	cpi	r22, 0xFF	; 255
    2224:	71 05       	cpc	r23, r1
    2226:	18 f5       	brcc	.+70     	; 0x226e <Timer_Start+0x22e>
  TCCR2 |=TIMER_PRESCALER_1024;
    2228:	85 b5       	in	r24, 0x25	; 37
    222a:	87 60       	ori	r24, 0x07	; 7
    222c:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    222e:	60 95       	com	r22
    2230:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    2232:	80 e0       	ldi	r24, 0x00	; 0
    2234:	08 95       	ret
break;
}
default:
Ret= E_NOK;
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	08 95       	ret
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    223a:	80 e0       	ldi	r24, 0x00	; 0
    223c:	08 95       	ret
    223e:	80 e0       	ldi	r24, 0x00	; 0
    2240:	08 95       	ret
    2242:	80 e0       	ldi	r24, 0x00	; 0
    2244:	08 95       	ret
    2246:	80 e0       	ldi	r24, 0x00	; 0
    2248:	08 95       	ret
    224a:	80 e0       	ldi	r24, 0x00	; 0
    224c:	08 95       	ret
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	08 95       	ret
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2252:	80 e0       	ldi	r24, 0x00	; 0
    2254:	08 95       	ret
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    2256:	80 e0       	ldi	r24, 0x00	; 0
    2258:	08 95       	ret
    225a:	80 e0       	ldi	r24, 0x00	; 0
    225c:	08 95       	ret
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	08 95       	ret
    2262:	80 e0       	ldi	r24, 0x00	; 0
    2264:	08 95       	ret
    2266:	80 e0       	ldi	r24, 0x00	; 0
    2268:	08 95       	ret
    226a:	80 e0       	ldi	r24, 0x00	; 0
    226c:	08 95       	ret
    226e:	80 e0       	ldi	r24, 0x00	; 0
Ret= E_NOK;
break;
}
return Ret;

}
    2270:	08 95       	ret

00002272 <Timer_Stop>:
 * Description: This function stops the needed timer.
 *
 */
ERROR_STATUS Timer_Stop(uint8_t Timer_CH_NO)
{uint8_t Ret;
switch (Timer_CH_NO) {
    2272:	81 30       	cpi	r24, 0x01	; 1
    2274:	51 f0       	breq	.+20     	; 0x228a <Timer_Stop+0x18>
    2276:	81 30       	cpi	r24, 0x01	; 1
    2278:	18 f0       	brcs	.+6      	; 0x2280 <Timer_Stop+0xe>
    227a:	82 30       	cpi	r24, 0x02	; 2
    227c:	91 f4       	brne	.+36     	; 0x22a2 <Timer_Stop+0x30>
    227e:	0c c0       	rjmp	.+24     	; 0x2298 <Timer_Stop+0x26>
  case TIMER_CH0:
  {
		TCCR0 &=0xF8;
    2280:	83 b7       	in	r24, 0x33	; 51
    2282:	88 7f       	andi	r24, 0xF8	; 248
    2284:	83 bf       	out	0x33, r24	; 51
		Ret=E_OK;
    2286:	80 e0       	ldi	r24, 0x00	; 0
		break;
    2288:	08 95       	ret
  }
  case TIMER_CH1:
  {
	     TCCR1 &=0xFFF8;
    228a:	8e b5       	in	r24, 0x2e	; 46
    228c:	9f b5       	in	r25, 0x2f	; 47
    228e:	88 7f       	andi	r24, 0xF8	; 248
    2290:	9f bd       	out	0x2f, r25	; 47
    2292:	8e bd       	out	0x2e, r24	; 46
		 Ret=E_OK;
    2294:	80 e0       	ldi	r24, 0x00	; 0
		 break;
    2296:	08 95       	ret
  }
  case TIMER_CH2:
    {
		 TCCR2 &= 0xF8;
    2298:	85 b5       	in	r24, 0x25	; 37
    229a:	88 7f       	andi	r24, 0xF8	; 248
    229c:	85 bd       	out	0x25, r24	; 37
		 Ret=E_OK;
    229e:	80 e0       	ldi	r24, 0x00	; 0
		 break;
    22a0:	08 95       	ret
    }
  default :
  Ret=E_NOK;
    22a2:	81 e0       	ldi	r24, 0x01	; 1
  break;
}

return Ret;

}
    22a4:	08 95       	ret

000022a6 <Timer_GetStatus>:
 * Description: This function is used to return if the flag of the timer is raised or not.
 *
 */
ERROR_STATUS Timer_GetStatus(uint8_t Timer_CH_NO,uint8_t* Data)
{
  switch (Timer_CH_NO) {
    22a6:	81 30       	cpi	r24, 0x01	; 1
    22a8:	59 f0       	breq	.+22     	; 0x22c0 <Timer_GetStatus+0x1a>
    22aa:	81 30       	cpi	r24, 0x01	; 1
    22ac:	18 f0       	brcs	.+6      	; 0x22b4 <Timer_GetStatus+0xe>
    22ae:	82 30       	cpi	r24, 0x02	; 2
    22b0:	c9 f4       	brne	.+50     	; 0x22e4 <Timer_GetStatus+0x3e>
    22b2:	0e c0       	rjmp	.+28     	; 0x22d0 <Timer_GetStatus+0x2a>
    case TIMER_CH0:
    {
  *Data =((TIFR>>TOV0)&1);
    22b4:	88 b7       	in	r24, 0x38	; 56
    22b6:	81 70       	andi	r24, 0x01	; 1
    22b8:	fb 01       	movw	r30, r22
    22ba:	80 83       	st	Z, r24
    return E_OK;
    22bc:	80 e0       	ldi	r24, 0x00	; 0
    22be:	08 95       	ret
    }
    case TIMER_CH1:
    {
    *Data =((TIFR>>TOV1)&1);
    22c0:	88 b7       	in	r24, 0x38	; 56
    22c2:	86 95       	lsr	r24
    22c4:	86 95       	lsr	r24
    22c6:	81 70       	andi	r24, 0x01	; 1
    22c8:	fb 01       	movw	r30, r22
    22ca:	80 83       	st	Z, r24
    return E_OK;
    22cc:	80 e0       	ldi	r24, 0x00	; 0
    22ce:	08 95       	ret
    }
     case TIMER_CH2:
      {
  *Data =((TIFR>>TOV2)&1);
    22d0:	88 b7       	in	r24, 0x38	; 56
    22d2:	82 95       	swap	r24
    22d4:	86 95       	lsr	r24
    22d6:	86 95       	lsr	r24
    22d8:	83 70       	andi	r24, 0x03	; 3
    22da:	81 70       	andi	r24, 0x01	; 1
    22dc:	fb 01       	movw	r30, r22
    22de:	80 83       	st	Z, r24
    return E_OK;
    22e0:	80 e0       	ldi	r24, 0x00	; 0
    22e2:	08 95       	ret
      }
    default :
    return E_NOK;
    22e4:	81 e0       	ldi	r24, 0x01	; 1
  }
}
    22e6:	08 95       	ret

000022e8 <Timer_GetValue>:
 * Return: The error status of the function.
 * Description: This function is used to return the value of the timer.
 *
 */
ERROR_STATUS Timer_GetValue(uint8_t Timer_CH_NO, uint16_t* Data)
{
    22e8:	fb 01       	movw	r30, r22
	uint8_t Ret=0;
	switch (Timer_CH_NO) {
    22ea:	81 30       	cpi	r24, 0x01	; 1
    22ec:	51 f0       	breq	.+20     	; 0x2302 <Timer_GetValue+0x1a>
    22ee:	81 30       	cpi	r24, 0x01	; 1
    22f0:	18 f0       	brcs	.+6      	; 0x22f8 <Timer_GetValue+0x10>
    22f2:	82 30       	cpi	r24, 0x02	; 2
    22f4:	89 f4       	brne	.+34     	; 0x2318 <Timer_GetValue+0x30>
    22f6:	0b c0       	rjmp	.+22     	; 0x230e <Timer_GetValue+0x26>
		case TIMER_CH0:
		{
			*Data =TCNT0;
    22f8:	82 b7       	in	r24, 0x32	; 50
    22fa:	80 83       	st	Z, r24
    22fc:	11 82       	std	Z+1, r1	; 0x01
			Ret= E_OK;
    22fe:	80 e0       	ldi	r24, 0x00	; 0
			break;
    2300:	08 95       	ret
		}
		case TIMER_CH1:
		{
			*Data =TCNT1;
    2302:	8c b5       	in	r24, 0x2c	; 44
    2304:	9d b5       	in	r25, 0x2d	; 45
    2306:	91 83       	std	Z+1, r25	; 0x01
    2308:	80 83       	st	Z, r24
			Ret= E_OK;
    230a:	80 e0       	ldi	r24, 0x00	; 0
			break;
    230c:	08 95       	ret
		}
		case TIMER_CH2:
		{
			*Data =TCNT2;
    230e:	84 b5       	in	r24, 0x24	; 36
    2310:	80 83       	st	Z, r24
    2312:	11 82       	std	Z+1, r1	; 0x01
			Ret = E_OK;
    2314:	80 e0       	ldi	r24, 0x00	; 0
			break;
    2316:	08 95       	ret
		}
		default :
		Ret= E_NOK;
    2318:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
return Ret;

}
    231a:	08 95       	ret

0000231c <Uart_Init>:
uint8_t BufferRequested[Buffer_Size];
//volatile uint8_t u8_index=0;
volatile uint8_t buf_is_full=0;
/****************************************************************************************************************************************/
void Uart_Init(En_BAUD_Rate Baud_rate,En_Stop_config Stop_bits_num, EN_Parity parity_Bit,EN_Data_Size data_num_bits,EN_UartMode uart_mode)
{
    231c:	0f 93       	push	r16
uint8_t Buffer=0;
switch (Baud_rate) {
    231e:	83 33       	cpi	r24, 0x33	; 51
    2320:	71 f0       	breq	.+28     	; 0x233e <Uart_Init+0x22>
    2322:	84 33       	cpi	r24, 0x34	; 52
    2324:	18 f4       	brcc	.+6      	; 0x232c <Uart_Init+0x10>
    2326:	89 31       	cpi	r24, 0x19	; 25
    2328:	79 f4       	brne	.+30     	; 0x2348 <Uart_Init+0x2c>
    232a:	0c c0       	rjmp	.+24     	; 0x2344 <Uart_Init+0x28>
    232c:	84 34       	cpi	r24, 0x44	; 68
    232e:	21 f0       	breq	.+8      	; 0x2338 <Uart_Init+0x1c>
    2330:	87 36       	cpi	r24, 0x67	; 103
    2332:	51 f4       	brne	.+20     	; 0x2348 <Uart_Init+0x2c>
  case Baud9600:
  UBRRL=Baud9600;
    2334:	89 b9       	out	0x09, r24	; 9
  break;
    2336:	08 c0       	rjmp	.+16     	; 0x2348 <Uart_Init+0x2c>
  case Baud14400:
  UBRRL=Baud14400;
    2338:	84 e4       	ldi	r24, 0x44	; 68
    233a:	89 b9       	out	0x09, r24	; 9
  break;
    233c:	05 c0       	rjmp	.+10     	; 0x2348 <Uart_Init+0x2c>
  case Baud19200:
  UBRRL=Baud19200;
    233e:	83 e3       	ldi	r24, 0x33	; 51
    2340:	89 b9       	out	0x09, r24	; 9
  break;
    2342:	02 c0       	rjmp	.+4      	; 0x2348 <Uart_Init+0x2c>
  case Baud38400:
  UBRRL=Baud38400;
    2344:	89 e1       	ldi	r24, 0x19	; 25
    2346:	89 b9       	out	0x09, r24	; 9
  break;
}
switch (Stop_bits_num) {
    2348:	66 23       	and	r22, r22
    234a:	31 f0       	breq	.+12     	; 0x2358 <Uart_Init+0x3c>
    234c:	61 30       	cpi	r22, 0x01	; 1
    234e:	11 f0       	breq	.+4      	; 0x2354 <Uart_Init+0x38>
//volatile uint8_t u8_index=0;
volatile uint8_t buf_is_full=0;
/****************************************************************************************************************************************/
void Uart_Init(En_BAUD_Rate Baud_rate,En_Stop_config Stop_bits_num, EN_Parity parity_Bit,EN_Data_Size data_num_bits,EN_UartMode uart_mode)
{
uint8_t Buffer=0;
    2350:	80 e0       	ldi	r24, 0x00	; 0
    2352:	03 c0       	rjmp	.+6      	; 0x235a <Uart_Init+0x3e>
  break;
}
case TwoStopBits:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,USBS);
    2354:	88 e8       	ldi	r24, 0x88	; 136
  break;
    2356:	01 c0       	rjmp	.+2      	; 0x235a <Uart_Init+0x3e>
  break;
}
switch (Stop_bits_num) {
case OneStopBit:
{ SET_BIT(Buffer,URSEL);
  CLEAR_BIT(Buffer,USBS);
    2358:	80 e8       	ldi	r24, 0x80	; 128
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,USBS);
  break;
}
}
switch (data_num_bits)
    235a:	22 30       	cpi	r18, 0x02	; 2
    235c:	a1 f0       	breq	.+40     	; 0x2386 <Uart_Init+0x6a>
    235e:	23 30       	cpi	r18, 0x03	; 3
    2360:	28 f4       	brcc	.+10     	; 0x236c <Uart_Init+0x50>
    2362:	22 23       	and	r18, r18
    2364:	41 f0       	breq	.+16     	; 0x2376 <Uart_Init+0x5a>
    2366:	21 30       	cpi	r18, 0x01	; 1
    2368:	b9 f4       	brne	.+46     	; 0x2398 <Uart_Init+0x7c>
    236a:	09 c0       	rjmp	.+18     	; 0x237e <Uart_Init+0x62>
    236c:	23 30       	cpi	r18, 0x03	; 3
    236e:	79 f0       	breq	.+30     	; 0x238e <Uart_Init+0x72>
    2370:	24 30       	cpi	r18, 0x04	; 4
    2372:	91 f4       	brne	.+36     	; 0x2398 <Uart_Init+0x7c>
    2374:	0f c0       	rjmp	.+30     	; 0x2394 <Uart_Init+0x78>
{
case FiveBits:
{
SET_BIT(Buffer,URSEL);
    2376:	80 68       	ori	r24, 0x80	; 128
CLEAR_BIT(Buffer,UCSZ0);
CLEAR_BIT(Buffer,UCSZ1);
    2378:	89 7f       	andi	r24, 0xF9	; 249
CLEAR_BIT(UCSRB,UCSZ2);
    237a:	52 98       	cbi	0x0a, 2	; 10
break;
    237c:	0d c0       	rjmp	.+26     	; 0x2398 <Uart_Init+0x7c>
}
case SexBits:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,UCSZ0);
    237e:	82 68       	ori	r24, 0x82	; 130
  CLEAR_BIT(Buffer,UCSZ1);
    2380:	8b 7f       	andi	r24, 0xFB	; 251
  CLEAR_BIT(UCSRB,UCSZ2);
    2382:	52 98       	cbi	0x0a, 2	; 10
  break;
    2384:	09 c0       	rjmp	.+18     	; 0x2398 <Uart_Init+0x7c>
}
case SevenBits:
{
  SET_BIT(Buffer,URSEL);
  CLEAR_BIT(Buffer,UCSZ0);
    2386:	89 77       	andi	r24, 0x79	; 121
  SET_BIT(Buffer,UCSZ1);
    2388:	84 68       	ori	r24, 0x84	; 132
  CLEAR_BIT(UCSRB,UCSZ2);
    238a:	52 98       	cbi	0x0a, 2	; 10
  break;
    238c:	05 c0       	rjmp	.+10     	; 0x2398 <Uart_Init+0x7c>
}
case EightBits:
{   SET_BIT(Buffer,URSEL);
    SET_BIT(Buffer,UCSZ0);
    SET_BIT(Buffer,UCSZ1);
    238e:	86 68       	ori	r24, 0x86	; 134
    CLEAR_BIT(UCSRB,UCSZ2);
    2390:	52 98       	cbi	0x0a, 2	; 10
break;
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <Uart_Init+0x7c>
}

case NineBits:
{   SET_BIT(Buffer,URSEL);
	SET_BIT(Buffer,UCSZ0);
	SET_BIT(Buffer,UCSZ1);
    2394:	86 68       	ori	r24, 0x86	; 134
	SET_BIT(UCSRB,UCSZ2);
    2396:	52 9a       	sbi	0x0a, 2	; 10
	break;
}

}

switch (uart_mode) {
    2398:	00 23       	and	r16, r16
    239a:	19 f0       	breq	.+6      	; 0x23a2 <Uart_Init+0x86>
    239c:	01 30       	cpi	r16, 0x01	; 1
    239e:	29 f4       	brne	.+10     	; 0x23aa <Uart_Init+0x8e>
    23a0:	03 c0       	rjmp	.+6      	; 0x23a8 <Uart_Init+0x8c>
  case ASynchronous:
  {
  SET_BIT(Buffer,URSEL);
    23a2:	80 68       	ori	r24, 0x80	; 128
  CLEAR_BIT(Buffer,UMSEL);
    23a4:	8f 7b       	andi	r24, 0xBF	; 191
  break;
    23a6:	01 c0       	rjmp	.+2      	; 0x23aa <Uart_Init+0x8e>
  }
case Synchronous:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,UMSEL);
    23a8:	80 6c       	ori	r24, 0xC0	; 192
  break;
}
}
switch (parity_Bit) {
    23aa:	41 30       	cpi	r20, 0x01	; 1
    23ac:	41 f0       	breq	.+16     	; 0x23be <Uart_Init+0xa2>
    23ae:	41 30       	cpi	r20, 0x01	; 1
    23b0:	18 f0       	brcs	.+6      	; 0x23b8 <Uart_Init+0x9c>
    23b2:	42 30       	cpi	r20, 0x02	; 2
    23b4:	41 f4       	brne	.+16     	; 0x23c6 <Uart_Init+0xaa>
    23b6:	06 c0       	rjmp	.+12     	; 0x23c4 <Uart_Init+0xa8>
  case NoParity:
{
SET_BIT(Buffer,URSEL);
    23b8:	80 68       	ori	r24, 0x80	; 128
CLEAR_BIT(Buffer,UPM0);
CLEAR_BIT(Buffer,UPM1);
    23ba:	8f 7c       	andi	r24, 0xCF	; 207
  break;
    23bc:	04 c0       	rjmp	.+8      	; 0x23c6 <Uart_Init+0xaa>
}
case EvenParity:
{
SET_BIT(Buffer,URSEL);
CLEAR_BIT(Buffer,UPM0);
    23be:	8f 74       	andi	r24, 0x4F	; 79
SET_BIT(Buffer,UPM1);
    23c0:	80 6a       	ori	r24, 0xA0	; 160
break;
    23c2:	01 c0       	rjmp	.+2      	; 0x23c6 <Uart_Init+0xaa>
}
case OddParity:
{
SET_BIT(Buffer,URSEL);
SET_BIT(Buffer,UPM1);
SET_BIT(Buffer,UPM0);
    23c4:	80 6b       	ori	r24, 0xB0	; 176
}


}

UCSRC=Buffer;
    23c6:	80 bd       	out	0x20, r24	; 32
SET_BIT(UCSRB,TXEN);/*TXEN*/
    23c8:	53 9a       	sbi	0x0a, 3	; 10
SET_BIT(UCSRB,RXEN);/*RXEN*/
    23ca:	54 9a       	sbi	0x0a, 4	; 10
}
    23cc:	0f 91       	pop	r16
    23ce:	08 95       	ret

000023d0 <UartTransmitPooling>:
void UartTransmitPooling(uint8_t Data)
{
while( !( UCSRA & (1<<UDRE)));
    23d0:	5d 9b       	sbis	0x0b, 5	; 11
    23d2:	fe cf       	rjmp	.-4      	; 0x23d0 <UartTransmitPooling>
UDR=Data;
    23d4:	8c b9       	out	0x0c, r24	; 12
}
    23d6:	08 95       	ret

000023d8 <UartRecievePooling>:
uint8_t UartRecievePooling(void)
{
	uint8_t data=0;
while (!( UCSRA & (1 << RXC)));/* Wait until new data receive*/
    23d8:	5f 9b       	sbis	0x0b, 7	; 11
    23da:	fe cf       	rjmp	.-4      	; 0x23d8 <UartRecievePooling>
data=UDR;
    23dc:	8c b1       	in	r24, 0x0c	; 12
return data;									/* Get and return received data */
}
    23de:	08 95       	ret

000023e0 <Enable_communication_interrupt>:


void Enable_communication_interrupt(void)
{
G_interrupt_Enable();
    23e0:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
SET_BIT(UCSRB,RXCIE);
    23e4:	57 9a       	sbi	0x0a, 7	; 10
SET_BIT(UCSRB,TXCIE);
    23e6:	56 9a       	sbi	0x0a, 6	; 10
SET_BIT(SPCR,SPIE);
    23e8:	6f 9a       	sbi	0x0d, 7	; 13
}
    23ea:	08 95       	ret

000023ec <UartRecieveInterrupt>:
//  buf_is_full=1;
//  u16_index=0;
//      }
/*if(u8_index<Buffer_Size)
{
  */u8_DATA=UDR;/*
    23ec:	8c b1       	in	r24, 0x0c	; 12
    23ee:	80 93 9a 05 	sts	0x059A, r24
  u8_index++;
}
  else{
    u8_index=0;
  }*/
}
    23f2:	08 95       	ret

000023f4 <UartTransmitInterrupt>:
{
/*When void Uart_tryansmitfirstbyte(uint8_t data) sends first byte before while(1) we start here sendine the next bytes
gU8_Data_transmited is shared with void UartTransmitdataInt(uint8_t data_to_transmit)
that changes its data
*/
UDR=u8_DATA;
    23f4:	80 91 9a 05 	lds	r24, 0x059A
    23f8:	8c b9       	out	0x0c, r24	; 12
//G_interrupt_Enable();
//u8_DATA ^=0xFF;
}
    23fa:	08 95       	ret

000023fc <UartTransmitdataInt>:
void UartTransmitdataInt(uint8_t data_to_transmit)
{
	  u8_DATA=data_to_transmit;
    23fc:	80 93 9a 05 	sts	0x059A, r24
}
    2400:	08 95       	ret

00002402 <Uart_tryansmitfirstbyte>:

void Uart_tryansmitfirstbyte(uint8_t data)
{
UDR=data;
    2402:	8c b9       	out	0x0c, r24	; 12
}
    2404:	08 95       	ret

00002406 <Uart_De_Init>:
void Uart_De_Init(void)
{
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
    2406:	53 98       	cbi	0x0a, 3	; 10
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/
    2408:	54 98       	cbi	0x0a, 4	; 10

}
    240a:	08 95       	ret

0000240c <uart_transmit_u16>:

void uart_transmit_u16(uint16_t sixtee_bits_var)
{
    240c:	ef 92       	push	r14
    240e:	ff 92       	push	r15
    2410:	0f 93       	push	r16
    2412:	1f 93       	push	r17
    2414:	cf 93       	push	r28
    2416:	df 93       	push	r29
    2418:	e8 e1       	ldi	r30, 0x18	; 24
    241a:	f1 e0       	ldi	r31, 0x01	; 1
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/

}

void uart_transmit_u16(uint16_t sixtee_bits_var)
    241c:	0f 2e       	mov	r0, r31
    241e:	fb ef       	ldi	r31, 0xFB	; 251
    2420:	ef 2e       	mov	r14, r31
    2422:	ff ef       	ldi	r31, 0xFF	; 255
    2424:	ff 2e       	mov	r15, r31
    2426:	f0 2d       	mov	r31, r0
    2428:	ee 0e       	add	r14, r30
    242a:	ff 1e       	adc	r15, r31
    242c:	ef 01       	movw	r28, r30
    242e:	24 97       	sbiw	r28, 0x04	; 4
uint8_t buffer_index=0;

for (i=4;i>0;i--)
{
	
	transmit_buffer[i]=sixtee_bits_var%10;
    2430:	2a e0       	ldi	r18, 0x0A	; 10
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	b9 01       	movw	r22, r18
    2436:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <__udivmodhi4>
    243a:	82 93       	st	-Z, r24
	sixtee_bits_var/=10;
    243c:	86 2f       	mov	r24, r22
    243e:	97 2f       	mov	r25, r23
void uart_transmit_u16(uint16_t sixtee_bits_var)
{
uint8_t i=5;
uint8_t buffer_index=0;

for (i=4;i>0;i--)
    2440:	ec 17       	cp	r30, r28
    2442:	fd 07       	cpc	r31, r29
    2444:	b9 f7       	brne	.-18     	; 0x2434 <uart_transmit_u16+0x28>
	
	transmit_buffer[i]=sixtee_bits_var%10;
	sixtee_bits_var/=10;

}
	transmit_buffer[i]=sixtee_bits_var;
    2446:	60 93 13 01 	sts	0x0113, r22
    244a:	03 e1       	ldi	r16, 0x13	; 19
    244c:	11 e0       	ldi	r17, 0x01	; 1
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/

}

void uart_transmit_u16(uint16_t sixtee_bits_var)
    244e:	e7 01       	movw	r28, r14
    2450:	25 96       	adiw	r28, 0x05	; 5

}
	transmit_buffer[i]=sixtee_bits_var;

	for(buffer_index=0;buffer_index < 5;buffer_index++)
	UartTransmitPooling(transmit_buffer[buffer_index]+48);
    2452:	f8 01       	movw	r30, r16
    2454:	81 91       	ld	r24, Z+
    2456:	8f 01       	movw	r16, r30
    2458:	80 5d       	subi	r24, 0xD0	; 208
    245a:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UartTransmitPooling>
	sixtee_bits_var/=10;

}
	transmit_buffer[i]=sixtee_bits_var;

	for(buffer_index=0;buffer_index < 5;buffer_index++)
    245e:	0c 17       	cp	r16, r28
    2460:	1d 07       	cpc	r17, r29
    2462:	b9 f7       	brne	.-18     	; 0x2452 <uart_transmit_u16+0x46>
	UartTransmitPooling(transmit_buffer[buffer_index]+48);



    2464:	df 91       	pop	r29
    2466:	cf 91       	pop	r28
    2468:	1f 91       	pop	r17
    246a:	0f 91       	pop	r16
    246c:	ff 90       	pop	r15
    246e:	ef 90       	pop	r14
    2470:	08 95       	ret

00002472 <main>:
 */ 
#include "SL/SOS/SOS.h"

int main(void)
{
	Uart_Init(Baud9600,OneStopBit,NoParity,EightBits,ASynchronous);
    2472:	87 e6       	ldi	r24, 0x67	; 103
    2474:	60 e0       	ldi	r22, 0x00	; 0
    2476:	40 e0       	ldi	r20, 0x00	; 0
    2478:	23 e0       	ldi	r18, 0x03	; 3
    247a:	00 e0       	ldi	r16, 0x00	; 0
    247c:	0e 94 8e 11 	call	0x231c	; 0x231c <Uart_Init>
	LCD_init();
    2480:	0e 94 a6 02 	call	0x54c	; 0x54c <LCD_init>
	DIO_init(&Dio_configurationB);
    2484:	88 eb       	ldi	r24, 0xB8	; 184
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
	DIO_init(&Dio_configurationC);
    248c:	85 eb       	ldi	r24, 0xB5	; 181
    248e:	90 e0       	ldi	r25, 0x00	; 0
    2490:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
	DIO_init(&Dio_configurationD);
    2494:	82 eb       	ldi	r24, 0xB2	; 178
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	0e 94 df 0a 	call	0x15be	; 0x15be <DIO_init>
	SOS_Init(&TMU_Configuration);
    249c:	8f ed       	ldi	r24, 0xDF	; 223
    249e:	90 e0       	ldi	r25, 0x00	; 0
    24a0:	0e 94 68 26 	call	0x4cd0	; 0x4cd0 <SOS_Init>

	//SOS_Create_Task(LCD_init,1,0,50);
	SOS_Create_Task(Read_Time_Task,1,1,5);
    24a4:	84 e8       	ldi	r24, 0x84	; 132
    24a6:	90 e0       	ldi	r25, 0x00	; 0
    24a8:	61 e0       	ldi	r22, 0x01	; 1
    24aa:	41 e0       	ldi	r20, 0x01	; 1
    24ac:	25 e0       	ldi	r18, 0x05	; 5
    24ae:	30 e0       	ldi	r19, 0x00	; 0
    24b0:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <SOS_Create_Task>
	//SOS_Create_Task(Display_Task,1,2,10);
	SOS_Create_Task(update_timing,1,4,1);
    24b4:	84 ef       	ldi	r24, 0xF4	; 244
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	61 e0       	ldi	r22, 0x01	; 1
    24ba:	44 e0       	ldi	r20, 0x04	; 4
    24bc:	21 e0       	ldi	r18, 0x01	; 1
    24be:	30 e0       	ldi	r19, 0x00	; 0
    24c0:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <SOS_Create_Task>
	SOS_Create_Task(Push_Task1,1,3,2);
    24c4:	84 e7       	ldi	r24, 0x74	; 116
    24c6:	90 e0       	ldi	r25, 0x00	; 0
    24c8:	61 e0       	ldi	r22, 0x01	; 1
    24ca:	43 e0       	ldi	r20, 0x03	; 3
    24cc:	22 e0       	ldi	r18, 0x02	; 2
    24ce:	30 e0       	ldi	r19, 0x00	; 0
    24d0:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <SOS_Create_Task>
	while(1)
	{
	
	
		SOS_Run();
    24d4:	0e 94 d8 26 	call	0x4db0	; 0x4db0 <SOS_Run>
    24d8:	fd cf       	rjmp	.-6      	; 0x24d4 <main+0x62>

000024da <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    24da:	44 23       	and	r20, r20
    24dc:	41 f4       	brne	.+16     	; 0x24ee <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    24de:	68 23       	and	r22, r24
    24e0:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
    24e2:	81 e0       	ldi	r24, 0x01	; 1
    24e4:	61 15       	cp	r22, r1
    24e6:	71 05       	cpc	r23, r1
    24e8:	51 f4       	brne	.+20     	; 0x24fe <prvTestWaitCondition+0x24>
    24ea:	80 e0       	ldi	r24, 0x00	; 0
    24ec:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    24ee:	9b 01       	movw	r18, r22
    24f0:	28 23       	and	r18, r24
    24f2:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
    24f4:	81 e0       	ldi	r24, 0x01	; 1
    24f6:	62 17       	cp	r22, r18
    24f8:	73 07       	cpc	r23, r19
    24fa:	09 f0       	breq	.+2      	; 0x24fe <prvTestWaitCondition+0x24>
    24fc:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
    24fe:	08 95       	ret

00002500 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    2500:	cf 93       	push	r28
    2502:	df 93       	push	r29
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    2504:	8b e0       	ldi	r24, 0x0B	; 11
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	0e 94 16 14 	call	0x282c	; 0x282c <pvPortMalloc>
    250c:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
    250e:	00 97       	sbiw	r24, 0x00	; 0
    2510:	31 f0       	breq	.+12     	; 0x251e <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
    2512:	fc 01       	movw	r30, r24
    2514:	11 92       	st	Z+, r1
    2516:	11 92       	st	Z+, r1
    2518:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    251a:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
	}
    251e:	8c 2f       	mov	r24, r28
    2520:	9d 2f       	mov	r25, r29
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	08 95       	ret

00002528 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2528:	af 92       	push	r10
    252a:	bf 92       	push	r11
    252c:	cf 92       	push	r12
    252e:	df 92       	push	r13
    2530:	ef 92       	push	r14
    2532:	ff 92       	push	r15
    2534:	0f 93       	push	r16
    2536:	1f 93       	push	r17
    2538:	cf 93       	push	r28
    253a:	df 93       	push	r29
    253c:	5c 01       	movw	r10, r24
    253e:	6b 01       	movw	r12, r22
    2540:	e4 2e       	mov	r14, r20
    2542:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2544:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2548:	f5 01       	movw	r30, r10
    254a:	c0 81       	ld	r28, Z
    254c:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    254e:	ce 01       	movw	r24, r28
    2550:	b6 01       	movw	r22, r12
    2552:	4f 2d       	mov	r20, r15
    2554:	0e 94 6d 12 	call	0x24da	; 0x24da <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
    2558:	88 23       	and	r24, r24
    255a:	51 f0       	breq	.+20     	; 0x2570 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    255c:	ee 20       	and	r14, r14
    255e:	01 f1       	breq	.+64     	; 0x25a0 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2560:	c0 94       	com	r12
    2562:	d0 94       	com	r13
    2564:	cc 22       	and	r12, r28
    2566:	dd 22       	and	r13, r29
    2568:	f5 01       	movw	r30, r10
    256a:	d1 82       	std	Z+1, r13	; 0x01
    256c:	c0 82       	st	Z, r12
    256e:	18 c0       	rjmp	.+48     	; 0x25a0 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2570:	01 15       	cp	r16, r1
    2572:	11 05       	cpc	r17, r1
    2574:	a9 f0       	breq	.+42     	; 0x25a0 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2576:	ee 20       	and	r14, r14
    2578:	19 f4       	brne	.+6      	; 0x2580 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
    257a:	60 e0       	ldi	r22, 0x00	; 0
    257c:	70 e0       	ldi	r23, 0x00	; 0
    257e:	02 c0       	rjmp	.+4      	; 0x2584 <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2580:	60 e0       	ldi	r22, 0x00	; 0
    2582:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2584:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2586:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2588:	6c 29       	or	r22, r12
    258a:	7d 29       	or	r23, r13
    258c:	c5 01       	movw	r24, r10
    258e:	02 96       	adiw	r24, 0x02	; 2
    2590:	a8 01       	movw	r20, r16
    2592:	0e 94 10 23 	call	0x4620	; 0x4620 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2596:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
    259a:	88 23       	and	r24, r24
    259c:	39 f4       	brne	.+14     	; 0x25ac <xEventGroupWaitBits+0x84>
    259e:	04 c0       	rjmp	.+8      	; 0x25a8 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    25a0:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    25a4:	ce 01       	movw	r24, r28
    25a6:	21 c0       	rjmp	.+66     	; 0x25ea <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    25a8:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    25ac:	0e 94 fd 23 	call	0x47fa	; 0x47fa <uxTaskResetEventItemValue>
    25b0:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    25b2:	91 fd       	sbrc	r25, 1
    25b4:	18 c0       	rjmp	.+48     	; 0x25e6 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
    25b6:	0f b6       	in	r0, 0x3f	; 63
    25b8:	f8 94       	cli
    25ba:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    25bc:	f5 01       	movw	r30, r10
    25be:	c0 81       	ld	r28, Z
    25c0:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    25c2:	ce 01       	movw	r24, r28
    25c4:	b6 01       	movw	r22, r12
    25c6:	4f 2d       	mov	r20, r15
    25c8:	0e 94 6d 12 	call	0x24da	; 0x24da <prvTestWaitCondition>
    25cc:	88 23       	and	r24, r24
    25ce:	49 f0       	breq	.+18     	; 0x25e2 <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
    25d0:	ee 20       	and	r14, r14
    25d2:	39 f0       	breq	.+14     	; 0x25e2 <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    25d4:	c0 94       	com	r12
    25d6:	d0 94       	com	r13
    25d8:	cc 22       	and	r12, r28
    25da:	dd 22       	and	r13, r29
    25dc:	f5 01       	movw	r30, r10
    25de:	d1 82       	std	Z+1, r13	; 0x01
    25e0:	c0 82       	st	Z, r12
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
			}
			taskEXIT_CRITICAL();
    25e2:	0f 90       	pop	r0
    25e4:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    25e6:	ce 01       	movw	r24, r28
    25e8:	90 70       	andi	r25, 0x00	; 0

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
}
    25ea:	df 91       	pop	r29
    25ec:	cf 91       	pop	r28
    25ee:	1f 91       	pop	r17
    25f0:	0f 91       	pop	r16
    25f2:	ff 90       	pop	r15
    25f4:	ef 90       	pop	r14
    25f6:	df 90       	pop	r13
    25f8:	cf 90       	pop	r12
    25fa:	bf 90       	pop	r11
    25fc:	af 90       	pop	r10
    25fe:	08 95       	ret

00002600 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    2600:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2602:	0f b6       	in	r0, 0x3f	; 63
    2604:	f8 94       	cli
    2606:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2608:	80 81       	ld	r24, Z
    260a:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    260c:	60 95       	com	r22
    260e:	70 95       	com	r23
    2610:	68 23       	and	r22, r24
    2612:	79 23       	and	r23, r25
    2614:	71 83       	std	Z+1, r23	; 0x01
    2616:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
    2618:	0f 90       	pop	r0
    261a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    261c:	08 95       	ret

0000261e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    261e:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2620:	80 81       	ld	r24, Z
    2622:	91 81       	ldd	r25, Z+1	; 0x01
    2624:	08 95       	ret

00002626 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2626:	af 92       	push	r10
    2628:	bf 92       	push	r11
    262a:	cf 92       	push	r12
    262c:	df 92       	push	r13
    262e:	ef 92       	push	r14
    2630:	ff 92       	push	r15
    2632:	0f 93       	push	r16
    2634:	1f 93       	push	r17
    2636:	cf 93       	push	r28
    2638:	df 93       	push	r29
    263a:	8c 01       	movw	r16, r24
    263c:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    263e:	0f 2e       	mov	r0, r31
    2640:	f5 e0       	ldi	r31, 0x05	; 5
    2642:	cf 2e       	mov	r12, r31
    2644:	dd 24       	eor	r13, r13
    2646:	f0 2d       	mov	r31, r0
    2648:	c8 0e       	add	r12, r24
    264a:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
    264c:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2650:	d8 01       	movw	r26, r16
    2652:	17 96       	adiw	r26, 0x07	; 7
    2654:	ed 91       	ld	r30, X+
    2656:	fc 91       	ld	r31, X
    2658:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    265a:	8d 91       	ld	r24, X+
    265c:	9c 91       	ld	r25, X
    265e:	11 97       	sbiw	r26, 0x01	; 1
    2660:	8c 2b       	or	r24, r28
    2662:	9d 2b       	or	r25, r29
    2664:	11 96       	adiw	r26, 0x01	; 1
    2666:	9c 93       	st	X, r25
    2668:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    266a:	ce 16       	cp	r12, r30
    266c:	df 06       	cpc	r13, r31
    266e:	c1 f1       	breq	.+112    	; 0x26e0 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2670:	aa 24       	eor	r10, r10
    2672:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    2674:	ff 24       	eor	r15, r15
    2676:	f3 94       	inc	r15
    2678:	ee 24       	eor	r14, r14
    267a:	01 c0       	rjmp	.+2      	; 0x267e <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    267c:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
    267e:	c2 81       	ldd	r28, Z+2	; 0x02
    2680:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2682:	80 81       	ld	r24, Z
    2684:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2686:	bc 01       	movw	r22, r24
    2688:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    268a:	9c 01       	movw	r18, r24
    268c:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    268e:	92 fd       	sbrc	r25, 2
    2690:	0b c0       	rjmp	.+22     	; 0x26a8 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2692:	d8 01       	movw	r26, r16
    2694:	8d 91       	ld	r24, X+
    2696:	9c 91       	ld	r25, X
    2698:	11 97       	sbiw	r26, 0x01	; 1
    269a:	82 23       	and	r24, r18
    269c:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
    269e:	4f 2d       	mov	r20, r15
    26a0:	00 97       	sbiw	r24, 0x00	; 0
    26a2:	69 f4       	brne	.+26     	; 0x26be <xEventGroupSetBits+0x98>
    26a4:	4e 2d       	mov	r20, r14
    26a6:	0b c0       	rjmp	.+22     	; 0x26be <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    26a8:	d8 01       	movw	r26, r16
    26aa:	8d 91       	ld	r24, X+
    26ac:	9c 91       	ld	r25, X
    26ae:	11 97       	sbiw	r26, 0x01	; 1
    26b0:	82 23       	and	r24, r18
    26b2:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    26b4:	4f 2d       	mov	r20, r15
    26b6:	28 17       	cp	r18, r24
    26b8:	39 07       	cpc	r19, r25
    26ba:	09 f0       	breq	.+2      	; 0x26be <xEventGroupSetBits+0x98>
    26bc:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    26be:	44 23       	and	r20, r20
    26c0:	59 f0       	breq	.+22     	; 0x26d8 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    26c2:	70 ff       	sbrs	r23, 0
    26c4:	02 c0       	rjmp	.+4      	; 0x26ca <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    26c6:	a2 2a       	or	r10, r18
    26c8:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    26ca:	d8 01       	movw	r26, r16
    26cc:	6d 91       	ld	r22, X+
    26ce:	7c 91       	ld	r23, X
    26d0:	72 60       	ori	r23, 0x02	; 2
    26d2:	cf 01       	movw	r24, r30
    26d4:	0e 94 74 23 	call	0x46e8	; 0x46e8 <vTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    26d8:	cc 16       	cp	r12, r28
    26da:	dd 06       	cpc	r13, r29
    26dc:	79 f6       	brne	.-98     	; 0x267c <xEventGroupSetBits+0x56>
    26de:	02 c0       	rjmp	.+4      	; 0x26e4 <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    26e0:	aa 24       	eor	r10, r10
    26e2:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    26e4:	c5 01       	movw	r24, r10
    26e6:	80 95       	com	r24
    26e8:	90 95       	com	r25
    26ea:	f8 01       	movw	r30, r16
    26ec:	a0 80       	ld	r10, Z
    26ee:	b1 80       	ldd	r11, Z+1	; 0x01
    26f0:	a8 22       	and	r10, r24
    26f2:	b9 22       	and	r11, r25
    26f4:	b1 82       	std	Z+1, r11	; 0x01
    26f6:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
    26f8:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
    26fc:	d8 01       	movw	r26, r16
    26fe:	8c 91       	ld	r24, X
    2700:	11 96       	adiw	r26, 0x01	; 1
    2702:	9c 91       	ld	r25, X
    2704:	11 97       	sbiw	r26, 0x01	; 1
    2706:	df 91       	pop	r29
    2708:	cf 91       	pop	r28
    270a:	1f 91       	pop	r17
    270c:	0f 91       	pop	r16
    270e:	ff 90       	pop	r15
    2710:	ef 90       	pop	r14
    2712:	df 90       	pop	r13
    2714:	cf 90       	pop	r12
    2716:	bf 90       	pop	r11
    2718:	af 90       	pop	r10
    271a:	08 95       	ret

0000271c <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    271c:	af 92       	push	r10
    271e:	bf 92       	push	r11
    2720:	cf 92       	push	r12
    2722:	df 92       	push	r13
    2724:	ef 92       	push	r14
    2726:	ff 92       	push	r15
    2728:	0f 93       	push	r16
    272a:	1f 93       	push	r17
    272c:	cf 93       	push	r28
    272e:	df 93       	push	r29
    2730:	6c 01       	movw	r12, r24
    2732:	eb 01       	movw	r28, r22
    2734:	7a 01       	movw	r14, r20
    2736:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2738:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    273c:	f6 01       	movw	r30, r12
    273e:	00 81       	ld	r16, Z
    2740:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2742:	c6 01       	movw	r24, r12
    2744:	be 01       	movw	r22, r28
    2746:	0e 94 13 13 	call	0x2626	; 0x2626 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    274a:	c0 2b       	or	r28, r16
    274c:	d1 2b       	or	r29, r17
    274e:	c7 01       	movw	r24, r14
    2750:	8c 23       	and	r24, r28
    2752:	9d 23       	and	r25, r29
    2754:	8e 15       	cp	r24, r14
    2756:	9f 05       	cpc	r25, r15
    2758:	51 f4       	brne	.+20     	; 0x276e <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    275a:	80 95       	com	r24
    275c:	90 95       	com	r25
    275e:	f6 01       	movw	r30, r12
    2760:	20 81       	ld	r18, Z
    2762:	31 81       	ldd	r19, Z+1	; 0x01
    2764:	82 23       	and	r24, r18
    2766:	93 23       	and	r25, r19
    2768:	91 83       	std	Z+1, r25	; 0x01
    276a:	80 83       	st	Z, r24
    276c:	12 c0       	rjmp	.+36     	; 0x2792 <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    276e:	a1 14       	cp	r10, r1
    2770:	b1 04       	cpc	r11, r1
    2772:	61 f0       	breq	.+24     	; 0x278c <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2774:	b7 01       	movw	r22, r14
    2776:	75 60       	ori	r23, 0x05	; 5
    2778:	c6 01       	movw	r24, r12
    277a:	02 96       	adiw	r24, 0x02	; 2
    277c:	a5 01       	movw	r20, r10
    277e:	0e 94 10 23 	call	0x4620	; 0x4620 <vTaskPlaceOnUnorderedEventList>
				uxReturn = pxEventBits->uxEventBits;
				xTimeoutOccurred = pdTRUE;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2782:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
    2786:	88 23       	and	r24, r24
    2788:	49 f4       	brne	.+18     	; 0x279c <xEventGroupSync+0x80>
    278a:	06 c0       	rjmp	.+12     	; 0x2798 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    278c:	f6 01       	movw	r30, r12
    278e:	c0 81       	ld	r28, Z
    2790:	d1 81       	ldd	r29, Z+1	; 0x01
				xTimeoutOccurred = pdTRUE;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2792:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    2796:	1c c0       	rjmp	.+56     	; 0x27d0 <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2798:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    279c:	0e 94 fd 23 	call	0x47fa	; 0x47fa <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    27a0:	91 fd       	sbrc	r25, 1
    27a2:	14 c0       	rjmp	.+40     	; 0x27cc <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    27a4:	0f b6       	in	r0, 0x3f	; 63
    27a6:	f8 94       	cli
    27a8:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    27aa:	f6 01       	movw	r30, r12
    27ac:	80 81       	ld	r24, Z
    27ae:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    27b0:	97 01       	movw	r18, r14
    27b2:	28 23       	and	r18, r24
    27b4:	39 23       	and	r19, r25
    27b6:	2e 15       	cp	r18, r14
    27b8:	3f 05       	cpc	r19, r15
    27ba:	31 f4       	brne	.+12     	; 0x27c8 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    27bc:	20 95       	com	r18
    27be:	30 95       	com	r19
    27c0:	28 23       	and	r18, r24
    27c2:	39 23       	and	r19, r25
    27c4:	31 83       	std	Z+1, r19	; 0x01
    27c6:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    27c8:	0f 90       	pop	r0
    27ca:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    27cc:	ec 01       	movw	r28, r24
    27ce:	d0 70       	andi	r29, 0x00	; 0

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
}
    27d0:	8c 2f       	mov	r24, r28
    27d2:	9d 2f       	mov	r25, r29
    27d4:	df 91       	pop	r29
    27d6:	cf 91       	pop	r28
    27d8:	1f 91       	pop	r17
    27da:	0f 91       	pop	r16
    27dc:	ff 90       	pop	r15
    27de:	ef 90       	pop	r14
    27e0:	df 90       	pop	r13
    27e2:	cf 90       	pop	r12
    27e4:	bf 90       	pop	r11
    27e6:	af 90       	pop	r10
    27e8:	08 95       	ret

000027ea <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    27ea:	cf 93       	push	r28
    27ec:	df 93       	push	r29
    27ee:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
    27f0:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    27f4:	8a 81       	ldd	r24, Y+2	; 0x02
    27f6:	88 23       	and	r24, r24
    27f8:	49 f0       	breq	.+18     	; 0x280c <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    27fa:	8f 81       	ldd	r24, Y+7	; 0x07
    27fc:	98 85       	ldd	r25, Y+8	; 0x08
    27fe:	60 e0       	ldi	r22, 0x00	; 0
    2800:	72 e0       	ldi	r23, 0x02	; 2
    2802:	0e 94 74 23 	call	0x46e8	; 0x46e8 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2806:	8a 81       	ldd	r24, Y+2	; 0x02
    2808:	88 23       	and	r24, r24
    280a:	b9 f7       	brne	.-18     	; 0x27fa <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    280c:	ce 01       	movw	r24, r28
    280e:	0e 94 4c 14 	call	0x2898	; 0x2898 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2812:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
}
    2816:	df 91       	pop	r29
    2818:	cf 91       	pop	r28
    281a:	08 95       	ret

0000281c <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    281c:	ba 01       	movw	r22, r20
    281e:	0e 94 13 13 	call	0x2626	; 0x2626 <xEventGroupSetBits>
}
    2822:	08 95       	ret

00002824 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2824:	ba 01       	movw	r22, r20
    2826:	0e 94 00 13 	call	0x2600	; 0x2600 <xEventGroupClearBits>
}
    282a:	08 95       	ret

0000282c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    282c:	cf 93       	push	r28
    282e:	df 93       	push	r29
    2830:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2832:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2836:	80 91 18 01 	lds	r24, 0x0118
    283a:	90 91 19 01 	lds	r25, 0x0119
    283e:	00 97       	sbiw	r24, 0x00	; 0
    2840:	31 f4       	brne	.+12     	; 0x284e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2842:	8b e1       	ldi	r24, 0x1B	; 27
    2844:	91 e0       	ldi	r25, 0x01	; 1
    2846:	90 93 19 01 	sts	0x0119, r25
    284a:	80 93 18 01 	sts	0x0118, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    284e:	20 91 02 05 	lds	r18, 0x0502
    2852:	30 91 03 05 	lds	r19, 0x0503
    2856:	ce 01       	movw	r24, r28
    2858:	82 0f       	add	r24, r18
    285a:	93 1f       	adc	r25, r19
    285c:	43 e0       	ldi	r20, 0x03	; 3
    285e:	87 3e       	cpi	r24, 0xE7	; 231
    2860:	94 07       	cpc	r25, r20
    2862:	70 f4       	brcc	.+28     	; 0x2880 <pvPortMalloc+0x54>
    2864:	28 17       	cp	r18, r24
    2866:	39 07       	cpc	r19, r25
    2868:	70 f4       	brcc	.+28     	; 0x2886 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    286a:	c0 91 18 01 	lds	r28, 0x0118
    286e:	d0 91 19 01 	lds	r29, 0x0119
    2872:	c2 0f       	add	r28, r18
    2874:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2876:	90 93 03 05 	sts	0x0503, r25
    287a:	80 93 02 05 	sts	0x0502, r24
    287e:	05 c0       	rjmp	.+10     	; 0x288a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2880:	c0 e0       	ldi	r28, 0x00	; 0
    2882:	d0 e0       	ldi	r29, 0x00	; 0
    2884:	02 c0       	rjmp	.+4      	; 0x288a <pvPortMalloc+0x5e>
    2886:	c0 e0       	ldi	r28, 0x00	; 0
    2888:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    288a:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    288e:	8c 2f       	mov	r24, r28
    2890:	9d 2f       	mov	r25, r29
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	08 95       	ret

00002898 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2898:	08 95       	ret

0000289a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    289a:	10 92 03 05 	sts	0x0503, r1
    289e:	10 92 02 05 	sts	0x0502, r1
}
    28a2:	08 95       	ret

000028a4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    28a4:	20 91 02 05 	lds	r18, 0x0502
    28a8:	30 91 03 05 	lds	r19, 0x0503
    28ac:	87 ee       	ldi	r24, 0xE7	; 231
    28ae:	93 e0       	ldi	r25, 0x03	; 3
    28b0:	82 1b       	sub	r24, r18
    28b2:	93 0b       	sbc	r25, r19
}
    28b4:	08 95       	ret

000028b6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    28b6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28b8:	03 96       	adiw	r24, 0x03	; 3
    28ba:	92 83       	std	Z+2, r25	; 0x02
    28bc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    28be:	2f ef       	ldi	r18, 0xFF	; 255
    28c0:	3f ef       	ldi	r19, 0xFF	; 255
    28c2:	34 83       	std	Z+4, r19	; 0x04
    28c4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28c6:	96 83       	std	Z+6, r25	; 0x06
    28c8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28ca:	90 87       	std	Z+8, r25	; 0x08
    28cc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    28ce:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    28d0:	08 95       	ret

000028d2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    28d2:	fc 01       	movw	r30, r24
    28d4:	11 86       	std	Z+9, r1	; 0x09
    28d6:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    28d8:	08 95       	ret

000028da <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    28da:	cf 93       	push	r28
    28dc:	df 93       	push	r29
    28de:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    28e0:	dc 01       	movw	r26, r24
    28e2:	11 96       	adiw	r26, 0x01	; 1
    28e4:	cd 91       	ld	r28, X+
    28e6:	dc 91       	ld	r29, X
    28e8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    28ea:	d3 83       	std	Z+3, r29	; 0x03
    28ec:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    28ee:	2c 81       	ldd	r18, Y+4	; 0x04
    28f0:	3d 81       	ldd	r19, Y+5	; 0x05
    28f2:	35 83       	std	Z+5, r19	; 0x05
    28f4:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    28f6:	ac 81       	ldd	r26, Y+4	; 0x04
    28f8:	bd 81       	ldd	r27, Y+5	; 0x05
    28fa:	13 96       	adiw	r26, 0x03	; 3
    28fc:	7c 93       	st	X, r23
    28fe:	6e 93       	st	-X, r22
    2900:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    2902:	7d 83       	std	Y+5, r23	; 0x05
    2904:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2906:	91 87       	std	Z+9, r25	; 0x09
    2908:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    290a:	fc 01       	movw	r30, r24
    290c:	20 81       	ld	r18, Z
    290e:	2f 5f       	subi	r18, 0xFF	; 255
    2910:	20 83       	st	Z, r18
}
    2912:	df 91       	pop	r29
    2914:	cf 91       	pop	r28
    2916:	08 95       	ret

00002918 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2918:	cf 93       	push	r28
    291a:	df 93       	push	r29
    291c:	ac 01       	movw	r20, r24
    291e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2920:	28 81       	ld	r18, Y
    2922:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2924:	8f ef       	ldi	r24, 0xFF	; 255
    2926:	2f 3f       	cpi	r18, 0xFF	; 255
    2928:	38 07       	cpc	r19, r24
    292a:	21 f4       	brne	.+8      	; 0x2934 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    292c:	fa 01       	movw	r30, r20
    292e:	a7 81       	ldd	r26, Z+7	; 0x07
    2930:	b0 85       	ldd	r27, Z+8	; 0x08
    2932:	0d c0       	rjmp	.+26     	; 0x294e <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2934:	da 01       	movw	r26, r20
    2936:	13 96       	adiw	r26, 0x03	; 3
    2938:	01 c0       	rjmp	.+2      	; 0x293c <vListInsert+0x24>
    293a:	df 01       	movw	r26, r30
    293c:	12 96       	adiw	r26, 0x02	; 2
    293e:	ed 91       	ld	r30, X+
    2940:	fc 91       	ld	r31, X
    2942:	13 97       	sbiw	r26, 0x03	; 3
    2944:	80 81       	ld	r24, Z
    2946:	91 81       	ldd	r25, Z+1	; 0x01
    2948:	28 17       	cp	r18, r24
    294a:	39 07       	cpc	r19, r25
    294c:	b0 f7       	brcc	.-20     	; 0x293a <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    294e:	12 96       	adiw	r26, 0x02	; 2
    2950:	ed 91       	ld	r30, X+
    2952:	fc 91       	ld	r31, X
    2954:	13 97       	sbiw	r26, 0x03	; 3
    2956:	fb 83       	std	Y+3, r31	; 0x03
    2958:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    295a:	d5 83       	std	Z+5, r29	; 0x05
    295c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    295e:	bd 83       	std	Y+5, r27	; 0x05
    2960:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2962:	13 96       	adiw	r26, 0x03	; 3
    2964:	dc 93       	st	X, r29
    2966:	ce 93       	st	-X, r28
    2968:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    296a:	59 87       	std	Y+9, r21	; 0x09
    296c:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    296e:	fa 01       	movw	r30, r20
    2970:	80 81       	ld	r24, Z
    2972:	8f 5f       	subi	r24, 0xFF	; 255
    2974:	80 83       	st	Z, r24
}
    2976:	df 91       	pop	r29
    2978:	cf 91       	pop	r28
    297a:	08 95       	ret

0000297c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    297c:	cf 93       	push	r28
    297e:	df 93       	push	r29
    2980:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2982:	c0 85       	ldd	r28, Z+8	; 0x08
    2984:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2986:	a2 81       	ldd	r26, Z+2	; 0x02
    2988:	b3 81       	ldd	r27, Z+3	; 0x03
    298a:	84 81       	ldd	r24, Z+4	; 0x04
    298c:	95 81       	ldd	r25, Z+5	; 0x05
    298e:	15 96       	adiw	r26, 0x05	; 5
    2990:	9c 93       	st	X, r25
    2992:	8e 93       	st	-X, r24
    2994:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2996:	a4 81       	ldd	r26, Z+4	; 0x04
    2998:	b5 81       	ldd	r27, Z+5	; 0x05
    299a:	82 81       	ldd	r24, Z+2	; 0x02
    299c:	93 81       	ldd	r25, Z+3	; 0x03
    299e:	13 96       	adiw	r26, 0x03	; 3
    29a0:	9c 93       	st	X, r25
    29a2:	8e 93       	st	-X, r24
    29a4:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    29a6:	a9 81       	ldd	r26, Y+1	; 0x01
    29a8:	ba 81       	ldd	r27, Y+2	; 0x02
    29aa:	ae 17       	cp	r26, r30
    29ac:	bf 07       	cpc	r27, r31
    29ae:	31 f4       	brne	.+12     	; 0x29bc <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    29b0:	14 96       	adiw	r26, 0x04	; 4
    29b2:	8d 91       	ld	r24, X+
    29b4:	9c 91       	ld	r25, X
    29b6:	15 97       	sbiw	r26, 0x05	; 5
    29b8:	9a 83       	std	Y+2, r25	; 0x02
    29ba:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    29bc:	11 86       	std	Z+9, r1	; 0x09
    29be:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    29c0:	88 81       	ld	r24, Y
    29c2:	81 50       	subi	r24, 0x01	; 1
    29c4:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
    29c6:	88 81       	ld	r24, Y
}
    29c8:	df 91       	pop	r29
    29ca:	cf 91       	pop	r28
    29cc:	08 95       	ret

000029ce <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    29ce:	21 e1       	ldi	r18, 0x11	; 17
    29d0:	fc 01       	movw	r30, r24
    29d2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    29d4:	31 97       	sbiw	r30, 0x01	; 1
    29d6:	32 e2       	ldi	r19, 0x22	; 34
    29d8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    29da:	fc 01       	movw	r30, r24
    29dc:	32 97       	sbiw	r30, 0x02	; 2
    29de:	a3 e3       	ldi	r26, 0x33	; 51
    29e0:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29e2:	fc 01       	movw	r30, r24
    29e4:	33 97       	sbiw	r30, 0x03	; 3
    29e6:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29e8:	fc 01       	movw	r30, r24
    29ea:	34 97       	sbiw	r30, 0x04	; 4
    29ec:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    29ee:	fc 01       	movw	r30, r24
    29f0:	35 97       	sbiw	r30, 0x05	; 5
    29f2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    29f4:	fc 01       	movw	r30, r24
    29f6:	36 97       	sbiw	r30, 0x06	; 6
    29f8:	60 e8       	ldi	r22, 0x80	; 128
    29fa:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    29fc:	fc 01       	movw	r30, r24
    29fe:	37 97       	sbiw	r30, 0x07	; 7
    2a00:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2a02:	fc 01       	movw	r30, r24
    2a04:	38 97       	sbiw	r30, 0x08	; 8
    2a06:	62 e0       	ldi	r22, 0x02	; 2
    2a08:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2a0a:	fc 01       	movw	r30, r24
    2a0c:	39 97       	sbiw	r30, 0x09	; 9
    2a0e:	63 e0       	ldi	r22, 0x03	; 3
    2a10:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2a12:	fc 01       	movw	r30, r24
    2a14:	3a 97       	sbiw	r30, 0x0a	; 10
    2a16:	64 e0       	ldi	r22, 0x04	; 4
    2a18:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	3b 97       	sbiw	r30, 0x0b	; 11
    2a1e:	65 e0       	ldi	r22, 0x05	; 5
    2a20:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2a22:	fc 01       	movw	r30, r24
    2a24:	3c 97       	sbiw	r30, 0x0c	; 12
    2a26:	66 e0       	ldi	r22, 0x06	; 6
    2a28:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	3d 97       	sbiw	r30, 0x0d	; 13
    2a2e:	67 e0       	ldi	r22, 0x07	; 7
    2a30:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2a32:	fc 01       	movw	r30, r24
    2a34:	3e 97       	sbiw	r30, 0x0e	; 14
    2a36:	68 e0       	ldi	r22, 0x08	; 8
    2a38:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2a3a:	fc 01       	movw	r30, r24
    2a3c:	3f 97       	sbiw	r30, 0x0f	; 15
    2a3e:	69 e0       	ldi	r22, 0x09	; 9
    2a40:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2a42:	fc 01       	movw	r30, r24
    2a44:	70 97       	sbiw	r30, 0x10	; 16
    2a46:	60 e1       	ldi	r22, 0x10	; 16
    2a48:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2a4a:	fc 01       	movw	r30, r24
    2a4c:	71 97       	sbiw	r30, 0x11	; 17
    2a4e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2a50:	fc 01       	movw	r30, r24
    2a52:	72 97       	sbiw	r30, 0x12	; 18
    2a54:	22 e1       	ldi	r18, 0x12	; 18
    2a56:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2a58:	fc 01       	movw	r30, r24
    2a5a:	73 97       	sbiw	r30, 0x13	; 19
    2a5c:	23 e1       	ldi	r18, 0x13	; 19
    2a5e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2a60:	fc 01       	movw	r30, r24
    2a62:	74 97       	sbiw	r30, 0x14	; 20
    2a64:	24 e1       	ldi	r18, 0x14	; 20
    2a66:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2a68:	fc 01       	movw	r30, r24
    2a6a:	75 97       	sbiw	r30, 0x15	; 21
    2a6c:	25 e1       	ldi	r18, 0x15	; 21
    2a6e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2a70:	fc 01       	movw	r30, r24
    2a72:	76 97       	sbiw	r30, 0x16	; 22
    2a74:	26 e1       	ldi	r18, 0x16	; 22
    2a76:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2a78:	fc 01       	movw	r30, r24
    2a7a:	77 97       	sbiw	r30, 0x17	; 23
    2a7c:	27 e1       	ldi	r18, 0x17	; 23
    2a7e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2a80:	fc 01       	movw	r30, r24
    2a82:	78 97       	sbiw	r30, 0x18	; 24
    2a84:	28 e1       	ldi	r18, 0x18	; 24
    2a86:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2a88:	fc 01       	movw	r30, r24
    2a8a:	79 97       	sbiw	r30, 0x19	; 25
    2a8c:	29 e1       	ldi	r18, 0x19	; 25
    2a8e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2a90:	fc 01       	movw	r30, r24
    2a92:	7a 97       	sbiw	r30, 0x1a	; 26
    2a94:	20 e2       	ldi	r18, 0x20	; 32
    2a96:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2a98:	fc 01       	movw	r30, r24
    2a9a:	7b 97       	sbiw	r30, 0x1b	; 27
    2a9c:	21 e2       	ldi	r18, 0x21	; 33
    2a9e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2aa0:	fc 01       	movw	r30, r24
    2aa2:	7c 97       	sbiw	r30, 0x1c	; 28
    2aa4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	7d 97       	sbiw	r30, 0x1d	; 29
    2aaa:	23 e2       	ldi	r18, 0x23	; 35
    2aac:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2aae:	fc 01       	movw	r30, r24
    2ab0:	7e 97       	sbiw	r30, 0x1e	; 30
    2ab2:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2ab4:	fc 01       	movw	r30, r24
    2ab6:	7f 97       	sbiw	r30, 0x1f	; 31
    2ab8:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2aba:	fc 01       	movw	r30, r24
    2abc:	b0 97       	sbiw	r30, 0x20	; 32
    2abe:	26 e2       	ldi	r18, 0x26	; 38
    2ac0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	b1 97       	sbiw	r30, 0x21	; 33
    2ac6:	27 e2       	ldi	r18, 0x27	; 39
    2ac8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2aca:	fc 01       	movw	r30, r24
    2acc:	b2 97       	sbiw	r30, 0x22	; 34
    2ace:	28 e2       	ldi	r18, 0x28	; 40
    2ad0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2ad2:	fc 01       	movw	r30, r24
    2ad4:	b3 97       	sbiw	r30, 0x23	; 35
    2ad6:	29 e2       	ldi	r18, 0x29	; 41
    2ad8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2ada:	fc 01       	movw	r30, r24
    2adc:	b4 97       	sbiw	r30, 0x24	; 36
    2ade:	20 e3       	ldi	r18, 0x30	; 48
    2ae0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2ae2:	fc 01       	movw	r30, r24
    2ae4:	b5 97       	sbiw	r30, 0x25	; 37
    2ae6:	21 e3       	ldi	r18, 0x31	; 49
    2ae8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2aea:	86 97       	sbiw	r24, 0x26	; 38
}
    2aec:	08 95       	ret

00002aee <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2aee:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    2af0:	89 ef       	ldi	r24, 0xF9	; 249
    2af2:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2af4:	8b e0       	ldi	r24, 0x0B	; 11
    2af6:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2af8:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2afa:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    2afc:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2afe:	a0 91 04 05 	lds	r26, 0x0504
    2b02:	b0 91 05 05 	lds	r27, 0x0505
    2b06:	cd 91       	ld	r28, X+
    2b08:	cd bf       	out	0x3d, r28	; 61
    2b0a:	dd 91       	ld	r29, X+
    2b0c:	de bf       	out	0x3e, r29	; 62
    2b0e:	ff 91       	pop	r31
    2b10:	ef 91       	pop	r30
    2b12:	df 91       	pop	r29
    2b14:	cf 91       	pop	r28
    2b16:	bf 91       	pop	r27
    2b18:	af 91       	pop	r26
    2b1a:	9f 91       	pop	r25
    2b1c:	8f 91       	pop	r24
    2b1e:	7f 91       	pop	r23
    2b20:	6f 91       	pop	r22
    2b22:	5f 91       	pop	r21
    2b24:	4f 91       	pop	r20
    2b26:	3f 91       	pop	r19
    2b28:	2f 91       	pop	r18
    2b2a:	1f 91       	pop	r17
    2b2c:	0f 91       	pop	r16
    2b2e:	ff 90       	pop	r15
    2b30:	ef 90       	pop	r14
    2b32:	df 90       	pop	r13
    2b34:	cf 90       	pop	r12
    2b36:	bf 90       	pop	r11
    2b38:	af 90       	pop	r10
    2b3a:	9f 90       	pop	r9
    2b3c:	8f 90       	pop	r8
    2b3e:	7f 90       	pop	r7
    2b40:	6f 90       	pop	r6
    2b42:	5f 90       	pop	r5
    2b44:	4f 90       	pop	r4
    2b46:	3f 90       	pop	r3
    2b48:	2f 90       	pop	r2
    2b4a:	1f 90       	pop	r1
    2b4c:	0f 90       	pop	r0
    2b4e:	0f be       	out	0x3f, r0	; 63
    2b50:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2b52:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2b54:	81 e0       	ldi	r24, 0x01	; 1
    2b56:	08 95       	ret

00002b58 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2b58:	08 95       	ret

00002b5a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2b5a:	0f 92       	push	r0
    2b5c:	0f b6       	in	r0, 0x3f	; 63
    2b5e:	f8 94       	cli
    2b60:	0f 92       	push	r0
    2b62:	1f 92       	push	r1
    2b64:	11 24       	eor	r1, r1
    2b66:	2f 92       	push	r2
    2b68:	3f 92       	push	r3
    2b6a:	4f 92       	push	r4
    2b6c:	5f 92       	push	r5
    2b6e:	6f 92       	push	r6
    2b70:	7f 92       	push	r7
    2b72:	8f 92       	push	r8
    2b74:	9f 92       	push	r9
    2b76:	af 92       	push	r10
    2b78:	bf 92       	push	r11
    2b7a:	cf 92       	push	r12
    2b7c:	df 92       	push	r13
    2b7e:	ef 92       	push	r14
    2b80:	ff 92       	push	r15
    2b82:	0f 93       	push	r16
    2b84:	1f 93       	push	r17
    2b86:	2f 93       	push	r18
    2b88:	3f 93       	push	r19
    2b8a:	4f 93       	push	r20
    2b8c:	5f 93       	push	r21
    2b8e:	6f 93       	push	r22
    2b90:	7f 93       	push	r23
    2b92:	8f 93       	push	r24
    2b94:	9f 93       	push	r25
    2b96:	af 93       	push	r26
    2b98:	bf 93       	push	r27
    2b9a:	cf 93       	push	r28
    2b9c:	df 93       	push	r29
    2b9e:	ef 93       	push	r30
    2ba0:	ff 93       	push	r31
    2ba2:	a0 91 04 05 	lds	r26, 0x0504
    2ba6:	b0 91 05 05 	lds	r27, 0x0505
    2baa:	0d b6       	in	r0, 0x3d	; 61
    2bac:	0d 92       	st	X+, r0
    2bae:	0e b6       	in	r0, 0x3e	; 62
    2bb0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2bb2:	0e 94 a2 22 	call	0x4544	; 0x4544 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2bb6:	a0 91 04 05 	lds	r26, 0x0504
    2bba:	b0 91 05 05 	lds	r27, 0x0505
    2bbe:	cd 91       	ld	r28, X+
    2bc0:	cd bf       	out	0x3d, r28	; 61
    2bc2:	dd 91       	ld	r29, X+
    2bc4:	de bf       	out	0x3e, r29	; 62
    2bc6:	ff 91       	pop	r31
    2bc8:	ef 91       	pop	r30
    2bca:	df 91       	pop	r29
    2bcc:	cf 91       	pop	r28
    2bce:	bf 91       	pop	r27
    2bd0:	af 91       	pop	r26
    2bd2:	9f 91       	pop	r25
    2bd4:	8f 91       	pop	r24
    2bd6:	7f 91       	pop	r23
    2bd8:	6f 91       	pop	r22
    2bda:	5f 91       	pop	r21
    2bdc:	4f 91       	pop	r20
    2bde:	3f 91       	pop	r19
    2be0:	2f 91       	pop	r18
    2be2:	1f 91       	pop	r17
    2be4:	0f 91       	pop	r16
    2be6:	ff 90       	pop	r15
    2be8:	ef 90       	pop	r14
    2bea:	df 90       	pop	r13
    2bec:	cf 90       	pop	r12
    2bee:	bf 90       	pop	r11
    2bf0:	af 90       	pop	r10
    2bf2:	9f 90       	pop	r9
    2bf4:	8f 90       	pop	r8
    2bf6:	7f 90       	pop	r7
    2bf8:	6f 90       	pop	r6
    2bfa:	5f 90       	pop	r5
    2bfc:	4f 90       	pop	r4
    2bfe:	3f 90       	pop	r3
    2c00:	2f 90       	pop	r2
    2c02:	1f 90       	pop	r1
    2c04:	0f 90       	pop	r0
    2c06:	0f be       	out	0x3f, r0	; 63
    2c08:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2c0a:	08 95       	ret

00002c0c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c0c:	0f 92       	push	r0
    2c0e:	0f b6       	in	r0, 0x3f	; 63
    2c10:	f8 94       	cli
    2c12:	0f 92       	push	r0
    2c14:	1f 92       	push	r1
    2c16:	11 24       	eor	r1, r1
    2c18:	2f 92       	push	r2
    2c1a:	3f 92       	push	r3
    2c1c:	4f 92       	push	r4
    2c1e:	5f 92       	push	r5
    2c20:	6f 92       	push	r6
    2c22:	7f 92       	push	r7
    2c24:	8f 92       	push	r8
    2c26:	9f 92       	push	r9
    2c28:	af 92       	push	r10
    2c2a:	bf 92       	push	r11
    2c2c:	cf 92       	push	r12
    2c2e:	df 92       	push	r13
    2c30:	ef 92       	push	r14
    2c32:	ff 92       	push	r15
    2c34:	0f 93       	push	r16
    2c36:	1f 93       	push	r17
    2c38:	2f 93       	push	r18
    2c3a:	3f 93       	push	r19
    2c3c:	4f 93       	push	r20
    2c3e:	5f 93       	push	r21
    2c40:	6f 93       	push	r22
    2c42:	7f 93       	push	r23
    2c44:	8f 93       	push	r24
    2c46:	9f 93       	push	r25
    2c48:	af 93       	push	r26
    2c4a:	bf 93       	push	r27
    2c4c:	cf 93       	push	r28
    2c4e:	df 93       	push	r29
    2c50:	ef 93       	push	r30
    2c52:	ff 93       	push	r31
    2c54:	a0 91 04 05 	lds	r26, 0x0504
    2c58:	b0 91 05 05 	lds	r27, 0x0505
    2c5c:	0d b6       	in	r0, 0x3d	; 61
    2c5e:	0d 92       	st	X+, r0
    2c60:	0e b6       	in	r0, 0x3e	; 62
    2c62:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2c64:	0e 94 50 21 	call	0x42a0	; 0x42a0 <xTaskIncrementTick>
    2c68:	88 23       	and	r24, r24
    2c6a:	11 f0       	breq	.+4      	; 0x2c70 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2c6c:	0e 94 a2 22 	call	0x4544	; 0x4544 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2c70:	a0 91 04 05 	lds	r26, 0x0504
    2c74:	b0 91 05 05 	lds	r27, 0x0505
    2c78:	cd 91       	ld	r28, X+
    2c7a:	cd bf       	out	0x3d, r28	; 61
    2c7c:	dd 91       	ld	r29, X+
    2c7e:	de bf       	out	0x3e, r29	; 62
    2c80:	ff 91       	pop	r31
    2c82:	ef 91       	pop	r30
    2c84:	df 91       	pop	r29
    2c86:	cf 91       	pop	r28
    2c88:	bf 91       	pop	r27
    2c8a:	af 91       	pop	r26
    2c8c:	9f 91       	pop	r25
    2c8e:	8f 91       	pop	r24
    2c90:	7f 91       	pop	r23
    2c92:	6f 91       	pop	r22
    2c94:	5f 91       	pop	r21
    2c96:	4f 91       	pop	r20
    2c98:	3f 91       	pop	r19
    2c9a:	2f 91       	pop	r18
    2c9c:	1f 91       	pop	r17
    2c9e:	0f 91       	pop	r16
    2ca0:	ff 90       	pop	r15
    2ca2:	ef 90       	pop	r14
    2ca4:	df 90       	pop	r13
    2ca6:	cf 90       	pop	r12
    2ca8:	bf 90       	pop	r11
    2caa:	af 90       	pop	r10
    2cac:	9f 90       	pop	r9
    2cae:	8f 90       	pop	r8
    2cb0:	7f 90       	pop	r7
    2cb2:	6f 90       	pop	r6
    2cb4:	5f 90       	pop	r5
    2cb6:	4f 90       	pop	r4
    2cb8:	3f 90       	pop	r3
    2cba:	2f 90       	pop	r2
    2cbc:	1f 90       	pop	r1
    2cbe:	0f 90       	pop	r0
    2cc0:	0f be       	out	0x3f, r0	; 63
    2cc2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2cc4:	08 95       	ret

00002cc6 <SIG_OUTPUT_COMPARE1A>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2cc6:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2cca:	18 95       	reti

00002ccc <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ccc:	0f b6       	in	r0, 0x3f	; 63
    2cce:	f8 94       	cli
    2cd0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2cd2:	fc 01       	movw	r30, r24
    2cd4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2cd6:	0f 90       	pop	r0
    2cd8:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
    2cda:	81 e0       	ldi	r24, 0x01	; 1
    2cdc:	91 11       	cpse	r25, r1
    2cde:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    2ce0:	08 95       	ret

00002ce2 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2ce2:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2ce4:	44 8d       	ldd	r20, Z+28	; 0x1c
    2ce6:	44 23       	and	r20, r20
    2ce8:	c1 f0       	breq	.+48     	; 0x2d1a <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2cea:	26 81       	ldd	r18, Z+6	; 0x06
    2cec:	37 81       	ldd	r19, Z+7	; 0x07
    2cee:	24 0f       	add	r18, r20
    2cf0:	31 1d       	adc	r19, r1
    2cf2:	37 83       	std	Z+7, r19	; 0x07
    2cf4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2cf6:	a4 81       	ldd	r26, Z+4	; 0x04
    2cf8:	b5 81       	ldd	r27, Z+5	; 0x05
    2cfa:	2a 17       	cp	r18, r26
    2cfc:	3b 07       	cpc	r19, r27
    2cfe:	20 f0       	brcs	.+8      	; 0x2d08 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2d00:	20 81       	ld	r18, Z
    2d02:	31 81       	ldd	r19, Z+1	; 0x01
    2d04:	37 83       	std	Z+7, r19	; 0x07
    2d06:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2d08:	36 81       	ldd	r19, Z+6	; 0x06
    2d0a:	27 81       	ldd	r18, Z+7	; 0x07
    2d0c:	86 2f       	mov	r24, r22
    2d0e:	97 2f       	mov	r25, r23
    2d10:	63 2f       	mov	r22, r19
    2d12:	72 2f       	mov	r23, r18
    2d14:	50 e0       	ldi	r21, 0x00	; 0
    2d16:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>
    2d1a:	08 95       	ret

00002d1c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2d1c:	0f 93       	push	r16
    2d1e:	1f 93       	push	r17
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	ec 01       	movw	r28, r24
    2d26:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2d28:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2d2a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2d2c:	44 23       	and	r20, r20
    2d2e:	b9 f1       	breq	.+110    	; 0x2d9e <prvCopyDataToQueue+0x82>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2d30:	11 23       	and	r17, r17
    2d32:	b1 f4       	brne	.+44     	; 0x2d60 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2d34:	8a 81       	ldd	r24, Y+2	; 0x02
    2d36:	9b 81       	ldd	r25, Y+3	; 0x03
    2d38:	50 e0       	ldi	r21, 0x00	; 0
    2d3a:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2d3e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2d40:	8a 81       	ldd	r24, Y+2	; 0x02
    2d42:	9b 81       	ldd	r25, Y+3	; 0x03
    2d44:	82 0f       	add	r24, r18
    2d46:	91 1d       	adc	r25, r1
    2d48:	9b 83       	std	Y+3, r25	; 0x03
    2d4a:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2d4c:	2c 81       	ldd	r18, Y+4	; 0x04
    2d4e:	3d 81       	ldd	r19, Y+5	; 0x05
    2d50:	82 17       	cp	r24, r18
    2d52:	93 07       	cpc	r25, r19
    2d54:	20 f1       	brcs	.+72     	; 0x2d9e <prvCopyDataToQueue+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2d56:	88 81       	ld	r24, Y
    2d58:	99 81       	ldd	r25, Y+1	; 0x01
    2d5a:	9b 83       	std	Y+3, r25	; 0x03
    2d5c:	8a 83       	std	Y+2, r24	; 0x02
    2d5e:	1f c0       	rjmp	.+62     	; 0x2d9e <prvCopyDataToQueue+0x82>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2d60:	8e 81       	ldd	r24, Y+6	; 0x06
    2d62:	9f 81       	ldd	r25, Y+7	; 0x07
    2d64:	50 e0       	ldi	r21, 0x00	; 0
    2d66:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2d6a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2d6c:	50 e0       	ldi	r21, 0x00	; 0
    2d6e:	50 95       	com	r21
    2d70:	41 95       	neg	r20
    2d72:	5f 4f       	sbci	r21, 0xFF	; 255
    2d74:	8e 81       	ldd	r24, Y+6	; 0x06
    2d76:	9f 81       	ldd	r25, Y+7	; 0x07
    2d78:	84 0f       	add	r24, r20
    2d7a:	95 1f       	adc	r25, r21
    2d7c:	9f 83       	std	Y+7, r25	; 0x07
    2d7e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2d80:	28 81       	ld	r18, Y
    2d82:	39 81       	ldd	r19, Y+1	; 0x01
    2d84:	82 17       	cp	r24, r18
    2d86:	93 07       	cpc	r25, r19
    2d88:	30 f4       	brcc	.+12     	; 0x2d96 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2d8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2d8e:	84 0f       	add	r24, r20
    2d90:	95 1f       	adc	r25, r21
    2d92:	9f 83       	std	Y+7, r25	; 0x07
    2d94:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2d96:	12 30       	cpi	r17, 0x02	; 2
    2d98:	11 f4       	brne	.+4      	; 0x2d9e <prvCopyDataToQueue+0x82>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d9a:	01 11       	cpse	r16, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2d9c:	01 50       	subi	r16, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2d9e:	0f 5f       	subi	r16, 0xFF	; 255
    2da0:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
    2da2:	80 e0       	ldi	r24, 0x00	; 0
    2da4:	df 91       	pop	r29
    2da6:	cf 91       	pop	r28
    2da8:	1f 91       	pop	r17
    2daa:	0f 91       	pop	r16
    2dac:	08 95       	ret

00002dae <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2dae:	ef 92       	push	r14
    2db0:	ff 92       	push	r15
    2db2:	0f 93       	push	r16
    2db4:	1f 93       	push	r17
    2db6:	cf 93       	push	r28
    2db8:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2dba:	0f b6       	in	r0, 0x3f	; 63
    2dbc:	f8 94       	cli
    2dbe:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2dc0:	fc 01       	movw	r30, r24
    2dc2:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2dc4:	1c 16       	cp	r1, r28
    2dc6:	cc f4       	brge	.+50     	; 0x2dfa <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2dc8:	81 89       	ldd	r24, Z+17	; 0x11
    2dca:	88 23       	and	r24, r24
    2dcc:	31 f4       	brne	.+12     	; 0x2dda <prvUnlockQueue+0x2c>
    2dce:	15 c0       	rjmp	.+42     	; 0x2dfa <prvUnlockQueue+0x4c>
    2dd0:	f8 01       	movw	r30, r16
    2dd2:	81 89       	ldd	r24, Z+17	; 0x11
    2dd4:	88 23       	and	r24, r24
    2dd6:	41 f4       	brne	.+16     	; 0x2de8 <prvUnlockQueue+0x3a>
    2dd8:	10 c0       	rjmp	.+32     	; 0x2dfa <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2dda:	0f 2e       	mov	r0, r31
    2ddc:	f1 e1       	ldi	r31, 0x11	; 17
    2dde:	ef 2e       	mov	r14, r31
    2de0:	ff 24       	eor	r15, r15
    2de2:	f0 2d       	mov	r31, r0
    2de4:	e0 0e       	add	r14, r16
    2de6:	f1 1e       	adc	r15, r17
    2de8:	c7 01       	movw	r24, r14
    2dea:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    2dee:	88 23       	and	r24, r24
    2df0:	11 f0       	breq	.+4      	; 0x2df6 <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2df2:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2df6:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2df8:	59 f7       	brne	.-42     	; 0x2dd0 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2dfa:	8f ef       	ldi	r24, 0xFF	; 255
    2dfc:	f8 01       	movw	r30, r16
    2dfe:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2e00:	0f 90       	pop	r0
    2e02:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2e04:	0f b6       	in	r0, 0x3f	; 63
    2e06:	f8 94       	cli
    2e08:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2e0a:	f8 01       	movw	r30, r16
    2e0c:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2e0e:	1c 16       	cp	r1, r28
    2e10:	c4 f4       	brge	.+48     	; 0x2e42 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e12:	80 85       	ldd	r24, Z+8	; 0x08
    2e14:	88 23       	and	r24, r24
    2e16:	31 f4       	brne	.+12     	; 0x2e24 <prvUnlockQueue+0x76>
    2e18:	14 c0       	rjmp	.+40     	; 0x2e42 <prvUnlockQueue+0x94>
    2e1a:	f8 01       	movw	r30, r16
    2e1c:	80 85       	ldd	r24, Z+8	; 0x08
    2e1e:	88 23       	and	r24, r24
    2e20:	39 f4       	brne	.+14     	; 0x2e30 <prvUnlockQueue+0x82>
    2e22:	0f c0       	rjmp	.+30     	; 0x2e42 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e24:	ee 24       	eor	r14, r14
    2e26:	ff 24       	eor	r15, r15
    2e28:	68 94       	set
    2e2a:	e3 f8       	bld	r14, 3
    2e2c:	e0 0e       	add	r14, r16
    2e2e:	f1 1e       	adc	r15, r17
    2e30:	c7 01       	movw	r24, r14
    2e32:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    2e36:	88 23       	and	r24, r24
    2e38:	11 f0       	breq	.+4      	; 0x2e3e <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
    2e3a:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2e3e:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2e40:	61 f7       	brne	.-40     	; 0x2e1a <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2e42:	8f ef       	ldi	r24, 0xFF	; 255
    2e44:	f8 01       	movw	r30, r16
    2e46:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2e48:	0f 90       	pop	r0
    2e4a:	0f be       	out	0x3f, r0	; 63
}
    2e4c:	cf 91       	pop	r28
    2e4e:	1f 91       	pop	r17
    2e50:	0f 91       	pop	r16
    2e52:	ff 90       	pop	r15
    2e54:	ef 90       	pop	r14
    2e56:	08 95       	ret

00002e58 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2e58:	cf 93       	push	r28
    2e5a:	df 93       	push	r29
    2e5c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2e5e:	0f b6       	in	r0, 0x3f	; 63
    2e60:	f8 94       	cli
    2e62:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2e64:	48 81       	ld	r20, Y
    2e66:	59 81       	ldd	r21, Y+1	; 0x01
    2e68:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2e6a:	ec 8d       	ldd	r30, Y+28	; 0x1c
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	f0 e0       	ldi	r31, 0x00	; 0
    2e70:	2e 9f       	mul	r18, r30
    2e72:	c0 01       	movw	r24, r0
    2e74:	2f 9f       	mul	r18, r31
    2e76:	90 0d       	add	r25, r0
    2e78:	3e 9f       	mul	r19, r30
    2e7a:	90 0d       	add	r25, r0
    2e7c:	11 24       	eor	r1, r1
    2e7e:	84 0f       	add	r24, r20
    2e80:	95 1f       	adc	r25, r21
    2e82:	9d 83       	std	Y+5, r25	; 0x05
    2e84:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2e86:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2e88:	5b 83       	std	Y+3, r21	; 0x03
    2e8a:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2e8c:	c9 01       	movw	r24, r18
    2e8e:	01 97       	sbiw	r24, 0x01	; 1
    2e90:	8e 9f       	mul	r24, r30
    2e92:	90 01       	movw	r18, r0
    2e94:	8f 9f       	mul	r24, r31
    2e96:	30 0d       	add	r19, r0
    2e98:	9e 9f       	mul	r25, r30
    2e9a:	30 0d       	add	r19, r0
    2e9c:	11 24       	eor	r1, r1
    2e9e:	24 0f       	add	r18, r20
    2ea0:	35 1f       	adc	r19, r21
    2ea2:	3f 83       	std	Y+7, r19	; 0x07
    2ea4:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2ea6:	8f ef       	ldi	r24, 0xFF	; 255
    2ea8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2eaa:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2eac:	66 23       	and	r22, r22
    2eae:	61 f4       	brne	.+24     	; 0x2ec8 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2eb0:	88 85       	ldd	r24, Y+8	; 0x08
    2eb2:	88 23       	and	r24, r24
    2eb4:	89 f0       	breq	.+34     	; 0x2ed8 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2eb6:	ce 01       	movw	r24, r28
    2eb8:	08 96       	adiw	r24, 0x08	; 8
    2eba:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    2ebe:	88 23       	and	r24, r24
    2ec0:	59 f0       	breq	.+22     	; 0x2ed8 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2ec2:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    2ec6:	08 c0       	rjmp	.+16     	; 0x2ed8 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2ec8:	ce 01       	movw	r24, r28
    2eca:	08 96       	adiw	r24, 0x08	; 8
    2ecc:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2ed0:	ce 01       	movw	r24, r28
    2ed2:	41 96       	adiw	r24, 0x11	; 17
    2ed4:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2ed8:	0f 90       	pop	r0
    2eda:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    2edc:	81 e0       	ldi	r24, 0x01	; 1
    2ede:	df 91       	pop	r29
    2ee0:	cf 91       	pop	r28
    2ee2:	08 95       	ret

00002ee4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2ee4:	0f 93       	push	r16
    2ee6:	1f 93       	push	r17
    2ee8:	cf 93       	push	r28
    2eea:	df 93       	push	r29
    2eec:	08 2f       	mov	r16, r24
    2eee:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2ef0:	66 23       	and	r22, r22
    2ef2:	21 f0       	breq	.+8      	; 0x2efc <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2ef4:	68 9f       	mul	r22, r24
    2ef6:	c0 01       	movw	r24, r0
    2ef8:	11 24       	eor	r1, r1
    2efa:	02 c0       	rjmp	.+4      	; 0x2f00 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    2efc:	80 e0       	ldi	r24, 0x00	; 0
    2efe:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2f00:	4f 96       	adiw	r24, 0x1f	; 31
    2f02:	0e 94 16 14 	call	0x282c	; 0x282c <pvPortMalloc>
    2f06:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    2f08:	00 97       	sbiw	r24, 0x00	; 0
    2f0a:	71 f0       	breq	.+28     	; 0x2f28 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2f0c:	11 23       	and	r17, r17
    2f0e:	19 f4       	brne	.+6      	; 0x2f16 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2f10:	99 83       	std	Y+1, r25	; 0x01
    2f12:	88 83       	st	Y, r24
    2f14:	03 c0       	rjmp	.+6      	; 0x2f1c <xQueueGenericCreate+0x38>
		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f16:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2f18:	99 83       	std	Y+1, r25	; 0x01
    2f1a:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    2f1c:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2f1e:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2f20:	ce 01       	movw	r24, r28
    2f22:	61 e0       	ldi	r22, 0x01	; 1
    2f24:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    2f28:	8c 2f       	mov	r24, r28
    2f2a:	9d 2f       	mov	r25, r29
    2f2c:	df 91       	pop	r29
    2f2e:	cf 91       	pop	r28
    2f30:	1f 91       	pop	r17
    2f32:	0f 91       	pop	r16
    2f34:	08 95       	ret

00002f36 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2f36:	8f 92       	push	r8
    2f38:	9f 92       	push	r9
    2f3a:	bf 92       	push	r11
    2f3c:	cf 92       	push	r12
    2f3e:	df 92       	push	r13
    2f40:	ef 92       	push	r14
    2f42:	ff 92       	push	r15
    2f44:	0f 93       	push	r16
    2f46:	1f 93       	push	r17
    2f48:	cf 93       	push	r28
    2f4a:	df 93       	push	r29
    2f4c:	00 d0       	rcall	.+0      	; 0x2f4e <xQueueGenericSend+0x18>
    2f4e:	00 d0       	rcall	.+0      	; 0x2f50 <xQueueGenericSend+0x1a>
    2f50:	0f 92       	push	r0
    2f52:	cd b7       	in	r28, 0x3d	; 61
    2f54:	de b7       	in	r29, 0x3e	; 62
    2f56:	8c 01       	movw	r16, r24
    2f58:	4b 01       	movw	r8, r22
    2f5a:	5d 83       	std	Y+5, r21	; 0x05
    2f5c:	4c 83       	std	Y+4, r20	; 0x04
    2f5e:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2f60:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2f62:	bb 24       	eor	r11, r11
    2f64:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2f66:	cc 24       	eor	r12, r12
    2f68:	dd 24       	eor	r13, r13
    2f6a:	68 94       	set
    2f6c:	c3 f8       	bld	r12, 3
    2f6e:	c8 0e       	add	r12, r24
    2f70:	d9 1e       	adc	r13, r25
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2f72:	0f b6       	in	r0, 0x3f	; 63
    2f74:	f8 94       	cli
    2f76:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2f78:	f8 01       	movw	r30, r16
    2f7a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f7e:	98 17       	cp	r25, r24
    2f80:	18 f0       	brcs	.+6      	; 0x2f88 <xQueueGenericSend+0x52>
    2f82:	f2 e0       	ldi	r31, 0x02	; 2
    2f84:	ef 16       	cp	r14, r31
    2f86:	d1 f4       	brne	.+52     	; 0x2fbc <xQueueGenericSend+0x86>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2f88:	c8 01       	movw	r24, r16
    2f8a:	b4 01       	movw	r22, r8
    2f8c:	4e 2d       	mov	r20, r14
    2f8e:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f92:	f8 01       	movw	r30, r16
    2f94:	91 89       	ldd	r25, Z+17	; 0x11
    2f96:	99 23       	and	r25, r25
    2f98:	49 f0       	breq	.+18     	; 0x2fac <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f9a:	c8 01       	movw	r24, r16
    2f9c:	41 96       	adiw	r24, 0x11	; 17
    2f9e:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    2fa2:	88 23       	and	r24, r24
    2fa4:	39 f0       	breq	.+14     	; 0x2fb4 <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2fa6:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    2faa:	04 c0       	rjmp	.+8      	; 0x2fb4 <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2fac:	88 23       	and	r24, r24
    2fae:	11 f0       	breq	.+4      	; 0x2fb4 <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2fb0:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2fb4:	0f 90       	pop	r0
    2fb6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	52 c0       	rjmp	.+164    	; 0x3060 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2fbc:	8c 81       	ldd	r24, Y+4	; 0x04
    2fbe:	9d 81       	ldd	r25, Y+5	; 0x05
    2fc0:	00 97       	sbiw	r24, 0x00	; 0
    2fc2:	21 f4       	brne	.+8      	; 0x2fcc <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2fc4:	0f 90       	pop	r0
    2fc6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2fc8:	80 e0       	ldi	r24, 0x00	; 0
    2fca:	4a c0       	rjmp	.+148    	; 0x3060 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    2fcc:	ff 20       	and	r15, r15
    2fce:	29 f4       	brne	.+10     	; 0x2fda <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2fd0:	ce 01       	movw	r24, r28
    2fd2:	01 96       	adiw	r24, 0x01	; 1
    2fd4:	0e 94 bc 23 	call	0x4778	; 0x4778 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2fd8:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2fda:	0f 90       	pop	r0
    2fdc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2fde:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2fe2:	0f b6       	in	r0, 0x3f	; 63
    2fe4:	f8 94       	cli
    2fe6:	0f 92       	push	r0
    2fe8:	f8 01       	movw	r30, r16
    2fea:	85 8d       	ldd	r24, Z+29	; 0x1d
    2fec:	8f 3f       	cpi	r24, 0xFF	; 255
    2fee:	09 f4       	brne	.+2      	; 0x2ff2 <xQueueGenericSend+0xbc>
    2ff0:	15 8e       	std	Z+29, r1	; 0x1d
    2ff2:	f8 01       	movw	r30, r16
    2ff4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ff6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ff8:	09 f4       	brne	.+2      	; 0x2ffc <xQueueGenericSend+0xc6>
    2ffa:	16 8e       	std	Z+30, r1	; 0x1e
    2ffc:	0f 90       	pop	r0
    2ffe:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3000:	ce 01       	movw	r24, r28
    3002:	01 96       	adiw	r24, 0x01	; 1
    3004:	be 01       	movw	r22, r28
    3006:	6c 5f       	subi	r22, 0xFC	; 252
    3008:	7f 4f       	sbci	r23, 0xFF	; 255
    300a:	0e 94 c7 23 	call	0x478e	; 0x478e <xTaskCheckForTimeOut>
    300e:	88 23       	and	r24, r24
    3010:	09 f5       	brne	.+66     	; 0x3054 <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3012:	0f b6       	in	r0, 0x3f	; 63
    3014:	f8 94       	cli
    3016:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3018:	f8 01       	movw	r30, r16
    301a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    301c:	0f 90       	pop	r0
    301e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3020:	f8 01       	movw	r30, r16
    3022:	83 8d       	ldd	r24, Z+27	; 0x1b
    3024:	98 17       	cp	r25, r24
    3026:	81 f4       	brne	.+32     	; 0x3048 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3028:	6c 81       	ldd	r22, Y+4	; 0x04
    302a:	7d 81       	ldd	r23, Y+5	; 0x05
    302c:	c6 01       	movw	r24, r12
    302e:	0e 94 fe 22 	call	0x45fc	; 0x45fc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3032:	c8 01       	movw	r24, r16
    3034:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3038:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    303c:	88 23       	and	r24, r24
    303e:	09 f0       	breq	.+2      	; 0x3042 <xQueueGenericSend+0x10c>
    3040:	98 cf       	rjmp	.-208    	; 0x2f72 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    3042:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    3046:	95 cf       	rjmp	.-214    	; 0x2f72 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3048:	c8 01       	movw	r24, r16
    304a:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    304e:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    3052:	8f cf       	rjmp	.-226    	; 0x2f72 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3054:	c8 01       	movw	r24, r16
    3056:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    305a:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    305e:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    3060:	0f 90       	pop	r0
    3062:	0f 90       	pop	r0
    3064:	0f 90       	pop	r0
    3066:	0f 90       	pop	r0
    3068:	0f 90       	pop	r0
    306a:	df 91       	pop	r29
    306c:	cf 91       	pop	r28
    306e:	1f 91       	pop	r17
    3070:	0f 91       	pop	r16
    3072:	ff 90       	pop	r15
    3074:	ef 90       	pop	r14
    3076:	df 90       	pop	r13
    3078:	cf 90       	pop	r12
    307a:	bf 90       	pop	r11
    307c:	9f 90       	pop	r9
    307e:	8f 90       	pop	r8
    3080:	08 95       	ret

00003082 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3082:	ef 92       	push	r14
    3084:	ff 92       	push	r15
    3086:	0f 93       	push	r16
    3088:	1f 93       	push	r17
    308a:	cf 93       	push	r28
    308c:	8c 01       	movw	r16, r24
    308e:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3090:	fc 01       	movw	r30, r24
    3092:	92 8d       	ldd	r25, Z+26	; 0x1a
    3094:	83 8d       	ldd	r24, Z+27	; 0x1b
    3096:	98 17       	cp	r25, r24
    3098:	10 f0       	brcs	.+4      	; 0x309e <xQueueGenericSendFromISR+0x1c>
    309a:	22 30       	cpi	r18, 0x02	; 2
    309c:	f1 f4       	brne	.+60     	; 0x30da <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    309e:	f8 01       	movw	r30, r16
    30a0:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    30a2:	c8 01       	movw	r24, r16
    30a4:	42 2f       	mov	r20, r18
    30a6:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    30aa:	cf 3f       	cpi	r28, 0xFF	; 255
    30ac:	89 f4       	brne	.+34     	; 0x30d0 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30ae:	f8 01       	movw	r30, r16
    30b0:	81 89       	ldd	r24, Z+17	; 0x11
    30b2:	88 23       	and	r24, r24
    30b4:	a1 f0       	breq	.+40     	; 0x30de <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30b6:	c8 01       	movw	r24, r16
    30b8:	41 96       	adiw	r24, 0x11	; 17
    30ba:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    30be:	88 23       	and	r24, r24
    30c0:	81 f0       	breq	.+32     	; 0x30e2 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    30c2:	e1 14       	cp	r14, r1
    30c4:	f1 04       	cpc	r15, r1
    30c6:	79 f0       	breq	.+30     	; 0x30e6 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	f7 01       	movw	r30, r14
    30cc:	80 83       	st	Z, r24
    30ce:	0c c0       	rjmp	.+24     	; 0x30e8 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    30d0:	cf 5f       	subi	r28, 0xFF	; 255
    30d2:	f8 01       	movw	r30, r16
    30d4:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    30d6:	81 e0       	ldi	r24, 0x01	; 1
    30d8:	07 c0       	rjmp	.+14     	; 0x30e8 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    30da:	80 e0       	ldi	r24, 0x00	; 0
    30dc:	05 c0       	rjmp	.+10     	; 0x30e8 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    30de:	81 e0       	ldi	r24, 0x01	; 1
    30e0:	03 c0       	rjmp	.+6      	; 0x30e8 <xQueueGenericSendFromISR+0x66>
    30e2:	81 e0       	ldi	r24, 0x01	; 1
    30e4:	01 c0       	rjmp	.+2      	; 0x30e8 <xQueueGenericSendFromISR+0x66>
    30e6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    30e8:	cf 91       	pop	r28
    30ea:	1f 91       	pop	r17
    30ec:	0f 91       	pop	r16
    30ee:	ff 90       	pop	r15
    30f0:	ef 90       	pop	r14
    30f2:	08 95       	ret

000030f4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    30f4:	cf 93       	push	r28
    30f6:	df 93       	push	r29
    30f8:	fc 01       	movw	r30, r24
    30fa:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    30fc:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    30fe:	93 8d       	ldd	r25, Z+27	; 0x1b
    3100:	89 17       	cp	r24, r25
    3102:	b8 f4       	brcc	.+46     	; 0x3132 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3104:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3106:	8f 5f       	subi	r24, 0xFF	; 255
    3108:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    310a:	9f 3f       	cpi	r25, 0xFF	; 255
    310c:	71 f4       	brne	.+28     	; 0x312a <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    310e:	81 89       	ldd	r24, Z+17	; 0x11
    3110:	88 23       	and	r24, r24
    3112:	89 f0       	breq	.+34     	; 0x3136 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3114:	cf 01       	movw	r24, r30
    3116:	41 96       	adiw	r24, 0x11	; 17
    3118:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    311c:	88 23       	and	r24, r24
    311e:	69 f0       	breq	.+26     	; 0x313a <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3120:	20 97       	sbiw	r28, 0x00	; 0
    3122:	69 f0       	breq	.+26     	; 0x313e <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	88 83       	st	Y, r24
    3128:	0b c0       	rjmp	.+22     	; 0x3140 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    312a:	9f 5f       	subi	r25, 0xFF	; 255
    312c:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    312e:	81 e0       	ldi	r24, 0x01	; 1
    3130:	07 c0       	rjmp	.+14     	; 0x3140 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3132:	80 e0       	ldi	r24, 0x00	; 0
    3134:	05 c0       	rjmp	.+10     	; 0x3140 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    3136:	81 e0       	ldi	r24, 0x01	; 1
    3138:	03 c0       	rjmp	.+6      	; 0x3140 <xQueueGiveFromISR+0x4c>
    313a:	81 e0       	ldi	r24, 0x01	; 1
    313c:	01 c0       	rjmp	.+2      	; 0x3140 <xQueueGiveFromISR+0x4c>
    313e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3140:	df 91       	pop	r29
    3142:	cf 91       	pop	r28
    3144:	08 95       	ret

00003146 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3146:	8f 92       	push	r8
    3148:	9f 92       	push	r9
    314a:	af 92       	push	r10
    314c:	bf 92       	push	r11
    314e:	df 92       	push	r13
    3150:	ef 92       	push	r14
    3152:	ff 92       	push	r15
    3154:	0f 93       	push	r16
    3156:	1f 93       	push	r17
    3158:	cf 93       	push	r28
    315a:	df 93       	push	r29
    315c:	00 d0       	rcall	.+0      	; 0x315e <xQueueReceive+0x18>
    315e:	00 d0       	rcall	.+0      	; 0x3160 <xQueueReceive+0x1a>
    3160:	0f 92       	push	r0
    3162:	cd b7       	in	r28, 0x3d	; 61
    3164:	de b7       	in	r29, 0x3e	; 62
    3166:	7c 01       	movw	r14, r24
    3168:	4b 01       	movw	r8, r22
    316a:	5d 83       	std	Y+5, r21	; 0x05
    316c:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    316e:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3170:	dd 24       	eor	r13, r13
    3172:	d3 94       	inc	r13
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3174:	0f 2e       	mov	r0, r31
    3176:	f1 e1       	ldi	r31, 0x11	; 17
    3178:	af 2e       	mov	r10, r31
    317a:	bb 24       	eor	r11, r11
    317c:	f0 2d       	mov	r31, r0
    317e:	a8 0e       	add	r10, r24
    3180:	b9 1e       	adc	r11, r25
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3182:	0f b6       	in	r0, 0x3f	; 63
    3184:	f8 94       	cli
    3186:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3188:	f7 01       	movw	r30, r14
    318a:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    318c:	11 23       	and	r17, r17
    318e:	b1 f0       	breq	.+44     	; 0x31bc <xQueueReceive+0x76>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3190:	c7 01       	movw	r24, r14
    3192:	b4 01       	movw	r22, r8
    3194:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3198:	11 50       	subi	r17, 0x01	; 1
    319a:	f7 01       	movw	r30, r14
    319c:	12 8f       	std	Z+26, r17	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    319e:	80 85       	ldd	r24, Z+8	; 0x08
    31a0:	88 23       	and	r24, r24
    31a2:	41 f0       	breq	.+16     	; 0x31b4 <xQueueReceive+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    31a4:	c7 01       	movw	r24, r14
    31a6:	08 96       	adiw	r24, 0x08	; 8
    31a8:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    31ac:	88 23       	and	r24, r24
    31ae:	11 f0       	breq	.+4      	; 0x31b4 <xQueueReceive+0x6e>
					{
						queueYIELD_IF_USING_PREEMPTION();
    31b0:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    31b4:	0f 90       	pop	r0
    31b6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    31b8:	81 e0       	ldi	r24, 0x01	; 1
    31ba:	52 c0       	rjmp	.+164    	; 0x3260 <xQueueReceive+0x11a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    31bc:	8c 81       	ldd	r24, Y+4	; 0x04
    31be:	9d 81       	ldd	r25, Y+5	; 0x05
    31c0:	00 97       	sbiw	r24, 0x00	; 0
    31c2:	21 f4       	brne	.+8      	; 0x31cc <xQueueReceive+0x86>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    31c4:	0f 90       	pop	r0
    31c6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    31c8:	80 e0       	ldi	r24, 0x00	; 0
    31ca:	4a c0       	rjmp	.+148    	; 0x3260 <xQueueReceive+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    31cc:	00 23       	and	r16, r16
    31ce:	29 f4       	brne	.+10     	; 0x31da <xQueueReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    31d0:	ce 01       	movw	r24, r28
    31d2:	01 96       	adiw	r24, 0x01	; 1
    31d4:	0e 94 bc 23 	call	0x4778	; 0x4778 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    31d8:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    31da:	0f 90       	pop	r0
    31dc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    31de:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    31e2:	0f b6       	in	r0, 0x3f	; 63
    31e4:	f8 94       	cli
    31e6:	0f 92       	push	r0
    31e8:	f7 01       	movw	r30, r14
    31ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    31ec:	8f 3f       	cpi	r24, 0xFF	; 255
    31ee:	09 f4       	brne	.+2      	; 0x31f2 <xQueueReceive+0xac>
    31f0:	15 8e       	std	Z+29, r1	; 0x1d
    31f2:	f7 01       	movw	r30, r14
    31f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    31f6:	8f 3f       	cpi	r24, 0xFF	; 255
    31f8:	09 f4       	brne	.+2      	; 0x31fc <xQueueReceive+0xb6>
    31fa:	16 8e       	std	Z+30, r1	; 0x1e
    31fc:	0f 90       	pop	r0
    31fe:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3200:	ce 01       	movw	r24, r28
    3202:	01 96       	adiw	r24, 0x01	; 1
    3204:	be 01       	movw	r22, r28
    3206:	6c 5f       	subi	r22, 0xFC	; 252
    3208:	7f 4f       	sbci	r23, 0xFF	; 255
    320a:	0e 94 c7 23 	call	0x478e	; 0x478e <xTaskCheckForTimeOut>
    320e:	88 23       	and	r24, r24
    3210:	d9 f4       	brne	.+54     	; 0x3248 <xQueueReceive+0x102>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3212:	c7 01       	movw	r24, r14
    3214:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <prvIsQueueEmpty>
    3218:	88 23       	and	r24, r24
    321a:	81 f0       	breq	.+32     	; 0x323c <xQueueReceive+0xf6>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    321c:	6c 81       	ldd	r22, Y+4	; 0x04
    321e:	7d 81       	ldd	r23, Y+5	; 0x05
    3220:	c5 01       	movw	r24, r10
    3222:	0e 94 fe 22 	call	0x45fc	; 0x45fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3226:	c7 01       	movw	r24, r14
    3228:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    322c:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    3230:	88 23       	and	r24, r24
    3232:	09 f0       	breq	.+2      	; 0x3236 <xQueueReceive+0xf0>
    3234:	a6 cf       	rjmp	.-180    	; 0x3182 <xQueueReceive+0x3c>
				{
					portYIELD_WITHIN_API();
    3236:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    323a:	a3 cf       	rjmp	.-186    	; 0x3182 <xQueueReceive+0x3c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    323c:	c7 01       	movw	r24, r14
    323e:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3242:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    3246:	9d cf       	rjmp	.-198    	; 0x3182 <xQueueReceive+0x3c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    3248:	c7 01       	movw	r24, r14
    324a:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    324e:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3252:	c7 01       	movw	r24, r14
    3254:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <prvIsQueueEmpty>
    3258:	88 23       	and	r24, r24
    325a:	09 f4       	brne	.+2      	; 0x325e <xQueueReceive+0x118>
    325c:	92 cf       	rjmp	.-220    	; 0x3182 <xQueueReceive+0x3c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    325e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3260:	0f 90       	pop	r0
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	0f 90       	pop	r0
    3268:	0f 90       	pop	r0
    326a:	df 91       	pop	r29
    326c:	cf 91       	pop	r28
    326e:	1f 91       	pop	r17
    3270:	0f 91       	pop	r16
    3272:	ff 90       	pop	r15
    3274:	ef 90       	pop	r14
    3276:	df 90       	pop	r13
    3278:	bf 90       	pop	r11
    327a:	af 90       	pop	r10
    327c:	9f 90       	pop	r9
    327e:	8f 90       	pop	r8
    3280:	08 95       	ret

00003282 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    3282:	cf 92       	push	r12
    3284:	df 92       	push	r13
    3286:	ef 92       	push	r14
    3288:	ff 92       	push	r15
    328a:	0f 93       	push	r16
    328c:	1f 93       	push	r17
    328e:	cf 93       	push	r28
    3290:	df 93       	push	r29
    3292:	00 d0       	rcall	.+0      	; 0x3294 <xQueueSemaphoreTake+0x12>
    3294:	00 d0       	rcall	.+0      	; 0x3296 <xQueueSemaphoreTake+0x14>
    3296:	0f 92       	push	r0
    3298:	cd b7       	in	r28, 0x3d	; 61
    329a:	de b7       	in	r29, 0x3e	; 62
    329c:	8c 01       	movw	r16, r24
    329e:	7d 83       	std	Y+5, r23	; 0x05
    32a0:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    32a2:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    32a4:	ee 24       	eor	r14, r14
    32a6:	e3 94       	inc	r14
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    32a8:	0f 2e       	mov	r0, r31
    32aa:	f1 e1       	ldi	r31, 0x11	; 17
    32ac:	cf 2e       	mov	r12, r31
    32ae:	dd 24       	eor	r13, r13
    32b0:	f0 2d       	mov	r31, r0
    32b2:	c8 0e       	add	r12, r24
    32b4:	d9 1e       	adc	r13, r25
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    32b6:	0f b6       	in	r0, 0x3f	; 63
    32b8:	f8 94       	cli
    32ba:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    32bc:	f8 01       	movw	r30, r16
    32be:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    32c0:	88 23       	and	r24, r24
    32c2:	89 f0       	breq	.+34     	; 0x32e6 <xQueueSemaphoreTake+0x64>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    32c4:	81 50       	subi	r24, 0x01	; 1
    32c6:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    32c8:	80 85       	ldd	r24, Z+8	; 0x08
    32ca:	88 23       	and	r24, r24
    32cc:	41 f0       	breq	.+16     	; 0x32de <xQueueSemaphoreTake+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    32ce:	c8 01       	movw	r24, r16
    32d0:	08 96       	adiw	r24, 0x08	; 8
    32d2:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    32d6:	88 23       	and	r24, r24
    32d8:	11 f0       	breq	.+4      	; 0x32de <xQueueSemaphoreTake+0x5c>
					{
						queueYIELD_IF_USING_PREEMPTION();
    32da:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    32de:	0f 90       	pop	r0
    32e0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    32e2:	81 e0       	ldi	r24, 0x01	; 1
    32e4:	52 c0       	rjmp	.+164    	; 0x338a <xQueueSemaphoreTake+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    32e6:	8c 81       	ldd	r24, Y+4	; 0x04
    32e8:	9d 81       	ldd	r25, Y+5	; 0x05
    32ea:	00 97       	sbiw	r24, 0x00	; 0
    32ec:	21 f4       	brne	.+8      	; 0x32f6 <xQueueSemaphoreTake+0x74>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    32ee:	0f 90       	pop	r0
    32f0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    32f2:	80 e0       	ldi	r24, 0x00	; 0
    32f4:	4a c0       	rjmp	.+148    	; 0x338a <xQueueSemaphoreTake+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
    32f6:	ff 20       	and	r15, r15
    32f8:	29 f4       	brne	.+10     	; 0x3304 <xQueueSemaphoreTake+0x82>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    32fa:	ce 01       	movw	r24, r28
    32fc:	01 96       	adiw	r24, 0x01	; 1
    32fe:	0e 94 bc 23 	call	0x4778	; 0x4778 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3302:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3304:	0f 90       	pop	r0
    3306:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    3308:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    330c:	0f b6       	in	r0, 0x3f	; 63
    330e:	f8 94       	cli
    3310:	0f 92       	push	r0
    3312:	f8 01       	movw	r30, r16
    3314:	85 8d       	ldd	r24, Z+29	; 0x1d
    3316:	8f 3f       	cpi	r24, 0xFF	; 255
    3318:	09 f4       	brne	.+2      	; 0x331c <xQueueSemaphoreTake+0x9a>
    331a:	15 8e       	std	Z+29, r1	; 0x1d
    331c:	f8 01       	movw	r30, r16
    331e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3320:	8f 3f       	cpi	r24, 0xFF	; 255
    3322:	09 f4       	brne	.+2      	; 0x3326 <xQueueSemaphoreTake+0xa4>
    3324:	16 8e       	std	Z+30, r1	; 0x1e
    3326:	0f 90       	pop	r0
    3328:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    332a:	ce 01       	movw	r24, r28
    332c:	01 96       	adiw	r24, 0x01	; 1
    332e:	be 01       	movw	r22, r28
    3330:	6c 5f       	subi	r22, 0xFC	; 252
    3332:	7f 4f       	sbci	r23, 0xFF	; 255
    3334:	0e 94 c7 23 	call	0x478e	; 0x478e <xTaskCheckForTimeOut>
    3338:	88 23       	and	r24, r24
    333a:	d9 f4       	brne	.+54     	; 0x3372 <xQueueSemaphoreTake+0xf0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    333c:	c8 01       	movw	r24, r16
    333e:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <prvIsQueueEmpty>
    3342:	88 23       	and	r24, r24
    3344:	81 f0       	breq	.+32     	; 0x3366 <xQueueSemaphoreTake+0xe4>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3346:	6c 81       	ldd	r22, Y+4	; 0x04
    3348:	7d 81       	ldd	r23, Y+5	; 0x05
    334a:	c6 01       	movw	r24, r12
    334c:	0e 94 fe 22 	call	0x45fc	; 0x45fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3350:	c8 01       	movw	r24, r16
    3352:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3356:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    335a:	88 23       	and	r24, r24
    335c:	09 f0       	breq	.+2      	; 0x3360 <xQueueSemaphoreTake+0xde>
    335e:	ab cf       	rjmp	.-170    	; 0x32b6 <xQueueSemaphoreTake+0x34>
				{
					portYIELD_WITHIN_API();
    3360:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    3364:	a8 cf       	rjmp	.-176    	; 0x32b6 <xQueueSemaphoreTake+0x34>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3366:	c8 01       	movw	r24, r16
    3368:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    336c:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    3370:	a2 cf       	rjmp	.-188    	; 0x32b6 <xQueueSemaphoreTake+0x34>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3372:	c8 01       	movw	r24, r16
    3374:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3378:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    337c:	c8 01       	movw	r24, r16
    337e:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <prvIsQueueEmpty>
    3382:	88 23       	and	r24, r24
    3384:	09 f4       	brne	.+2      	; 0x3388 <xQueueSemaphoreTake+0x106>
    3386:	97 cf       	rjmp	.-210    	; 0x32b6 <xQueueSemaphoreTake+0x34>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3388:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    338a:	0f 90       	pop	r0
    338c:	0f 90       	pop	r0
    338e:	0f 90       	pop	r0
    3390:	0f 90       	pop	r0
    3392:	0f 90       	pop	r0
    3394:	df 91       	pop	r29
    3396:	cf 91       	pop	r28
    3398:	1f 91       	pop	r17
    339a:	0f 91       	pop	r16
    339c:	ff 90       	pop	r15
    339e:	ef 90       	pop	r14
    33a0:	df 90       	pop	r13
    33a2:	cf 90       	pop	r12
    33a4:	08 95       	ret

000033a6 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    33a6:	af 92       	push	r10
    33a8:	bf 92       	push	r11
    33aa:	cf 92       	push	r12
    33ac:	df 92       	push	r13
    33ae:	ef 92       	push	r14
    33b0:	ff 92       	push	r15
    33b2:	0f 93       	push	r16
    33b4:	1f 93       	push	r17
    33b6:	cf 93       	push	r28
    33b8:	df 93       	push	r29
    33ba:	00 d0       	rcall	.+0      	; 0x33bc <xQueuePeek+0x16>
    33bc:	00 d0       	rcall	.+0      	; 0x33be <xQueuePeek+0x18>
    33be:	0f 92       	push	r0
    33c0:	cd b7       	in	r28, 0x3d	; 61
    33c2:	de b7       	in	r29, 0x3e	; 62
    33c4:	8c 01       	movw	r16, r24
    33c6:	5b 01       	movw	r10, r22
    33c8:	5d 83       	std	Y+5, r21	; 0x05
    33ca:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    33cc:	ff 24       	eor	r15, r15
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    33ce:	ee 24       	eor	r14, r14
    33d0:	e3 94       	inc	r14
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    33d2:	0f 2e       	mov	r0, r31
    33d4:	f1 e1       	ldi	r31, 0x11	; 17
    33d6:	cf 2e       	mov	r12, r31
    33d8:	dd 24       	eor	r13, r13
    33da:	f0 2d       	mov	r31, r0
    33dc:	c8 0e       	add	r12, r24
    33de:	d9 1e       	adc	r13, r25
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    33e0:	0f b6       	in	r0, 0x3f	; 63
    33e2:	f8 94       	cli
    33e4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    33e6:	f8 01       	movw	r30, r16
    33e8:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    33ea:	88 23       	and	r24, r24
    33ec:	c1 f0       	breq	.+48     	; 0x341e <xQueuePeek+0x78>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    33ee:	e6 80       	ldd	r14, Z+6	; 0x06
    33f0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    33f2:	c8 01       	movw	r24, r16
    33f4:	b5 01       	movw	r22, r10
    33f6:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    33fa:	f8 01       	movw	r30, r16
    33fc:	f7 82       	std	Z+7, r15	; 0x07
    33fe:	e6 82       	std	Z+6, r14	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3400:	81 89       	ldd	r24, Z+17	; 0x11
    3402:	88 23       	and	r24, r24
    3404:	41 f0       	breq	.+16     	; 0x3416 <xQueuePeek+0x70>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3406:	c8 01       	movw	r24, r16
    3408:	41 96       	adiw	r24, 0x11	; 17
    340a:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    340e:	88 23       	and	r24, r24
    3410:	11 f0       	breq	.+4      	; 0x3416 <xQueuePeek+0x70>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    3412:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3416:	0f 90       	pop	r0
    3418:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    341a:	81 e0       	ldi	r24, 0x01	; 1
    341c:	52 c0       	rjmp	.+164    	; 0x34c2 <xQueuePeek+0x11c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    341e:	8c 81       	ldd	r24, Y+4	; 0x04
    3420:	9d 81       	ldd	r25, Y+5	; 0x05
    3422:	00 97       	sbiw	r24, 0x00	; 0
    3424:	21 f4       	brne	.+8      	; 0x342e <xQueuePeek+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3426:	0f 90       	pop	r0
    3428:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    342a:	80 e0       	ldi	r24, 0x00	; 0
    342c:	4a c0       	rjmp	.+148    	; 0x34c2 <xQueuePeek+0x11c>
				}
				else if( xEntryTimeSet == pdFALSE )
    342e:	ff 20       	and	r15, r15
    3430:	29 f4       	brne	.+10     	; 0x343c <xQueuePeek+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3432:	ce 01       	movw	r24, r28
    3434:	01 96       	adiw	r24, 0x01	; 1
    3436:	0e 94 bc 23 	call	0x4778	; 0x4778 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    343a:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    343c:	0f 90       	pop	r0
    343e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3440:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	0f 92       	push	r0
    344a:	f8 01       	movw	r30, r16
    344c:	85 8d       	ldd	r24, Z+29	; 0x1d
    344e:	8f 3f       	cpi	r24, 0xFF	; 255
    3450:	09 f4       	brne	.+2      	; 0x3454 <xQueuePeek+0xae>
    3452:	15 8e       	std	Z+29, r1	; 0x1d
    3454:	f8 01       	movw	r30, r16
    3456:	86 8d       	ldd	r24, Z+30	; 0x1e
    3458:	8f 3f       	cpi	r24, 0xFF	; 255
    345a:	09 f4       	brne	.+2      	; 0x345e <xQueuePeek+0xb8>
    345c:	16 8e       	std	Z+30, r1	; 0x1e
    345e:	0f 90       	pop	r0
    3460:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3462:	ce 01       	movw	r24, r28
    3464:	01 96       	adiw	r24, 0x01	; 1
    3466:	be 01       	movw	r22, r28
    3468:	6c 5f       	subi	r22, 0xFC	; 252
    346a:	7f 4f       	sbci	r23, 0xFF	; 255
    346c:	0e 94 c7 23 	call	0x478e	; 0x478e <xTaskCheckForTimeOut>
    3470:	88 23       	and	r24, r24
    3472:	d9 f4       	brne	.+54     	; 0x34aa <xQueuePeek+0x104>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3474:	c8 01       	movw	r24, r16
    3476:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <prvIsQueueEmpty>
    347a:	88 23       	and	r24, r24
    347c:	81 f0       	breq	.+32     	; 0x349e <xQueuePeek+0xf8>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    347e:	6c 81       	ldd	r22, Y+4	; 0x04
    3480:	7d 81       	ldd	r23, Y+5	; 0x05
    3482:	c6 01       	movw	r24, r12
    3484:	0e 94 fe 22 	call	0x45fc	; 0x45fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3488:	c8 01       	movw	r24, r16
    348a:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    348e:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    3492:	88 23       	and	r24, r24
    3494:	09 f0       	breq	.+2      	; 0x3498 <xQueuePeek+0xf2>
    3496:	a4 cf       	rjmp	.-184    	; 0x33e0 <xQueuePeek+0x3a>
				{
					portYIELD_WITHIN_API();
    3498:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    349c:	a1 cf       	rjmp	.-190    	; 0x33e0 <xQueuePeek+0x3a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    349e:	c8 01       	movw	r24, r16
    34a0:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    34a4:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    34a8:	9b cf       	rjmp	.-202    	; 0x33e0 <xQueuePeek+0x3a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    34aa:	c8 01       	movw	r24, r16
    34ac:	0e 94 d7 16 	call	0x2dae	; 0x2dae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    34b0:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    34b4:	c8 01       	movw	r24, r16
    34b6:	0e 94 66 16 	call	0x2ccc	; 0x2ccc <prvIsQueueEmpty>
    34ba:	88 23       	and	r24, r24
    34bc:	09 f4       	brne	.+2      	; 0x34c0 <xQueuePeek+0x11a>
    34be:	90 cf       	rjmp	.-224    	; 0x33e0 <xQueuePeek+0x3a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    34c0:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    34c2:	0f 90       	pop	r0
    34c4:	0f 90       	pop	r0
    34c6:	0f 90       	pop	r0
    34c8:	0f 90       	pop	r0
    34ca:	0f 90       	pop	r0
    34cc:	df 91       	pop	r29
    34ce:	cf 91       	pop	r28
    34d0:	1f 91       	pop	r17
    34d2:	0f 91       	pop	r16
    34d4:	ff 90       	pop	r15
    34d6:	ef 90       	pop	r14
    34d8:	df 90       	pop	r13
    34da:	cf 90       	pop	r12
    34dc:	bf 90       	pop	r11
    34de:	af 90       	pop	r10
    34e0:	08 95       	ret

000034e2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    34e2:	ef 92       	push	r14
    34e4:	ff 92       	push	r15
    34e6:	0f 93       	push	r16
    34e8:	1f 93       	push	r17
    34ea:	cf 93       	push	r28
    34ec:	df 93       	push	r29
    34ee:	8c 01       	movw	r16, r24
    34f0:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34f2:	fc 01       	movw	r30, r24
    34f4:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    34f6:	cc 23       	and	r28, r28
    34f8:	e9 f0       	breq	.+58     	; 0x3534 <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    34fa:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    34fc:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3500:	c1 50       	subi	r28, 0x01	; 1
    3502:	f8 01       	movw	r30, r16
    3504:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3506:	df 3f       	cpi	r29, 0xFF	; 255
    3508:	81 f4       	brne	.+32     	; 0x352a <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    350a:	80 85       	ldd	r24, Z+8	; 0x08
    350c:	88 23       	and	r24, r24
    350e:	a1 f0       	breq	.+40     	; 0x3538 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3510:	c8 01       	movw	r24, r16
    3512:	08 96       	adiw	r24, 0x08	; 8
    3514:	0e 94 29 23 	call	0x4652	; 0x4652 <xTaskRemoveFromEventList>
    3518:	88 23       	and	r24, r24
    351a:	81 f0       	breq	.+32     	; 0x353c <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    351c:	e1 14       	cp	r14, r1
    351e:	f1 04       	cpc	r15, r1
    3520:	79 f0       	breq	.+30     	; 0x3540 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3522:	81 e0       	ldi	r24, 0x01	; 1
    3524:	f7 01       	movw	r30, r14
    3526:	80 83       	st	Z, r24
    3528:	0c c0       	rjmp	.+24     	; 0x3542 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    352a:	df 5f       	subi	r29, 0xFF	; 255
    352c:	f8 01       	movw	r30, r16
    352e:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    3530:	81 e0       	ldi	r24, 0x01	; 1
    3532:	07 c0       	rjmp	.+14     	; 0x3542 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    3534:	80 e0       	ldi	r24, 0x00	; 0
    3536:	05 c0       	rjmp	.+10     	; 0x3542 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    3538:	81 e0       	ldi	r24, 0x01	; 1
    353a:	03 c0       	rjmp	.+6      	; 0x3542 <xQueueReceiveFromISR+0x60>
    353c:	81 e0       	ldi	r24, 0x01	; 1
    353e:	01 c0       	rjmp	.+2      	; 0x3542 <xQueueReceiveFromISR+0x60>
    3540:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3542:	df 91       	pop	r29
    3544:	cf 91       	pop	r28
    3546:	1f 91       	pop	r17
    3548:	0f 91       	pop	r16
    354a:	ff 90       	pop	r15
    354c:	ef 90       	pop	r14
    354e:	08 95       	ret

00003550 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3550:	0f 93       	push	r16
    3552:	1f 93       	push	r17
    3554:	cf 93       	push	r28
    3556:	df 93       	push	r29
    3558:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    355a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    355c:	88 23       	and	r24, r24
    355e:	49 f0       	breq	.+18     	; 0x3572 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3560:	0e 81       	ldd	r16, Y+6	; 0x06
    3562:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3564:	ce 01       	movw	r24, r28
    3566:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    356a:	1f 83       	std	Y+7, r17	; 0x07
    356c:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    356e:	81 e0       	ldi	r24, 0x01	; 1
    3570:	01 c0       	rjmp	.+2      	; 0x3574 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    3572:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3574:	df 91       	pop	r29
    3576:	cf 91       	pop	r28
    3578:	1f 91       	pop	r17
    357a:	0f 91       	pop	r16
    357c:	08 95       	ret

0000357e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    357e:	0f b6       	in	r0, 0x3f	; 63
    3580:	f8 94       	cli
    3582:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3584:	fc 01       	movw	r30, r24
    3586:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    3588:	0f 90       	pop	r0
    358a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    358c:	08 95       	ret

0000358e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    358e:	fc 01       	movw	r30, r24
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3590:	0f b6       	in	r0, 0x3f	; 63
    3592:	f8 94       	cli
    3594:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3596:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    3598:	0f 90       	pop	r0
    359a:	0f be       	out	0x3f, r0	; 63

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    359c:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    359e:	89 1b       	sub	r24, r25
    35a0:	08 95       	ret

000035a2 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    35a2:	fc 01       	movw	r30, r24
    35a4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    35a6:	08 95       	ret

000035a8 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    35a8:	0e 94 4c 14 	call	0x2898	; 0x2898 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    35ac:	08 95       	ret

000035ae <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    35ae:	fc 01       	movw	r30, r24
    35b0:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    35b2:	81 e0       	ldi	r24, 0x01	; 1
    35b4:	91 11       	cpse	r25, r1
    35b6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    35b8:	08 95       	ret

000035ba <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    35ba:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    35bc:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    35be:	81 e0       	ldi	r24, 0x01	; 1
    35c0:	93 8d       	ldd	r25, Z+27	; 0x1b
    35c2:	29 13       	cpse	r18, r25
    35c4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    35c6:	08 95       	ret

000035c8 <prvBytesInBuffer>:
	return xCount;
}
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    35c8:	fc 01       	movw	r30, r24
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    35ca:	24 81       	ldd	r18, Z+4	; 0x04
    35cc:	35 81       	ldd	r19, Z+5	; 0x05
    35ce:	82 81       	ldd	r24, Z+2	; 0x02
    35d0:	93 81       	ldd	r25, Z+3	; 0x03
    35d2:	82 0f       	add	r24, r18
    35d4:	93 1f       	adc	r25, r19
	xCount -= pxStreamBuffer->xTail;
    35d6:	40 81       	ld	r20, Z
    35d8:	51 81       	ldd	r21, Z+1	; 0x01
    35da:	84 1b       	sub	r24, r20
    35dc:	95 0b       	sbc	r25, r21
	if ( xCount >= pxStreamBuffer->xLength )
    35de:	82 17       	cp	r24, r18
    35e0:	93 07       	cpc	r25, r19
    35e2:	10 f0       	brcs	.+4      	; 0x35e8 <prvBytesInBuffer+0x20>
	{
		xCount -= pxStreamBuffer->xLength;
    35e4:	82 1b       	sub	r24, r18
    35e6:	93 0b       	sbc	r25, r19
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
}
    35e8:	08 95       	ret

000035ea <prvReadBytesFromBuffer>:
	return xCount;
}
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    35ea:	af 92       	push	r10
    35ec:	bf 92       	push	r11
    35ee:	cf 92       	push	r12
    35f0:	df 92       	push	r13
    35f2:	ef 92       	push	r14
    35f4:	ff 92       	push	r15
    35f6:	0f 93       	push	r16
    35f8:	1f 93       	push	r17
    35fa:	cf 93       	push	r28
    35fc:	df 93       	push	r29
    35fe:	8c 01       	movw	r16, r24
    3600:	6b 01       	movw	r12, r22
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3602:	c2 2f       	mov	r28, r18
    3604:	d3 2f       	mov	r29, r19
    3606:	4c 17       	cp	r20, r28
    3608:	5d 07       	cpc	r21, r29
    360a:	08 f4       	brcc	.+2      	; 0x360e <prvReadBytesFromBuffer+0x24>
    360c:	ea 01       	movw	r28, r20

	if( xCount > ( size_t ) 0 )
    360e:	20 97       	sbiw	r28, 0x00	; 0
    3610:	99 f1       	breq	.+102    	; 0x3678 <prvReadBytesFromBuffer+0x8e>
	{
		xNextTail = pxStreamBuffer->xTail;
    3612:	f8 01       	movw	r30, r16
    3614:	a0 80       	ld	r10, Z
    3616:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3618:	84 81       	ldd	r24, Z+4	; 0x04
    361a:	95 81       	ldd	r25, Z+5	; 0x05
    361c:	8a 19       	sub	r24, r10
    361e:	9b 09       	sbc	r25, r11
    3620:	7e 01       	movw	r14, r28
    3622:	8c 17       	cp	r24, r28
    3624:	9d 07       	cpc	r25, r29
    3626:	08 f4       	brcc	.+2      	; 0x362a <prvReadBytesFromBuffer+0x40>
    3628:	7c 01       	movw	r14, r24

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    362a:	f8 01       	movw	r30, r16
    362c:	64 85       	ldd	r22, Z+12	; 0x0c
    362e:	75 85       	ldd	r23, Z+13	; 0x0d
    3630:	6a 0d       	add	r22, r10
    3632:	7b 1d       	adc	r23, r11
    3634:	8c 2d       	mov	r24, r12
    3636:	9d 2d       	mov	r25, r13
    3638:	4e 2d       	mov	r20, r14
    363a:	5f 2d       	mov	r21, r15
    363c:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3640:	ec 16       	cp	r14, r28
    3642:	fd 06       	cpc	r15, r29
    3644:	58 f4       	brcc	.+22     	; 0x365c <prvReadBytesFromBuffer+0x72>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3646:	c6 01       	movw	r24, r12
    3648:	8e 0d       	add	r24, r14
    364a:	9f 1d       	adc	r25, r15
    364c:	ae 01       	movw	r20, r28
    364e:	4e 19       	sub	r20, r14
    3650:	5f 09       	sbc	r21, r15
    3652:	f8 01       	movw	r30, r16
    3654:	64 85       	ldd	r22, Z+12	; 0x0c
    3656:	75 85       	ldd	r23, Z+13	; 0x0d
    3658:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    365c:	ce 01       	movw	r24, r28
    365e:	8a 0d       	add	r24, r10
    3660:	9b 1d       	adc	r25, r11

		if( xNextTail >= pxStreamBuffer->xLength )
    3662:	f8 01       	movw	r30, r16
    3664:	24 81       	ldd	r18, Z+4	; 0x04
    3666:	35 81       	ldd	r19, Z+5	; 0x05
    3668:	82 17       	cp	r24, r18
    366a:	93 07       	cpc	r25, r19
    366c:	10 f0       	brcs	.+4      	; 0x3672 <prvReadBytesFromBuffer+0x88>
		{
			xNextTail -= pxStreamBuffer->xLength;
    366e:	82 1b       	sub	r24, r18
    3670:	93 0b       	sbc	r25, r19
		}

		pxStreamBuffer->xTail = xNextTail;
    3672:	f8 01       	movw	r30, r16
    3674:	91 83       	std	Z+1, r25	; 0x01
    3676:	80 83       	st	Z, r24
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
}
    3678:	8c 2f       	mov	r24, r28
    367a:	9d 2f       	mov	r25, r29
    367c:	df 91       	pop	r29
    367e:	cf 91       	pop	r28
    3680:	1f 91       	pop	r17
    3682:	0f 91       	pop	r16
    3684:	ff 90       	pop	r15
    3686:	ef 90       	pop	r14
    3688:	df 90       	pop	r13
    368a:	cf 90       	pop	r12
    368c:	bf 90       	pop	r11
    368e:	af 90       	pop	r10
    3690:	08 95       	ret

00003692 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    3692:	6f 92       	push	r6
    3694:	7f 92       	push	r7
    3696:	8f 92       	push	r8
    3698:	9f 92       	push	r9
    369a:	af 92       	push	r10
    369c:	bf 92       	push	r11
    369e:	cf 92       	push	r12
    36a0:	df 92       	push	r13
    36a2:	ef 92       	push	r14
    36a4:	ff 92       	push	r15
    36a6:	0f 93       	push	r16
    36a8:	1f 93       	push	r17
    36aa:	cf 93       	push	r28
    36ac:	df 93       	push	r29
    36ae:	00 d0       	rcall	.+0      	; 0x36b0 <prvReadMessageFromBuffer+0x1e>
    36b0:	cd b7       	in	r28, 0x3d	; 61
    36b2:	de b7       	in	r29, 0x3e	; 62
    36b4:	5c 01       	movw	r10, r24
    36b6:	4b 01       	movw	r8, r22
    36b8:	7a 01       	movw	r14, r20
    36ba:	69 01       	movw	r12, r18
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    36bc:	01 15       	cp	r16, r1
    36be:	11 05       	cpc	r17, r1
    36c0:	a9 f0       	breq	.+42     	; 0x36ec <prvReadMessageFromBuffer+0x5a>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    36c2:	fc 01       	movw	r30, r24
    36c4:	60 80       	ld	r6, Z
    36c6:	71 80       	ldd	r7, Z+1	; 0x01
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    36c8:	be 01       	movw	r22, r28
    36ca:	6f 5f       	subi	r22, 0xFF	; 255
    36cc:	7f 4f       	sbci	r23, 0xFF	; 255
    36ce:	a8 01       	movw	r20, r16
    36d0:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    36d4:	49 81       	ldd	r20, Y+1	; 0x01
    36d6:	5a 81       	ldd	r21, Y+2	; 0x02

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    36d8:	c0 1a       	sub	r12, r16
    36da:	d1 0a       	sbc	r13, r17

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    36dc:	e4 16       	cp	r14, r20
    36de:	f5 06       	cpc	r15, r21
    36e0:	28 f4       	brcc	.+10     	; 0x36ec <prvReadMessageFromBuffer+0x5a>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    36e2:	f5 01       	movw	r30, r10
    36e4:	71 82       	std	Z+1, r7	; 0x01
    36e6:	60 82       	st	Z, r6
			xNextMessageLength = 0;
    36e8:	40 e0       	ldi	r20, 0x00	; 0
    36ea:	50 e0       	ldi	r21, 0x00	; 0
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    36ec:	c5 01       	movw	r24, r10
    36ee:	b4 01       	movw	r22, r8
    36f0:	96 01       	movw	r18, r12
    36f2:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <prvReadBytesFromBuffer>

	return xReceivedLength;
}
    36f6:	0f 90       	pop	r0
    36f8:	0f 90       	pop	r0
    36fa:	df 91       	pop	r29
    36fc:	cf 91       	pop	r28
    36fe:	1f 91       	pop	r17
    3700:	0f 91       	pop	r16
    3702:	ff 90       	pop	r15
    3704:	ef 90       	pop	r14
    3706:	df 90       	pop	r13
    3708:	cf 90       	pop	r12
    370a:	bf 90       	pop	r11
    370c:	af 90       	pop	r10
    370e:	9f 90       	pop	r9
    3710:	8f 90       	pop	r8
    3712:	7f 90       	pop	r7
    3714:	6f 90       	pop	r6
    3716:	08 95       	ret

00003718 <prvWriteBytesToBuffer>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3718:	af 92       	push	r10
    371a:	bf 92       	push	r11
    371c:	cf 92       	push	r12
    371e:	df 92       	push	r13
    3720:	ef 92       	push	r14
    3722:	ff 92       	push	r15
    3724:	0f 93       	push	r16
    3726:	1f 93       	push	r17
    3728:	cf 93       	push	r28
    372a:	df 93       	push	r29
    372c:	ec 01       	movw	r28, r24
    372e:	5b 01       	movw	r10, r22
    3730:	8a 01       	movw	r16, r20
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3732:	ca 80       	ldd	r12, Y+2	; 0x02
    3734:	db 80       	ldd	r13, Y+3	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3736:	8c 81       	ldd	r24, Y+4	; 0x04
    3738:	9d 81       	ldd	r25, Y+5	; 0x05
    373a:	8c 19       	sub	r24, r12
    373c:	9d 09       	sbc	r25, r13
    373e:	7a 01       	movw	r14, r20
    3740:	84 17       	cp	r24, r20
    3742:	95 07       	cpc	r25, r21
    3744:	08 f4       	brcc	.+2      	; 0x3748 <prvWriteBytesToBuffer+0x30>
    3746:	7c 01       	movw	r14, r24

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3748:	8c 85       	ldd	r24, Y+12	; 0x0c
    374a:	9d 85       	ldd	r25, Y+13	; 0x0d
    374c:	8c 0d       	add	r24, r12
    374e:	9d 1d       	adc	r25, r13
    3750:	6a 2d       	mov	r22, r10
    3752:	7b 2d       	mov	r23, r11
    3754:	4e 2d       	mov	r20, r14
    3756:	5f 2d       	mov	r21, r15
    3758:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    375c:	e0 16       	cp	r14, r16
    375e:	f1 06       	cpc	r15, r17
    3760:	50 f4       	brcc	.+20     	; 0x3776 <prvWriteBytesToBuffer+0x5e>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3762:	a8 01       	movw	r20, r16
    3764:	4e 19       	sub	r20, r14
    3766:	5f 09       	sbc	r21, r15
    3768:	b5 01       	movw	r22, r10
    376a:	6e 0d       	add	r22, r14
    376c:	7f 1d       	adc	r23, r15
    376e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3770:	9d 85       	ldd	r25, Y+13	; 0x0d
    3772:	0e 94 32 29 	call	0x5264	; 0x5264 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3776:	c8 01       	movw	r24, r16
    3778:	8c 0d       	add	r24, r12
    377a:	9d 1d       	adc	r25, r13
	if( xNextHead >= pxStreamBuffer->xLength )
    377c:	2c 81       	ldd	r18, Y+4	; 0x04
    377e:	3d 81       	ldd	r19, Y+5	; 0x05
    3780:	82 17       	cp	r24, r18
    3782:	93 07       	cpc	r25, r19
    3784:	10 f0       	brcs	.+4      	; 0x378a <prvWriteBytesToBuffer+0x72>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3786:	82 1b       	sub	r24, r18
    3788:	93 0b       	sbc	r25, r19
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    378a:	9b 83       	std	Y+3, r25	; 0x03
    378c:	8a 83       	std	Y+2, r24	; 0x02

	return xCount;
}
    378e:	80 2f       	mov	r24, r16
    3790:	91 2f       	mov	r25, r17
    3792:	df 91       	pop	r29
    3794:	cf 91       	pop	r28
    3796:	1f 91       	pop	r17
    3798:	0f 91       	pop	r16
    379a:	ff 90       	pop	r15
    379c:	ef 90       	pop	r14
    379e:	df 90       	pop	r13
    37a0:	cf 90       	pop	r12
    37a2:	bf 90       	pop	r11
    37a4:	af 90       	pop	r10
    37a6:	08 95       	ret

000037a8 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    37a8:	cf 92       	push	r12
    37aa:	df 92       	push	r13
    37ac:	ef 92       	push	r14
    37ae:	ff 92       	push	r15
    37b0:	0f 93       	push	r16
    37b2:	1f 93       	push	r17
    37b4:	cf 93       	push	r28
    37b6:	df 93       	push	r29
    37b8:	00 d0       	rcall	.+0      	; 0x37ba <prvWriteMessageToBuffer+0x12>
    37ba:	cd b7       	in	r28, 0x3d	; 61
    37bc:	de b7       	in	r29, 0x3e	; 62
    37be:	7c 01       	movw	r14, r24
    37c0:	6b 01       	movw	r12, r22
    37c2:	5a 83       	std	Y+2, r21	; 0x02
    37c4:	49 83       	std	Y+1, r20	; 0x01
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    37c6:	21 15       	cp	r18, r1
    37c8:	31 05       	cpc	r19, r1
    37ca:	b9 f0       	breq	.+46     	; 0x37fa <prvWriteMessageToBuffer+0x52>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    37cc:	fc 01       	movw	r30, r24
    37ce:	86 85       	ldd	r24, Z+14	; 0x0e
    37d0:	80 fd       	sbrc	r24, 0
    37d2:	07 c0       	rjmp	.+14     	; 0x37e2 <prvWriteMessageToBuffer+0x3a>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    37d4:	42 17       	cp	r20, r18
    37d6:	53 07       	cpc	r21, r19
    37d8:	08 f4       	brcc	.+2      	; 0x37dc <prvWriteMessageToBuffer+0x34>
    37da:	9a 01       	movw	r18, r20
    37dc:	3a 83       	std	Y+2, r19	; 0x02
    37de:	29 83       	std	Y+1, r18	; 0x01
    37e0:	1c c0       	rjmp	.+56     	; 0x381a <prvWriteMessageToBuffer+0x72>
	}
	else if( xSpace >= xRequiredSpace )
    37e2:	20 17       	cp	r18, r16
    37e4:	31 07       	cpc	r19, r17
    37e6:	60 f0       	brcs	.+24     	; 0x3800 <prvWriteMessageToBuffer+0x58>
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    37e8:	c7 01       	movw	r24, r14
    37ea:	be 01       	movw	r22, r28
    37ec:	6f 5f       	subi	r22, 0xFF	; 255
    37ee:	7f 4f       	sbci	r23, 0xFF	; 255
    37f0:	42 e0       	ldi	r20, 0x02	; 2
    37f2:	50 e0       	ldi	r21, 0x00	; 0
    37f4:	0e 94 8c 1b 	call	0x3718	; 0x3718 <prvWriteBytesToBuffer>
    37f8:	10 c0       	rjmp	.+32     	; 0x381a <prvWriteMessageToBuffer+0x72>
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
	}
	else
	{
		xReturn = 0;
    37fa:	80 e0       	ldi	r24, 0x00	; 0
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	02 c0       	rjmp	.+4      	; 0x3804 <prvWriteMessageToBuffer+0x5c>
    3800:	80 e0       	ldi	r24, 0x00	; 0
    3802:	90 e0       	ldi	r25, 0x00	; 0
	}

	return xReturn;
}
    3804:	0f 90       	pop	r0
    3806:	0f 90       	pop	r0
    3808:	df 91       	pop	r29
    380a:	cf 91       	pop	r28
    380c:	1f 91       	pop	r17
    380e:	0f 91       	pop	r16
    3810:	ff 90       	pop	r15
    3812:	ef 90       	pop	r14
    3814:	df 90       	pop	r13
    3816:	cf 90       	pop	r12
    3818:	08 95       	ret
	}

	if( xShouldWrite != pdFALSE )
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    381a:	49 81       	ldd	r20, Y+1	; 0x01
    381c:	5a 81       	ldd	r21, Y+2	; 0x02
    381e:	c7 01       	movw	r24, r14
    3820:	b6 01       	movw	r22, r12
    3822:	0e 94 8c 1b 	call	0x3718	; 0x3718 <prvWriteBytesToBuffer>
    3826:	ee cf       	rjmp	.-36     	; 0x3804 <prvWriteMessageToBuffer+0x5c>

00003828 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3828:	0f 93       	push	r16
    382a:	fc 01       	movw	r30, r24
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    382c:	8f e0       	ldi	r24, 0x0F	; 15
    382e:	df 01       	movw	r26, r30
    3830:	1d 92       	st	X+, r1
    3832:	8a 95       	dec	r24
    3834:	e9 f7       	brne	.-6      	; 0x3830 <prvInitialiseNewStreamBuffer+0x8>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3836:	75 87       	std	Z+13, r23	; 0x0d
    3838:	64 87       	std	Z+12, r22	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    383a:	55 83       	std	Z+5, r21	; 0x05
    383c:	44 83       	std	Z+4, r20	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    383e:	37 83       	std	Z+7, r19	; 0x07
    3840:	26 83       	std	Z+6, r18	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3842:	06 87       	std	Z+14, r16	; 0x0e
}
    3844:	0f 91       	pop	r16
    3846:	08 95       	ret

00003848 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    3848:	df 92       	push	r13
    384a:	ef 92       	push	r14
    384c:	ff 92       	push	r15
    384e:	0f 93       	push	r16
    3850:	1f 93       	push	r17
    3852:	cf 93       	push	r28
    3854:	df 93       	push	r29
    3856:	8c 01       	movw	r16, r24
    3858:	7b 01       	movw	r14, r22
    385a:	d4 2e       	mov	r13, r20
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    385c:	61 15       	cp	r22, r1
    385e:	71 05       	cpc	r23, r1
    3860:	19 f4       	brne	.+6      	; 0x3868 <xStreamBufferGenericCreate+0x20>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3862:	ee 24       	eor	r14, r14
    3864:	ff 24       	eor	r15, r15
    3866:	e3 94       	inc	r14
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    3868:	c8 01       	movw	r24, r16
    386a:	40 96       	adiw	r24, 0x10	; 16
    386c:	0e 94 16 14 	call	0x282c	; 0x282c <pvPortMalloc>
    3870:	ec 01       	movw	r28, r24

		if( pucAllocatedMemory != NULL )
    3872:	00 97       	sbiw	r24, 0x00	; 0
    3874:	69 f0       	breq	.+26     	; 0x3890 <xStreamBufferGenericCreate+0x48>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3876:	bc 01       	movw	r22, r24
    3878:	61 5f       	subi	r22, 0xF1	; 241
    387a:	7f 4f       	sbci	r23, 0xFF	; 255
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    387c:	a8 01       	movw	r20, r16
    387e:	4f 5f       	subi	r20, 0xFF	; 255
    3880:	5f 4f       	sbci	r21, 0xFF	; 255
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3882:	01 e0       	ldi	r16, 0x01	; 1
    3884:	d0 12       	cpse	r13, r16
    3886:	00 e0       	ldi	r16, 0x00	; 0
		xBufferSizeBytes++;
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */

		if( pucAllocatedMemory != NULL )
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3888:	ce 01       	movw	r24, r28
    388a:	97 01       	movw	r18, r14
    388c:	0e 94 14 1c 	call	0x3828	; 0x3828 <prvInitialiseNewStreamBuffer>
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
	}
    3890:	8c 2f       	mov	r24, r28
    3892:	9d 2f       	mov	r25, r29
    3894:	df 91       	pop	r29
    3896:	cf 91       	pop	r28
    3898:	1f 91       	pop	r17
    389a:	0f 91       	pop	r16
    389c:	ff 90       	pop	r15
    389e:	ef 90       	pop	r14
    38a0:	df 90       	pop	r13
    38a2:	08 95       	ret

000038a4 <vStreamBufferDelete>:

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    38a4:	fc 01       	movw	r30, r24
    38a6:	26 85       	ldd	r18, Z+14	; 0x0e
    38a8:	21 fd       	sbrc	r18, 1
    38aa:	03 c0       	rjmp	.+6      	; 0x38b2 <vStreamBufferDelete+0xe>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    38ac:	0e 94 4c 14 	call	0x2898	; 0x2898 <vPortFree>
    38b0:	08 95       	ret
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    38b2:	2f e0       	ldi	r18, 0x0F	; 15
    38b4:	fc 01       	movw	r30, r24
    38b6:	11 92       	st	Z+, r1
    38b8:	2a 95       	dec	r18
    38ba:	e9 f7       	brne	.-6      	; 0x38b6 <vStreamBufferDelete+0x12>
    38bc:	08 95       	ret

000038be <xStreamBufferReset>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    38be:	0f 93       	push	r16
    38c0:	fc 01       	movw	r30, r24
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    38c8:	80 85       	ldd	r24, Z+8	; 0x08
    38ca:	91 85       	ldd	r25, Z+9	; 0x09
    38cc:	00 97       	sbiw	r24, 0x00	; 0
    38ce:	81 f4       	brne	.+32     	; 0x38f0 <xStreamBufferReset+0x32>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    38d0:	82 85       	ldd	r24, Z+10	; 0x0a
    38d2:	93 85       	ldd	r25, Z+11	; 0x0b
    38d4:	00 97       	sbiw	r24, 0x00	; 0
    38d6:	71 f4       	brne	.+28     	; 0x38f4 <xStreamBufferReset+0x36>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    38d8:	64 85       	ldd	r22, Z+12	; 0x0c
    38da:	75 85       	ldd	r23, Z+13	; 0x0d
    38dc:	44 81       	ldd	r20, Z+4	; 0x04
    38de:	55 81       	ldd	r21, Z+5	; 0x05
    38e0:	26 81       	ldd	r18, Z+6	; 0x06
    38e2:	37 81       	ldd	r19, Z+7	; 0x07
    38e4:	cf 01       	movw	r24, r30
    38e6:	06 85       	ldd	r16, Z+14	; 0x0e
    38e8:	0e 94 14 1c 	call	0x3828	; 0x3828 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    38ec:	81 e0       	ldi	r24, 0x01	; 1
    38ee:	03 c0       	rjmp	.+6      	; 0x38f6 <xStreamBufferReset+0x38>
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
BaseType_t xReturn = pdFAIL;
    38f0:	80 e0       	ldi	r24, 0x00	; 0
    38f2:	01 c0       	rjmp	.+2      	; 0x38f6 <xStreamBufferReset+0x38>
    38f4:	80 e0       	ldi	r24, 0x00	; 0

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    38f6:	0f 90       	pop	r0
    38f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    38fa:	0f 91       	pop	r16
    38fc:	08 95       	ret

000038fe <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    38fe:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3900:	61 15       	cp	r22, r1
    3902:	71 05       	cpc	r23, r1
    3904:	11 f4       	brne	.+4      	; 0x390a <xStreamBufferSetTriggerLevel+0xc>
	{
		xTriggerLevel = ( size_t ) 1;
    3906:	61 e0       	ldi	r22, 0x01	; 1
    3908:	70 e0       	ldi	r23, 0x00	; 0
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    390a:	84 81       	ldd	r24, Z+4	; 0x04
    390c:	95 81       	ldd	r25, Z+5	; 0x05
    390e:	86 17       	cp	r24, r22
    3910:	97 07       	cpc	r25, r23
    3912:	20 f0       	brcs	.+8      	; 0x391c <xStreamBufferSetTriggerLevel+0x1e>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3914:	77 83       	std	Z+7, r23	; 0x07
    3916:	66 83       	std	Z+6, r22	; 0x06
		xReturn = pdPASS;
    3918:	81 e0       	ldi	r24, 0x01	; 1
    391a:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    391c:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    391e:	08 95       	ret

00003920 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3920:	fc 01       	movw	r30, r24
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3922:	24 81       	ldd	r18, Z+4	; 0x04
    3924:	35 81       	ldd	r19, Z+5	; 0x05
    3926:	40 81       	ld	r20, Z
    3928:	51 81       	ldd	r21, Z+1	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    392a:	62 81       	ldd	r22, Z+2	; 0x02
    392c:	73 81       	ldd	r23, Z+3	; 0x03
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    392e:	c9 01       	movw	r24, r18
    3930:	84 0f       	add	r24, r20
    3932:	95 1f       	adc	r25, r21
	xSpace -= pxStreamBuffer->xHead;
    3934:	01 97       	sbiw	r24, 0x01	; 1
	xSpace -= ( size_t ) 1;
    3936:	86 1b       	sub	r24, r22
    3938:	97 0b       	sbc	r25, r23

	if( xSpace >= pxStreamBuffer->xLength )
    393a:	82 17       	cp	r24, r18
    393c:	93 07       	cpc	r25, r19
    393e:	10 f0       	brcs	.+4      	; 0x3944 <xStreamBufferSpacesAvailable+0x24>
	{
		xSpace -= pxStreamBuffer->xLength;
    3940:	82 1b       	sub	r24, r18
    3942:	93 0b       	sbc	r25, r19
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
}
    3944:	08 95       	ret

00003946 <xStreamBufferBytesAvailable>:
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3946:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
	return xReturn;
}
    394a:	08 95       	ret

0000394c <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    394c:	4f 92       	push	r4
    394e:	5f 92       	push	r5
    3950:	6f 92       	push	r6
    3952:	7f 92       	push	r7
    3954:	8f 92       	push	r8
    3956:	9f 92       	push	r9
    3958:	af 92       	push	r10
    395a:	bf 92       	push	r11
    395c:	cf 92       	push	r12
    395e:	df 92       	push	r13
    3960:	ef 92       	push	r14
    3962:	ff 92       	push	r15
    3964:	0f 93       	push	r16
    3966:	1f 93       	push	r17
    3968:	cf 93       	push	r28
    396a:	df 93       	push	r29
    396c:	00 d0       	rcall	.+0      	; 0x396e <xStreamBufferSend+0x22>
    396e:	00 d0       	rcall	.+0      	; 0x3970 <xStreamBufferSend+0x24>
    3970:	0f 92       	push	r0
    3972:	cd b7       	in	r28, 0x3d	; 61
    3974:	de b7       	in	r29, 0x3e	; 62
    3976:	6c 01       	movw	r12, r24
    3978:	2b 01       	movw	r4, r22
    397a:	3a 01       	movw	r6, r20
    397c:	3d 83       	std	Y+5, r19	; 0x05
    397e:	2c 83       	std	Y+4, r18	; 0x04

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3980:	fc 01       	movw	r30, r24
    3982:	86 85       	ldd	r24, Z+14	; 0x0e
    3984:	80 ff       	sbrs	r24, 0
    3986:	07 c0       	rjmp	.+14     	; 0x3996 <xStreamBufferSend+0x4a>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3988:	88 24       	eor	r8, r8
    398a:	99 24       	eor	r9, r9
    398c:	68 94       	set
    398e:	81 f8       	bld	r8, 1
    3990:	84 0e       	add	r8, r20
    3992:	95 1e       	adc	r9, r21
    3994:	01 c0       	rjmp	.+2      	; 0x3998 <xStreamBufferSend+0x4c>
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn, xSpace = 0;
size_t xRequiredSpace = xDataLengthBytes;
    3996:	4a 01       	movw	r8, r20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3998:	8c 81       	ldd	r24, Y+4	; 0x04
    399a:	9d 81       	ldd	r25, Y+5	; 0x05
    399c:	00 97       	sbiw	r24, 0x00	; 0
    399e:	b9 f1       	breq	.+110    	; 0x3a0e <xStreamBufferSend+0xc2>
	{
		vTaskSetTimeOutState( &xTimeOut );
    39a0:	ce 01       	movw	r24, r28
    39a2:	01 96       	adiw	r24, 0x01	; 1
    39a4:	0e 94 ac 23 	call	0x4758	; 0x4758 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    39a8:	0f b6       	in	r0, 0x3f	; 63
    39aa:	f8 94       	cli
    39ac:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    39ae:	c6 01       	movw	r24, r12
    39b0:	0e 94 90 1c 	call	0x3920	; 0x3920 <xStreamBufferSpacesAvailable>
    39b4:	5c 01       	movw	r10, r24

				if( xSpace < xRequiredSpace )
    39b6:	88 15       	cp	r24, r8
    39b8:	99 05       	cpc	r25, r9
    39ba:	28 f5       	brcc	.+74     	; 0x3a06 <xStreamBufferSend+0xba>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    39bc:	80 e0       	ldi	r24, 0x00	; 0
    39be:	90 e0       	ldi	r25, 0x00	; 0
    39c0:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    39c4:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <xTaskGetCurrentTaskHandle>
    39c8:	f6 01       	movw	r30, r12
    39ca:	93 87       	std	Z+11, r25	; 0x0b
    39cc:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    39ce:	0f 90       	pop	r0
    39d0:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    39d2:	ec 80       	ldd	r14, Y+4	; 0x04
    39d4:	fd 80       	ldd	r15, Y+5	; 0x05
    39d6:	60 e0       	ldi	r22, 0x00	; 0
    39d8:	70 e0       	ldi	r23, 0x00	; 0
    39da:	cb 01       	movw	r24, r22
    39dc:	20 e0       	ldi	r18, 0x00	; 0
    39de:	30 e0       	ldi	r19, 0x00	; 0
    39e0:	a9 01       	movw	r20, r18
    39e2:	00 e0       	ldi	r16, 0x00	; 0
    39e4:	10 e0       	ldi	r17, 0x00	; 0
    39e6:	0e 94 70 24 	call	0x48e0	; 0x48e0 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    39ea:	f6 01       	movw	r30, r12
    39ec:	13 86       	std	Z+11, r1	; 0x0b
    39ee:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    39f0:	ce 01       	movw	r24, r28
    39f2:	01 96       	adiw	r24, 0x01	; 1
    39f4:	be 01       	movw	r22, r28
    39f6:	6c 5f       	subi	r22, 0xFC	; 252
    39f8:	7f 4f       	sbci	r23, 0xFF	; 255
    39fa:	0e 94 c7 23 	call	0x478e	; 0x478e <xTaskCheckForTimeOut>
    39fe:	88 23       	and	r24, r24
    3a00:	99 f2       	breq	.-90     	; 0x39a8 <xStreamBufferSend+0x5c>
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3a02:	c5 01       	movw	r24, r10
    3a04:	02 c0       	rjmp	.+4      	; 0x3a0a <xStreamBufferSend+0xbe>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3a06:	0f 90       	pop	r0
    3a08:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3a0a:	00 97       	sbiw	r24, 0x00	; 0
    3a0c:	21 f4       	brne	.+8      	; 0x3a16 <xStreamBufferSend+0xca>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3a0e:	c6 01       	movw	r24, r12
    3a10:	0e 94 90 1c 	call	0x3920	; 0x3920 <xStreamBufferSpacesAvailable>
    3a14:	5c 01       	movw	r10, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3a16:	c6 01       	movw	r24, r12
    3a18:	b2 01       	movw	r22, r4
    3a1a:	a3 01       	movw	r20, r6
    3a1c:	95 01       	movw	r18, r10
    3a1e:	84 01       	movw	r16, r8
    3a20:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvWriteMessageToBuffer>
    3a24:	7c 01       	movw	r14, r24

	if( xReturn > ( size_t ) 0 )
    3a26:	00 97       	sbiw	r24, 0x00	; 0
    3a28:	f9 f0       	breq	.+62     	; 0x3a68 <xStreamBufferSend+0x11c>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3a2a:	c6 01       	movw	r24, r12
    3a2c:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3a30:	f6 01       	movw	r30, r12
    3a32:	26 81       	ldd	r18, Z+6	; 0x06
    3a34:	37 81       	ldd	r19, Z+7	; 0x07
    3a36:	82 17       	cp	r24, r18
    3a38:	93 07       	cpc	r25, r19
    3a3a:	b0 f0       	brcs	.+44     	; 0x3a68 <xStreamBufferSend+0x11c>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3a3c:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
    3a40:	f6 01       	movw	r30, r12
    3a42:	80 85       	ldd	r24, Z+8	; 0x08
    3a44:	91 85       	ldd	r25, Z+9	; 0x09
    3a46:	00 97       	sbiw	r24, 0x00	; 0
    3a48:	69 f0       	breq	.+26     	; 0x3a64 <xStreamBufferSend+0x118>
    3a4a:	80 85       	ldd	r24, Z+8	; 0x08
    3a4c:	91 85       	ldd	r25, Z+9	; 0x09
    3a4e:	40 e0       	ldi	r20, 0x00	; 0
    3a50:	50 e0       	ldi	r21, 0x00	; 0
    3a52:	ba 01       	movw	r22, r20
    3a54:	20 e0       	ldi	r18, 0x00	; 0
    3a56:	00 e0       	ldi	r16, 0x00	; 0
    3a58:	10 e0       	ldi	r17, 0x00	; 0
    3a5a:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <xTaskGenericNotify>
    3a5e:	f6 01       	movw	r30, r12
    3a60:	11 86       	std	Z+9, r1	; 0x09
    3a62:	10 86       	std	Z+8, r1	; 0x08
    3a64:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
}
    3a68:	8e 2d       	mov	r24, r14
    3a6a:	9f 2d       	mov	r25, r15
    3a6c:	0f 90       	pop	r0
    3a6e:	0f 90       	pop	r0
    3a70:	0f 90       	pop	r0
    3a72:	0f 90       	pop	r0
    3a74:	0f 90       	pop	r0
    3a76:	df 91       	pop	r29
    3a78:	cf 91       	pop	r28
    3a7a:	1f 91       	pop	r17
    3a7c:	0f 91       	pop	r16
    3a7e:	ff 90       	pop	r15
    3a80:	ef 90       	pop	r14
    3a82:	df 90       	pop	r13
    3a84:	cf 90       	pop	r12
    3a86:	bf 90       	pop	r11
    3a88:	af 90       	pop	r10
    3a8a:	9f 90       	pop	r9
    3a8c:	8f 90       	pop	r8
    3a8e:	7f 90       	pop	r7
    3a90:	6f 90       	pop	r6
    3a92:	5f 90       	pop	r5
    3a94:	4f 90       	pop	r4
    3a96:	08 95       	ret

00003a98 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3a98:	af 92       	push	r10
    3a9a:	bf 92       	push	r11
    3a9c:	cf 92       	push	r12
    3a9e:	df 92       	push	r13
    3aa0:	ef 92       	push	r14
    3aa2:	ff 92       	push	r15
    3aa4:	0f 93       	push	r16
    3aa6:	1f 93       	push	r17
    3aa8:	cf 93       	push	r28
    3aaa:	df 93       	push	r29
    3aac:	ec 01       	movw	r28, r24
    3aae:	6b 01       	movw	r12, r22
    3ab0:	7a 01       	movw	r14, r20
    3ab2:	59 01       	movw	r10, r18

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3ab4:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ab6:	80 ff       	sbrs	r24, 0
    3ab8:	04 c0       	rjmp	.+8      	; 0x3ac2 <xStreamBufferSendFromISR+0x2a>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3aba:	8a 01       	movw	r16, r20
    3abc:	0e 5f       	subi	r16, 0xFE	; 254
    3abe:	1f 4f       	sbci	r17, 0xFF	; 255
    3ac0:	01 c0       	rjmp	.+2      	; 0x3ac4 <xStreamBufferSendFromISR+0x2c>
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3ac2:	8a 01       	movw	r16, r20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3ac4:	ce 01       	movw	r24, r28
    3ac6:	0e 94 90 1c 	call	0x3920	; 0x3920 <xStreamBufferSpacesAvailable>
    3aca:	9c 01       	movw	r18, r24
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3acc:	ce 01       	movw	r24, r28
    3ace:	b6 01       	movw	r22, r12
    3ad0:	a7 01       	movw	r20, r14
    3ad2:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvWriteMessageToBuffer>
    3ad6:	6c 01       	movw	r12, r24

	if( xReturn > ( size_t ) 0 )
    3ad8:	00 97       	sbiw	r24, 0x00	; 0
    3ada:	c9 f0       	breq	.+50     	; 0x3b0e <xStreamBufferSendFromISR+0x76>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3adc:	ce 01       	movw	r24, r28
    3ade:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3ae2:	2e 81       	ldd	r18, Y+6	; 0x06
    3ae4:	3f 81       	ldd	r19, Y+7	; 0x07
    3ae6:	82 17       	cp	r24, r18
    3ae8:	93 07       	cpc	r25, r19
    3aea:	88 f0       	brcs	.+34     	; 0x3b0e <xStreamBufferSendFromISR+0x76>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3aec:	88 85       	ldd	r24, Y+8	; 0x08
    3aee:	99 85       	ldd	r25, Y+9	; 0x09
    3af0:	00 97       	sbiw	r24, 0x00	; 0
    3af2:	69 f0       	breq	.+26     	; 0x3b0e <xStreamBufferSendFromISR+0x76>
    3af4:	88 85       	ldd	r24, Y+8	; 0x08
    3af6:	99 85       	ldd	r25, Y+9	; 0x09
    3af8:	40 e0       	ldi	r20, 0x00	; 0
    3afa:	50 e0       	ldi	r21, 0x00	; 0
    3afc:	ba 01       	movw	r22, r20
    3afe:	20 e0       	ldi	r18, 0x00	; 0
    3b00:	00 e0       	ldi	r16, 0x00	; 0
    3b02:	10 e0       	ldi	r17, 0x00	; 0
    3b04:	75 01       	movw	r14, r10
    3b06:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGenericNotifyFromISR>
    3b0a:	19 86       	std	Y+9, r1	; 0x09
    3b0c:	18 86       	std	Y+8, r1	; 0x08
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
}
    3b0e:	8c 2d       	mov	r24, r12
    3b10:	9d 2d       	mov	r25, r13
    3b12:	df 91       	pop	r29
    3b14:	cf 91       	pop	r28
    3b16:	1f 91       	pop	r17
    3b18:	0f 91       	pop	r16
    3b1a:	ff 90       	pop	r15
    3b1c:	ef 90       	pop	r14
    3b1e:	df 90       	pop	r13
    3b20:	cf 90       	pop	r12
    3b22:	bf 90       	pop	r11
    3b24:	af 90       	pop	r10
    3b26:	08 95       	ret

00003b28 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3b28:	6f 92       	push	r6
    3b2a:	7f 92       	push	r7
    3b2c:	8f 92       	push	r8
    3b2e:	9f 92       	push	r9
    3b30:	af 92       	push	r10
    3b32:	bf 92       	push	r11
    3b34:	cf 92       	push	r12
    3b36:	df 92       	push	r13
    3b38:	ef 92       	push	r14
    3b3a:	ff 92       	push	r15
    3b3c:	0f 93       	push	r16
    3b3e:	1f 93       	push	r17
    3b40:	cf 93       	push	r28
    3b42:	df 93       	push	r29
    3b44:	5c 01       	movw	r10, r24
    3b46:	4b 01       	movw	r8, r22
    3b48:	3a 01       	movw	r6, r20
    3b4a:	79 01       	movw	r14, r18
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3b4c:	fc 01       	movw	r30, r24
    3b4e:	86 85       	ldd	r24, Z+14	; 0x0e
    3b50:	80 ff       	sbrs	r24, 0
    3b52:	05 c0       	rjmp	.+10     	; 0x3b5e <xStreamBufferReceive+0x36>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3b54:	cc 24       	eor	r12, r12
    3b56:	dd 24       	eor	r13, r13
    3b58:	68 94       	set
    3b5a:	c1 f8       	bld	r12, 1
    3b5c:	02 c0       	rjmp	.+4      	; 0x3b62 <xStreamBufferReceive+0x3a>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3b5e:	cc 24       	eor	r12, r12
    3b60:	dd 24       	eor	r13, r13
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3b62:	e1 14       	cp	r14, r1
    3b64:	f1 04       	cpc	r15, r1
    3b66:	51 f1       	breq	.+84     	; 0x3bbc <xStreamBufferReceive+0x94>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3b68:	0f b6       	in	r0, 0x3f	; 63
    3b6a:	f8 94       	cli
    3b6c:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3b6e:	c5 01       	movw	r24, r10
    3b70:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3b74:	ec 01       	movw	r28, r24
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3b76:	c8 16       	cp	r12, r24
    3b78:	d9 06       	cpc	r13, r25
    3b7a:	48 f0       	brcs	.+18     	; 0x3b8e <xStreamBufferReceive+0x66>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3b7c:	80 e0       	ldi	r24, 0x00	; 0
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3b84:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <xTaskGetCurrentTaskHandle>
    3b88:	f5 01       	movw	r30, r10
    3b8a:	91 87       	std	Z+9, r25	; 0x09
    3b8c:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3b8e:	0f 90       	pop	r0
    3b90:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3b92:	cc 16       	cp	r12, r28
    3b94:	dd 06       	cpc	r13, r29
    3b96:	c8 f0       	brcs	.+50     	; 0x3bca <xStreamBufferReceive+0xa2>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3b98:	60 e0       	ldi	r22, 0x00	; 0
    3b9a:	70 e0       	ldi	r23, 0x00	; 0
    3b9c:	cb 01       	movw	r24, r22
    3b9e:	20 e0       	ldi	r18, 0x00	; 0
    3ba0:	30 e0       	ldi	r19, 0x00	; 0
    3ba2:	a9 01       	movw	r20, r18
    3ba4:	00 e0       	ldi	r16, 0x00	; 0
    3ba6:	10 e0       	ldi	r17, 0x00	; 0
    3ba8:	0e 94 70 24 	call	0x48e0	; 0x48e0 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3bac:	f5 01       	movw	r30, r10
    3bae:	11 86       	std	Z+9, r1	; 0x09
    3bb0:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3bb2:	c5 01       	movw	r24, r10
    3bb4:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3bb8:	ec 01       	movw	r28, r24
    3bba:	04 c0       	rjmp	.+8      	; 0x3bc4 <xStreamBufferReceive+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3bbc:	c5 01       	movw	r24, r10
    3bbe:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3bc2:	ec 01       	movw	r28, r24
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3bc4:	cc 16       	cp	r12, r28
    3bc6:	dd 06       	cpc	r13, r29
    3bc8:	08 f5       	brcc	.+66     	; 0x3c0c <xStreamBufferReceive+0xe4>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3bca:	c5 01       	movw	r24, r10
    3bcc:	b4 01       	movw	r22, r8
    3bce:	a3 01       	movw	r20, r6
    3bd0:	9e 01       	movw	r18, r28
    3bd2:	86 01       	movw	r16, r12
    3bd4:	0e 94 49 1b 	call	0x3692	; 0x3692 <prvReadMessageFromBuffer>
    3bd8:	ec 01       	movw	r28, r24

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3bda:	00 97       	sbiw	r24, 0x00	; 0
    3bdc:	c9 f0       	breq	.+50     	; 0x3c10 <xStreamBufferReceive+0xe8>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3bde:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
    3be2:	f5 01       	movw	r30, r10
    3be4:	82 85       	ldd	r24, Z+10	; 0x0a
    3be6:	93 85       	ldd	r25, Z+11	; 0x0b
    3be8:	00 97       	sbiw	r24, 0x00	; 0
    3bea:	69 f0       	breq	.+26     	; 0x3c06 <xStreamBufferReceive+0xde>
    3bec:	82 85       	ldd	r24, Z+10	; 0x0a
    3bee:	93 85       	ldd	r25, Z+11	; 0x0b
    3bf0:	40 e0       	ldi	r20, 0x00	; 0
    3bf2:	50 e0       	ldi	r21, 0x00	; 0
    3bf4:	ba 01       	movw	r22, r20
    3bf6:	20 e0       	ldi	r18, 0x00	; 0
    3bf8:	00 e0       	ldi	r16, 0x00	; 0
    3bfa:	10 e0       	ldi	r17, 0x00	; 0
    3bfc:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <xTaskGenericNotify>
    3c00:	f5 01       	movw	r30, r10
    3c02:	13 86       	std	Z+11, r1	; 0x0b
    3c04:	12 86       	std	Z+10, r1	; 0x0a
    3c06:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
    3c0a:	02 c0       	rjmp	.+4      	; 0x3c10 <xStreamBufferReceive+0xe8>
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3c0c:	c0 e0       	ldi	r28, 0x00	; 0
    3c0e:	d0 e0       	ldi	r29, 0x00	; 0
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
}
    3c10:	8c 2f       	mov	r24, r28
    3c12:	9d 2f       	mov	r25, r29
    3c14:	df 91       	pop	r29
    3c16:	cf 91       	pop	r28
    3c18:	1f 91       	pop	r17
    3c1a:	0f 91       	pop	r16
    3c1c:	ff 90       	pop	r15
    3c1e:	ef 90       	pop	r14
    3c20:	df 90       	pop	r13
    3c22:	cf 90       	pop	r12
    3c24:	bf 90       	pop	r11
    3c26:	af 90       	pop	r10
    3c28:	9f 90       	pop	r9
    3c2a:	8f 90       	pop	r8
    3c2c:	7f 90       	pop	r7
    3c2e:	6f 90       	pop	r6
    3c30:	08 95       	ret

00003c32 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3c32:	ef 92       	push	r14
    3c34:	ff 92       	push	r15
    3c36:	0f 93       	push	r16
    3c38:	1f 93       	push	r17
    3c3a:	cf 93       	push	r28
    3c3c:	df 93       	push	r29
    3c3e:	00 d0       	rcall	.+0      	; 0x3c40 <xStreamBufferNextMessageLengthBytes+0xe>
    3c40:	cd b7       	in	r28, 0x3d	; 61
    3c42:	de b7       	in	r29, 0x3e	; 62
    3c44:	8c 01       	movw	r16, r24
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3c46:	fc 01       	movw	r30, r24
    3c48:	86 85       	ldd	r24, Z+14	; 0x0e
    3c4a:	80 ff       	sbrs	r24, 0
    3c4c:	18 c0       	rjmp	.+48     	; 0x3c7e <xStreamBufferNextMessageLengthBytes+0x4c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3c4e:	c8 01       	movw	r24, r16
    3c50:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3c54:	9c 01       	movw	r18, r24
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3c56:	83 30       	cpi	r24, 0x03	; 3
    3c58:	91 05       	cpc	r25, r1
    3c5a:	a0 f0       	brcs	.+40     	; 0x3c84 <xStreamBufferNextMessageLengthBytes+0x52>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3c5c:	f8 01       	movw	r30, r16
    3c5e:	e0 80       	ld	r14, Z
    3c60:	f1 80       	ldd	r15, Z+1	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    3c62:	c8 01       	movw	r24, r16
    3c64:	be 01       	movw	r22, r28
    3c66:	6f 5f       	subi	r22, 0xFF	; 255
    3c68:	7f 4f       	sbci	r23, 0xFF	; 255
    3c6a:	42 e0       	ldi	r20, 0x02	; 2
    3c6c:	50 e0       	ldi	r21, 0x00	; 0
    3c6e:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3c72:	89 81       	ldd	r24, Y+1	; 0x01
    3c74:	9a 81       	ldd	r25, Y+2	; 0x02
			pxStreamBuffer->xTail = xOriginalTail;
    3c76:	f8 01       	movw	r30, r16
    3c78:	f1 82       	std	Z+1, r15	; 0x01
    3c7a:	e0 82       	st	Z, r14
    3c7c:	05 c0       	rjmp	.+10     	; 0x3c88 <xStreamBufferNextMessageLengthBytes+0x56>
			xReturn = 0;
		}
	}
	else
	{
		xReturn = 0;
    3c7e:	80 e0       	ldi	r24, 0x00	; 0
    3c80:	90 e0       	ldi	r25, 0x00	; 0
    3c82:	02 c0       	rjmp	.+4      	; 0x3c88 <xStreamBufferNextMessageLengthBytes+0x56>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    3c84:	80 e0       	ldi	r24, 0x00	; 0
    3c86:	90 e0       	ldi	r25, 0x00	; 0
	{
		xReturn = 0;
	}

	return xReturn;
}
    3c88:	0f 90       	pop	r0
    3c8a:	0f 90       	pop	r0
    3c8c:	df 91       	pop	r29
    3c8e:	cf 91       	pop	r28
    3c90:	1f 91       	pop	r17
    3c92:	0f 91       	pop	r16
    3c94:	ff 90       	pop	r15
    3c96:	ef 90       	pop	r14
    3c98:	08 95       	ret

00003c9a <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    3c9a:	af 92       	push	r10
    3c9c:	bf 92       	push	r11
    3c9e:	cf 92       	push	r12
    3ca0:	df 92       	push	r13
    3ca2:	ef 92       	push	r14
    3ca4:	ff 92       	push	r15
    3ca6:	0f 93       	push	r16
    3ca8:	1f 93       	push	r17
    3caa:	cf 93       	push	r28
    3cac:	df 93       	push	r29
    3cae:	6c 01       	movw	r12, r24
    3cb0:	eb 01       	movw	r28, r22
    3cb2:	7a 01       	movw	r14, r20
    3cb4:	59 01       	movw	r10, r18
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3cb6:	fc 01       	movw	r30, r24
    3cb8:	86 85       	ldd	r24, Z+14	; 0x0e
    3cba:	80 ff       	sbrs	r24, 0
    3cbc:	03 c0       	rjmp	.+6      	; 0x3cc4 <xStreamBufferReceiveFromISR+0x2a>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3cbe:	02 e0       	ldi	r16, 0x02	; 2
    3cc0:	10 e0       	ldi	r17, 0x00	; 0
    3cc2:	02 c0       	rjmp	.+4      	; 0x3cc8 <xStreamBufferReceiveFromISR+0x2e>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3cc4:	00 e0       	ldi	r16, 0x00	; 0
    3cc6:	10 e0       	ldi	r17, 0x00	; 0
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3cc8:	c6 01       	movw	r24, r12
    3cca:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <prvBytesInBuffer>
    3cce:	9c 01       	movw	r18, r24
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3cd0:	08 17       	cp	r16, r24
    3cd2:	19 07       	cpc	r17, r25
    3cd4:	e0 f4       	brcc	.+56     	; 0x3d0e <xStreamBufferReceiveFromISR+0x74>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3cd6:	c6 01       	movw	r24, r12
    3cd8:	be 01       	movw	r22, r28
    3cda:	a7 01       	movw	r20, r14
    3cdc:	0e 94 49 1b 	call	0x3692	; 0x3692 <prvReadMessageFromBuffer>
    3ce0:	ec 01       	movw	r28, r24

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3ce2:	00 97       	sbiw	r24, 0x00	; 0
    3ce4:	b1 f0       	breq	.+44     	; 0x3d12 <xStreamBufferReceiveFromISR+0x78>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3ce6:	f6 01       	movw	r30, r12
    3ce8:	82 85       	ldd	r24, Z+10	; 0x0a
    3cea:	93 85       	ldd	r25, Z+11	; 0x0b
    3cec:	00 97       	sbiw	r24, 0x00	; 0
    3cee:	89 f0       	breq	.+34     	; 0x3d12 <xStreamBufferReceiveFromISR+0x78>
    3cf0:	82 85       	ldd	r24, Z+10	; 0x0a
    3cf2:	93 85       	ldd	r25, Z+11	; 0x0b
    3cf4:	40 e0       	ldi	r20, 0x00	; 0
    3cf6:	50 e0       	ldi	r21, 0x00	; 0
    3cf8:	ba 01       	movw	r22, r20
    3cfa:	20 e0       	ldi	r18, 0x00	; 0
    3cfc:	00 e0       	ldi	r16, 0x00	; 0
    3cfe:	10 e0       	ldi	r17, 0x00	; 0
    3d00:	75 01       	movw	r14, r10
    3d02:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGenericNotifyFromISR>
    3d06:	f6 01       	movw	r30, r12
    3d08:	13 86       	std	Z+11, r1	; 0x0b
    3d0a:	12 86       	std	Z+10, r1	; 0x0a
    3d0c:	02 c0       	rjmp	.+4      	; 0x3d12 <xStreamBufferReceiveFromISR+0x78>
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3d0e:	c0 e0       	ldi	r28, 0x00	; 0
    3d10:	d0 e0       	ldi	r29, 0x00	; 0
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
}
    3d12:	8c 2f       	mov	r24, r28
    3d14:	9d 2f       	mov	r25, r29
    3d16:	df 91       	pop	r29
    3d18:	cf 91       	pop	r28
    3d1a:	1f 91       	pop	r17
    3d1c:	0f 91       	pop	r16
    3d1e:	ff 90       	pop	r15
    3d20:	ef 90       	pop	r14
    3d22:	df 90       	pop	r13
    3d24:	cf 90       	pop	r12
    3d26:	bf 90       	pop	r11
    3d28:	af 90       	pop	r10
    3d2a:	08 95       	ret

00003d2c <xStreamBufferIsEmpty>:
	return xReceivedLength;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3d2c:	fc 01       	movw	r30, r24
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3d2e:	40 81       	ld	r20, Z
    3d30:	51 81       	ldd	r21, Z+1	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    3d32:	22 81       	ldd	r18, Z+2	; 0x02
    3d34:	33 81       	ldd	r19, Z+3	; 0x03
	{
		xReturn = pdTRUE;
    3d36:	81 e0       	ldi	r24, 0x01	; 1
    3d38:	42 17       	cp	r20, r18
    3d3a:	53 07       	cpc	r21, r19
    3d3c:	09 f0       	breq	.+2      	; 0x3d40 <xStreamBufferIsEmpty+0x14>
    3d3e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    3d40:	08 95       	ret

00003d42 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    3d42:	cf 93       	push	r28
    3d44:	df 93       	push	r29

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3d46:	fc 01       	movw	r30, r24
    3d48:	26 85       	ldd	r18, Z+14	; 0x0e
    3d4a:	20 ff       	sbrs	r18, 0
    3d4c:	03 c0       	rjmp	.+6      	; 0x3d54 <xStreamBufferIsFull+0x12>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3d4e:	c2 e0       	ldi	r28, 0x02	; 2
    3d50:	d0 e0       	ldi	r29, 0x00	; 0
    3d52:	02 c0       	rjmp	.+4      	; 0x3d58 <xStreamBufferIsFull+0x16>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3d54:	c0 e0       	ldi	r28, 0x00	; 0
    3d56:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    3d58:	0e 94 90 1c 	call	0x3920	; 0x3920 <xStreamBufferSpacesAvailable>
	{
		xReturn = pdTRUE;
    3d5c:	21 e0       	ldi	r18, 0x01	; 1
    3d5e:	c8 17       	cp	r28, r24
    3d60:	d9 07       	cpc	r29, r25
    3d62:	08 f4       	brcc	.+2      	; 0x3d66 <xStreamBufferIsFull+0x24>
    3d64:	20 e0       	ldi	r18, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    3d66:	82 2f       	mov	r24, r18
    3d68:	df 91       	pop	r29
    3d6a:	cf 91       	pop	r28
    3d6c:	08 95       	ret

00003d6e <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3d6e:	ef 92       	push	r14
    3d70:	ff 92       	push	r15
    3d72:	0f 93       	push	r16
    3d74:	1f 93       	push	r17
    3d76:	cf 93       	push	r28
    3d78:	df 93       	push	r29
    3d7a:	ec 01       	movw	r28, r24
    3d7c:	7b 01       	movw	r14, r22

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    3d7e:	88 85       	ldd	r24, Y+8	; 0x08
    3d80:	99 85       	ldd	r25, Y+9	; 0x09
    3d82:	00 97       	sbiw	r24, 0x00	; 0
    3d84:	71 f0       	breq	.+28     	; 0x3da2 <xStreamBufferSendCompletedFromISR+0x34>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3d86:	88 85       	ldd	r24, Y+8	; 0x08
    3d88:	99 85       	ldd	r25, Y+9	; 0x09
    3d8a:	40 e0       	ldi	r20, 0x00	; 0
    3d8c:	50 e0       	ldi	r21, 0x00	; 0
    3d8e:	ba 01       	movw	r22, r20
    3d90:	20 e0       	ldi	r18, 0x00	; 0
    3d92:	00 e0       	ldi	r16, 0x00	; 0
    3d94:	10 e0       	ldi	r17, 0x00	; 0
    3d96:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3d9a:	19 86       	std	Y+9, r1	; 0x09
    3d9c:	18 86       	std	Y+8, r1	; 0x08
			xReturn = pdTRUE;
    3d9e:	81 e0       	ldi	r24, 0x01	; 1
    3da0:	01 c0       	rjmp	.+2      	; 0x3da4 <xStreamBufferSendCompletedFromISR+0x36>
		}
		else
		{
			xReturn = pdFALSE;
    3da2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3da4:	df 91       	pop	r29
    3da6:	cf 91       	pop	r28
    3da8:	1f 91       	pop	r17
    3daa:	0f 91       	pop	r16
    3dac:	ff 90       	pop	r15
    3dae:	ef 90       	pop	r14
    3db0:	08 95       	ret

00003db2 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3db2:	ef 92       	push	r14
    3db4:	ff 92       	push	r15
    3db6:	0f 93       	push	r16
    3db8:	1f 93       	push	r17
    3dba:	cf 93       	push	r28
    3dbc:	df 93       	push	r29
    3dbe:	ec 01       	movw	r28, r24
    3dc0:	7b 01       	movw	r14, r22

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    3dc2:	8a 85       	ldd	r24, Y+10	; 0x0a
    3dc4:	9b 85       	ldd	r25, Y+11	; 0x0b
    3dc6:	00 97       	sbiw	r24, 0x00	; 0
    3dc8:	71 f0       	breq	.+28     	; 0x3de6 <xStreamBufferReceiveCompletedFromISR+0x34>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3dca:	8a 85       	ldd	r24, Y+10	; 0x0a
    3dcc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3dce:	40 e0       	ldi	r20, 0x00	; 0
    3dd0:	50 e0       	ldi	r21, 0x00	; 0
    3dd2:	ba 01       	movw	r22, r20
    3dd4:	20 e0       	ldi	r18, 0x00	; 0
    3dd6:	00 e0       	ldi	r16, 0x00	; 0
    3dd8:	10 e0       	ldi	r17, 0x00	; 0
    3dda:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3dde:	1b 86       	std	Y+11, r1	; 0x0b
    3de0:	1a 86       	std	Y+10, r1	; 0x0a
			xReturn = pdTRUE;
    3de2:	81 e0       	ldi	r24, 0x01	; 1
    3de4:	01 c0       	rjmp	.+2      	; 0x3de8 <xStreamBufferReceiveCompletedFromISR+0x36>
		}
		else
		{
			xReturn = pdFALSE;
    3de6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3de8:	df 91       	pop	r29
    3dea:	cf 91       	pop	r28
    3dec:	1f 91       	pop	r17
    3dee:	0f 91       	pop	r16
    3df0:	ff 90       	pop	r15
    3df2:	ef 90       	pop	r14
    3df4:	08 95       	ret

00003df6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3df6:	e0 91 14 05 	lds	r30, 0x0514
    3dfa:	f0 91 15 05 	lds	r31, 0x0515
    3dfe:	80 81       	ld	r24, Z
    3e00:	88 23       	and	r24, r24
    3e02:	39 f4       	brne	.+14     	; 0x3e12 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3e04:	8f ef       	ldi	r24, 0xFF	; 255
    3e06:	9f ef       	ldi	r25, 0xFF	; 255
    3e08:	90 93 08 05 	sts	0x0508, r25
    3e0c:	80 93 07 05 	sts	0x0507, r24
    3e10:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e12:	e0 91 14 05 	lds	r30, 0x0514
    3e16:	f0 91 15 05 	lds	r31, 0x0515
    3e1a:	05 80       	ldd	r0, Z+5	; 0x05
    3e1c:	f6 81       	ldd	r31, Z+6	; 0x06
    3e1e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3e20:	06 80       	ldd	r0, Z+6	; 0x06
    3e22:	f7 81       	ldd	r31, Z+7	; 0x07
    3e24:	e0 2d       	mov	r30, r0
    3e26:	82 81       	ldd	r24, Z+2	; 0x02
    3e28:	93 81       	ldd	r25, Z+3	; 0x03
    3e2a:	90 93 08 05 	sts	0x0508, r25
    3e2e:	80 93 07 05 	sts	0x0507, r24
    3e32:	08 95       	ret

00003e34 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    3e34:	0f 93       	push	r16
    3e36:	1f 93       	push	r17
    3e38:	cf 93       	push	r28
    3e3a:	df 93       	push	r29
    3e3c:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3e3e:	00 91 0e 05 	lds	r16, 0x050E
    3e42:	10 91 0f 05 	lds	r17, 0x050F
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3e46:	80 91 04 05 	lds	r24, 0x0504
    3e4a:	90 91 05 05 	lds	r25, 0x0505
    3e4e:	02 96       	adiw	r24, 0x02	; 2
    3e50:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    3e54:	c0 0f       	add	r28, r16
    3e56:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    3e58:	e0 91 04 05 	lds	r30, 0x0504
    3e5c:	f0 91 05 05 	lds	r31, 0x0505
    3e60:	d3 83       	std	Z+3, r29	; 0x03
    3e62:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    3e64:	c0 17       	cp	r28, r16
    3e66:	d1 07       	cpc	r29, r17
    3e68:	68 f4       	brcc	.+26     	; 0x3e84 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3e6a:	80 91 12 05 	lds	r24, 0x0512
    3e6e:	90 91 13 05 	lds	r25, 0x0513
    3e72:	60 91 04 05 	lds	r22, 0x0504
    3e76:	70 91 05 05 	lds	r23, 0x0505
    3e7a:	6e 5f       	subi	r22, 0xFE	; 254
    3e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e7e:	0e 94 8c 14 	call	0x2918	; 0x2918 <vListInsert>
    3e82:	17 c0       	rjmp	.+46     	; 0x3eb2 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3e84:	80 91 14 05 	lds	r24, 0x0514
    3e88:	90 91 15 05 	lds	r25, 0x0515
    3e8c:	60 91 04 05 	lds	r22, 0x0504
    3e90:	70 91 05 05 	lds	r23, 0x0505
    3e94:	6e 5f       	subi	r22, 0xFE	; 254
    3e96:	7f 4f       	sbci	r23, 0xFF	; 255
    3e98:	0e 94 8c 14 	call	0x2918	; 0x2918 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    3e9c:	80 91 07 05 	lds	r24, 0x0507
    3ea0:	90 91 08 05 	lds	r25, 0x0508
    3ea4:	c8 17       	cp	r28, r24
    3ea6:	d9 07       	cpc	r29, r25
    3ea8:	20 f4       	brcc	.+8      	; 0x3eb2 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    3eaa:	d0 93 08 05 	sts	0x0508, r29
    3eae:	c0 93 07 05 	sts	0x0507, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3eb2:	df 91       	pop	r29
    3eb4:	cf 91       	pop	r28
    3eb6:	1f 91       	pop	r17
    3eb8:	0f 91       	pop	r16
    3eba:	08 95       	ret

00003ebc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    3ebc:	cf 93       	push	r28
    3ebe:	df 93       	push	r29
    3ec0:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3ec2:	8f 89       	ldd	r24, Y+23	; 0x17
    3ec4:	98 8d       	ldd	r25, Y+24	; 0x18
    3ec6:	0e 94 4c 14 	call	0x2898	; 0x2898 <vPortFree>
			vPortFree( pxTCB );
    3eca:	ce 01       	movw	r24, r28
    3ecc:	0e 94 4c 14 	call	0x2898	; 0x2898 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    3ed0:	df 91       	pop	r29
    3ed2:	cf 91       	pop	r28
    3ed4:	08 95       	ret

00003ed6 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3ed6:	1c c0       	rjmp	.+56     	; 0x3f10 <prvIdleTask+0x3a>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3ed8:	0f b6       	in	r0, 0x3f	; 63
    3eda:	f8 94       	cli
    3edc:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ede:	e0 91 5b 05 	lds	r30, 0x055B
    3ee2:	f0 91 5c 05 	lds	r31, 0x055C
    3ee6:	c6 81       	ldd	r28, Z+6	; 0x06
    3ee8:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3eea:	ce 01       	movw	r24, r28
    3eec:	02 96       	adiw	r24, 0x02	; 2
    3eee:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
				--uxCurrentNumberOfTasks;
    3ef2:	80 91 10 05 	lds	r24, 0x0510
    3ef6:	81 50       	subi	r24, 0x01	; 1
    3ef8:	80 93 10 05 	sts	0x0510, r24
				--uxDeletedTasksWaitingCleanUp;
    3efc:	80 91 11 05 	lds	r24, 0x0511
    3f00:	81 50       	subi	r24, 0x01	; 1
    3f02:	80 93 11 05 	sts	0x0511, r24
			}
			taskEXIT_CRITICAL();
    3f06:	0f 90       	pop	r0
    3f08:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    3f0a:	ce 01       	movw	r24, r28
    3f0c:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3f10:	80 91 11 05 	lds	r24, 0x0511
    3f14:	88 23       	and	r24, r24
    3f16:	01 f7       	brne	.-64     	; 0x3ed8 <prvIdleTask+0x2>
    3f18:	fb cf       	rjmp	.-10     	; 0x3f10 <prvIdleTask+0x3a>

00003f1a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3f1a:	2f 92       	push	r2
    3f1c:	3f 92       	push	r3
    3f1e:	4f 92       	push	r4
    3f20:	5f 92       	push	r5
    3f22:	6f 92       	push	r6
    3f24:	7f 92       	push	r7
    3f26:	8f 92       	push	r8
    3f28:	9f 92       	push	r9
    3f2a:	af 92       	push	r10
    3f2c:	bf 92       	push	r11
    3f2e:	df 92       	push	r13
    3f30:	ef 92       	push	r14
    3f32:	ff 92       	push	r15
    3f34:	0f 93       	push	r16
    3f36:	1f 93       	push	r17
    3f38:	cf 93       	push	r28
    3f3a:	df 93       	push	r29
    3f3c:	3c 01       	movw	r6, r24
    3f3e:	5b 01       	movw	r10, r22
    3f40:	ea 01       	movw	r28, r20
    3f42:	29 01       	movw	r4, r18
    3f44:	d0 2e       	mov	r13, r16
    3f46:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3f48:	ca 01       	movw	r24, r20
    3f4a:	0e 94 16 14 	call	0x282c	; 0x282c <pvPortMalloc>
    3f4e:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    3f50:	00 97       	sbiw	r24, 0x00	; 0
    3f52:	09 f4       	brne	.+2      	; 0x3f56 <xTaskCreate+0x3c>
    3f54:	ec c0       	rjmp	.+472    	; 0x412e <xTaskCreate+0x214>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3f56:	86 e2       	ldi	r24, 0x26	; 38
    3f58:	90 e0       	ldi	r25, 0x00	; 0
    3f5a:	0e 94 16 14 	call	0x282c	; 0x282c <pvPortMalloc>
    3f5e:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    3f60:	00 97       	sbiw	r24, 0x00	; 0
    3f62:	59 f0       	breq	.+22     	; 0x3f7a <xTaskCreate+0x60>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3f64:	fc 01       	movw	r30, r24
    3f66:	f0 8e       	std	Z+24, r15	; 0x18
    3f68:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3f6a:	21 97       	sbiw	r28, 0x01	; 1
    3f6c:	17 01       	movw	r2, r14
    3f6e:	2c 0e       	add	r2, r28
    3f70:	3d 1e       	adc	r3, r29
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3f72:	a1 14       	cp	r10, r1
    3f74:	b1 04       	cpc	r11, r1
    3f76:	31 f4       	brne	.+12     	; 0x3f84 <xTaskCreate+0x6a>
    3f78:	1e c0       	rjmp	.+60     	; 0x3fb6 <xTaskCreate+0x9c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3f7a:	c7 01       	movw	r24, r14
    3f7c:	0e 94 4c 14 	call	0x2898	; 0x2898 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3f80:	8f ef       	ldi	r24, 0xFF	; 255
    3f82:	da c0       	rjmp	.+436    	; 0x4138 <xTaskCreate+0x21e>
	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3f84:	f5 01       	movw	r30, r10
    3f86:	80 81       	ld	r24, Z
    3f88:	f8 01       	movw	r30, r16
    3f8a:	81 8f       	std	Z+25, r24	; 0x19

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3f8c:	f5 01       	movw	r30, r10
    3f8e:	80 81       	ld	r24, Z
    3f90:	88 23       	and	r24, r24
    3f92:	71 f0       	breq	.+28     	; 0x3fb0 <xTaskCreate+0x96>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    3f94:	e8 01       	movw	r28, r16
    3f96:	6a 96       	adiw	r28, 0x1a	; 26
    3f98:	d5 01       	movw	r26, r10
    3f9a:	11 96       	adiw	r26, 0x01	; 1
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3f9c:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    3f9e:	fd 01       	movw	r30, r26
	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3fa0:	9d 91       	ld	r25, X+
    3fa2:	99 93       	st	Y+, r25

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3fa4:	90 81       	ld	r25, Z
    3fa6:	99 23       	and	r25, r25
    3fa8:	19 f0       	breq	.+6      	; 0x3fb0 <xTaskCreate+0x96>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3faa:	8f 5f       	subi	r24, 0xFF	; 255
    3fac:	88 30       	cpi	r24, 0x08	; 8
    3fae:	b9 f7       	brne	.-18     	; 0x3f9e <xTaskCreate+0x84>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3fb0:	f8 01       	movw	r30, r16
    3fb2:	10 a2       	lds	r17, 0x90
    3fb4:	02 c0       	rjmp	.+4      	; 0x3fba <xTaskCreate+0xa0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3fb6:	fc 01       	movw	r30, r24
    3fb8:	11 8e       	std	Z+25, r1	; 0x19
    3fba:	cd 2d       	mov	r28, r13
    3fbc:	c4 30       	cpi	r28, 0x04	; 4
    3fbe:	08 f0       	brcs	.+2      	; 0x3fc2 <xTaskCreate+0xa8>
    3fc0:	c3 e0       	ldi	r28, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3fc2:	f8 01       	movw	r30, r16
    3fc4:	c6 8b       	std	Z+22, r28	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3fc6:	ee 24       	eor	r14, r14
    3fc8:	ff 24       	eor	r15, r15
    3fca:	68 94       	set
    3fcc:	e1 f8       	bld	r14, 1
    3fce:	e0 0e       	add	r14, r16
    3fd0:	f1 1e       	adc	r15, r17
    3fd2:	c7 01       	movw	r24, r14
    3fd4:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3fd8:	c8 01       	movw	r24, r16
    3fda:	0c 96       	adiw	r24, 0x0c	; 12
    3fdc:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3fe0:	f8 01       	movw	r30, r16
    3fe2:	11 87       	std	Z+9, r17	; 0x09
    3fe4:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3fe6:	84 e0       	ldi	r24, 0x04	; 4
    3fe8:	90 e0       	ldi	r25, 0x00	; 0
    3fea:	8c 1b       	sub	r24, r28
    3fec:	91 09       	sbc	r25, r1
    3fee:	95 87       	std	Z+13, r25	; 0x0d
    3ff0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3ff2:	13 8b       	std	Z+19, r17	; 0x13
    3ff4:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3ff6:	11 a2       	lds	r17, 0x91
    3ff8:	12 a2       	lds	r17, 0x92
    3ffa:	13 a2       	lds	r17, 0x93
    3ffc:	14 a2       	lds	r17, 0x94
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3ffe:	15 a2       	lds	r17, 0x95
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4000:	c1 01       	movw	r24, r2
    4002:	b3 01       	movw	r22, r6
    4004:	a2 01       	movw	r20, r4
    4006:	0e 94 e7 14 	call	0x29ce	; 0x29ce <pxPortInitialiseStack>
    400a:	f8 01       	movw	r30, r16
    400c:	91 83       	std	Z+1, r25	; 0x01
    400e:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4010:	81 14       	cp	r8, r1
    4012:	91 04       	cpc	r9, r1
    4014:	19 f0       	breq	.+6      	; 0x401c <xTaskCreate+0x102>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4016:	f4 01       	movw	r30, r8
    4018:	11 83       	std	Z+1, r17	; 0x01
    401a:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    401c:	0f b6       	in	r0, 0x3f	; 63
    401e:	f8 94       	cli
    4020:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4022:	80 91 10 05 	lds	r24, 0x0510
    4026:	8f 5f       	subi	r24, 0xFF	; 255
    4028:	80 93 10 05 	sts	0x0510, r24
		if( pxCurrentTCB == NULL )
    402c:	80 91 04 05 	lds	r24, 0x0504
    4030:	90 91 05 05 	lds	r25, 0x0505
    4034:	00 97       	sbiw	r24, 0x00	; 0
    4036:	d9 f5       	brne	.+118    	; 0x40ae <xTaskCreate+0x194>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4038:	10 93 05 05 	sts	0x0505, r17
    403c:	00 93 04 05 	sts	0x0504, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4040:	80 91 10 05 	lds	r24, 0x0510
    4044:	81 30       	cpi	r24, 0x01	; 1
    4046:	09 f0       	breq	.+2      	; 0x404a <xTaskCreate+0x130>
    4048:	43 c0       	rjmp	.+134    	; 0x40d0 <xTaskCreate+0x1b6>
    404a:	c0 e0       	ldi	r28, 0x00	; 0
    404c:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    404e:	ce 01       	movw	r24, r28
    4050:	88 0f       	add	r24, r24
    4052:	99 1f       	adc	r25, r25
    4054:	88 0f       	add	r24, r24
    4056:	99 1f       	adc	r25, r25
    4058:	88 0f       	add	r24, r24
    405a:	99 1f       	adc	r25, r25
    405c:	8c 0f       	add	r24, r28
    405e:	9d 1f       	adc	r25, r29
    4060:	89 5e       	subi	r24, 0xE9	; 233
    4062:	9a 4f       	sbci	r25, 0xFA	; 250
    4064:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
    4068:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    406a:	c4 30       	cpi	r28, 0x04	; 4
    406c:	d1 05       	cpc	r29, r1
    406e:	79 f7       	brne	.-34     	; 0x404e <xTaskCreate+0x134>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4070:	cb e3       	ldi	r28, 0x3B	; 59
    4072:	d5 e0       	ldi	r29, 0x05	; 5
    4074:	ce 01       	movw	r24, r28
    4076:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    407a:	0f 2e       	mov	r0, r31
    407c:	f4 e4       	ldi	r31, 0x44	; 68
    407e:	af 2e       	mov	r10, r31
    4080:	f5 e0       	ldi	r31, 0x05	; 5
    4082:	bf 2e       	mov	r11, r31
    4084:	f0 2d       	mov	r31, r0
    4086:	c5 01       	movw	r24, r10
    4088:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    408c:	8d e4       	ldi	r24, 0x4D	; 77
    408e:	95 e0       	ldi	r25, 0x05	; 5
    4090:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4094:	86 e5       	ldi	r24, 0x56	; 86
    4096:	95 e0       	ldi	r25, 0x05	; 5
    4098:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    409c:	d0 93 15 05 	sts	0x0515, r29
    40a0:	c0 93 14 05 	sts	0x0514, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    40a4:	b0 92 13 05 	sts	0x0513, r11
    40a8:	a0 92 12 05 	sts	0x0512, r10
    40ac:	11 c0       	rjmp	.+34     	; 0x40d0 <xTaskCreate+0x1b6>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    40ae:	80 91 0c 05 	lds	r24, 0x050C
    40b2:	88 23       	and	r24, r24
    40b4:	69 f4       	brne	.+26     	; 0x40d0 <xTaskCreate+0x1b6>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    40b6:	e0 91 04 05 	lds	r30, 0x0504
    40ba:	f0 91 05 05 	lds	r31, 0x0505
    40be:	96 89       	ldd	r25, Z+22	; 0x16
    40c0:	f8 01       	movw	r30, r16
    40c2:	86 89       	ldd	r24, Z+22	; 0x16
    40c4:	89 17       	cp	r24, r25
    40c6:	20 f0       	brcs	.+8      	; 0x40d0 <xTaskCreate+0x1b6>
				{
					pxCurrentTCB = pxNewTCB;
    40c8:	10 93 05 05 	sts	0x0505, r17
    40cc:	00 93 04 05 	sts	0x0504, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    40d0:	80 91 16 05 	lds	r24, 0x0516
    40d4:	8f 5f       	subi	r24, 0xFF	; 255
    40d6:	80 93 16 05 	sts	0x0516, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    40da:	f8 01       	movw	r30, r16
    40dc:	86 89       	ldd	r24, Z+22	; 0x16
    40de:	90 91 0d 05 	lds	r25, 0x050D
    40e2:	98 17       	cp	r25, r24
    40e4:	10 f4       	brcc	.+4      	; 0x40ea <xTaskCreate+0x1d0>
    40e6:	80 93 0d 05 	sts	0x050D, r24
    40ea:	90 e0       	ldi	r25, 0x00	; 0
    40ec:	9c 01       	movw	r18, r24
    40ee:	22 0f       	add	r18, r18
    40f0:	33 1f       	adc	r19, r19
    40f2:	22 0f       	add	r18, r18
    40f4:	33 1f       	adc	r19, r19
    40f6:	22 0f       	add	r18, r18
    40f8:	33 1f       	adc	r19, r19
    40fa:	82 0f       	add	r24, r18
    40fc:	93 1f       	adc	r25, r19
    40fe:	89 5e       	subi	r24, 0xE9	; 233
    4100:	9a 4f       	sbci	r25, 0xFA	; 250
    4102:	b7 01       	movw	r22, r14
    4104:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4108:	0f 90       	pop	r0
    410a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    410c:	80 91 0c 05 	lds	r24, 0x050C
    4110:	88 23       	and	r24, r24
    4112:	79 f0       	breq	.+30     	; 0x4132 <xTaskCreate+0x218>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4114:	e0 91 04 05 	lds	r30, 0x0504
    4118:	f0 91 05 05 	lds	r31, 0x0505
    411c:	96 89       	ldd	r25, Z+22	; 0x16
    411e:	f8 01       	movw	r30, r16
    4120:	86 89       	ldd	r24, Z+22	; 0x16
    4122:	98 17       	cp	r25, r24
    4124:	40 f4       	brcc	.+16     	; 0x4136 <xTaskCreate+0x21c>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4126:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    412a:	81 e0       	ldi	r24, 0x01	; 1
    412c:	05 c0       	rjmp	.+10     	; 0x4138 <xTaskCreate+0x21e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    412e:	8f ef       	ldi	r24, 0xFF	; 255
    4130:	03 c0       	rjmp	.+6      	; 0x4138 <xTaskCreate+0x21e>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    4132:	81 e0       	ldi	r24, 0x01	; 1
    4134:	01 c0       	rjmp	.+2      	; 0x4138 <xTaskCreate+0x21e>
    4136:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    4138:	df 91       	pop	r29
    413a:	cf 91       	pop	r28
    413c:	1f 91       	pop	r17
    413e:	0f 91       	pop	r16
    4140:	ff 90       	pop	r15
    4142:	ef 90       	pop	r14
    4144:	df 90       	pop	r13
    4146:	bf 90       	pop	r11
    4148:	af 90       	pop	r10
    414a:	9f 90       	pop	r9
    414c:	8f 90       	pop	r8
    414e:	7f 90       	pop	r7
    4150:	6f 90       	pop	r6
    4152:	5f 90       	pop	r5
    4154:	4f 90       	pop	r4
    4156:	3f 90       	pop	r3
    4158:	2f 90       	pop	r2
    415a:	08 95       	ret

0000415c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    415c:	0f 93       	push	r16
    415e:	1f 93       	push	r17
    4160:	cf 93       	push	r28
    4162:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4164:	0f b6       	in	r0, 0x3f	; 63
    4166:	f8 94       	cli
    4168:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    416a:	00 97       	sbiw	r24, 0x00	; 0
    416c:	29 f4       	brne	.+10     	; 0x4178 <vTaskDelete+0x1c>
    416e:	c0 91 04 05 	lds	r28, 0x0504
    4172:	d0 91 05 05 	lds	r29, 0x0505
    4176:	01 c0       	rjmp	.+2      	; 0x417a <vTaskDelete+0x1e>
    4178:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    417a:	8e 01       	movw	r16, r28
    417c:	0e 5f       	subi	r16, 0xFE	; 254
    417e:	1f 4f       	sbci	r17, 0xFF	; 255
    4180:	c8 01       	movw	r24, r16
    4182:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4186:	8c 89       	ldd	r24, Y+20	; 0x14
    4188:	9d 89       	ldd	r25, Y+21	; 0x15
    418a:	00 97       	sbiw	r24, 0x00	; 0
    418c:	21 f0       	breq	.+8      	; 0x4196 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    418e:	ce 01       	movw	r24, r28
    4190:	0c 96       	adiw	r24, 0x0c	; 12
    4192:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4196:	80 91 16 05 	lds	r24, 0x0516
    419a:	8f 5f       	subi	r24, 0xFF	; 255
    419c:	80 93 16 05 	sts	0x0516, r24

			if( pxTCB == pxCurrentTCB )
    41a0:	80 91 04 05 	lds	r24, 0x0504
    41a4:	90 91 05 05 	lds	r25, 0x0505
    41a8:	c8 17       	cp	r28, r24
    41aa:	d9 07       	cpc	r29, r25
    41ac:	59 f4       	brne	.+22     	; 0x41c4 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    41ae:	86 e5       	ldi	r24, 0x56	; 86
    41b0:	95 e0       	ldi	r25, 0x05	; 5
    41b2:	b8 01       	movw	r22, r16
    41b4:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    41b8:	80 91 11 05 	lds	r24, 0x0511
    41bc:	8f 5f       	subi	r24, 0xFF	; 255
    41be:	80 93 11 05 	sts	0x0511, r24
    41c2:	0a c0       	rjmp	.+20     	; 0x41d8 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    41c4:	80 91 10 05 	lds	r24, 0x0510
    41c8:	81 50       	subi	r24, 0x01	; 1
    41ca:	80 93 10 05 	sts	0x0510, r24
				prvDeleteTCB( pxTCB );
    41ce:	ce 01       	movw	r24, r28
    41d0:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    41d4:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    41d8:	0f 90       	pop	r0
    41da:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    41dc:	80 91 0c 05 	lds	r24, 0x050C
    41e0:	88 23       	and	r24, r24
    41e2:	49 f0       	breq	.+18     	; 0x41f6 <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    41e4:	80 91 04 05 	lds	r24, 0x0504
    41e8:	90 91 05 05 	lds	r25, 0x0505
    41ec:	c8 17       	cp	r28, r24
    41ee:	d9 07       	cpc	r29, r25
    41f0:	11 f4       	brne	.+4      	; 0x41f6 <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    41f2:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    41f6:	df 91       	pop	r29
    41f8:	cf 91       	pop	r28
    41fa:	1f 91       	pop	r17
    41fc:	0f 91       	pop	r16
    41fe:	08 95       	ret

00004200 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4200:	ef 92       	push	r14
    4202:	ff 92       	push	r15
    4204:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4206:	8b e6       	ldi	r24, 0x6B	; 107
    4208:	9f e1       	ldi	r25, 0x1F	; 31
    420a:	6a ed       	ldi	r22, 0xDA	; 218
    420c:	70 e0       	ldi	r23, 0x00	; 0
    420e:	45 e5       	ldi	r20, 0x55	; 85
    4210:	50 e0       	ldi	r21, 0x00	; 0
    4212:	20 e0       	ldi	r18, 0x00	; 0
    4214:	30 e0       	ldi	r19, 0x00	; 0
    4216:	00 e0       	ldi	r16, 0x00	; 0
    4218:	0f 2e       	mov	r0, r31
    421a:	ff e5       	ldi	r31, 0x5F	; 95
    421c:	ef 2e       	mov	r14, r31
    421e:	f5 e0       	ldi	r31, 0x05	; 5
    4220:	ff 2e       	mov	r15, r31
    4222:	f0 2d       	mov	r31, r0
    4224:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4228:	81 30       	cpi	r24, 0x01	; 1
    422a:	81 f4       	brne	.+32     	; 0x424c <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    422c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    422e:	8f ef       	ldi	r24, 0xFF	; 255
    4230:	9f ef       	ldi	r25, 0xFF	; 255
    4232:	90 93 08 05 	sts	0x0508, r25
    4236:	80 93 07 05 	sts	0x0507, r24
		xSchedulerRunning = pdTRUE;
    423a:	81 e0       	ldi	r24, 0x01	; 1
    423c:	80 93 0c 05 	sts	0x050C, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4240:	10 92 0f 05 	sts	0x050F, r1
    4244:	10 92 0e 05 	sts	0x050E, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4248:	0e 94 77 15 	call	0x2aee	; 0x2aee <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    424c:	0f 91       	pop	r16
    424e:	ff 90       	pop	r15
    4250:	ef 90       	pop	r14
    4252:	08 95       	ret

00004254 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4254:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4256:	10 92 0c 05 	sts	0x050C, r1
	vPortEndScheduler();
    425a:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <vPortEndScheduler>
}
    425e:	08 95       	ret

00004260 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4260:	80 91 06 05 	lds	r24, 0x0506
    4264:	8f 5f       	subi	r24, 0xFF	; 255
    4266:	80 93 06 05 	sts	0x0506, r24
}
    426a:	08 95       	ret

0000426c <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    426c:	0f b6       	in	r0, 0x3f	; 63
    426e:	f8 94       	cli
    4270:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4272:	80 91 0e 05 	lds	r24, 0x050E
    4276:	90 91 0f 05 	lds	r25, 0x050F
	}
	portTICK_TYPE_EXIT_CRITICAL();
    427a:	0f 90       	pop	r0
    427c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    427e:	08 95       	ret

00004280 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    4280:	80 91 0e 05 	lds	r24, 0x050E
    4284:	90 91 0f 05 	lds	r25, 0x050F
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    4288:	08 95       	ret

0000428a <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    428a:	80 91 10 05 	lds	r24, 0x0510
}
    428e:	08 95       	ret

00004290 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4290:	00 97       	sbiw	r24, 0x00	; 0
    4292:	21 f4       	brne	.+8      	; 0x429c <pcTaskGetName+0xc>
    4294:	80 91 04 05 	lds	r24, 0x0504
    4298:	90 91 05 05 	lds	r25, 0x0505
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    429c:	49 96       	adiw	r24, 0x19	; 25
}
    429e:	08 95       	ret

000042a0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    42a0:	cf 92       	push	r12
    42a2:	df 92       	push	r13
    42a4:	ef 92       	push	r14
    42a6:	ff 92       	push	r15
    42a8:	0f 93       	push	r16
    42aa:	1f 93       	push	r17
    42ac:	cf 93       	push	r28
    42ae:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    42b0:	80 91 06 05 	lds	r24, 0x0506
    42b4:	88 23       	and	r24, r24
    42b6:	09 f0       	breq	.+2      	; 0x42ba <xTaskIncrementTick+0x1a>
    42b8:	98 c0       	rjmp	.+304    	; 0x43ea <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    42ba:	c0 90 0e 05 	lds	r12, 0x050E
    42be:	d0 90 0f 05 	lds	r13, 0x050F
    42c2:	08 94       	sec
    42c4:	c1 1c       	adc	r12, r1
    42c6:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    42c8:	d0 92 0f 05 	sts	0x050F, r13
    42cc:	c0 92 0e 05 	sts	0x050E, r12

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    42d0:	c1 14       	cp	r12, r1
    42d2:	d1 04       	cpc	r13, r1
    42d4:	b9 f4       	brne	.+46     	; 0x4304 <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    42d6:	80 91 14 05 	lds	r24, 0x0514
    42da:	90 91 15 05 	lds	r25, 0x0515
    42de:	20 91 12 05 	lds	r18, 0x0512
    42e2:	30 91 13 05 	lds	r19, 0x0513
    42e6:	30 93 15 05 	sts	0x0515, r19
    42ea:	20 93 14 05 	sts	0x0514, r18
    42ee:	90 93 13 05 	sts	0x0513, r25
    42f2:	80 93 12 05 	sts	0x0512, r24
    42f6:	80 91 09 05 	lds	r24, 0x0509
    42fa:	8f 5f       	subi	r24, 0xFF	; 255
    42fc:	80 93 09 05 	sts	0x0509, r24
    4300:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4304:	80 91 07 05 	lds	r24, 0x0507
    4308:	90 91 08 05 	lds	r25, 0x0508
    430c:	c8 16       	cp	r12, r24
    430e:	d9 06       	cpc	r13, r25
    4310:	20 f4       	brcc	.+8      	; 0x431a <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4312:	ff 24       	eor	r15, r15
    4314:	54 c0       	rjmp	.+168    	; 0x43be <xTaskIncrementTick+0x11e>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    4316:	fe 2c       	mov	r15, r14
    4318:	03 c0       	rjmp	.+6      	; 0x4320 <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    431a:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    431c:	ee 24       	eor	r14, r14
    431e:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4320:	e0 91 14 05 	lds	r30, 0x0514
    4324:	f0 91 15 05 	lds	r31, 0x0515
    4328:	80 81       	ld	r24, Z
    432a:	88 23       	and	r24, r24
    432c:	39 f4       	brne	.+14     	; 0x433c <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    432e:	8f ef       	ldi	r24, 0xFF	; 255
    4330:	9f ef       	ldi	r25, 0xFF	; 255
    4332:	90 93 08 05 	sts	0x0508, r25
    4336:	80 93 07 05 	sts	0x0507, r24
					break;
    433a:	41 c0       	rjmp	.+130    	; 0x43be <xTaskIncrementTick+0x11e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    433c:	e0 91 14 05 	lds	r30, 0x0514
    4340:	f0 91 15 05 	lds	r31, 0x0515
    4344:	05 80       	ldd	r0, Z+5	; 0x05
    4346:	f6 81       	ldd	r31, Z+6	; 0x06
    4348:	e0 2d       	mov	r30, r0
    434a:	c6 81       	ldd	r28, Z+6	; 0x06
    434c:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    434e:	8a 81       	ldd	r24, Y+2	; 0x02
    4350:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    4352:	c8 16       	cp	r12, r24
    4354:	d9 06       	cpc	r13, r25
    4356:	28 f4       	brcc	.+10     	; 0x4362 <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4358:	90 93 08 05 	sts	0x0508, r25
    435c:	80 93 07 05 	sts	0x0507, r24
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4360:	2e c0       	rjmp	.+92     	; 0x43be <xTaskIncrementTick+0x11e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4362:	8e 01       	movw	r16, r28
    4364:	0e 5f       	subi	r16, 0xFE	; 254
    4366:	1f 4f       	sbci	r17, 0xFF	; 255
    4368:	c8 01       	movw	r24, r16
    436a:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    436e:	8c 89       	ldd	r24, Y+20	; 0x14
    4370:	9d 89       	ldd	r25, Y+21	; 0x15
    4372:	00 97       	sbiw	r24, 0x00	; 0
    4374:	21 f0       	breq	.+8      	; 0x437e <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4376:	ce 01       	movw	r24, r28
    4378:	0c 96       	adiw	r24, 0x0c	; 12
    437a:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    437e:	8e 89       	ldd	r24, Y+22	; 0x16
    4380:	90 91 0d 05 	lds	r25, 0x050D
    4384:	98 17       	cp	r25, r24
    4386:	10 f4       	brcc	.+4      	; 0x438c <xTaskIncrementTick+0xec>
    4388:	80 93 0d 05 	sts	0x050D, r24
    438c:	90 e0       	ldi	r25, 0x00	; 0
    438e:	9c 01       	movw	r18, r24
    4390:	22 0f       	add	r18, r18
    4392:	33 1f       	adc	r19, r19
    4394:	22 0f       	add	r18, r18
    4396:	33 1f       	adc	r19, r19
    4398:	22 0f       	add	r18, r18
    439a:	33 1f       	adc	r19, r19
    439c:	82 0f       	add	r24, r18
    439e:	93 1f       	adc	r25, r19
    43a0:	89 5e       	subi	r24, 0xE9	; 233
    43a2:	9a 4f       	sbci	r25, 0xFA	; 250
    43a4:	b8 01       	movw	r22, r16
    43a6:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    43aa:	e0 91 04 05 	lds	r30, 0x0504
    43ae:	f0 91 05 05 	lds	r31, 0x0505
    43b2:	9e 89       	ldd	r25, Y+22	; 0x16
    43b4:	86 89       	ldd	r24, Z+22	; 0x16
    43b6:	98 17       	cp	r25, r24
    43b8:	08 f0       	brcs	.+2      	; 0x43bc <xTaskIncrementTick+0x11c>
    43ba:	ad cf       	rjmp	.-166    	; 0x4316 <xTaskIncrementTick+0x76>
    43bc:	b1 cf       	rjmp	.-158    	; 0x4320 <xTaskIncrementTick+0x80>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    43be:	e0 91 04 05 	lds	r30, 0x0504
    43c2:	f0 91 05 05 	lds	r31, 0x0505
    43c6:	86 89       	ldd	r24, Z+22	; 0x16
    43c8:	90 e0       	ldi	r25, 0x00	; 0
    43ca:	fc 01       	movw	r30, r24
    43cc:	ee 0f       	add	r30, r30
    43ce:	ff 1f       	adc	r31, r31
    43d0:	ee 0f       	add	r30, r30
    43d2:	ff 1f       	adc	r31, r31
    43d4:	ee 0f       	add	r30, r30
    43d6:	ff 1f       	adc	r31, r31
    43d8:	8e 0f       	add	r24, r30
    43da:	9f 1f       	adc	r25, r31
    43dc:	fc 01       	movw	r30, r24
    43de:	e9 5e       	subi	r30, 0xE9	; 233
    43e0:	fa 4f       	sbci	r31, 0xFA	; 250
    43e2:	80 81       	ld	r24, Z
    43e4:	82 30       	cpi	r24, 0x02	; 2
    43e6:	40 f4       	brcc	.+16     	; 0x43f8 <xTaskIncrementTick+0x158>
    43e8:	09 c0       	rjmp	.+18     	; 0x43fc <xTaskIncrementTick+0x15c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    43ea:	80 91 0b 05 	lds	r24, 0x050B
    43ee:	8f 5f       	subi	r24, 0xFF	; 255
    43f0:	80 93 0b 05 	sts	0x050B, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    43f4:	ff 24       	eor	r15, r15
    43f6:	02 c0       	rjmp	.+4      	; 0x43fc <xTaskIncrementTick+0x15c>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    43f8:	ff 24       	eor	r15, r15
    43fa:	f3 94       	inc	r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    43fc:	80 91 0a 05 	lds	r24, 0x050A
    4400:	88 23       	and	r24, r24
    4402:	11 f0       	breq	.+4      	; 0x4408 <xTaskIncrementTick+0x168>
		{
			xSwitchRequired = pdTRUE;
    4404:	ff 24       	eor	r15, r15
    4406:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    4408:	8f 2d       	mov	r24, r15
    440a:	df 91       	pop	r29
    440c:	cf 91       	pop	r28
    440e:	1f 91       	pop	r17
    4410:	0f 91       	pop	r16
    4412:	ff 90       	pop	r15
    4414:	ef 90       	pop	r14
    4416:	df 90       	pop	r13
    4418:	cf 90       	pop	r12
    441a:	08 95       	ret

0000441c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    441c:	df 92       	push	r13
    441e:	ef 92       	push	r14
    4420:	ff 92       	push	r15
    4422:	0f 93       	push	r16
    4424:	1f 93       	push	r17
    4426:	cf 93       	push	r28
    4428:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    442a:	0f b6       	in	r0, 0x3f	; 63
    442c:	f8 94       	cli
    442e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4430:	80 91 06 05 	lds	r24, 0x0506
    4434:	81 50       	subi	r24, 0x01	; 1
    4436:	80 93 06 05 	sts	0x0506, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    443a:	80 91 06 05 	lds	r24, 0x0506
    443e:	88 23       	and	r24, r24
    4440:	09 f0       	breq	.+2      	; 0x4444 <xTaskResumeAll+0x28>
    4442:	5f c0       	rjmp	.+190    	; 0x4502 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4444:	80 91 10 05 	lds	r24, 0x0510
    4448:	88 23       	and	r24, r24
    444a:	91 f5       	brne	.+100    	; 0x44b0 <xTaskResumeAll+0x94>
    444c:	5d c0       	rjmp	.+186    	; 0x4508 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    444e:	e0 91 52 05 	lds	r30, 0x0552
    4452:	f0 91 53 05 	lds	r31, 0x0553
    4456:	c6 81       	ldd	r28, Z+6	; 0x06
    4458:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    445a:	ce 01       	movw	r24, r28
    445c:	0c 96       	adiw	r24, 0x0c	; 12
    445e:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4462:	8e 01       	movw	r16, r28
    4464:	0e 5f       	subi	r16, 0xFE	; 254
    4466:	1f 4f       	sbci	r17, 0xFF	; 255
    4468:	c8 01       	movw	r24, r16
    446a:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    446e:	8e 89       	ldd	r24, Y+22	; 0x16
    4470:	90 91 0d 05 	lds	r25, 0x050D
    4474:	98 17       	cp	r25, r24
    4476:	10 f4       	brcc	.+4      	; 0x447c <xTaskResumeAll+0x60>
    4478:	80 93 0d 05 	sts	0x050D, r24
    447c:	90 e0       	ldi	r25, 0x00	; 0
    447e:	9c 01       	movw	r18, r24
    4480:	22 0f       	add	r18, r18
    4482:	33 1f       	adc	r19, r19
    4484:	22 0f       	add	r18, r18
    4486:	33 1f       	adc	r19, r19
    4488:	22 0f       	add	r18, r18
    448a:	33 1f       	adc	r19, r19
    448c:	82 0f       	add	r24, r18
    448e:	93 1f       	adc	r25, r19
    4490:	89 5e       	subi	r24, 0xE9	; 233
    4492:	9a 4f       	sbci	r25, 0xFA	; 250
    4494:	b8 01       	movw	r22, r16
    4496:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    449a:	e0 91 04 05 	lds	r30, 0x0504
    449e:	f0 91 05 05 	lds	r31, 0x0505
    44a2:	9e 89       	ldd	r25, Y+22	; 0x16
    44a4:	86 89       	ldd	r24, Z+22	; 0x16
    44a6:	98 17       	cp	r25, r24
    44a8:	68 f0       	brcs	.+26     	; 0x44c4 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    44aa:	d0 92 0a 05 	sts	0x050A, r13
    44ae:	0a c0       	rjmp	.+20     	; 0x44c4 <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    44b0:	c0 e0       	ldi	r28, 0x00	; 0
    44b2:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    44b4:	0f 2e       	mov	r0, r31
    44b6:	fd e4       	ldi	r31, 0x4D	; 77
    44b8:	ef 2e       	mov	r14, r31
    44ba:	f5 e0       	ldi	r31, 0x05	; 5
    44bc:	ff 2e       	mov	r15, r31
    44be:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    44c0:	dd 24       	eor	r13, r13
    44c2:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    44c4:	f7 01       	movw	r30, r14
    44c6:	80 81       	ld	r24, Z
    44c8:	88 23       	and	r24, r24
    44ca:	09 f6       	brne	.-126    	; 0x444e <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    44cc:	20 97       	sbiw	r28, 0x00	; 0
    44ce:	11 f0       	breq	.+4      	; 0x44d4 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    44d0:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    44d4:	c0 91 0b 05 	lds	r28, 0x050B

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    44d8:	cc 23       	and	r28, r28
    44da:	59 f0       	breq	.+22     	; 0x44f2 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    44dc:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    44de:	0e 94 50 21 	call	0x42a0	; 0x42a0 <xTaskIncrementTick>
    44e2:	88 23       	and	r24, r24
    44e4:	11 f0       	breq	.+4      	; 0x44ea <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    44e6:	00 93 0a 05 	sts	0x050A, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    44ea:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    44ec:	c1 f7       	brne	.-16     	; 0x44de <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    44ee:	10 92 0b 05 	sts	0x050B, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    44f2:	80 91 0a 05 	lds	r24, 0x050A
    44f6:	88 23       	and	r24, r24
    44f8:	31 f0       	breq	.+12     	; 0x4506 <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    44fa:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    44fe:	81 e0       	ldi	r24, 0x01	; 1
    4500:	03 c0       	rjmp	.+6      	; 0x4508 <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    4502:	80 e0       	ldi	r24, 0x00	; 0
    4504:	01 c0       	rjmp	.+2      	; 0x4508 <xTaskResumeAll+0xec>
    4506:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4508:	0f 90       	pop	r0
    450a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    450c:	df 91       	pop	r29
    450e:	cf 91       	pop	r28
    4510:	1f 91       	pop	r17
    4512:	0f 91       	pop	r16
    4514:	ff 90       	pop	r15
    4516:	ef 90       	pop	r14
    4518:	df 90       	pop	r13
    451a:	08 95       	ret

0000451c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    451c:	cf 93       	push	r28
    451e:	df 93       	push	r29
    4520:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4522:	00 97       	sbiw	r24, 0x00	; 0
    4524:	51 f0       	breq	.+20     	; 0x453a <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4526:	0e 94 30 21 	call	0x4260	; 0x4260 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    452a:	ce 01       	movw	r24, r28
    452c:	60 e0       	ldi	r22, 0x00	; 0
    452e:	0e 94 1a 1f 	call	0x3e34	; 0x3e34 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4532:	0e 94 0e 22 	call	0x441c	; 0x441c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4536:	88 23       	and	r24, r24
    4538:	11 f4       	brne	.+4      	; 0x453e <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    453a:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    453e:	df 91       	pop	r29
    4540:	cf 91       	pop	r28
    4542:	08 95       	ret

00004544 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4544:	80 91 06 05 	lds	r24, 0x0506
    4548:	88 23       	and	r24, r24
    454a:	21 f0       	breq	.+8      	; 0x4554 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    454c:	81 e0       	ldi	r24, 0x01	; 1
    454e:	80 93 0a 05 	sts	0x050A, r24
    4552:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    4554:	10 92 0a 05 	sts	0x050A, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4558:	20 91 0d 05 	lds	r18, 0x050D
    455c:	82 2f       	mov	r24, r18
    455e:	90 e0       	ldi	r25, 0x00	; 0
    4560:	fc 01       	movw	r30, r24
    4562:	ee 0f       	add	r30, r30
    4564:	ff 1f       	adc	r31, r31
    4566:	ee 0f       	add	r30, r30
    4568:	ff 1f       	adc	r31, r31
    456a:	ee 0f       	add	r30, r30
    456c:	ff 1f       	adc	r31, r31
    456e:	e8 0f       	add	r30, r24
    4570:	f9 1f       	adc	r31, r25
    4572:	e9 5e       	subi	r30, 0xE9	; 233
    4574:	fa 4f       	sbci	r31, 0xFA	; 250
    4576:	30 81       	ld	r19, Z
    4578:	33 23       	and	r19, r19
    457a:	89 f4       	brne	.+34     	; 0x459e <vTaskSwitchContext+0x5a>
    457c:	21 50       	subi	r18, 0x01	; 1
    457e:	82 2f       	mov	r24, r18
    4580:	90 e0       	ldi	r25, 0x00	; 0
    4582:	fc 01       	movw	r30, r24
    4584:	ee 0f       	add	r30, r30
    4586:	ff 1f       	adc	r31, r31
    4588:	ee 0f       	add	r30, r30
    458a:	ff 1f       	adc	r31, r31
    458c:	ee 0f       	add	r30, r30
    458e:	ff 1f       	adc	r31, r31
    4590:	e8 0f       	add	r30, r24
    4592:	f9 1f       	adc	r31, r25
    4594:	e9 5e       	subi	r30, 0xE9	; 233
    4596:	fa 4f       	sbci	r31, 0xFA	; 250
    4598:	30 81       	ld	r19, Z
    459a:	33 23       	and	r19, r19
    459c:	79 f3       	breq	.-34     	; 0x457c <vTaskSwitchContext+0x38>
    459e:	dc 01       	movw	r26, r24
    45a0:	aa 0f       	add	r26, r26
    45a2:	bb 1f       	adc	r27, r27
    45a4:	aa 0f       	add	r26, r26
    45a6:	bb 1f       	adc	r27, r27
    45a8:	aa 0f       	add	r26, r26
    45aa:	bb 1f       	adc	r27, r27
    45ac:	8a 0f       	add	r24, r26
    45ae:	9b 1f       	adc	r25, r27
    45b0:	dc 01       	movw	r26, r24
    45b2:	a9 5e       	subi	r26, 0xE9	; 233
    45b4:	ba 4f       	sbci	r27, 0xFA	; 250
    45b6:	11 96       	adiw	r26, 0x01	; 1
    45b8:	ed 91       	ld	r30, X+
    45ba:	fc 91       	ld	r31, X
    45bc:	12 97       	sbiw	r26, 0x02	; 2
    45be:	02 80       	ldd	r0, Z+2	; 0x02
    45c0:	f3 81       	ldd	r31, Z+3	; 0x03
    45c2:	e0 2d       	mov	r30, r0
    45c4:	12 96       	adiw	r26, 0x02	; 2
    45c6:	fc 93       	st	X, r31
    45c8:	ee 93       	st	-X, r30
    45ca:	11 97       	sbiw	r26, 0x01	; 1
    45cc:	cd 01       	movw	r24, r26
    45ce:	03 96       	adiw	r24, 0x03	; 3
    45d0:	e8 17       	cp	r30, r24
    45d2:	f9 07       	cpc	r31, r25
    45d4:	31 f4       	brne	.+12     	; 0x45e2 <vTaskSwitchContext+0x9e>
    45d6:	82 81       	ldd	r24, Z+2	; 0x02
    45d8:	93 81       	ldd	r25, Z+3	; 0x03
    45da:	12 96       	adiw	r26, 0x02	; 2
    45dc:	9c 93       	st	X, r25
    45de:	8e 93       	st	-X, r24
    45e0:	11 97       	sbiw	r26, 0x01	; 1
    45e2:	11 96       	adiw	r26, 0x01	; 1
    45e4:	ed 91       	ld	r30, X+
    45e6:	fc 91       	ld	r31, X
    45e8:	12 97       	sbiw	r26, 0x02	; 2
    45ea:	86 81       	ldd	r24, Z+6	; 0x06
    45ec:	97 81       	ldd	r25, Z+7	; 0x07
    45ee:	90 93 05 05 	sts	0x0505, r25
    45f2:	80 93 04 05 	sts	0x0504, r24
    45f6:	20 93 0d 05 	sts	0x050D, r18
    45fa:	08 95       	ret

000045fc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    45fc:	cf 93       	push	r28
    45fe:	df 93       	push	r29
    4600:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4602:	60 91 04 05 	lds	r22, 0x0504
    4606:	70 91 05 05 	lds	r23, 0x0505
    460a:	64 5f       	subi	r22, 0xF4	; 244
    460c:	7f 4f       	sbci	r23, 0xFF	; 255
    460e:	0e 94 8c 14 	call	0x2918	; 0x2918 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4612:	ce 01       	movw	r24, r28
    4614:	61 e0       	ldi	r22, 0x01	; 1
    4616:	0e 94 1a 1f 	call	0x3e34	; 0x3e34 <prvAddCurrentTaskToDelayedList>
}
    461a:	df 91       	pop	r29
    461c:	cf 91       	pop	r28
    461e:	08 95       	ret

00004620 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4620:	cf 93       	push	r28
    4622:	df 93       	push	r29
    4624:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4626:	e0 91 04 05 	lds	r30, 0x0504
    462a:	f0 91 05 05 	lds	r31, 0x0505
    462e:	70 68       	ori	r23, 0x80	; 128
    4630:	75 87       	std	Z+13, r23	; 0x0d
    4632:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4634:	60 91 04 05 	lds	r22, 0x0504
    4638:	70 91 05 05 	lds	r23, 0x0505
    463c:	64 5f       	subi	r22, 0xF4	; 244
    463e:	7f 4f       	sbci	r23, 0xFF	; 255
    4640:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4644:	ce 01       	movw	r24, r28
    4646:	61 e0       	ldi	r22, 0x01	; 1
    4648:	0e 94 1a 1f 	call	0x3e34	; 0x3e34 <prvAddCurrentTaskToDelayedList>
}
    464c:	df 91       	pop	r29
    464e:	cf 91       	pop	r28
    4650:	08 95       	ret

00004652 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4652:	0f 93       	push	r16
    4654:	1f 93       	push	r17
    4656:	cf 93       	push	r28
    4658:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    465a:	dc 01       	movw	r26, r24
    465c:	15 96       	adiw	r26, 0x05	; 5
    465e:	ed 91       	ld	r30, X+
    4660:	fc 91       	ld	r31, X
    4662:	16 97       	sbiw	r26, 0x06	; 6
    4664:	06 81       	ldd	r16, Z+6	; 0x06
    4666:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4668:	e8 01       	movw	r28, r16
    466a:	2c 96       	adiw	r28, 0x0c	; 12
    466c:	ce 01       	movw	r24, r28
    466e:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4672:	80 91 06 05 	lds	r24, 0x0506
    4676:	88 23       	and	r24, r24
    4678:	e9 f4       	brne	.+58     	; 0x46b4 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    467a:	e8 01       	movw	r28, r16
    467c:	22 96       	adiw	r28, 0x02	; 2
    467e:	ce 01       	movw	r24, r28
    4680:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4684:	f8 01       	movw	r30, r16
    4686:	86 89       	ldd	r24, Z+22	; 0x16
    4688:	90 91 0d 05 	lds	r25, 0x050D
    468c:	98 17       	cp	r25, r24
    468e:	10 f4       	brcc	.+4      	; 0x4694 <xTaskRemoveFromEventList+0x42>
    4690:	80 93 0d 05 	sts	0x050D, r24
    4694:	90 e0       	ldi	r25, 0x00	; 0
    4696:	9c 01       	movw	r18, r24
    4698:	22 0f       	add	r18, r18
    469a:	33 1f       	adc	r19, r19
    469c:	22 0f       	add	r18, r18
    469e:	33 1f       	adc	r19, r19
    46a0:	22 0f       	add	r18, r18
    46a2:	33 1f       	adc	r19, r19
    46a4:	82 0f       	add	r24, r18
    46a6:	93 1f       	adc	r25, r19
    46a8:	89 5e       	subi	r24, 0xE9	; 233
    46aa:	9a 4f       	sbci	r25, 0xFA	; 250
    46ac:	be 01       	movw	r22, r28
    46ae:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
    46b2:	05 c0       	rjmp	.+10     	; 0x46be <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    46b4:	8d e4       	ldi	r24, 0x4D	; 77
    46b6:	95 e0       	ldi	r25, 0x05	; 5
    46b8:	be 01       	movw	r22, r28
    46ba:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    46be:	e0 91 04 05 	lds	r30, 0x0504
    46c2:	f0 91 05 05 	lds	r31, 0x0505
    46c6:	d8 01       	movw	r26, r16
    46c8:	56 96       	adiw	r26, 0x16	; 22
    46ca:	9c 91       	ld	r25, X
    46cc:	56 97       	sbiw	r26, 0x16	; 22
    46ce:	86 89       	ldd	r24, Z+22	; 0x16
    46d0:	89 17       	cp	r24, r25
    46d2:	20 f4       	brcc	.+8      	; 0x46dc <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    46d4:	81 e0       	ldi	r24, 0x01	; 1
    46d6:	80 93 0a 05 	sts	0x050A, r24
    46da:	01 c0       	rjmp	.+2      	; 0x46de <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    46dc:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    46de:	df 91       	pop	r29
    46e0:	cf 91       	pop	r28
    46e2:	1f 91       	pop	r17
    46e4:	0f 91       	pop	r16
    46e6:	08 95       	ret

000046e8 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    46e8:	0f 93       	push	r16
    46ea:	1f 93       	push	r17
    46ec:	cf 93       	push	r28
    46ee:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    46f0:	70 68       	ori	r23, 0x80	; 128
    46f2:	fc 01       	movw	r30, r24
    46f4:	71 83       	std	Z+1, r23	; 0x01
    46f6:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46f8:	c6 81       	ldd	r28, Z+6	; 0x06
    46fa:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    46fc:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4700:	8e 01       	movw	r16, r28
    4702:	0e 5f       	subi	r16, 0xFE	; 254
    4704:	1f 4f       	sbci	r17, 0xFF	; 255
    4706:	c8 01       	movw	r24, r16
    4708:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    470c:	8e 89       	ldd	r24, Y+22	; 0x16
    470e:	90 91 0d 05 	lds	r25, 0x050D
    4712:	98 17       	cp	r25, r24
    4714:	10 f4       	brcc	.+4      	; 0x471a <vTaskRemoveFromUnorderedEventList+0x32>
    4716:	80 93 0d 05 	sts	0x050D, r24
    471a:	90 e0       	ldi	r25, 0x00	; 0
    471c:	9c 01       	movw	r18, r24
    471e:	22 0f       	add	r18, r18
    4720:	33 1f       	adc	r19, r19
    4722:	22 0f       	add	r18, r18
    4724:	33 1f       	adc	r19, r19
    4726:	22 0f       	add	r18, r18
    4728:	33 1f       	adc	r19, r19
    472a:	82 0f       	add	r24, r18
    472c:	93 1f       	adc	r25, r19
    472e:	89 5e       	subi	r24, 0xE9	; 233
    4730:	9a 4f       	sbci	r25, 0xFA	; 250
    4732:	b8 01       	movw	r22, r16
    4734:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4738:	e0 91 04 05 	lds	r30, 0x0504
    473c:	f0 91 05 05 	lds	r31, 0x0505
    4740:	9e 89       	ldd	r25, Y+22	; 0x16
    4742:	86 89       	ldd	r24, Z+22	; 0x16
    4744:	89 17       	cp	r24, r25
    4746:	18 f4       	brcc	.+6      	; 0x474e <vTaskRemoveFromUnorderedEventList+0x66>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4748:	81 e0       	ldi	r24, 0x01	; 1
    474a:	80 93 0a 05 	sts	0x050A, r24
	}
}
    474e:	df 91       	pop	r29
    4750:	cf 91       	pop	r28
    4752:	1f 91       	pop	r17
    4754:	0f 91       	pop	r16
    4756:	08 95       	ret

00004758 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4758:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    475a:	0f b6       	in	r0, 0x3f	; 63
    475c:	f8 94       	cli
    475e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4760:	80 91 09 05 	lds	r24, 0x0509
    4764:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4766:	80 91 0e 05 	lds	r24, 0x050E
    476a:	90 91 0f 05 	lds	r25, 0x050F
    476e:	92 83       	std	Z+2, r25	; 0x02
    4770:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4772:	0f 90       	pop	r0
    4774:	0f be       	out	0x3f, r0	; 63
}
    4776:	08 95       	ret

00004778 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4778:	fc 01       	movw	r30, r24
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    477a:	80 91 09 05 	lds	r24, 0x0509
    477e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4780:	80 91 0e 05 	lds	r24, 0x050E
    4784:	90 91 0f 05 	lds	r25, 0x050F
    4788:	92 83       	std	Z+2, r25	; 0x02
    478a:	81 83       	std	Z+1, r24	; 0x01
}
    478c:	08 95       	ret

0000478e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    478e:	fc 01       	movw	r30, r24
    4790:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4792:	0f b6       	in	r0, 0x3f	; 63
    4794:	f8 94       	cli
    4796:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4798:	20 91 0e 05 	lds	r18, 0x050E
    479c:	30 91 0f 05 	lds	r19, 0x050F
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    47a0:	81 81       	ldd	r24, Z+1	; 0x01
    47a2:	92 81       	ldd	r25, Z+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    47a4:	40 91 09 05 	lds	r20, 0x0509
    47a8:	50 81       	ld	r21, Z
    47aa:	54 17       	cp	r21, r20
    47ac:	19 f0       	breq	.+6      	; 0x47b4 <xTaskCheckForTimeOut+0x26>
    47ae:	28 17       	cp	r18, r24
    47b0:	39 07       	cpc	r19, r25
    47b2:	b0 f4       	brcc	.+44     	; 0x47e0 <xTaskCheckForTimeOut+0x52>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    47b4:	28 1b       	sub	r18, r24
    47b6:	39 0b       	sbc	r19, r25
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    47b8:	8d 91       	ld	r24, X+
    47ba:	9c 91       	ld	r25, X
    47bc:	11 97       	sbiw	r26, 0x01	; 1
    47be:	28 17       	cp	r18, r24
    47c0:	39 07       	cpc	r19, r25
    47c2:	48 f4       	brcc	.+18     	; 0x47d6 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    47c4:	82 1b       	sub	r24, r18
    47c6:	93 0b       	sbc	r25, r19
    47c8:	8d 93       	st	X+, r24
    47ca:	9c 93       	st	X, r25
			vTaskInternalSetTimeOutState( pxTimeOut );
    47cc:	cf 01       	movw	r24, r30
    47ce:	0e 94 bc 23 	call	0x4778	; 0x4778 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    47d2:	80 e0       	ldi	r24, 0x00	; 0
    47d4:	06 c0       	rjmp	.+12     	; 0x47e2 <xTaskCheckForTimeOut+0x54>
		}
		else
		{
			*pxTicksToWait = 0;
    47d6:	11 96       	adiw	r26, 0x01	; 1
    47d8:	1c 92       	st	X, r1
    47da:	1e 92       	st	-X, r1
			xReturn = pdTRUE;
    47dc:	81 e0       	ldi	r24, 0x01	; 1
    47de:	01 c0       	rjmp	.+2      	; 0x47e2 <xTaskCheckForTimeOut+0x54>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    47e0:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    47e2:	0f 90       	pop	r0
    47e4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    47e6:	08 95       	ret

000047e8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    47e8:	81 e0       	ldi	r24, 0x01	; 1
    47ea:	80 93 0a 05 	sts	0x050A, r24
}
    47ee:	08 95       	ret

000047f0 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    47f0:	80 91 04 05 	lds	r24, 0x0504
    47f4:	90 91 05 05 	lds	r25, 0x0505

		return xReturn;
	}
    47f8:	08 95       	ret

000047fa <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    47fa:	e0 91 04 05 	lds	r30, 0x0504
    47fe:	f0 91 05 05 	lds	r31, 0x0505
    4802:	84 85       	ldd	r24, Z+12	; 0x0c
    4804:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4806:	e0 91 04 05 	lds	r30, 0x0504
    480a:	f0 91 05 05 	lds	r31, 0x0505
    480e:	a0 91 04 05 	lds	r26, 0x0504
    4812:	b0 91 05 05 	lds	r27, 0x0505
    4816:	56 96       	adiw	r26, 0x16	; 22
    4818:	4c 91       	ld	r20, X
    481a:	56 97       	sbiw	r26, 0x16	; 22
    481c:	24 e0       	ldi	r18, 0x04	; 4
    481e:	30 e0       	ldi	r19, 0x00	; 0
    4820:	24 1b       	sub	r18, r20
    4822:	31 09       	sbc	r19, r1
    4824:	35 87       	std	Z+13, r19	; 0x0d
    4826:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    4828:	08 95       	ret

0000482a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    482a:	0f 93       	push	r16
    482c:	1f 93       	push	r17
    482e:	cf 93       	push	r28
    4830:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4832:	0f b6       	in	r0, 0x3f	; 63
    4834:	f8 94       	cli
    4836:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4838:	e0 91 04 05 	lds	r30, 0x0504
    483c:	f0 91 05 05 	lds	r31, 0x0505
    4840:	81 a1       	lds	r24, 0x41
    4842:	92 a1       	lds	r25, 0x42
    4844:	a3 a1       	lds	r26, 0x43
    4846:	b4 a1       	lds	r27, 0x44
    4848:	00 97       	sbiw	r24, 0x00	; 0
    484a:	a1 05       	cpc	r26, r1
    484c:	b1 05       	cpc	r27, r1
    484e:	79 f4       	brne	.+30     	; 0x486e <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4850:	e0 91 04 05 	lds	r30, 0x0504
    4854:	f0 91 05 05 	lds	r31, 0x0505
    4858:	81 e0       	ldi	r24, 0x01	; 1
    485a:	85 a3       	lds	r24, 0x55

				if( xTicksToWait > ( TickType_t ) 0 )
    485c:	61 15       	cp	r22, r1
    485e:	71 05       	cpc	r23, r1
    4860:	31 f0       	breq	.+12     	; 0x486e <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4862:	cb 01       	movw	r24, r22
    4864:	61 e0       	ldi	r22, 0x01	; 1
    4866:	0e 94 1a 1f 	call	0x3e34	; 0x3e34 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    486a:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    486e:	0f 90       	pop	r0
    4870:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4872:	0f b6       	in	r0, 0x3f	; 63
    4874:	f8 94       	cli
    4876:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4878:	e0 91 04 05 	lds	r30, 0x0504
    487c:	f0 91 05 05 	lds	r31, 0x0505
    4880:	01 a1       	lds	r16, 0x41
    4882:	12 a1       	lds	r17, 0x42
    4884:	23 a1       	lds	r18, 0x43
    4886:	34 a1       	lds	r19, 0x44

			if( ulReturn != 0UL )
    4888:	01 15       	cp	r16, r1
    488a:	11 05       	cpc	r17, r1
    488c:	21 05       	cpc	r18, r1
    488e:	31 05       	cpc	r19, r1
    4890:	c1 f0       	breq	.+48     	; 0x48c2 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    4892:	cc 23       	and	r28, r28
    4894:	49 f0       	breq	.+18     	; 0x48a8 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4896:	e0 91 04 05 	lds	r30, 0x0504
    489a:	f0 91 05 05 	lds	r31, 0x0505
    489e:	11 a2       	lds	r17, 0x91
    48a0:	12 a2       	lds	r17, 0x92
    48a2:	13 a2       	lds	r17, 0x93
    48a4:	14 a2       	lds	r17, 0x94
    48a6:	0d c0       	rjmp	.+26     	; 0x48c2 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    48a8:	e0 91 04 05 	lds	r30, 0x0504
    48ac:	f0 91 05 05 	lds	r31, 0x0505
    48b0:	d9 01       	movw	r26, r18
    48b2:	c8 01       	movw	r24, r16
    48b4:	01 97       	sbiw	r24, 0x01	; 1
    48b6:	a1 09       	sbc	r26, r1
    48b8:	b1 09       	sbc	r27, r1
    48ba:	81 a3       	lds	r24, 0x51
    48bc:	92 a3       	lds	r25, 0x52
    48be:	a3 a3       	lds	r26, 0x53
    48c0:	b4 a3       	lds	r27, 0x54
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    48c2:	e0 91 04 05 	lds	r30, 0x0504
    48c6:	f0 91 05 05 	lds	r31, 0x0505
    48ca:	15 a2       	lds	r17, 0x95
		}
		taskEXIT_CRITICAL();
    48cc:	0f 90       	pop	r0
    48ce:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    48d0:	60 2f       	mov	r22, r16
    48d2:	71 2f       	mov	r23, r17
    48d4:	82 2f       	mov	r24, r18
    48d6:	93 2f       	mov	r25, r19
    48d8:	cf 91       	pop	r28
    48da:	1f 91       	pop	r17
    48dc:	0f 91       	pop	r16
    48de:	08 95       	ret

000048e0 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    48e0:	8f 92       	push	r8
    48e2:	9f 92       	push	r9
    48e4:	af 92       	push	r10
    48e6:	bf 92       	push	r11
    48e8:	ef 92       	push	r14
    48ea:	ff 92       	push	r15
    48ec:	0f 93       	push	r16
    48ee:	1f 93       	push	r17
    48f0:	dc 01       	movw	r26, r24
    48f2:	cb 01       	movw	r24, r22
    48f4:	49 01       	movw	r8, r18
    48f6:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    48f8:	0f b6       	in	r0, 0x3f	; 63
    48fa:	f8 94       	cli
    48fc:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    48fe:	e0 91 04 05 	lds	r30, 0x0504
    4902:	f0 91 05 05 	lds	r31, 0x0505
    4906:	25 a1       	lds	r18, 0x45
    4908:	22 30       	cpi	r18, 0x02	; 2
    490a:	19 f1       	breq	.+70     	; 0x4952 <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    490c:	e0 91 04 05 	lds	r30, 0x0504
    4910:	f0 91 05 05 	lds	r31, 0x0505
    4914:	41 a1       	lds	r20, 0x41
    4916:	52 a1       	lds	r21, 0x42
    4918:	63 a1       	lds	r22, 0x43
    491a:	74 a1       	lds	r23, 0x44
    491c:	80 95       	com	r24
    491e:	90 95       	com	r25
    4920:	a0 95       	com	r26
    4922:	b0 95       	com	r27
    4924:	84 23       	and	r24, r20
    4926:	95 23       	and	r25, r21
    4928:	a6 23       	and	r26, r22
    492a:	b7 23       	and	r27, r23
    492c:	81 a3       	lds	r24, 0x51
    492e:	92 a3       	lds	r25, 0x52
    4930:	a3 a3       	lds	r26, 0x53
    4932:	b4 a3       	lds	r27, 0x54

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4934:	e0 91 04 05 	lds	r30, 0x0504
    4938:	f0 91 05 05 	lds	r31, 0x0505
    493c:	81 e0       	ldi	r24, 0x01	; 1
    493e:	85 a3       	lds	r24, 0x55

				if( xTicksToWait > ( TickType_t ) 0 )
    4940:	e1 14       	cp	r14, r1
    4942:	f1 04       	cpc	r15, r1
    4944:	31 f0       	breq	.+12     	; 0x4952 <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4946:	c7 01       	movw	r24, r14
    4948:	61 e0       	ldi	r22, 0x01	; 1
    494a:	0e 94 1a 1f 	call	0x3e34	; 0x3e34 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    494e:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4952:	0f 90       	pop	r0
    4954:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4956:	0f b6       	in	r0, 0x3f	; 63
    4958:	f8 94       	cli
    495a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    495c:	01 15       	cp	r16, r1
    495e:	11 05       	cpc	r17, r1
    4960:	69 f0       	breq	.+26     	; 0x497c <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4962:	e0 91 04 05 	lds	r30, 0x0504
    4966:	f0 91 05 05 	lds	r31, 0x0505
    496a:	81 a1       	lds	r24, 0x41
    496c:	92 a1       	lds	r25, 0x42
    496e:	a3 a1       	lds	r26, 0x43
    4970:	b4 a1       	lds	r27, 0x44
    4972:	f8 01       	movw	r30, r16
    4974:	80 83       	st	Z, r24
    4976:	91 83       	std	Z+1, r25	; 0x01
    4978:	a2 83       	std	Z+2, r26	; 0x02
    497a:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    497c:	e0 91 04 05 	lds	r30, 0x0504
    4980:	f0 91 05 05 	lds	r31, 0x0505
    4984:	85 a1       	lds	r24, 0x45
    4986:	82 30       	cpi	r24, 0x02	; 2
    4988:	b1 f4       	brne	.+44     	; 0x49b6 <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    498a:	e0 91 04 05 	lds	r30, 0x0504
    498e:	f0 91 05 05 	lds	r31, 0x0505
    4992:	81 a1       	lds	r24, 0x41
    4994:	92 a1       	lds	r25, 0x42
    4996:	a3 a1       	lds	r26, 0x43
    4998:	b4 a1       	lds	r27, 0x44
    499a:	80 94       	com	r8
    499c:	90 94       	com	r9
    499e:	a0 94       	com	r10
    49a0:	b0 94       	com	r11
    49a2:	88 22       	and	r8, r24
    49a4:	99 22       	and	r9, r25
    49a6:	aa 22       	and	r10, r26
    49a8:	bb 22       	and	r11, r27
    49aa:	81 a2       	lds	r24, 0x91
    49ac:	92 a2       	lds	r25, 0x92
    49ae:	a3 a2       	lds	r26, 0x93
    49b0:	b4 a2       	lds	r27, 0x94
				xReturn = pdTRUE;
    49b2:	81 e0       	ldi	r24, 0x01	; 1
    49b4:	01 c0       	rjmp	.+2      	; 0x49b8 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    49b6:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    49b8:	e0 91 04 05 	lds	r30, 0x0504
    49bc:	f0 91 05 05 	lds	r31, 0x0505
    49c0:	15 a2       	lds	r17, 0x95
		}
		taskEXIT_CRITICAL();
    49c2:	0f 90       	pop	r0
    49c4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    49c6:	1f 91       	pop	r17
    49c8:	0f 91       	pop	r16
    49ca:	ff 90       	pop	r15
    49cc:	ef 90       	pop	r14
    49ce:	bf 90       	pop	r11
    49d0:	af 90       	pop	r10
    49d2:	9f 90       	pop	r9
    49d4:	8f 90       	pop	r8
    49d6:	08 95       	ret

000049d8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    49d8:	0f 93       	push	r16
    49da:	1f 93       	push	r17
    49dc:	cf 93       	push	r28
    49de:	df 93       	push	r29
    49e0:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    49e2:	0f b6       	in	r0, 0x3f	; 63
    49e4:	f8 94       	cli
    49e6:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    49e8:	01 15       	cp	r16, r1
    49ea:	11 05       	cpc	r17, r1
    49ec:	49 f0       	breq	.+18     	; 0x4a00 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    49ee:	89 a1       	lds	r24, 0x49
    49f0:	9a a1       	lds	r25, 0x4a
    49f2:	ab a1       	lds	r26, 0x4b
    49f4:	bc a1       	lds	r27, 0x4c
    49f6:	f8 01       	movw	r30, r16
    49f8:	80 83       	st	Z, r24
    49fa:	91 83       	std	Z+1, r25	; 0x01
    49fc:	a2 83       	std	Z+2, r26	; 0x02
    49fe:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4a00:	3d a1       	lds	r19, 0x4d

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4a02:	82 e0       	ldi	r24, 0x02	; 2
    4a04:	8d a3       	lds	r24, 0x5d

			switch( eAction )
    4a06:	22 30       	cpi	r18, 0x02	; 2
    4a08:	b9 f0       	breq	.+46     	; 0x4a38 <xTaskGenericNotify+0x60>
    4a0a:	23 30       	cpi	r18, 0x03	; 3
    4a0c:	18 f4       	brcc	.+6      	; 0x4a14 <xTaskGenericNotify+0x3c>
    4a0e:	21 30       	cpi	r18, 0x01	; 1
    4a10:	51 f5       	brne	.+84     	; 0x4a66 <xTaskGenericNotify+0x8e>
    4a12:	05 c0       	rjmp	.+10     	; 0x4a1e <xTaskGenericNotify+0x46>
    4a14:	23 30       	cpi	r18, 0x03	; 3
    4a16:	e1 f0       	breq	.+56     	; 0x4a50 <xTaskGenericNotify+0x78>
    4a18:	24 30       	cpi	r18, 0x04	; 4
    4a1a:	29 f5       	brne	.+74     	; 0x4a66 <xTaskGenericNotify+0x8e>
    4a1c:	1e c0       	rjmp	.+60     	; 0x4a5a <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4a1e:	89 a1       	lds	r24, 0x49
    4a20:	9a a1       	lds	r25, 0x4a
    4a22:	ab a1       	lds	r26, 0x4b
    4a24:	bc a1       	lds	r27, 0x4c
    4a26:	48 2b       	or	r20, r24
    4a28:	59 2b       	or	r21, r25
    4a2a:	6a 2b       	or	r22, r26
    4a2c:	7b 2b       	or	r23, r27
    4a2e:	49 a3       	lds	r20, 0x59
    4a30:	5a a3       	lds	r21, 0x5a
    4a32:	6b a3       	lds	r22, 0x5b
    4a34:	7c a3       	lds	r23, 0x5c
					break;
    4a36:	17 c0       	rjmp	.+46     	; 0x4a66 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4a38:	89 a1       	lds	r24, 0x49
    4a3a:	9a a1       	lds	r25, 0x4a
    4a3c:	ab a1       	lds	r26, 0x4b
    4a3e:	bc a1       	lds	r27, 0x4c
    4a40:	01 96       	adiw	r24, 0x01	; 1
    4a42:	a1 1d       	adc	r26, r1
    4a44:	b1 1d       	adc	r27, r1
    4a46:	89 a3       	lds	r24, 0x59
    4a48:	9a a3       	lds	r25, 0x5a
    4a4a:	ab a3       	lds	r26, 0x5b
    4a4c:	bc a3       	lds	r27, 0x5c
					break;
    4a4e:	0b c0       	rjmp	.+22     	; 0x4a66 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4a50:	49 a3       	lds	r20, 0x59
    4a52:	5a a3       	lds	r21, 0x5a
    4a54:	6b a3       	lds	r22, 0x5b
    4a56:	7c a3       	lds	r23, 0x5c
					break;
    4a58:	06 c0       	rjmp	.+12     	; 0x4a66 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4a5a:	32 30       	cpi	r19, 0x02	; 2
    4a5c:	71 f1       	breq	.+92     	; 0x4aba <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4a5e:	49 a3       	lds	r20, 0x59
    4a60:	5a a3       	lds	r21, 0x5a
    4a62:	6b a3       	lds	r22, 0x5b
    4a64:	7c a3       	lds	r23, 0x5c

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4a66:	31 30       	cpi	r19, 0x01	; 1
    4a68:	51 f5       	brne	.+84     	; 0x4abe <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4a6a:	8e 01       	movw	r16, r28
    4a6c:	0e 5f       	subi	r16, 0xFE	; 254
    4a6e:	1f 4f       	sbci	r17, 0xFF	; 255
    4a70:	c8 01       	movw	r24, r16
    4a72:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4a76:	8e 89       	ldd	r24, Y+22	; 0x16
    4a78:	90 91 0d 05 	lds	r25, 0x050D
    4a7c:	98 17       	cp	r25, r24
    4a7e:	10 f4       	brcc	.+4      	; 0x4a84 <xTaskGenericNotify+0xac>
    4a80:	80 93 0d 05 	sts	0x050D, r24
    4a84:	90 e0       	ldi	r25, 0x00	; 0
    4a86:	9c 01       	movw	r18, r24
    4a88:	22 0f       	add	r18, r18
    4a8a:	33 1f       	adc	r19, r19
    4a8c:	22 0f       	add	r18, r18
    4a8e:	33 1f       	adc	r19, r19
    4a90:	22 0f       	add	r18, r18
    4a92:	33 1f       	adc	r19, r19
    4a94:	82 0f       	add	r24, r18
    4a96:	93 1f       	adc	r25, r19
    4a98:	89 5e       	subi	r24, 0xE9	; 233
    4a9a:	9a 4f       	sbci	r25, 0xFA	; 250
    4a9c:	b8 01       	movw	r22, r16
    4a9e:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4aa2:	e0 91 04 05 	lds	r30, 0x0504
    4aa6:	f0 91 05 05 	lds	r31, 0x0505
    4aaa:	9e 89       	ldd	r25, Y+22	; 0x16
    4aac:	86 89       	ldd	r24, Z+22	; 0x16
    4aae:	89 17       	cp	r24, r25
    4ab0:	40 f4       	brcc	.+16     	; 0x4ac2 <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4ab2:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vPortYield>
    4ab6:	81 e0       	ldi	r24, 0x01	; 1
    4ab8:	05 c0       	rjmp	.+10     	; 0x4ac4 <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4aba:	80 e0       	ldi	r24, 0x00	; 0
    4abc:	03 c0       	rjmp	.+6      	; 0x4ac4 <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4abe:	81 e0       	ldi	r24, 0x01	; 1
    4ac0:	01 c0       	rjmp	.+2      	; 0x4ac4 <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ac2:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4ac4:	0f 90       	pop	r0
    4ac6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4ac8:	df 91       	pop	r29
    4aca:	cf 91       	pop	r28
    4acc:	1f 91       	pop	r17
    4ace:	0f 91       	pop	r16
    4ad0:	08 95       	ret

00004ad2 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4ad2:	ef 92       	push	r14
    4ad4:	ff 92       	push	r15
    4ad6:	0f 93       	push	r16
    4ad8:	1f 93       	push	r17
    4ada:	cf 93       	push	r28
    4adc:	df 93       	push	r29
    4ade:	ec 01       	movw	r28, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    4ae0:	01 15       	cp	r16, r1
    4ae2:	11 05       	cpc	r17, r1
    4ae4:	49 f0       	breq	.+18     	; 0x4af8 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4ae6:	89 a1       	lds	r24, 0x49
    4ae8:	9a a1       	lds	r25, 0x4a
    4aea:	ab a1       	lds	r26, 0x4b
    4aec:	bc a1       	lds	r27, 0x4c
    4aee:	f8 01       	movw	r30, r16
    4af0:	80 83       	st	Z, r24
    4af2:	91 83       	std	Z+1, r25	; 0x01
    4af4:	a2 83       	std	Z+2, r26	; 0x02
    4af6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4af8:	3d a1       	lds	r19, 0x4d
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4afa:	82 e0       	ldi	r24, 0x02	; 2
    4afc:	8d a3       	lds	r24, 0x5d

			switch( eAction )
    4afe:	22 30       	cpi	r18, 0x02	; 2
    4b00:	b9 f0       	breq	.+46     	; 0x4b30 <xTaskGenericNotifyFromISR+0x5e>
    4b02:	23 30       	cpi	r18, 0x03	; 3
    4b04:	18 f4       	brcc	.+6      	; 0x4b0c <xTaskGenericNotifyFromISR+0x3a>
    4b06:	21 30       	cpi	r18, 0x01	; 1
    4b08:	59 f5       	brne	.+86     	; 0x4b60 <xTaskGenericNotifyFromISR+0x8e>
    4b0a:	05 c0       	rjmp	.+10     	; 0x4b16 <xTaskGenericNotifyFromISR+0x44>
    4b0c:	23 30       	cpi	r18, 0x03	; 3
    4b0e:	e1 f0       	breq	.+56     	; 0x4b48 <xTaskGenericNotifyFromISR+0x76>
    4b10:	24 30       	cpi	r18, 0x04	; 4
    4b12:	31 f5       	brne	.+76     	; 0x4b60 <xTaskGenericNotifyFromISR+0x8e>
    4b14:	1e c0       	rjmp	.+60     	; 0x4b52 <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4b16:	89 a1       	lds	r24, 0x49
    4b18:	9a a1       	lds	r25, 0x4a
    4b1a:	ab a1       	lds	r26, 0x4b
    4b1c:	bc a1       	lds	r27, 0x4c
    4b1e:	84 2b       	or	r24, r20
    4b20:	95 2b       	or	r25, r21
    4b22:	a6 2b       	or	r26, r22
    4b24:	b7 2b       	or	r27, r23
    4b26:	89 a3       	lds	r24, 0x59
    4b28:	9a a3       	lds	r25, 0x5a
    4b2a:	ab a3       	lds	r26, 0x5b
    4b2c:	bc a3       	lds	r27, 0x5c
					break;
    4b2e:	18 c0       	rjmp	.+48     	; 0x4b60 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4b30:	89 a1       	lds	r24, 0x49
    4b32:	9a a1       	lds	r25, 0x4a
    4b34:	ab a1       	lds	r26, 0x4b
    4b36:	bc a1       	lds	r27, 0x4c
    4b38:	01 96       	adiw	r24, 0x01	; 1
    4b3a:	a1 1d       	adc	r26, r1
    4b3c:	b1 1d       	adc	r27, r1
    4b3e:	89 a3       	lds	r24, 0x59
    4b40:	9a a3       	lds	r25, 0x5a
    4b42:	ab a3       	lds	r26, 0x5b
    4b44:	bc a3       	lds	r27, 0x5c
					break;
    4b46:	0c c0       	rjmp	.+24     	; 0x4b60 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4b48:	49 a3       	lds	r20, 0x59
    4b4a:	5a a3       	lds	r21, 0x5a
    4b4c:	6b a3       	lds	r22, 0x5b
    4b4e:	7c a3       	lds	r23, 0x5c
					break;
    4b50:	07 c0       	rjmp	.+14     	; 0x4b60 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4b52:	32 30       	cpi	r19, 0x02	; 2
    4b54:	09 f4       	brne	.+2      	; 0x4b58 <xTaskGenericNotifyFromISR+0x86>
    4b56:	40 c0       	rjmp	.+128    	; 0x4bd8 <xTaskGenericNotifyFromISR+0x106>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4b58:	49 a3       	lds	r20, 0x59
    4b5a:	5a a3       	lds	r21, 0x5a
    4b5c:	6b a3       	lds	r22, 0x5b
    4b5e:	7c a3       	lds	r23, 0x5c

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4b60:	31 30       	cpi	r19, 0x01	; 1
    4b62:	e1 f5       	brne	.+120    	; 0x4bdc <xTaskGenericNotifyFromISR+0x10a>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4b64:	80 91 06 05 	lds	r24, 0x0506
    4b68:	88 23       	and	r24, r24
    4b6a:	e9 f4       	brne	.+58     	; 0x4ba6 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4b6c:	8e 01       	movw	r16, r28
    4b6e:	0e 5f       	subi	r16, 0xFE	; 254
    4b70:	1f 4f       	sbci	r17, 0xFF	; 255
    4b72:	c8 01       	movw	r24, r16
    4b74:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4b78:	8e 89       	ldd	r24, Y+22	; 0x16
    4b7a:	90 91 0d 05 	lds	r25, 0x050D
    4b7e:	98 17       	cp	r25, r24
    4b80:	10 f4       	brcc	.+4      	; 0x4b86 <xTaskGenericNotifyFromISR+0xb4>
    4b82:	80 93 0d 05 	sts	0x050D, r24
    4b86:	90 e0       	ldi	r25, 0x00	; 0
    4b88:	9c 01       	movw	r18, r24
    4b8a:	22 0f       	add	r18, r18
    4b8c:	33 1f       	adc	r19, r19
    4b8e:	22 0f       	add	r18, r18
    4b90:	33 1f       	adc	r19, r19
    4b92:	22 0f       	add	r18, r18
    4b94:	33 1f       	adc	r19, r19
    4b96:	82 0f       	add	r24, r18
    4b98:	93 1f       	adc	r25, r19
    4b9a:	89 5e       	subi	r24, 0xE9	; 233
    4b9c:	9a 4f       	sbci	r25, 0xFA	; 250
    4b9e:	b8 01       	movw	r22, r16
    4ba0:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
    4ba4:	07 c0       	rjmp	.+14     	; 0x4bb4 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4ba6:	be 01       	movw	r22, r28
    4ba8:	64 5f       	subi	r22, 0xF4	; 244
    4baa:	7f 4f       	sbci	r23, 0xFF	; 255
    4bac:	8d e4       	ldi	r24, 0x4D	; 77
    4bae:	95 e0       	ldi	r25, 0x05	; 5
    4bb0:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4bb4:	e0 91 04 05 	lds	r30, 0x0504
    4bb8:	f0 91 05 05 	lds	r31, 0x0505
    4bbc:	9e 89       	ldd	r25, Y+22	; 0x16
    4bbe:	86 89       	ldd	r24, Z+22	; 0x16
    4bc0:	89 17       	cp	r24, r25
    4bc2:	70 f4       	brcc	.+28     	; 0x4be0 <xTaskGenericNotifyFromISR+0x10e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4bc4:	e1 14       	cp	r14, r1
    4bc6:	f1 04       	cpc	r15, r1
    4bc8:	19 f0       	breq	.+6      	; 0x4bd0 <xTaskGenericNotifyFromISR+0xfe>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4bca:	81 e0       	ldi	r24, 0x01	; 1
    4bcc:	f7 01       	movw	r30, r14
    4bce:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4bd0:	81 e0       	ldi	r24, 0x01	; 1
    4bd2:	80 93 0a 05 	sts	0x050A, r24
    4bd6:	05 c0       	rjmp	.+10     	; 0x4be2 <xTaskGenericNotifyFromISR+0x110>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4bd8:	80 e0       	ldi	r24, 0x00	; 0
    4bda:	03 c0       	rjmp	.+6      	; 0x4be2 <xTaskGenericNotifyFromISR+0x110>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4bdc:	81 e0       	ldi	r24, 0x01	; 1
    4bde:	01 c0       	rjmp	.+2      	; 0x4be2 <xTaskGenericNotifyFromISR+0x110>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4be0:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    4be2:	df 91       	pop	r29
    4be4:	cf 91       	pop	r28
    4be6:	1f 91       	pop	r17
    4be8:	0f 91       	pop	r16
    4bea:	ff 90       	pop	r15
    4bec:	ef 90       	pop	r14
    4bee:	08 95       	ret

00004bf0 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4bf0:	ef 92       	push	r14
    4bf2:	ff 92       	push	r15
    4bf4:	0f 93       	push	r16
    4bf6:	1f 93       	push	r17
    4bf8:	cf 93       	push	r28
    4bfa:	df 93       	push	r29
    4bfc:	ec 01       	movw	r28, r24
    4bfe:	8b 01       	movw	r16, r22

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4c00:	2d a1       	lds	r18, 0x4d
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4c02:	82 e0       	ldi	r24, 0x02	; 2
    4c04:	8d a3       	lds	r24, 0x5d

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4c06:	89 a1       	lds	r24, 0x49
    4c08:	9a a1       	lds	r25, 0x4a
    4c0a:	ab a1       	lds	r26, 0x4b
    4c0c:	bc a1       	lds	r27, 0x4c
    4c0e:	01 96       	adiw	r24, 0x01	; 1
    4c10:	a1 1d       	adc	r26, r1
    4c12:	b1 1d       	adc	r27, r1
    4c14:	89 a3       	lds	r24, 0x59
    4c16:	9a a3       	lds	r25, 0x5a
    4c18:	ab a3       	lds	r26, 0x5b
    4c1a:	bc a3       	lds	r27, 0x5c

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4c1c:	21 30       	cpi	r18, 0x01	; 1
    4c1e:	e1 f5       	brne	.+120    	; 0x4c98 <vTaskNotifyGiveFromISR+0xa8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4c20:	80 91 06 05 	lds	r24, 0x0506
    4c24:	88 23       	and	r24, r24
    4c26:	01 f5       	brne	.+64     	; 0x4c68 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4c28:	ee 24       	eor	r14, r14
    4c2a:	ff 24       	eor	r15, r15
    4c2c:	68 94       	set
    4c2e:	e1 f8       	bld	r14, 1
    4c30:	ec 0e       	add	r14, r28
    4c32:	fd 1e       	adc	r15, r29
    4c34:	c7 01       	movw	r24, r14
    4c36:	0e 94 be 14 	call	0x297c	; 0x297c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4c3a:	8e 89       	ldd	r24, Y+22	; 0x16
    4c3c:	90 91 0d 05 	lds	r25, 0x050D
    4c40:	98 17       	cp	r25, r24
    4c42:	10 f4       	brcc	.+4      	; 0x4c48 <vTaskNotifyGiveFromISR+0x58>
    4c44:	80 93 0d 05 	sts	0x050D, r24
    4c48:	90 e0       	ldi	r25, 0x00	; 0
    4c4a:	9c 01       	movw	r18, r24
    4c4c:	22 0f       	add	r18, r18
    4c4e:	33 1f       	adc	r19, r19
    4c50:	22 0f       	add	r18, r18
    4c52:	33 1f       	adc	r19, r19
    4c54:	22 0f       	add	r18, r18
    4c56:	33 1f       	adc	r19, r19
    4c58:	82 0f       	add	r24, r18
    4c5a:	93 1f       	adc	r25, r19
    4c5c:	89 5e       	subi	r24, 0xE9	; 233
    4c5e:	9a 4f       	sbci	r25, 0xFA	; 250
    4c60:	b7 01       	movw	r22, r14
    4c62:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
    4c66:	07 c0       	rjmp	.+14     	; 0x4c76 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4c68:	be 01       	movw	r22, r28
    4c6a:	64 5f       	subi	r22, 0xF4	; 244
    4c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    4c6e:	8d e4       	ldi	r24, 0x4D	; 77
    4c70:	95 e0       	ldi	r25, 0x05	; 5
    4c72:	0e 94 6d 14 	call	0x28da	; 0x28da <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4c76:	e0 91 04 05 	lds	r30, 0x0504
    4c7a:	f0 91 05 05 	lds	r31, 0x0505
    4c7e:	9e 89       	ldd	r25, Y+22	; 0x16
    4c80:	86 89       	ldd	r24, Z+22	; 0x16
    4c82:	89 17       	cp	r24, r25
    4c84:	48 f4       	brcc	.+18     	; 0x4c98 <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4c86:	01 15       	cp	r16, r1
    4c88:	11 05       	cpc	r17, r1
    4c8a:	19 f0       	breq	.+6      	; 0x4c92 <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4c8c:	81 e0       	ldi	r24, 0x01	; 1
    4c8e:	f8 01       	movw	r30, r16
    4c90:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4c92:	81 e0       	ldi	r24, 0x01	; 1
    4c94:	80 93 0a 05 	sts	0x050A, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4c98:	df 91       	pop	r29
    4c9a:	cf 91       	pop	r28
    4c9c:	1f 91       	pop	r17
    4c9e:	0f 91       	pop	r16
    4ca0:	ff 90       	pop	r15
    4ca2:	ef 90       	pop	r14
    4ca4:	08 95       	ret

00004ca6 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4ca6:	00 97       	sbiw	r24, 0x00	; 0
    4ca8:	29 f4       	brne	.+10     	; 0x4cb4 <xTaskNotifyStateClear+0xe>
    4caa:	e0 91 04 05 	lds	r30, 0x0504
    4cae:	f0 91 05 05 	lds	r31, 0x0505
    4cb2:	01 c0       	rjmp	.+2      	; 0x4cb6 <xTaskNotifyStateClear+0x10>
    4cb4:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    4cb6:	0f b6       	in	r0, 0x3f	; 63
    4cb8:	f8 94       	cli
    4cba:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4cbc:	85 a1       	lds	r24, 0x45
    4cbe:	82 30       	cpi	r24, 0x02	; 2
    4cc0:	19 f4       	brne	.+6      	; 0x4cc8 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4cc2:	15 a2       	lds	r17, 0x95
				xReturn = pdPASS;
    4cc4:	81 e0       	ldi	r24, 0x01	; 1
    4cc6:	01 c0       	rjmp	.+2      	; 0x4cca <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    4cc8:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    4cca:	0f 90       	pop	r0
    4ccc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4cce:	08 95       	ret

00004cd0 <SOS_Init>:
//static uint8_t u8_is_Started=0;
uint8_t Start_status[Buffer_Size];


ERROR_STATUS SOS_Init (const TMU_ConfigType * ConfigPtr )
{uint8_t u8_channel_ID=ConfigPtr->u8_Timer_channel;
    4cd0:	0f 93       	push	r16
    4cd2:	1f 93       	push	r17
    4cd4:	cf 93       	push	r28
    4cd6:	df 93       	push	r29
    4cd8:	ec 01       	movw	r28, r24
    4cda:	09 81       	ldd	r16, Y+1	; 0x01
uint8_t ret=E_OK;
/*************************************************************************/
/*			Intializ the required timer identified by the user			 */
/************************************************************************/
u8_Is_Intialized++;
    4cdc:	80 91 63 05 	lds	r24, 0x0563
    4ce0:	8f 5f       	subi	r24, 0xFF	; 255
    4ce2:	80 93 63 05 	sts	0x0563, r24

if(ConfigPtr==NULL){ret=TMU_MODULE+NULL_PTR;}
    4ce6:	20 97       	sbiw	r28, 0x00	; 0
    4ce8:	11 f0       	breq	.+4      	; 0x4cee <SOS_Init+0x1e>
uint8_t Start_status[Buffer_Size];


ERROR_STATUS SOS_Init (const TMU_ConfigType * ConfigPtr )
{uint8_t u8_channel_ID=ConfigPtr->u8_Timer_channel;
uint8_t ret=E_OK;
    4cea:	10 e0       	ldi	r17, 0x00	; 0
    4cec:	01 c0       	rjmp	.+2      	; 0x4cf0 <SOS_Init+0x20>
/*************************************************************************/
/*			Intializ the required timer identified by the user			 */
/************************************************************************/
u8_Is_Intialized++;

if(ConfigPtr==NULL){ret=TMU_MODULE+NULL_PTR;}
    4cee:	1a e2       	ldi	r17, 0x2A	; 42
switch(u8_channel_ID)
    4cf0:	00 23       	and	r16, r16
    4cf2:	19 f0       	breq	.+6      	; 0x4cfa <SOS_Init+0x2a>
    4cf4:	02 30       	cpi	r16, 0x02	; 2
    4cf6:	79 f4       	brne	.+30     	; 0x4d16 <SOS_Init+0x46>
    4cf8:	07 c0       	rjmp	.+14     	; 0x4d08 <SOS_Init+0x38>
{
	case TIMER_CH0:
			G_interrupt_Enable();
    4cfa:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
			Timer_Init(&Timer_Configuration0);
    4cfe:	8e ec       	ldi	r24, 0xCE	; 206
    4d00:	90 e0       	ldi	r25, 0x00	; 0
    4d02:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <Timer_Init>
				break;
    4d06:	08 c0       	rjmp	.+16     	; 0x4d18 <SOS_Init+0x48>
	case TIMER_CH2:
		G_interrupt_Enable();
    4d08:	0e 94 c0 06 	call	0xd80	; 0xd80 <G_interrupt_Enable>
		Timer_Init(&Timer_Configuration2);
    4d0c:	84 ed       	ldi	r24, 0xD4	; 212
    4d0e:	90 e0       	ldi	r25, 0x00	; 0
    4d10:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <Timer_Init>
			break;
    4d14:	01 c0       	rjmp	.+2      	; 0x4d18 <SOS_Init+0x48>
	default:
			ret+=E_NOK;
    4d16:	1f 5f       	subi	r17, 0xFF	; 255

/*************************************************************************/
/*Intializ the required timer identified by the user using required prescaler  */
/************************************************************************/

switch(ConfigPtr->u8_resolution)
    4d18:	88 81       	ld	r24, Y
    4d1a:	81 30       	cpi	r24, 0x01	; 1
    4d1c:	99 f4       	brne	.+38     	; 0x4d44 <SOS_Init+0x74>
{
	case TIMER_RESOLUTION_1_MS:
	{
		switch(u8_channel_ID)
    4d1e:	00 23       	and	r16, r16
    4d20:	19 f0       	breq	.+6      	; 0x4d28 <SOS_Init+0x58>
    4d22:	02 30       	cpi	r16, 0x02	; 2
    4d24:	69 f4       	brne	.+26     	; 0x4d40 <SOS_Init+0x70>
    4d26:	06 c0       	rjmp	.+12     	; 0x4d34 <SOS_Init+0x64>
		{
			case TIMER_CH0 :
		Timer_Start(TIMER_CH0,250);
    4d28:	80 e0       	ldi	r24, 0x00	; 0
    4d2a:	6a ef       	ldi	r22, 0xFA	; 250
    4d2c:	70 e0       	ldi	r23, 0x00	; 0
    4d2e:	0e 94 20 10 	call	0x2040	; 0x2040 <Timer_Start>
					//TCNT0=5;
					break;
    4d32:	09 c0       	rjmp	.+18     	; 0x4d46 <SOS_Init+0x76>
			case TIMER_CH2 :
				Timer_Start(TIMER_CH2,14);
    4d34:	82 e0       	ldi	r24, 0x02	; 2
    4d36:	6e e0       	ldi	r22, 0x0E	; 14
    4d38:	70 e0       	ldi	r23, 0x00	; 0
    4d3a:	0e 94 20 10 	call	0x2040	; 0x2040 <Timer_Start>
					break;
    4d3e:	03 c0       	rjmp	.+6      	; 0x4d46 <SOS_Init+0x76>
			default:
				ret+=E_NOK;
    4d40:	1f 5f       	subi	r17, 0xFF	; 255
					break;
    4d42:	01 c0       	rjmp	.+2      	; 0x4d46 <SOS_Init+0x76>
	}	
	
	
	
	default:
	ret+=E_NOK;
    4d44:	1f 5f       	subi	r17, 0xFF	; 255

/****************************************************************************/
/*      Deal with Errors  to be returned									*/
/***************************************************************************/
return ret;
}
    4d46:	81 2f       	mov	r24, r17
    4d48:	df 91       	pop	r29
    4d4a:	cf 91       	pop	r28
    4d4c:	1f 91       	pop	r17
    4d4e:	0f 91       	pop	r16
    4d50:	08 95       	ret

00004d52 <TMU_DeInit>:
	uint8_t ret=E_OK;
	/************************************************************************************************/
	/*1    	De_intialize the timer																	*/
	/*2		make sure this function is not called unless timer was intialized before by  TMU_INIT	*/
	/************************************************************************************************/
if (u8_Is_Intialized==1)
    4d52:	80 91 63 05 	lds	r24, 0x0563
    4d56:	81 30       	cpi	r24, 0x01	; 1
    4d58:	41 f4       	brne	.+16     	; 0x4d6a <TMU_DeInit+0x18>
{/*Make the timer without a clk*/
	Timer_Init(&Timer_Deinit_Configuration0);
    4d5a:	88 ec       	ldi	r24, 0xC8	; 200
    4d5c:	90 e0       	ldi	r25, 0x00	; 0
    4d5e:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <Timer_Init>

	u8_Is_Intialized=0;
    4d62:	10 92 63 05 	sts	0x0563, r1



ERROR_STATUS TMU_DeInit( void )
{
	uint8_t ret=E_OK;
    4d66:	80 e0       	ldi	r24, 0x00	; 0
    4d68:	08 95       	ret
{/*Make the timer without a clk*/
	Timer_Init(&Timer_Deinit_Configuration0);

	u8_Is_Intialized=0;
	
}else if(u8_Is_Intialized>1){ret+=MULTIPLE_INIT;}
    4d6a:	82 30       	cpi	r24, 0x02	; 2
    4d6c:	10 f0       	brcs	.+4      	; 0x4d72 <TMU_DeInit+0x20>
    4d6e:	86 e0       	ldi	r24, 0x06	; 6
    4d70:	08 95       	ret
	else{
	ret=E_NOK;
    4d72:	81 e0       	ldi	r24, 0x01	; 1
	}

	
return ret;	
}
    4d74:	08 95       	ret

00004d76 <SOS_Create_Task>:
	/*
	this enables interrupt and start the timer with the required configurations
	and provide the request to request buffer (ptr_to_func,delay) Dispatcher with the call back function needed(consumer)
	and make sure this function must not be excuted unless Init happened and De_init not happened
  	*/
	if(u8_Is_Intialized == 1)
    4d76:	50 91 63 05 	lds	r21, 0x0563
    4d7a:	51 30       	cpi	r21, 0x01	; 1
    4d7c:	99 f4       	brne	.+38     	; 0x4da4 <SOS_Create_Task+0x2e>
	{
		
		
		(Buffer_Array[u8_function_index]).Fuction_consumer=Function_Consumer;
    4d7e:	e4 2f       	mov	r30, r20
    4d80:	f0 e0       	ldi	r31, 0x00	; 0
    4d82:	ee 0f       	add	r30, r30
    4d84:	ff 1f       	adc	r31, r31
    4d86:	ee 0f       	add	r30, r30
    4d88:	ff 1f       	adc	r31, r31
    4d8a:	ee 0f       	add	r30, r30
    4d8c:	ff 1f       	adc	r31, r31
    4d8e:	e4 55       	subi	r30, 0x54	; 84
    4d90:	fa 4f       	sbci	r31, 0xFA	; 250
    4d92:	91 83       	std	Z+1, r25	; 0x01
    4d94:	80 83       	st	Z, r24
		(Buffer_Array[u8_function_index]).preodic=u8_Preodicity;
    4d96:	65 83       	std	Z+5, r22	; 0x05
		(Buffer_Array[u8_function_index]).u16_time_delay=u16_Time_delay;
    4d98:	34 83       	std	Z+4, r19	; 0x04
    4d9a:	23 83       	std	Z+3, r18	; 0x03
		(Buffer_Array[u8_function_index]).u8_flag_is_stopped=1;
    4d9c:	81 e0       	ldi	r24, 0x01	; 1
    4d9e:	82 83       	std	Z+2, r24	; 0x02
	
return ret;	
}

ERROR_STATUS SOS_Create_Task(ptr_to_Fun Function_Consumer,uint8_t  u8_Preodicity,uint8_t u8_function_index,uint16_t u16_Time_delay)
{uint8_t ret=E_OK;
    4da0:	80 e0       	ldi	r24, 0x00	; 0
    4da2:	08 95       	ret
		(Buffer_Array[u8_function_index]).u16_time_delay=u16_Time_delay;
		(Buffer_Array[u8_function_index]).u8_flag_is_stopped=1;
		
		
	}
	else if(u8_Is_Intialized>1){ret+=MULTIPLE_INIT;}else{
    4da4:	52 30       	cpi	r21, 0x02	; 2
    4da6:	10 f0       	brcs	.+4      	; 0x4dac <SOS_Create_Task+0x36>
    4da8:	86 e0       	ldi	r24, 0x06	; 6
    4daa:	08 95       	ret
		ret+=NOT_INIT;
    4dac:	84 e0       	ldi	r24, 0x04	; 4
	}

	return ret;
}
    4dae:	08 95       	ret

00004db0 <SOS_Run>:

ERROR_STATUS SOS_Run(void)
{	uint8_t ret=E_OK;
    4db0:	cf 93       	push	r28
    4db2:	df 93       	push	r29
	uint16_t u16_Time_needed=0;
	ptr_to_Fun Excuted;
	*//***********************************************************************/
	/*					LOOP upon Buffer Request						*/
	/*********************************************************************/
if (u8Excution_to_be_done==1)
    4db4:	80 91 61 05 	lds	r24, 0x0561
    4db8:	81 30       	cpi	r24, 0x01	; 1
    4dba:	09 f0       	breq	.+2      	; 0x4dbe <SOS_Run+0xe>
    4dbc:	65 c0       	rjmp	.+202    	; 0x4e88 <SOS_Run+0xd8>
{	u8Excution_to_be_done=0;
    4dbe:	10 92 61 05 	sts	0x0561, r1

		for (u8_FUN_index=0;u8_FUN_index<Buffer_Size;u8_FUN_index++)
    4dc2:	10 92 62 05 	sts	0x0562, r1
    4dc6:	20 e0       	ldi	r18, 0x00	; 0
	status_flag =(Buffer_Array[u8_FUN_index]).u8_flag_is_stopped;
	preodic_status_flag=(Buffer_Array[u8_FUN_index]).preodic;
*/
/****************************************************************/
/* check if the event is stopped ... do nothing*/
		if((Buffer_Array[u8_FUN_index]).u8_flag_is_stopped==0){ret=E_OK;}
    4dc8:	cc ea       	ldi	r28, 0xAC	; 172
    4dca:	d5 e0       	ldi	r29, 0x05	; 5
    4dcc:	30 e0       	ldi	r19, 0x00	; 0
    4dce:	f9 01       	movw	r30, r18
    4dd0:	ee 0f       	add	r30, r30
    4dd2:	ff 1f       	adc	r31, r31
    4dd4:	ee 0f       	add	r30, r30
    4dd6:	ff 1f       	adc	r31, r31
    4dd8:	ee 0f       	add	r30, r30
    4dda:	ff 1f       	adc	r31, r31
    4ddc:	ec 0f       	add	r30, r28
    4dde:	fd 1f       	adc	r31, r29
    4de0:	82 81       	ldd	r24, Z+2	; 0x02
    4de2:	88 23       	and	r24, r24
    4de4:	09 f4       	brne	.+2      	; 0x4de8 <SOS_Run+0x38>
    4de6:	48 c0       	rjmp	.+144    	; 0x4e78 <SOS_Run+0xc8>
	/*if the timer started .. and condition met excute the consumer*/
	/***************************************************************/
		
	/********************************************/
	/*Count up when flag is set**/
	((Buffer_Array[u8_FUN_index]).u16_Counter)++;
    4de8:	f9 01       	movw	r30, r18
    4dea:	ee 0f       	add	r30, r30
    4dec:	ff 1f       	adc	r31, r31
    4dee:	ee 0f       	add	r30, r30
    4df0:	ff 1f       	adc	r31, r31
    4df2:	ee 0f       	add	r30, r30
    4df4:	ff 1f       	adc	r31, r31
    4df6:	ec 0f       	add	r30, r28
    4df8:	fd 1f       	adc	r31, r29
    4dfa:	86 81       	ldd	r24, Z+6	; 0x06
    4dfc:	97 81       	ldd	r25, Z+7	; 0x07
    4dfe:	ac 01       	movw	r20, r24
    4e00:	4f 5f       	subi	r20, 0xFF	; 255
    4e02:	5f 4f       	sbci	r21, 0xFF	; 255
    4e04:	57 83       	std	Z+7, r21	; 0x07
    4e06:	46 83       	std	Z+6, r20	; 0x06
	/*make the flag down*/
							
			
/*	u16Excution_to_be_done=100;  ISR*/
	if(((Buffer_Array[u8_FUN_index]).u16_time_delay) == ((Buffer_Array[u8_FUN_index]).u16_Counter) )
    4e08:	83 81       	ldd	r24, Z+3	; 0x03
    4e0a:	94 81       	ldd	r25, Z+4	; 0x04
    4e0c:	48 17       	cp	r20, r24
    4e0e:	59 07       	cpc	r21, r25
    4e10:	d1 f4       	brne	.+52     	; 0x4e46 <SOS_Run+0x96>
	{
		((Buffer_Array[u8_FUN_index]).Fuction_consumer)();
    4e12:	f9 01       	movw	r30, r18
    4e14:	ee 0f       	add	r30, r30
    4e16:	ff 1f       	adc	r31, r31
    4e18:	ee 0f       	add	r30, r30
    4e1a:	ff 1f       	adc	r31, r31
    4e1c:	ee 0f       	add	r30, r30
    4e1e:	ff 1f       	adc	r31, r31
    4e20:	ec 0f       	add	r30, r28
    4e22:	fd 1f       	adc	r31, r29
    4e24:	01 90       	ld	r0, Z+
    4e26:	f0 81       	ld	r31, Z
    4e28:	e0 2d       	mov	r30, r0
    4e2a:	09 95       	icall
	/******************************************/
	/*Make it zero so that it will work the next time at the required time (to stop it of ovf)*/
		(Buffer_Array[u8_FUN_index]).u16_Counter=0;
    4e2c:	e0 91 62 05 	lds	r30, 0x0562
    4e30:	f0 e0       	ldi	r31, 0x00	; 0
    4e32:	ee 0f       	add	r30, r30
    4e34:	ff 1f       	adc	r31, r31
    4e36:	ee 0f       	add	r30, r30
    4e38:	ff 1f       	adc	r31, r31
    4e3a:	ee 0f       	add	r30, r30
    4e3c:	ff 1f       	adc	r31, r31
    4e3e:	ec 0f       	add	r30, r28
    4e40:	fd 1f       	adc	r31, r29
    4e42:	17 82       	std	Z+7, r1	; 0x07
    4e44:	16 82       	std	Z+6, r1	; 0x06
		
	/*********************************************************/
	/* if not preodic increment the index after excuteing	*/
	/*********************************************************/

	if((Buffer_Array[u8_FUN_index]).preodic==0)
    4e46:	80 91 62 05 	lds	r24, 0x0562
    4e4a:	90 e0       	ldi	r25, 0x00	; 0
    4e4c:	fc 01       	movw	r30, r24
    4e4e:	ee 0f       	add	r30, r30
    4e50:	ff 1f       	adc	r31, r31
    4e52:	ee 0f       	add	r30, r30
    4e54:	ff 1f       	adc	r31, r31
    4e56:	ee 0f       	add	r30, r30
    4e58:	ff 1f       	adc	r31, r31
    4e5a:	ec 0f       	add	r30, r28
    4e5c:	fd 1f       	adc	r31, r29
    4e5e:	25 81       	ldd	r18, Z+5	; 0x05
    4e60:	22 23       	and	r18, r18
    4e62:	51 f4       	brne	.+20     	; 0x4e78 <SOS_Run+0xc8>
	{
		/*to make it see the next event in the next time
		Also Status_flag =1 so that this function will be stopped
		*/
		(Buffer_Array[u8_FUN_index]).u8_flag_is_stopped=0;	
    4e64:	fc 01       	movw	r30, r24
    4e66:	ee 0f       	add	r30, r30
    4e68:	ff 1f       	adc	r31, r31
    4e6a:	ee 0f       	add	r30, r30
    4e6c:	ff 1f       	adc	r31, r31
    4e6e:	ee 0f       	add	r30, r30
    4e70:	ff 1f       	adc	r31, r31
    4e72:	ec 0f       	add	r30, r28
    4e74:	fd 1f       	adc	r31, r29
    4e76:	12 82       	std	Z+2, r1	; 0x02
	/*					LOOP upon Buffer Request						*/
	/*********************************************************************/
if (u8Excution_to_be_done==1)
{	u8Excution_to_be_done=0;

		for (u8_FUN_index=0;u8_FUN_index<Buffer_Size;u8_FUN_index++)
    4e78:	20 91 62 05 	lds	r18, 0x0562
    4e7c:	2f 5f       	subi	r18, 0xFF	; 255
    4e7e:	20 93 62 05 	sts	0x0562, r18
    4e82:	27 30       	cpi	r18, 0x07	; 7
    4e84:	08 f4       	brcc	.+2      	; 0x4e88 <SOS_Run+0xd8>
    4e86:	a2 cf       	rjmp	.-188    	; 0x4dcc <SOS_Run+0x1c>

		}		
	}
}	
return ret;
}
    4e88:	80 e0       	ldi	r24, 0x00	; 0
    4e8a:	df 91       	pop	r29
    4e8c:	cf 91       	pop	r28
    4e8e:	08 95       	ret

00004e90 <TMU_Stop_Timer>:
{

	/***************************************************/
	/*     Set the stop flag							*/
	/***************************************************/
	(Buffer_Array[u8_function_index]).u8_flag_is_stopped=0;
    4e90:	e8 2f       	mov	r30, r24
    4e92:	f0 e0       	ldi	r31, 0x00	; 0
    4e94:	ee 0f       	add	r30, r30
    4e96:	ff 1f       	adc	r31, r31
    4e98:	ee 0f       	add	r30, r30
    4e9a:	ff 1f       	adc	r31, r31
    4e9c:	ee 0f       	add	r30, r30
    4e9e:	ff 1f       	adc	r31, r31
    4ea0:	e4 55       	subi	r30, 0x54	; 84
    4ea2:	fa 4f       	sbci	r31, 0xFA	; 250
    4ea4:	12 82       	std	Z+2, r1	; 0x02
}
    4ea6:	08 95       	ret

00004ea8 <timer_interrupt>:



void timer_interrupt(void)
{
	u8Excution_to_be_done =1;	
    4ea8:	81 e0       	ldi	r24, 0x01	; 1
    4eaa:	80 93 61 05 	sts	0x0561, r24
    4eae:	08 95       	ret

00004eb0 <__divsf3>:
    4eb0:	0c d0       	rcall	.+24     	; 0x4eca <__divsf3x>
    4eb2:	e6 c0       	rjmp	.+460    	; 0x5080 <__fp_round>
    4eb4:	de d0       	rcall	.+444    	; 0x5072 <__fp_pscB>
    4eb6:	40 f0       	brcs	.+16     	; 0x4ec8 <__divsf3+0x18>
    4eb8:	d5 d0       	rcall	.+426    	; 0x5064 <__fp_pscA>
    4eba:	30 f0       	brcs	.+12     	; 0x4ec8 <__divsf3+0x18>
    4ebc:	21 f4       	brne	.+8      	; 0x4ec6 <__divsf3+0x16>
    4ebe:	5f 3f       	cpi	r21, 0xFF	; 255
    4ec0:	19 f0       	breq	.+6      	; 0x4ec8 <__divsf3+0x18>
    4ec2:	c7 c0       	rjmp	.+398    	; 0x5052 <__fp_inf>
    4ec4:	51 11       	cpse	r21, r1
    4ec6:	10 c1       	rjmp	.+544    	; 0x50e8 <__fp_szero>
    4ec8:	ca c0       	rjmp	.+404    	; 0x505e <__fp_nan>

00004eca <__divsf3x>:
    4eca:	eb d0       	rcall	.+470    	; 0x50a2 <__fp_split3>
    4ecc:	98 f3       	brcs	.-26     	; 0x4eb4 <__divsf3+0x4>

00004ece <__divsf3_pse>:
    4ece:	99 23       	and	r25, r25
    4ed0:	c9 f3       	breq	.-14     	; 0x4ec4 <__divsf3+0x14>
    4ed2:	55 23       	and	r21, r21
    4ed4:	b1 f3       	breq	.-20     	; 0x4ec2 <__divsf3+0x12>
    4ed6:	95 1b       	sub	r25, r21
    4ed8:	55 0b       	sbc	r21, r21
    4eda:	bb 27       	eor	r27, r27
    4edc:	aa 27       	eor	r26, r26
    4ede:	62 17       	cp	r22, r18
    4ee0:	73 07       	cpc	r23, r19
    4ee2:	84 07       	cpc	r24, r20
    4ee4:	38 f0       	brcs	.+14     	; 0x4ef4 <__divsf3_pse+0x26>
    4ee6:	9f 5f       	subi	r25, 0xFF	; 255
    4ee8:	5f 4f       	sbci	r21, 0xFF	; 255
    4eea:	22 0f       	add	r18, r18
    4eec:	33 1f       	adc	r19, r19
    4eee:	44 1f       	adc	r20, r20
    4ef0:	aa 1f       	adc	r26, r26
    4ef2:	a9 f3       	breq	.-22     	; 0x4ede <__divsf3_pse+0x10>
    4ef4:	33 d0       	rcall	.+102    	; 0x4f5c <__divsf3_pse+0x8e>
    4ef6:	0e 2e       	mov	r0, r30
    4ef8:	3a f0       	brmi	.+14     	; 0x4f08 <__divsf3_pse+0x3a>
    4efa:	e0 e8       	ldi	r30, 0x80	; 128
    4efc:	30 d0       	rcall	.+96     	; 0x4f5e <__divsf3_pse+0x90>
    4efe:	91 50       	subi	r25, 0x01	; 1
    4f00:	50 40       	sbci	r21, 0x00	; 0
    4f02:	e6 95       	lsr	r30
    4f04:	00 1c       	adc	r0, r0
    4f06:	ca f7       	brpl	.-14     	; 0x4efa <__divsf3_pse+0x2c>
    4f08:	29 d0       	rcall	.+82     	; 0x4f5c <__divsf3_pse+0x8e>
    4f0a:	fe 2f       	mov	r31, r30
    4f0c:	27 d0       	rcall	.+78     	; 0x4f5c <__divsf3_pse+0x8e>
    4f0e:	66 0f       	add	r22, r22
    4f10:	77 1f       	adc	r23, r23
    4f12:	88 1f       	adc	r24, r24
    4f14:	bb 1f       	adc	r27, r27
    4f16:	26 17       	cp	r18, r22
    4f18:	37 07       	cpc	r19, r23
    4f1a:	48 07       	cpc	r20, r24
    4f1c:	ab 07       	cpc	r26, r27
    4f1e:	b0 e8       	ldi	r27, 0x80	; 128
    4f20:	09 f0       	breq	.+2      	; 0x4f24 <__divsf3_pse+0x56>
    4f22:	bb 0b       	sbc	r27, r27
    4f24:	80 2d       	mov	r24, r0
    4f26:	bf 01       	movw	r22, r30
    4f28:	ff 27       	eor	r31, r31
    4f2a:	93 58       	subi	r25, 0x83	; 131
    4f2c:	5f 4f       	sbci	r21, 0xFF	; 255
    4f2e:	2a f0       	brmi	.+10     	; 0x4f3a <__divsf3_pse+0x6c>
    4f30:	9e 3f       	cpi	r25, 0xFE	; 254
    4f32:	51 05       	cpc	r21, r1
    4f34:	68 f0       	brcs	.+26     	; 0x4f50 <__divsf3_pse+0x82>
    4f36:	8d c0       	rjmp	.+282    	; 0x5052 <__fp_inf>
    4f38:	d7 c0       	rjmp	.+430    	; 0x50e8 <__fp_szero>
    4f3a:	5f 3f       	cpi	r21, 0xFF	; 255
    4f3c:	ec f3       	brlt	.-6      	; 0x4f38 <__divsf3_pse+0x6a>
    4f3e:	98 3e       	cpi	r25, 0xE8	; 232
    4f40:	dc f3       	brlt	.-10     	; 0x4f38 <__divsf3_pse+0x6a>
    4f42:	86 95       	lsr	r24
    4f44:	77 95       	ror	r23
    4f46:	67 95       	ror	r22
    4f48:	b7 95       	ror	r27
    4f4a:	f7 95       	ror	r31
    4f4c:	9f 5f       	subi	r25, 0xFF	; 255
    4f4e:	c9 f7       	brne	.-14     	; 0x4f42 <__divsf3_pse+0x74>
    4f50:	88 0f       	add	r24, r24
    4f52:	91 1d       	adc	r25, r1
    4f54:	96 95       	lsr	r25
    4f56:	87 95       	ror	r24
    4f58:	97 f9       	bld	r25, 7
    4f5a:	08 95       	ret
    4f5c:	e1 e0       	ldi	r30, 0x01	; 1
    4f5e:	66 0f       	add	r22, r22
    4f60:	77 1f       	adc	r23, r23
    4f62:	88 1f       	adc	r24, r24
    4f64:	bb 1f       	adc	r27, r27
    4f66:	62 17       	cp	r22, r18
    4f68:	73 07       	cpc	r23, r19
    4f6a:	84 07       	cpc	r24, r20
    4f6c:	ba 07       	cpc	r27, r26
    4f6e:	20 f0       	brcs	.+8      	; 0x4f78 <__divsf3_pse+0xaa>
    4f70:	62 1b       	sub	r22, r18
    4f72:	73 0b       	sbc	r23, r19
    4f74:	84 0b       	sbc	r24, r20
    4f76:	ba 0b       	sbc	r27, r26
    4f78:	ee 1f       	adc	r30, r30
    4f7a:	88 f7       	brcc	.-30     	; 0x4f5e <__divsf3_pse+0x90>
    4f7c:	e0 95       	com	r30
    4f7e:	08 95       	ret

00004f80 <__fixunssfsi>:
    4f80:	98 d0       	rcall	.+304    	; 0x50b2 <__fp_splitA>
    4f82:	88 f0       	brcs	.+34     	; 0x4fa6 <__fixunssfsi+0x26>
    4f84:	9f 57       	subi	r25, 0x7F	; 127
    4f86:	90 f0       	brcs	.+36     	; 0x4fac <__fixunssfsi+0x2c>
    4f88:	b9 2f       	mov	r27, r25
    4f8a:	99 27       	eor	r25, r25
    4f8c:	b7 51       	subi	r27, 0x17	; 23
    4f8e:	a0 f0       	brcs	.+40     	; 0x4fb8 <__fixunssfsi+0x38>
    4f90:	d1 f0       	breq	.+52     	; 0x4fc6 <__fixunssfsi+0x46>
    4f92:	66 0f       	add	r22, r22
    4f94:	77 1f       	adc	r23, r23
    4f96:	88 1f       	adc	r24, r24
    4f98:	99 1f       	adc	r25, r25
    4f9a:	1a f0       	brmi	.+6      	; 0x4fa2 <__fixunssfsi+0x22>
    4f9c:	ba 95       	dec	r27
    4f9e:	c9 f7       	brne	.-14     	; 0x4f92 <__fixunssfsi+0x12>
    4fa0:	12 c0       	rjmp	.+36     	; 0x4fc6 <__fixunssfsi+0x46>
    4fa2:	b1 30       	cpi	r27, 0x01	; 1
    4fa4:	81 f0       	breq	.+32     	; 0x4fc6 <__fixunssfsi+0x46>
    4fa6:	9f d0       	rcall	.+318    	; 0x50e6 <__fp_zero>
    4fa8:	b1 e0       	ldi	r27, 0x01	; 1
    4faa:	08 95       	ret
    4fac:	9c c0       	rjmp	.+312    	; 0x50e6 <__fp_zero>
    4fae:	67 2f       	mov	r22, r23
    4fb0:	78 2f       	mov	r23, r24
    4fb2:	88 27       	eor	r24, r24
    4fb4:	b8 5f       	subi	r27, 0xF8	; 248
    4fb6:	39 f0       	breq	.+14     	; 0x4fc6 <__fixunssfsi+0x46>
    4fb8:	b9 3f       	cpi	r27, 0xF9	; 249
    4fba:	cc f3       	brlt	.-14     	; 0x4fae <__fixunssfsi+0x2e>
    4fbc:	86 95       	lsr	r24
    4fbe:	77 95       	ror	r23
    4fc0:	67 95       	ror	r22
    4fc2:	b3 95       	inc	r27
    4fc4:	d9 f7       	brne	.-10     	; 0x4fbc <__fixunssfsi+0x3c>
    4fc6:	3e f4       	brtc	.+14     	; 0x4fd6 <__fixunssfsi+0x56>
    4fc8:	90 95       	com	r25
    4fca:	80 95       	com	r24
    4fcc:	70 95       	com	r23
    4fce:	61 95       	neg	r22
    4fd0:	7f 4f       	sbci	r23, 0xFF	; 255
    4fd2:	8f 4f       	sbci	r24, 0xFF	; 255
    4fd4:	9f 4f       	sbci	r25, 0xFF	; 255
    4fd6:	08 95       	ret

00004fd8 <__floatunsisf>:
    4fd8:	e8 94       	clt
    4fda:	09 c0       	rjmp	.+18     	; 0x4fee <__floatsisf+0x12>

00004fdc <__floatsisf>:
    4fdc:	97 fb       	bst	r25, 7
    4fde:	3e f4       	brtc	.+14     	; 0x4fee <__floatsisf+0x12>
    4fe0:	90 95       	com	r25
    4fe2:	80 95       	com	r24
    4fe4:	70 95       	com	r23
    4fe6:	61 95       	neg	r22
    4fe8:	7f 4f       	sbci	r23, 0xFF	; 255
    4fea:	8f 4f       	sbci	r24, 0xFF	; 255
    4fec:	9f 4f       	sbci	r25, 0xFF	; 255
    4fee:	99 23       	and	r25, r25
    4ff0:	a9 f0       	breq	.+42     	; 0x501c <__floatsisf+0x40>
    4ff2:	f9 2f       	mov	r31, r25
    4ff4:	96 e9       	ldi	r25, 0x96	; 150
    4ff6:	bb 27       	eor	r27, r27
    4ff8:	93 95       	inc	r25
    4ffa:	f6 95       	lsr	r31
    4ffc:	87 95       	ror	r24
    4ffe:	77 95       	ror	r23
    5000:	67 95       	ror	r22
    5002:	b7 95       	ror	r27
    5004:	f1 11       	cpse	r31, r1
    5006:	f8 cf       	rjmp	.-16     	; 0x4ff8 <__floatsisf+0x1c>
    5008:	fa f4       	brpl	.+62     	; 0x5048 <__floatsisf+0x6c>
    500a:	bb 0f       	add	r27, r27
    500c:	11 f4       	brne	.+4      	; 0x5012 <__floatsisf+0x36>
    500e:	60 ff       	sbrs	r22, 0
    5010:	1b c0       	rjmp	.+54     	; 0x5048 <__floatsisf+0x6c>
    5012:	6f 5f       	subi	r22, 0xFF	; 255
    5014:	7f 4f       	sbci	r23, 0xFF	; 255
    5016:	8f 4f       	sbci	r24, 0xFF	; 255
    5018:	9f 4f       	sbci	r25, 0xFF	; 255
    501a:	16 c0       	rjmp	.+44     	; 0x5048 <__floatsisf+0x6c>
    501c:	88 23       	and	r24, r24
    501e:	11 f0       	breq	.+4      	; 0x5024 <__floatsisf+0x48>
    5020:	96 e9       	ldi	r25, 0x96	; 150
    5022:	11 c0       	rjmp	.+34     	; 0x5046 <__floatsisf+0x6a>
    5024:	77 23       	and	r23, r23
    5026:	21 f0       	breq	.+8      	; 0x5030 <__floatsisf+0x54>
    5028:	9e e8       	ldi	r25, 0x8E	; 142
    502a:	87 2f       	mov	r24, r23
    502c:	76 2f       	mov	r23, r22
    502e:	05 c0       	rjmp	.+10     	; 0x503a <__floatsisf+0x5e>
    5030:	66 23       	and	r22, r22
    5032:	71 f0       	breq	.+28     	; 0x5050 <__floatsisf+0x74>
    5034:	96 e8       	ldi	r25, 0x86	; 134
    5036:	86 2f       	mov	r24, r22
    5038:	70 e0       	ldi	r23, 0x00	; 0
    503a:	60 e0       	ldi	r22, 0x00	; 0
    503c:	2a f0       	brmi	.+10     	; 0x5048 <__floatsisf+0x6c>
    503e:	9a 95       	dec	r25
    5040:	66 0f       	add	r22, r22
    5042:	77 1f       	adc	r23, r23
    5044:	88 1f       	adc	r24, r24
    5046:	da f7       	brpl	.-10     	; 0x503e <__floatsisf+0x62>
    5048:	88 0f       	add	r24, r24
    504a:	96 95       	lsr	r25
    504c:	87 95       	ror	r24
    504e:	97 f9       	bld	r25, 7
    5050:	08 95       	ret

00005052 <__fp_inf>:
    5052:	97 f9       	bld	r25, 7
    5054:	9f 67       	ori	r25, 0x7F	; 127
    5056:	80 e8       	ldi	r24, 0x80	; 128
    5058:	70 e0       	ldi	r23, 0x00	; 0
    505a:	60 e0       	ldi	r22, 0x00	; 0
    505c:	08 95       	ret

0000505e <__fp_nan>:
    505e:	9f ef       	ldi	r25, 0xFF	; 255
    5060:	80 ec       	ldi	r24, 0xC0	; 192
    5062:	08 95       	ret

00005064 <__fp_pscA>:
    5064:	00 24       	eor	r0, r0
    5066:	0a 94       	dec	r0
    5068:	16 16       	cp	r1, r22
    506a:	17 06       	cpc	r1, r23
    506c:	18 06       	cpc	r1, r24
    506e:	09 06       	cpc	r0, r25
    5070:	08 95       	ret

00005072 <__fp_pscB>:
    5072:	00 24       	eor	r0, r0
    5074:	0a 94       	dec	r0
    5076:	12 16       	cp	r1, r18
    5078:	13 06       	cpc	r1, r19
    507a:	14 06       	cpc	r1, r20
    507c:	05 06       	cpc	r0, r21
    507e:	08 95       	ret

00005080 <__fp_round>:
    5080:	09 2e       	mov	r0, r25
    5082:	03 94       	inc	r0
    5084:	00 0c       	add	r0, r0
    5086:	11 f4       	brne	.+4      	; 0x508c <__fp_round+0xc>
    5088:	88 23       	and	r24, r24
    508a:	52 f0       	brmi	.+20     	; 0x50a0 <__fp_round+0x20>
    508c:	bb 0f       	add	r27, r27
    508e:	40 f4       	brcc	.+16     	; 0x50a0 <__fp_round+0x20>
    5090:	bf 2b       	or	r27, r31
    5092:	11 f4       	brne	.+4      	; 0x5098 <__fp_round+0x18>
    5094:	60 ff       	sbrs	r22, 0
    5096:	04 c0       	rjmp	.+8      	; 0x50a0 <__fp_round+0x20>
    5098:	6f 5f       	subi	r22, 0xFF	; 255
    509a:	7f 4f       	sbci	r23, 0xFF	; 255
    509c:	8f 4f       	sbci	r24, 0xFF	; 255
    509e:	9f 4f       	sbci	r25, 0xFF	; 255
    50a0:	08 95       	ret

000050a2 <__fp_split3>:
    50a2:	57 fd       	sbrc	r21, 7
    50a4:	90 58       	subi	r25, 0x80	; 128
    50a6:	44 0f       	add	r20, r20
    50a8:	55 1f       	adc	r21, r21
    50aa:	59 f0       	breq	.+22     	; 0x50c2 <__fp_splitA+0x10>
    50ac:	5f 3f       	cpi	r21, 0xFF	; 255
    50ae:	71 f0       	breq	.+28     	; 0x50cc <__fp_splitA+0x1a>
    50b0:	47 95       	ror	r20

000050b2 <__fp_splitA>:
    50b2:	88 0f       	add	r24, r24
    50b4:	97 fb       	bst	r25, 7
    50b6:	99 1f       	adc	r25, r25
    50b8:	61 f0       	breq	.+24     	; 0x50d2 <__fp_splitA+0x20>
    50ba:	9f 3f       	cpi	r25, 0xFF	; 255
    50bc:	79 f0       	breq	.+30     	; 0x50dc <__fp_splitA+0x2a>
    50be:	87 95       	ror	r24
    50c0:	08 95       	ret
    50c2:	12 16       	cp	r1, r18
    50c4:	13 06       	cpc	r1, r19
    50c6:	14 06       	cpc	r1, r20
    50c8:	55 1f       	adc	r21, r21
    50ca:	f2 cf       	rjmp	.-28     	; 0x50b0 <__fp_split3+0xe>
    50cc:	46 95       	lsr	r20
    50ce:	f1 df       	rcall	.-30     	; 0x50b2 <__fp_splitA>
    50d0:	08 c0       	rjmp	.+16     	; 0x50e2 <__fp_splitA+0x30>
    50d2:	16 16       	cp	r1, r22
    50d4:	17 06       	cpc	r1, r23
    50d6:	18 06       	cpc	r1, r24
    50d8:	99 1f       	adc	r25, r25
    50da:	f1 cf       	rjmp	.-30     	; 0x50be <__fp_splitA+0xc>
    50dc:	86 95       	lsr	r24
    50de:	71 05       	cpc	r23, r1
    50e0:	61 05       	cpc	r22, r1
    50e2:	08 94       	sec
    50e4:	08 95       	ret

000050e6 <__fp_zero>:
    50e6:	e8 94       	clt

000050e8 <__fp_szero>:
    50e8:	bb 27       	eor	r27, r27
    50ea:	66 27       	eor	r22, r22
    50ec:	77 27       	eor	r23, r23
    50ee:	cb 01       	movw	r24, r22
    50f0:	97 f9       	bld	r25, 7
    50f2:	08 95       	ret

000050f4 <__mulsf3>:
    50f4:	0b d0       	rcall	.+22     	; 0x510c <__mulsf3x>
    50f6:	c4 cf       	rjmp	.-120    	; 0x5080 <__fp_round>
    50f8:	b5 df       	rcall	.-150    	; 0x5064 <__fp_pscA>
    50fa:	28 f0       	brcs	.+10     	; 0x5106 <__mulsf3+0x12>
    50fc:	ba df       	rcall	.-140    	; 0x5072 <__fp_pscB>
    50fe:	18 f0       	brcs	.+6      	; 0x5106 <__mulsf3+0x12>
    5100:	95 23       	and	r25, r21
    5102:	09 f0       	breq	.+2      	; 0x5106 <__mulsf3+0x12>
    5104:	a6 cf       	rjmp	.-180    	; 0x5052 <__fp_inf>
    5106:	ab cf       	rjmp	.-170    	; 0x505e <__fp_nan>
    5108:	11 24       	eor	r1, r1
    510a:	ee cf       	rjmp	.-36     	; 0x50e8 <__fp_szero>

0000510c <__mulsf3x>:
    510c:	ca df       	rcall	.-108    	; 0x50a2 <__fp_split3>
    510e:	a0 f3       	brcs	.-24     	; 0x50f8 <__mulsf3+0x4>

00005110 <__mulsf3_pse>:
    5110:	95 9f       	mul	r25, r21
    5112:	d1 f3       	breq	.-12     	; 0x5108 <__mulsf3+0x14>
    5114:	95 0f       	add	r25, r21
    5116:	50 e0       	ldi	r21, 0x00	; 0
    5118:	55 1f       	adc	r21, r21
    511a:	62 9f       	mul	r22, r18
    511c:	f0 01       	movw	r30, r0
    511e:	72 9f       	mul	r23, r18
    5120:	bb 27       	eor	r27, r27
    5122:	f0 0d       	add	r31, r0
    5124:	b1 1d       	adc	r27, r1
    5126:	63 9f       	mul	r22, r19
    5128:	aa 27       	eor	r26, r26
    512a:	f0 0d       	add	r31, r0
    512c:	b1 1d       	adc	r27, r1
    512e:	aa 1f       	adc	r26, r26
    5130:	64 9f       	mul	r22, r20
    5132:	66 27       	eor	r22, r22
    5134:	b0 0d       	add	r27, r0
    5136:	a1 1d       	adc	r26, r1
    5138:	66 1f       	adc	r22, r22
    513a:	82 9f       	mul	r24, r18
    513c:	22 27       	eor	r18, r18
    513e:	b0 0d       	add	r27, r0
    5140:	a1 1d       	adc	r26, r1
    5142:	62 1f       	adc	r22, r18
    5144:	73 9f       	mul	r23, r19
    5146:	b0 0d       	add	r27, r0
    5148:	a1 1d       	adc	r26, r1
    514a:	62 1f       	adc	r22, r18
    514c:	83 9f       	mul	r24, r19
    514e:	a0 0d       	add	r26, r0
    5150:	61 1d       	adc	r22, r1
    5152:	22 1f       	adc	r18, r18
    5154:	74 9f       	mul	r23, r20
    5156:	33 27       	eor	r19, r19
    5158:	a0 0d       	add	r26, r0
    515a:	61 1d       	adc	r22, r1
    515c:	23 1f       	adc	r18, r19
    515e:	84 9f       	mul	r24, r20
    5160:	60 0d       	add	r22, r0
    5162:	21 1d       	adc	r18, r1
    5164:	82 2f       	mov	r24, r18
    5166:	76 2f       	mov	r23, r22
    5168:	6a 2f       	mov	r22, r26
    516a:	11 24       	eor	r1, r1
    516c:	9f 57       	subi	r25, 0x7F	; 127
    516e:	50 40       	sbci	r21, 0x00	; 0
    5170:	8a f0       	brmi	.+34     	; 0x5194 <__mulsf3_pse+0x84>
    5172:	e1 f0       	breq	.+56     	; 0x51ac <__mulsf3_pse+0x9c>
    5174:	88 23       	and	r24, r24
    5176:	4a f0       	brmi	.+18     	; 0x518a <__mulsf3_pse+0x7a>
    5178:	ee 0f       	add	r30, r30
    517a:	ff 1f       	adc	r31, r31
    517c:	bb 1f       	adc	r27, r27
    517e:	66 1f       	adc	r22, r22
    5180:	77 1f       	adc	r23, r23
    5182:	88 1f       	adc	r24, r24
    5184:	91 50       	subi	r25, 0x01	; 1
    5186:	50 40       	sbci	r21, 0x00	; 0
    5188:	a9 f7       	brne	.-22     	; 0x5174 <__mulsf3_pse+0x64>
    518a:	9e 3f       	cpi	r25, 0xFE	; 254
    518c:	51 05       	cpc	r21, r1
    518e:	70 f0       	brcs	.+28     	; 0x51ac <__mulsf3_pse+0x9c>
    5190:	60 cf       	rjmp	.-320    	; 0x5052 <__fp_inf>
    5192:	aa cf       	rjmp	.-172    	; 0x50e8 <__fp_szero>
    5194:	5f 3f       	cpi	r21, 0xFF	; 255
    5196:	ec f3       	brlt	.-6      	; 0x5192 <__mulsf3_pse+0x82>
    5198:	98 3e       	cpi	r25, 0xE8	; 232
    519a:	dc f3       	brlt	.-10     	; 0x5192 <__mulsf3_pse+0x82>
    519c:	86 95       	lsr	r24
    519e:	77 95       	ror	r23
    51a0:	67 95       	ror	r22
    51a2:	b7 95       	ror	r27
    51a4:	f7 95       	ror	r31
    51a6:	e7 95       	ror	r30
    51a8:	9f 5f       	subi	r25, 0xFF	; 255
    51aa:	c1 f7       	brne	.-16     	; 0x519c <__mulsf3_pse+0x8c>
    51ac:	fe 2b       	or	r31, r30
    51ae:	88 0f       	add	r24, r24
    51b0:	91 1d       	adc	r25, r1
    51b2:	96 95       	lsr	r25
    51b4:	87 95       	ror	r24
    51b6:	97 f9       	bld	r25, 7
    51b8:	08 95       	ret

000051ba <__mulsi3>:
    51ba:	62 9f       	mul	r22, r18
    51bc:	d0 01       	movw	r26, r0
    51be:	73 9f       	mul	r23, r19
    51c0:	f0 01       	movw	r30, r0
    51c2:	82 9f       	mul	r24, r18
    51c4:	e0 0d       	add	r30, r0
    51c6:	f1 1d       	adc	r31, r1
    51c8:	64 9f       	mul	r22, r20
    51ca:	e0 0d       	add	r30, r0
    51cc:	f1 1d       	adc	r31, r1
    51ce:	92 9f       	mul	r25, r18
    51d0:	f0 0d       	add	r31, r0
    51d2:	83 9f       	mul	r24, r19
    51d4:	f0 0d       	add	r31, r0
    51d6:	74 9f       	mul	r23, r20
    51d8:	f0 0d       	add	r31, r0
    51da:	65 9f       	mul	r22, r21
    51dc:	f0 0d       	add	r31, r0
    51de:	99 27       	eor	r25, r25
    51e0:	72 9f       	mul	r23, r18
    51e2:	b0 0d       	add	r27, r0
    51e4:	e1 1d       	adc	r30, r1
    51e6:	f9 1f       	adc	r31, r25
    51e8:	63 9f       	mul	r22, r19
    51ea:	b0 0d       	add	r27, r0
    51ec:	e1 1d       	adc	r30, r1
    51ee:	f9 1f       	adc	r31, r25
    51f0:	bd 01       	movw	r22, r26
    51f2:	cf 01       	movw	r24, r30
    51f4:	11 24       	eor	r1, r1
    51f6:	08 95       	ret

000051f8 <__udivmodhi4>:
    51f8:	aa 1b       	sub	r26, r26
    51fa:	bb 1b       	sub	r27, r27
    51fc:	51 e1       	ldi	r21, 0x11	; 17
    51fe:	07 c0       	rjmp	.+14     	; 0x520e <__udivmodhi4_ep>

00005200 <__udivmodhi4_loop>:
    5200:	aa 1f       	adc	r26, r26
    5202:	bb 1f       	adc	r27, r27
    5204:	a6 17       	cp	r26, r22
    5206:	b7 07       	cpc	r27, r23
    5208:	10 f0       	brcs	.+4      	; 0x520e <__udivmodhi4_ep>
    520a:	a6 1b       	sub	r26, r22
    520c:	b7 0b       	sbc	r27, r23

0000520e <__udivmodhi4_ep>:
    520e:	88 1f       	adc	r24, r24
    5210:	99 1f       	adc	r25, r25
    5212:	5a 95       	dec	r21
    5214:	a9 f7       	brne	.-22     	; 0x5200 <__udivmodhi4_loop>
    5216:	80 95       	com	r24
    5218:	90 95       	com	r25
    521a:	bc 01       	movw	r22, r24
    521c:	cd 01       	movw	r24, r26
    521e:	08 95       	ret

00005220 <__udivmodsi4>:
    5220:	a1 e2       	ldi	r26, 0x21	; 33
    5222:	1a 2e       	mov	r1, r26
    5224:	aa 1b       	sub	r26, r26
    5226:	bb 1b       	sub	r27, r27
    5228:	fd 01       	movw	r30, r26
    522a:	0d c0       	rjmp	.+26     	; 0x5246 <__udivmodsi4_ep>

0000522c <__udivmodsi4_loop>:
    522c:	aa 1f       	adc	r26, r26
    522e:	bb 1f       	adc	r27, r27
    5230:	ee 1f       	adc	r30, r30
    5232:	ff 1f       	adc	r31, r31
    5234:	a2 17       	cp	r26, r18
    5236:	b3 07       	cpc	r27, r19
    5238:	e4 07       	cpc	r30, r20
    523a:	f5 07       	cpc	r31, r21
    523c:	20 f0       	brcs	.+8      	; 0x5246 <__udivmodsi4_ep>
    523e:	a2 1b       	sub	r26, r18
    5240:	b3 0b       	sbc	r27, r19
    5242:	e4 0b       	sbc	r30, r20
    5244:	f5 0b       	sbc	r31, r21

00005246 <__udivmodsi4_ep>:
    5246:	66 1f       	adc	r22, r22
    5248:	77 1f       	adc	r23, r23
    524a:	88 1f       	adc	r24, r24
    524c:	99 1f       	adc	r25, r25
    524e:	1a 94       	dec	r1
    5250:	69 f7       	brne	.-38     	; 0x522c <__udivmodsi4_loop>
    5252:	60 95       	com	r22
    5254:	70 95       	com	r23
    5256:	80 95       	com	r24
    5258:	90 95       	com	r25
    525a:	9b 01       	movw	r18, r22
    525c:	ac 01       	movw	r20, r24
    525e:	bd 01       	movw	r22, r26
    5260:	cf 01       	movw	r24, r30
    5262:	08 95       	ret

00005264 <memcpy>:
    5264:	fb 01       	movw	r30, r22
    5266:	dc 01       	movw	r26, r24
    5268:	02 c0       	rjmp	.+4      	; 0x526e <memcpy+0xa>
    526a:	01 90       	ld	r0, Z+
    526c:	0d 92       	st	X+, r0
    526e:	41 50       	subi	r20, 0x01	; 1
    5270:	50 40       	sbci	r21, 0x00	; 0
    5272:	d8 f7       	brcc	.-10     	; 0x526a <memcpy+0x6>
    5274:	08 95       	ret

00005276 <_exit>:
    5276:	f8 94       	cli

00005278 <__stop_program>:
    5278:	ff cf       	rjmp	.-2      	; 0x5278 <__stop_program>
