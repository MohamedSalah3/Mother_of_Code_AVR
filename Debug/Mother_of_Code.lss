
Mother_of_Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000553e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008e  00800060  0000553e  000055d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000517  008000ee  008000ee  00005660  2**0
                  ALLOC
  3 .stab         00001c50  00000000  00000000  00005660  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000005e5  00000000  00000000  000072b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  00007898  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007610  00000000  00000000  00007cb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021ec  00000000  00000000  0000f2c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002f7a  00000000  00000000  000114b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e04  00000000  00000000  00014430  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000029f0  00000000  00000000  00016234  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007e26  00000000  00000000  00018c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  00020a4a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 63 07 	jmp	0xec6	; 0xec6 <__vector_1>
       8:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <__vector_2>
       c:	0c 94 b1 07 	jmp	0xf62	; 0xf62 <__vector_3>
      10:	0c 94 d8 07 	jmp	0xfb0	; 0xfb0 <__vector_4>
      14:	0c 94 ff 07 	jmp	0xffe	; 0xffe <__vector_5>
      18:	0c 94 26 08 	jmp	0x104c	; 0x104c <__vector_6>
      1c:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__vector_7>
      20:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <__vector_8>
      24:	0c 94 9b 08 	jmp	0x1136	; 0x1136 <__vector_9>
      28:	0c 94 c2 08 	jmp	0x1184	; 0x1184 <__vector_10>
      2c:	0c 94 e9 08 	jmp	0x11d2	; 0x11d2 <__vector_11>
      30:	0c 94 10 09 	jmp	0x1220	; 0x1220 <__vector_12>
      34:	0c 94 37 09 	jmp	0x126e	; 0x126e <__vector_13>
      38:	0c 94 5e 09 	jmp	0x12bc	; 0x12bc <__vector_14>
      3c:	0c 94 85 09 	jmp	0x130a	; 0x130a <__vector_15>
      40:	0c 94 ac 09 	jmp	0x1358	; 0x1358 <__vector_16>
      44:	0c 94 d3 09 	jmp	0x13a6	; 0x13a6 <__vector_17>
      48:	0c 94 fa 09 	jmp	0x13f4	; 0x13f4 <__vector_18>
      4c:	0c 94 21 0a 	jmp	0x1442	; 0x1442 <__vector_19>
      50:	0c 94 48 0a 	jmp	0x1490	; 0x1490 <__vector_20>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e3       	ldi	r30, 0x3E	; 62
      68:	f5 e5       	ldi	r31, 0x55	; 85
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 3e       	cpi	r26, 0xEE	; 238
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ae ee       	ldi	r26, 0xEE	; 238
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 30       	cpi	r26, 0x05	; 5
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ca 13 	call	0x2794	; 0x2794 <main>
      8a:	0c 94 9d 2a 	jmp	0x553a	; 0x553a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Car_SM_Init>:
//extern uint16_t Distance;
static uint16_t Distance;
ERROR_STATUS Car_SM_Init(void)
{
uint8_t ret=E_OK;
Steering_Init();
      92:	0e 94 48 02 	call	0x490	; 0x490 <Steering_Init>
Us_Init();
      96:	0e 94 fd 06 	call	0xdfa	; 0xdfa <Us_Init>
return ret;
}
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	08 95       	ret

0000009e <Car_SM_Update>:


ERROR_STATUS Car_SM_Update(void)
{uint8_t ret=E_OK;
Us_Trigger();
      9e:	0e 94 06 07 	call	0xe0c	; 0xe0c <Us_Trigger>
Us_GetDistance(&Distance);
      a2:	8e ee       	ldi	r24, 0xEE	; 238
      a4:	90 e0       	ldi	r25, 0x00	; 0
      a6:	0e 94 1c 07 	call	0xe38	; 0xe38 <Us_GetDistance>

if(Distance <= 30)
      aa:	80 91 ee 00 	lds	r24, 0x00EE
      ae:	90 91 ef 00 	lds	r25, 0x00EF
      b2:	8f 31       	cpi	r24, 0x1F	; 31
      b4:	91 05       	cpc	r25, r1
      b6:	28 f4       	brcc	.+10     	; 0xc2 <Car_SM_Update+0x24>
{
	
	Steering_SteerCar(CAR_RIGHT,50);
      b8:	83 e0       	ldi	r24, 0x03	; 3
      ba:	62 e3       	ldi	r22, 0x32	; 50
      bc:	0e 94 4c 02 	call	0x498	; 0x498 <Steering_SteerCar>
      c0:	04 c0       	rjmp	.+8      	; 0xca <Car_SM_Update+0x2c>
}else
{
	Steering_SteerCar(CAR_FORWARD,50);
      c2:	81 e0       	ldi	r24, 0x01	; 1
      c4:	62 e3       	ldi	r22, 0x32	; 50
      c6:	0e 94 4c 02 	call	0x498	; 0x498 <Steering_SteerCar>
}

return ret;
}	
      ca:	80 e0       	ldi	r24, 0x00	; 0
      cc:	08 95       	ret

000000ce <init_fun_plastic>:


void init_fun_plastic(void)
{
/*initialization of magnetic sensor*/
DIO_init(&Dio_D_magnetic);
      ce:	89 e6       	ldi	r24, 0x69	; 105
      d0:	90 e0       	ldi	r25, 0x00	; 0
      d2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*initialization of on off switch*/
DIO_init(&Dio_B_On_Off);
      d6:	86 e6       	ldi	r24, 0x66	; 102
      d8:	90 e0       	ldi	r25, 0x00	; 0
      da:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*initialization of the alarm output*/
DIO_init(&Dio_D_ALARM);
      de:	83 e6       	ldi	r24, 0x63	; 99
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*initialization of the motor output*/
DIO_init(&Dio_B_MOTOR);
      e6:	80 e6       	ldi	r24, 0x60	; 96
      e8:	90 e0       	ldi	r25, 0x00	; 0
      ea:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*SW1
 EX_interrupt_enable0();
*/


}
      ee:	08 95       	ret

000000f0 <on_switch_int>:
void on_switch_int(void)
{



}
      f0:	08 95       	ret

000000f2 <off_switch_int>:
void off_switch_int(void)
{
/*Motor_stop*/


}
      f2:	08 95       	ret

000000f4 <sw_int>:


void sw_int(void)
{
 
if(READBIT(MCUCSR,6))
      f4:	84 b7       	in	r24, 0x34	; 52
      f6:	82 95       	swap	r24
      f8:	86 95       	lsr	r24
      fa:	86 95       	lsr	r24
      fc:	83 70       	andi	r24, 0x03	; 3
      fe:	80 ff       	sbrs	r24, 0
     100:	09 c0       	rjmp	.+18     	; 0x114 <sw_int+0x20>
{	/**if rising edge*/
	/*Motor_start*/
	DIO_Write(GPIOB,BIT5,HIGH);
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	60 e2       	ldi	r22, 0x20	; 32
     106:	4f ef       	ldi	r20, 0xFF	; 255
     108:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	CLEAR_BIT(MCUCSR,6);
     10c:	84 b7       	in	r24, 0x34	; 52
     10e:	8f 7b       	andi	r24, 0xBF	; 191
     110:	84 bf       	out	0x34, r24	; 52
     112:	08 95       	ret
}
else{
/*if fallen edge*/
DIO_Write(GPIOB,BIT5,HIGH);
     114:	81 e0       	ldi	r24, 0x01	; 1
     116:	60 e2       	ldi	r22, 0x20	; 32
     118:	4f ef       	ldi	r20, 0xFF	; 255
     11a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/*Motor_stop*/
/*********************************/
SET_BIT(MCUCSR,6);		/*Make it Rising*/
     11e:	84 b7       	in	r24, 0x34	; 52
     120:	80 64       	ori	r24, 0x40	; 64
     122:	84 bf       	out	0x34, r24	; 52
     124:	08 95       	ret

00000126 <Display_Task>:
	u8_Init_finished=0;

	
	}
*/
		LCD_goto_xy(0,0);
     126:	80 e0       	ldi	r24, 0x00	; 0
     128:	60 e0       	ldi	r22, 0x00	; 0
     12a:	0e 94 67 03 	call	0x6ce	; 0x6ce <LCD_goto_xy>
		LCD_send_char('x');
     12e:	88 e7       	ldi	r24, 0x78	; 120
     130:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <LCD_send_char>



}
     134:	08 95       	ret

00000136 <Push_Task>:
		u8_Counter1=0;
	}
	

	*/
DIO_Toggle(GPIOD,BIT4);
     136:	83 e0       	ldi	r24, 0x03	; 3
     138:	60 e1       	ldi	r22, 0x10	; 16
     13a:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
}
     13e:	08 95       	ret

00000140 <Push_Task1>:
void Push_Task1(void)
{
u8_flag_push = pushButtonGetStatus(BTN_0);
     140:	80 e0       	ldi	r24, 0x00	; 0
     142:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <pushButtonGetStatus>
     146:	80 93 f1 00 	sts	0x00F1, r24
if (u8_flag_push)
     14a:	88 23       	and	r24, r24
     14c:	19 f0       	breq	.+6      	; 0x154 <Push_Task1+0x14>
{
	u8_State_Machine=BUTTON_PRESSED;
     14e:	87 e0       	ldi	r24, 0x07	; 7
     150:	80 93 f2 00 	sts	0x00F2, r24
     154:	08 95       	ret

00000156 <Push_Task2>:
}
}
void Push_Task2(void){
	DIO_Toggle(GPIOD,BIT2);
     156:	83 e0       	ldi	r24, 0x03	; 3
     158:	64 e0       	ldi	r22, 0x04	; 4
     15a:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
}
     15e:	08 95       	ret

00000160 <Read_Time_Task>:

void Read_Time_Task(void)
{
	static uint8_t st_u16_indix=0;
	adc_read();
     160:	0e 94 3d 0b 	call	0x167a	; 0x167a <adc_read>
//u16_ADC_readings_Channel[st_u16_indix]
if (st_u16_indix <3)
     164:	80 91 f3 00 	lds	r24, 0x00F3
     168:	83 30       	cpi	r24, 0x03	; 3
     16a:	20 f4       	brcc	.+8      	; 0x174 <Read_Time_Task+0x14>
{st_u16_indix++;}
     16c:	8f 5f       	subi	r24, 0xFF	; 255
     16e:	80 93 f3 00 	sts	0x00F3, r24
     172:	02 c0       	rjmp	.+4      	; 0x178 <Read_Time_Task+0x18>
else{st_u16_indix=0;}
     174:	10 92 f3 00 	sts	0x00F3, r1
Timing_arr[st_u16_indix]=(u16_ADC_readings_Channel[st_u16_indix])*3  ;
     178:	80 91 f3 00 	lds	r24, 0x00F3
     17c:	90 e0       	ldi	r25, 0x00	; 0
     17e:	88 0f       	add	r24, r24
     180:	99 1f       	adc	r25, r25
     182:	fc 01       	movw	r30, r24
     184:	e4 59       	subi	r30, 0x94	; 148
     186:	ff 4f       	sbci	r31, 0xFF	; 255
     188:	83 56       	subi	r24, 0x63	; 99
     18a:	9a 4f       	sbci	r25, 0xFA	; 250
     18c:	dc 01       	movw	r26, r24
     18e:	8d 91       	ld	r24, X+
     190:	9c 91       	ld	r25, X
     192:	11 97       	sbiw	r26, 0x01	; 1
     194:	9c 01       	movw	r18, r24
     196:	22 0f       	add	r18, r18
     198:	33 1f       	adc	r19, r19
     19a:	82 0f       	add	r24, r18
     19c:	93 1f       	adc	r25, r19
     19e:	91 83       	std	Z+1, r25	; 0x01
     1a0:	80 83       	st	Z, r24


}
     1a2:	08 95       	ret

000001a4 <relay2>:
}

void relay2(void)
{
	/*************************************************************************************/
	counting_arr[2] += 1;
     1a4:	80 91 f8 00 	lds	r24, 0x00F8
     1a8:	90 91 f9 00 	lds	r25, 0x00F9
     1ac:	01 96       	adiw	r24, 0x01	; 1
     1ae:	90 93 f9 00 	sts	0x00F9, r25
     1b2:	80 93 f8 00 	sts	0x00F8, r24
	/*************************************************************************************/
	/*************************************************************************************/
	if (counting_arr[2]==Timing_arr[2])
     1b6:	20 91 70 00 	lds	r18, 0x0070
     1ba:	30 91 71 00 	lds	r19, 0x0071
     1be:	82 17       	cp	r24, r18
     1c0:	93 07       	cpc	r25, r19
     1c2:	51 f4       	brne	.+20     	; 0x1d8 <relay2+0x34>
	{DIO_Toggle(GPIOD,BIT4);
     1c4:	83 e0       	ldi	r24, 0x03	; 3
     1c6:	60 e1       	ldi	r22, 0x10	; 16
     1c8:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
		counting_arr[2]=0;
     1cc:	10 92 f9 00 	sts	0x00F9, r1
     1d0:	10 92 f8 00 	sts	0x00F8, r1
		relay0();
     1d4:	0e 94 08 01 	call	0x210	; 0x210 <relay0>
     1d8:	08 95       	ret

000001da <relay1>:
}

void relay1(void)
{
	/*************************************************************************************/
	counting_arr[1] += 1;
     1da:	80 91 f6 00 	lds	r24, 0x00F6
     1de:	90 91 f7 00 	lds	r25, 0x00F7
     1e2:	01 96       	adiw	r24, 0x01	; 1
     1e4:	90 93 f7 00 	sts	0x00F7, r25
     1e8:	80 93 f6 00 	sts	0x00F6, r24
	/*************************************************************************************/
	/*************************************************************************************/
	if (counting_arr[1]==Timing_arr[1])
     1ec:	20 91 6e 00 	lds	r18, 0x006E
     1f0:	30 91 6f 00 	lds	r19, 0x006F
     1f4:	82 17       	cp	r24, r18
     1f6:	93 07       	cpc	r25, r19
     1f8:	51 f4       	brne	.+20     	; 0x20e <relay1+0x34>
	{DIO_Toggle(GPIOD,BIT2);
     1fa:	83 e0       	ldi	r24, 0x03	; 3
     1fc:	64 e0       	ldi	r22, 0x04	; 4
     1fe:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
		counting_arr[1]=0;
     202:	10 92 f7 00 	sts	0x00F7, r1
     206:	10 92 f6 00 	sts	0x00F6, r1
		relay2();
     20a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <relay2>
     20e:	08 95       	ret

00000210 <relay0>:
}

void relay0(void)
{
/*************************************************************************************/
counting_arr[0] += 1;
     210:	80 91 f4 00 	lds	r24, 0x00F4
     214:	90 91 f5 00 	lds	r25, 0x00F5
     218:	01 96       	adiw	r24, 0x01	; 1
     21a:	90 93 f5 00 	sts	0x00F5, r25
     21e:	80 93 f4 00 	sts	0x00F4, r24
/*************************************************************************************/
/*************************************************************************************/
if (counting_arr[0]==Timing_arr[0])
     222:	20 91 6c 00 	lds	r18, 0x006C
     226:	30 91 6d 00 	lds	r19, 0x006D
     22a:	82 17       	cp	r24, r18
     22c:	93 07       	cpc	r25, r19
     22e:	51 f4       	brne	.+20     	; 0x244 <relay0+0x34>
{
	DIO_Toggle(GPIOD,BIT2);
     230:	83 e0       	ldi	r24, 0x03	; 3
     232:	64 e0       	ldi	r22, 0x04	; 4
     234:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
	counting_arr[0]=0;
     238:	10 92 f5 00 	sts	0x00F5, r1
     23c:	10 92 f4 00 	sts	0x00F4, r1
	relay1();
     240:	0e 94 ed 00 	call	0x1da	; 0x1da <relay1>
     244:	08 95       	ret

00000246 <update_timing>:
SOS_Create_Task(Push_Task1,1,4,20);
SOS_Create_Task(Push_Task2,1,5,30);
*/

/*************************************************************************************/
if (u8_State_Machine == BUTTON_PRESSED || u8_State_Machine == RELAY0_COUNTING)
     246:	80 91 f2 00 	lds	r24, 0x00F2
     24a:	87 30       	cpi	r24, 0x07	; 7
     24c:	11 f0       	breq	.+4      	; 0x252 <update_timing+0xc>
     24e:	81 30       	cpi	r24, 0x01	; 1
     250:	91 f4       	brne	.+36     	; 0x276 <update_timing+0x30>
{
	DIO_Write(GPIOD,BIT2,HIGH);
     252:	83 e0       	ldi	r24, 0x03	; 3
     254:	64 e0       	ldi	r22, 0x04	; 4
     256:	4f ef       	ldi	r20, 0xFF	; 255
     258:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	counting_arr[0] += 1;
     25c:	80 91 f4 00 	lds	r24, 0x00F4
     260:	90 91 f5 00 	lds	r25, 0x00F5
     264:	01 96       	adiw	r24, 0x01	; 1
     266:	90 93 f5 00 	sts	0x00F5, r25
     26a:	80 93 f4 00 	sts	0x00F4, r24
	
	u8_State_Machine=RELAY0_COUNTING;
     26e:	81 e0       	ldi	r24, 0x01	; 1
     270:	80 93 f2 00 	sts	0x00F2, r24
     274:	22 c0       	rjmp	.+68     	; 0x2ba <update_timing+0x74>
}
	    
/*************************************************************************************/
   if (u8_State_Machine==RELAY0_ACTION_DONE)// || u8_State_Machine == RELAY1_COUNTING)
     276:	84 30       	cpi	r24, 0x04	; 4
     278:	71 f4       	brne	.+28     	; 0x296 <update_timing+0x50>
   {
	DIO_Write(GPIOD,BIT3,HIGH);   
     27a:	83 e0       	ldi	r24, 0x03	; 3
     27c:	68 e0       	ldi	r22, 0x08	; 8
     27e:	4f ef       	ldi	r20, 0xFF	; 255
     280:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	    counting_arr[1] += 1;
     284:	80 91 f6 00 	lds	r24, 0x00F6
     288:	90 91 f7 00 	lds	r25, 0x00F7
     28c:	01 96       	adiw	r24, 0x01	; 1
     28e:	90 93 f7 00 	sts	0x00F7, r25
     292:	80 93 f6 00 	sts	0x00F6, r24
	//	u8_State_Machine=RELAY1_COUNTING;
   }
   
/*************************************************************************************/
if (u8_State_Machine == RELAY1_ACTION_DONE )//|| u8_State_Machine == RELAY2_COUNTING)
     296:	80 91 f2 00 	lds	r24, 0x00F2
     29a:	85 30       	cpi	r24, 0x05	; 5
     29c:	71 f4       	brne	.+28     	; 0x2ba <update_timing+0x74>
{
	DIO_Write(GPIOD,BIT4,HIGH);
     29e:	83 e0       	ldi	r24, 0x03	; 3
     2a0:	60 e1       	ldi	r22, 0x10	; 16
     2a2:	4f ef       	ldi	r20, 0xFF	; 255
     2a4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     counting_arr[2] += 1;
     2a8:	80 91 f8 00 	lds	r24, 0x00F8
     2ac:	90 91 f9 00 	lds	r25, 0x00F9
     2b0:	01 96       	adiw	r24, 0x01	; 1
     2b2:	90 93 f9 00 	sts	0x00F9, r25
     2b6:	80 93 f8 00 	sts	0x00F8, r24
//	 u8_State_Machine=RELAY2_COUNTING;
}

	
/*************************************************************************************/
if (counting_arr[0]==Timing_arr[0])
     2ba:	20 91 f4 00 	lds	r18, 0x00F4
     2be:	30 91 f5 00 	lds	r19, 0x00F5
     2c2:	80 91 6c 00 	lds	r24, 0x006C
     2c6:	90 91 6d 00 	lds	r25, 0x006D
     2ca:	28 17       	cp	r18, r24
     2cc:	39 07       	cpc	r19, r25
     2ce:	c9 f5       	brne	.+114    	; 0x342 <update_timing+0xfc>
{
	DIO_Write(GPIOD,BIT2,LOW);
     2d0:	83 e0       	ldi	r24, 0x03	; 3
     2d2:	64 e0       	ldi	r22, 0x04	; 4
     2d4:	40 e0       	ldi	r20, 0x00	; 0
     2d6:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	UartTransmitPooling('A');
     2da:	81 e4       	ldi	r24, 0x41	; 65
     2dc:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     2e0:	84 e4       	ldi	r24, 0x44	; 68
     2e2:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     2e6:	83 e4       	ldi	r24, 0x43	; 67
     2e8:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('0');
     2ec:	80 e3       	ldi	r24, 0x30	; 48
     2ee:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     2f2:	8d e3       	ldi	r24, 0x3D	; 61
     2f4:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(Timing_arr[0]);
     2f8:	80 91 6c 00 	lds	r24, 0x006C
     2fc:	90 91 6d 00 	lds	r25, 0x006D
     300:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('A');
     304:	81 e4       	ldi	r24, 0x41	; 65
     306:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     30a:	84 e4       	ldi	r24, 0x44	; 68
     30c:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     310:	83 e4       	ldi	r24, 0x43	; 67
     312:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('0');
     316:	80 e3       	ldi	r24, 0x30	; 48
     318:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     31c:	8d e3       	ldi	r24, 0x3D	; 61
     31e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[0]);
     322:	80 91 f4 00 	lds	r24, 0x00F4
     326:	90 91 f5 00 	lds	r25, 0x00F5
     32a:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('\n');
     32e:	8a e0       	ldi	r24, 0x0A	; 10
     330:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
counting_arr[0]=0;
     334:	10 92 f5 00 	sts	0x00F5, r1
     338:	10 92 f4 00 	sts	0x00F4, r1
u8_State_Machine=RELAY0_ACTION_DONE;
     33c:	84 e0       	ldi	r24, 0x04	; 4
     33e:	80 93 f2 00 	sts	0x00F2, r24
}
/**************************************************************************************/
if (counting_arr[1]==Timing_arr[1] && u8_State_Machine==RELAY0_ACTION_DONE)
     342:	20 91 f6 00 	lds	r18, 0x00F6
     346:	30 91 f7 00 	lds	r19, 0x00F7
     34a:	80 91 6e 00 	lds	r24, 0x006E
     34e:	90 91 6f 00 	lds	r25, 0x006F
     352:	28 17       	cp	r18, r24
     354:	39 07       	cpc	r19, r25
     356:	09 f0       	breq	.+2      	; 0x35a <update_timing+0x114>
     358:	45 c0       	rjmp	.+138    	; 0x3e4 <update_timing+0x19e>
     35a:	80 91 f2 00 	lds	r24, 0x00F2
     35e:	84 30       	cpi	r24, 0x04	; 4
     360:	09 f0       	breq	.+2      	; 0x364 <update_timing+0x11e>
     362:	40 c0       	rjmp	.+128    	; 0x3e4 <update_timing+0x19e>
{
	DIO_Write(GPIOD,BIT2,LOW);
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	64 e0       	ldi	r22, 0x04	; 4
     368:	40 e0       	ldi	r20, 0x00	; 0
     36a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
DIO_Toggle(GPIOD,BIT3);
     36e:	83 e0       	ldi	r24, 0x03	; 3
     370:	68 e0       	ldi	r22, 0x08	; 8
     372:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
UartTransmitPooling(' ');
     376:	80 e2       	ldi	r24, 0x20	; 32
     378:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('A');
     37c:	81 e4       	ldi	r24, 0x41	; 65
     37e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     382:	84 e4       	ldi	r24, 0x44	; 68
     384:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     388:	83 e4       	ldi	r24, 0x43	; 67
     38a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('1');
     38e:	81 e3       	ldi	r24, 0x31	; 49
     390:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     394:	8d e3       	ldi	r24, 0x3D	; 61
     396:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(Timing_arr[1]);
     39a:	80 91 6e 00 	lds	r24, 0x006E
     39e:	90 91 6f 00 	lds	r25, 0x006F
     3a2:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('A');
     3a6:	81 e4       	ldi	r24, 0x41	; 65
     3a8:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     3ac:	84 e4       	ldi	r24, 0x44	; 68
     3ae:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     3b2:	83 e4       	ldi	r24, 0x43	; 67
     3b4:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('1');
     3b8:	81 e3       	ldi	r24, 0x31	; 49
     3ba:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     3be:	8d e3       	ldi	r24, 0x3D	; 61
     3c0:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[1]);
     3c4:	80 91 f6 00 	lds	r24, 0x00F6
     3c8:	90 91 f7 00 	lds	r25, 0x00F7
     3cc:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('\n');
     3d0:	8a e0       	ldi	r24, 0x0A	; 10
     3d2:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
counting_arr[1]=0;
     3d6:	10 92 f7 00 	sts	0x00F7, r1
     3da:	10 92 f6 00 	sts	0x00F6, r1
u8_State_Machine=RELAY1_ACTION_DONE;
     3de:	85 e0       	ldi	r24, 0x05	; 5
     3e0:	80 93 f2 00 	sts	0x00F2, r24
}
/**************************************************************************************/
if (counting_arr[2]==Timing_arr[2]&& u8_State_Machine==RELAY1_ACTION_DONE)
     3e4:	20 91 f8 00 	lds	r18, 0x00F8
     3e8:	30 91 f9 00 	lds	r19, 0x00F9
     3ec:	80 91 70 00 	lds	r24, 0x0070
     3f0:	90 91 71 00 	lds	r25, 0x0071
     3f4:	28 17       	cp	r18, r24
     3f6:	39 07       	cpc	r19, r25
     3f8:	09 f0       	breq	.+2      	; 0x3fc <update_timing+0x1b6>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <update_timing+0x23a>
     3fc:	80 91 f2 00 	lds	r24, 0x00F2
     400:	85 30       	cpi	r24, 0x05	; 5
     402:	f1 f5       	brne	.+124    	; 0x480 <update_timing+0x23a>
{
	DIO_Write(GPIOD,BIT3,LOW);
     404:	83 e0       	ldi	r24, 0x03	; 3
     406:	68 e0       	ldi	r22, 0x08	; 8
     408:	40 e0       	ldi	r20, 0x00	; 0
     40a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
DIO_Toggle(GPIOD,BIT4);
     40e:	83 e0       	ldi	r24, 0x03	; 3
     410:	60 e1       	ldi	r22, 0x10	; 16
     412:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>

	UartTransmitPooling(' ');
     416:	80 e2       	ldi	r24, 0x20	; 32
     418:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('A');
     41c:	81 e4       	ldi	r24, 0x41	; 65
     41e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     422:	84 e4       	ldi	r24, 0x44	; 68
     424:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     428:	83 e4       	ldi	r24, 0x43	; 67
     42a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('2');
     42e:	82 e3       	ldi	r24, 0x32	; 50
     430:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     434:	8d e3       	ldi	r24, 0x3D	; 61
     436:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(Timing_arr[2]);
     43a:	80 91 70 00 	lds	r24, 0x0070
     43e:	90 91 71 00 	lds	r25, 0x0071
     442:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('A');
     446:	81 e4       	ldi	r24, 0x41	; 65
     448:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     44c:	84 e4       	ldi	r24, 0x44	; 68
     44e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     452:	83 e4       	ldi	r24, 0x43	; 67
     454:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('2');
     458:	82 e3       	ldi	r24, 0x32	; 50
     45a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     45e:	8d e3       	ldi	r24, 0x3D	; 61
     460:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[2]);
     464:	80 91 f8 00 	lds	r24, 0x00F8
     468:	90 91 f9 00 	lds	r25, 0x00F9
     46c:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('\n');
     470:	8a e0       	ldi	r24, 0x0A	; 10
     472:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	counting_arr[2]=0;
     476:	10 92 f9 00 	sts	0x00F9, r1
     47a:	10 92 f8 00 	sts	0x00F8, r1
     47e:	04 c0       	rjmp	.+8      	; 0x488 <update_timing+0x242>
u8_State_Machine=RELAY2_ACTION_DONE;
}
if (u8_State_Machine == RELAY2_ACTION_DONE)
     480:	80 91 f2 00 	lds	r24, 0x00F2
     484:	86 30       	cpi	r24, 0x06	; 6
     486:	11 f4       	brne	.+4      	; 0x48c <update_timing+0x246>
{
	u8_State_Machine=NO_ACTION;
     488:	10 92 f2 00 	sts	0x00F2, r1
     48c:	08 95       	ret

0000048e <uart_send_sos>:
{
	
	
	
	
}
     48e:	08 95       	ret

00000490 <Steering_Init>:


ERROR_STATUS Steering_Init(void)
{
	uint8_t ret=0;
	ret=Motor_Init(MOTOR_1|MOTOR_2);
     490:	83 e0       	ldi	r24, 0x03	; 3
     492:	0e 94 94 05 	call	0xb28	; 0xb28 <Motor_Init>
	return ret;
}
     496:	08 95       	ret

00000498 <Steering_SteerCar>:


ERROR_STATUS Steering_SteerCar(uint8_t Steering_CarCmd, uint8_t speed)
{
     498:	cf 93       	push	r28
     49a:	c6 2f       	mov	r28, r22
	uint8_t ret=0;
		switch(Steering_CarCmd)
     49c:	82 30       	cpi	r24, 0x02	; 2
     49e:	a1 f0       	breq	.+40     	; 0x4c8 <Steering_SteerCar+0x30>
     4a0:	83 30       	cpi	r24, 0x03	; 3
     4a2:	20 f4       	brcc	.+8      	; 0x4ac <Steering_SteerCar+0x14>
     4a4:	81 30       	cpi	r24, 0x01	; 1
     4a6:	09 f0       	breq	.+2      	; 0x4aa <Steering_SteerCar+0x12>
     4a8:	42 c0       	rjmp	.+132    	; 0x52e <Steering_SteerCar+0x96>
     4aa:	05 c0       	rjmp	.+10     	; 0x4b6 <Steering_SteerCar+0x1e>
     4ac:	83 30       	cpi	r24, 0x03	; 3
     4ae:	51 f1       	breq	.+84     	; 0x504 <Steering_SteerCar+0x6c>
     4b0:	84 30       	cpi	r24, 0x04	; 4
     4b2:	e9 f5       	brne	.+122    	; 0x52e <Steering_SteerCar+0x96>
     4b4:	12 c0       	rjmp	.+36     	; 0x4da <Steering_SteerCar+0x42>
	{
		case CAR_FORWARD:
			ret= Motor_Direction(MOTOR_1|MOTOR_2, CAR_FORWARD);
     4b6:	83 e0       	ldi	r24, 0x03	; 3
     4b8:	61 e0       	ldi	r22, 0x01	; 1
     4ba:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     4be:	83 e0       	ldi	r24, 0x03	; 3
     4c0:	6c 2f       	mov	r22, r28
     4c2:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>
			break;
     4c6:	34 c0       	rjmp	.+104    	; 0x530 <Steering_SteerCar+0x98>
			case CAR_BACKWARD:
			ret= Motor_Direction(MOTOR_1|MOTOR_2,CAR_BACKWARD);
     4c8:	83 e0       	ldi	r24, 0x03	; 3
     4ca:	62 e0       	ldi	r22, 0x02	; 2
     4cc:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     4d0:	83 e0       	ldi	r24, 0x03	; 3
     4d2:	6c 2f       	mov	r22, r28
     4d4:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>
			break;
     4d8:	2b c0       	rjmp	.+86     	; 0x530 <Steering_SteerCar+0x98>
			case CAR_LEFT:
			ret= Motor_Direction(MOTOR_1, CAR_FORWARD);
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	61 e0       	ldi	r22, 0x01	; 1
     4de:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_BACKWARD);
     4e2:	82 e0       	ldi	r24, 0x02	; 2
     4e4:	62 e0       	ldi	r22, 0x02	; 2
     4e6:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     4ea:	83 e0       	ldi	r24, 0x03	; 3
     4ec:	6c 2f       	mov	r22, r28
     4ee:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>

/*************************************************************/
			ret= Motor_Direction(MOTOR_1, CAR_STOP);
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	60 e0       	ldi	r22, 0x00	; 0
     4f6:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_STOP);
     4fa:	82 e0       	ldi	r24, 0x02	; 2
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			break;
     502:	16 c0       	rjmp	.+44     	; 0x530 <Steering_SteerCar+0x98>
			case CAR_RIGHT:
			ret= Motor_Direction(MOTOR_1, CAR_BACKWARD);
     504:	81 e0       	ldi	r24, 0x01	; 1
     506:	62 e0       	ldi	r22, 0x02	; 2
     508:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_FORWARD);
     50c:	82 e0       	ldi	r24, 0x02	; 2
     50e:	61 e0       	ldi	r22, 0x01	; 1
     510:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     514:	83 e0       	ldi	r24, 0x03	; 3
     516:	6c 2f       	mov	r22, r28
     518:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>
		/*	timer2Start();
			timer2DelayMs(100);
*//***********************************************************/
			ret= Motor_Direction(MOTOR_1, CAR_STOP);
     51c:	81 e0       	ldi	r24, 0x01	; 1
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_STOP);
     524:	82 e0       	ldi	r24, 0x02	; 2
     526:	60 e0       	ldi	r22, 0x00	; 0
     528:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			break;
     52c:	01 c0       	rjmp	.+2      	; 0x530 <Steering_SteerCar+0x98>
}


ERROR_STATUS Steering_SteerCar(uint8_t Steering_CarCmd, uint8_t speed)
{
	uint8_t ret=0;
     52e:	80 e0       	ldi	r24, 0x00	; 0
			break;
	}
	
	
return ret;
     530:	cf 91       	pop	r28
     532:	08 95       	ret

00000534 <LCD_EN_pulse>:
 #include <stdlib.h>
extern uint8_t u8_Init_finished;
 static uint8_t U8_index=0;
 void LCD_EN_pulse(void)
 {
	 DIO_Write(LCD_EN_PORT, LCD_EN_PIN, HIGH);
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	68 e0       	ldi	r22, 0x08	; 8
     538:	4f ef       	ldi	r20, 0xFF	; 255
     53a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/***********************************************************/
	 SwDelay_us(10);
     53e:	6a e0       	ldi	r22, 0x0A	; 10
     540:	70 e0       	ldi	r23, 0x00	; 0
     542:	80 e0       	ldi	r24, 0x00	; 0
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	0e 94 f2 06 	call	0xde4	; 0xde4 <SwDelay_us>
	 DIO_Write(LCD_EN_PORT, LCD_EN_PIN, LOW);
     54a:	81 e0       	ldi	r24, 0x01	; 1
     54c:	68 e0       	ldi	r22, 0x08	; 8
     54e:	40 e0       	ldi	r20, 0x00	; 0
     550:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/*************************************************************/	 
	 SwDelay_us(10);
     554:	6a e0       	ldi	r22, 0x0A	; 10
     556:	70 e0       	ldi	r23, 0x00	; 0
     558:	80 e0       	ldi	r24, 0x00	; 0
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 f2 06 	call	0xde4	; 0xde4 <SwDelay_us>
 }
     560:	08 95       	ret

00000562 <LCD_config_pins>:

 void LCD_config_pins(void){

	 /* set LCD pins as outputs */
	DIO_init(&Dio_configurationB);
     562:	84 ec       	ldi	r24, 0xC4	; 196
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
}
     56a:	08 95       	ret

0000056c <LCD_send_nibble>:

 void LCD_send_nibble(uint8_t data){
     56c:	cf 93       	push	r28
	 uint8_t mask = 1;
	 data >>= 4;
     56e:	c8 2f       	mov	r28, r24
     570:	c2 95       	swap	r28
     572:	cf 70       	andi	r28, 0x0F	; 15
	 if(data & mask)
     574:	c0 ff       	sbrs	r28, 0
     576:	06 c0       	rjmp	.+12     	; 0x584 <LCD_send_nibble+0x18>
	 DIO_Write(LCD_D4_PORT, LCD_D4_PIN, HIGH);
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	60 e1       	ldi	r22, 0x10	; 16
     57c:	4f ef       	ldi	r20, 0xFF	; 255
     57e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     582:	05 c0       	rjmp	.+10     	; 0x58e <LCD_send_nibble+0x22>
	 else
	 DIO_Write(LCD_D4_PORT, LCD_D4_PIN, LOW);
     584:	81 e0       	ldi	r24, 0x01	; 1
     586:	60 e1       	ldi	r22, 0x10	; 16
     588:	40 e0       	ldi	r20, 0x00	; 0
     58a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     58e:	c1 ff       	sbrs	r28, 1
     590:	06 c0       	rjmp	.+12     	; 0x59e <LCD_send_nibble+0x32>
	 DIO_Write(LCD_D5_PORT, LCD_D5_PIN, HIGH);
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	60 e2       	ldi	r22, 0x20	; 32
     596:	4f ef       	ldi	r20, 0xFF	; 255
     598:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     59c:	05 c0       	rjmp	.+10     	; 0x5a8 <LCD_send_nibble+0x3c>
	 else
	 DIO_Write(LCD_D5_PORT, LCD_D5_PIN, LOW);
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	60 e2       	ldi	r22, 0x20	; 32
     5a2:	40 e0       	ldi	r20, 0x00	; 0
     5a4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     5a8:	c2 ff       	sbrs	r28, 2
     5aa:	06 c0       	rjmp	.+12     	; 0x5b8 <LCD_send_nibble+0x4c>
	 DIO_Write(LCD_D6_PORT, LCD_D6_PIN, HIGH);
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	60 e4       	ldi	r22, 0x40	; 64
     5b0:	4f ef       	ldi	r20, 0xFF	; 255
     5b2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     5b6:	05 c0       	rjmp	.+10     	; 0x5c2 <LCD_send_nibble+0x56>
	 else
	 DIO_Write(LCD_D6_PORT, LCD_D6_PIN, LOW);
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	60 e4       	ldi	r22, 0x40	; 64
     5bc:	40 e0       	ldi	r20, 0x00	; 0
     5be:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     5c2:	c8 70       	andi	r28, 0x08	; 8
     5c4:	31 f0       	breq	.+12     	; 0x5d2 <LCD_send_nibble+0x66>
	 DIO_Write(LCD_D7_PORT, LCD_D7_PIN, HIGH);
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	60 e8       	ldi	r22, 0x80	; 128
     5ca:	4f ef       	ldi	r20, 0xFF	; 255
     5cc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     5d0:	05 c0       	rjmp	.+10     	; 0x5dc <LCD_send_nibble+0x70>
	 else
	 DIO_Write(LCD_D7_PORT, LCD_D7_PIN, LOW);
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	60 e8       	ldi	r22, 0x80	; 128
     5d6:	40 e0       	ldi	r20, 0x00	; 0
     5d8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
 }
     5dc:	cf 91       	pop	r28
     5de:	08 95       	ret

000005e0 <LCD_send_char>:
/***************************************************************************/
 void LCD_send_char(char data)		//Sends Char to LCD
 {
     5e0:	cf 93       	push	r28
     5e2:	c8 2f       	mov	r28, r24
	 DIO_Write(LCD_RS_PORT, LCD_RS_PIN, HIGH);
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	62 e0       	ldi	r22, 0x02	; 2
     5e8:	4f ef       	ldi	r20, 0xFF	; 255
     5ea:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	 LCD_send_nibble(data); // Higher nibble first
     5ee:	8c 2f       	mov	r24, r28
     5f0:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     5f4:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>

	 LCD_send_nibble(data<<4);
     5f8:	8c 2f       	mov	r24, r28
     5fa:	82 95       	swap	r24
     5fc:	80 7f       	andi	r24, 0xF0	; 240
     5fe:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     602:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>
 }
     606:	cf 91       	pop	r28
     608:	08 95       	ret

0000060a <LCD_send_command>:
 /**************************************************************************/
 void LCD_send_command(uint8_t data)	//Sends Command to LCD
 {
     60a:	cf 93       	push	r28
     60c:	c8 2f       	mov	r28, r24
	 DIO_Write(LCD_RS_PORT, LCD_RS_PIN, LOW);
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	62 e0       	ldi	r22, 0x02	; 2
     612:	40 e0       	ldi	r20, 0x00	; 0
     614:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	 LCD_send_nibble(data); // Higher nibble first
     618:	8c 2f       	mov	r24, r28
     61a:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     61e:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>

	 LCD_send_nibble(data<<4);
     622:	8c 2f       	mov	r24, r28
     624:	82 95       	swap	r24
     626:	80 7f       	andi	r24, 0xF0	; 240
     628:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     62c:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>
	 SwDelay_ms(1);
     630:	61 e0       	ldi	r22, 0x01	; 1
     632:	70 e0       	ldi	r23, 0x00	; 0
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	90 e0       	ldi	r25, 0x00	; 0
     638:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <SwDelay_ms>
 }
     63c:	cf 91       	pop	r28
     63e:	08 95       	ret

00000640 <LCD_init>:
	/*
	uint8_t commands[9]={0x33,0x32,Four_bit,Cursor_on,Lcd_clear,Increment_cursor,Cursor_off,0};
	 LCD_config_pins();
	 */
	/*******************************************************************/
	 SwDelay_ms(20);
     640:	64 e1       	ldi	r22, 0x14	; 20
     642:	70 e0       	ldi	r23, 0x00	; 0
     644:	80 e0       	ldi	r24, 0x00	; 0
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <SwDelay_ms>
	LCD_send_nibble(0x00);
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	
		DIO_Write(LCD_RS_PORT, LCD_RS_PIN, LOW);
     652:	81 e0       	ldi	r24, 0x01	; 1
     654:	62 e0       	ldi	r22, 0x02	; 2
     656:	40 e0       	ldi	r20, 0x00	; 0
     658:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(LCD_RW_PORT, LCD_RW_PIN, LOW);
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	64 e0       	ldi	r22, 0x04	; 4
     660:	40 e0       	ldi	r20, 0x00	; 0
     662:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(LCD_EN_PORT, LCD_EN_PIN, LOW);
     666:	81 e0       	ldi	r24, 0x01	; 1
     668:	68 e0       	ldi	r22, 0x08	; 8
     66a:	40 e0       	ldi	r20, 0x00	; 0
     66c:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 LCD_send_command(Four_bit); // 4-bit
     670:	88 e2       	ldi	r24, 0x28	; 40
     672:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(0x38);
     676:	88 e3       	ldi	r24, 0x38	; 56
     678:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(0x32);
     67c:	82 e3       	ldi	r24, 0x32	; 50
     67e:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 
	 LCD_send_command(Cursor_on);
     682:	8e e0       	ldi	r24, 0x0E	; 14
     684:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(Lcd_clear);
     688:	81 e0       	ldi	r24, 0x01	; 1
     68a:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 
	SwDelay_ms(10);
     68e:	6a e0       	ldi	r22, 0x0A	; 10
     690:	70 e0       	ldi	r23, 0x00	; 0
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <SwDelay_ms>
	 LCD_send_command(Increment_cursor);
     69a:	86 e0       	ldi	r24, 0x06	; 6
     69c:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(Cursor_off); // Cursor off
     6a0:	8c e0       	ldi	r24, 0x0C	; 12
     6a2:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
}else
{
	u8_Init_finished=1;
}
 */
}
     6a6:	08 95       	ret

000006a8 <LCD_clear>:
 void LCD_clear(void)				//Clears LCD
 {
	 LCD_send_command(Lcd_clear);
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
 }
     6ae:	08 95       	ret

000006b0 <LCD_send_string>:

 void LCD_send_string(char* data)	//Outputs string to LCD
 {
     6b0:	cf 93       	push	r28
     6b2:	df 93       	push	r29
     6b4:	ec 01       	movw	r28, r24
	while(*data)
     6b6:	88 81       	ld	r24, Y
     6b8:	88 23       	and	r24, r24
     6ba:	31 f0       	breq	.+12     	; 0x6c8 <LCD_send_string+0x18>
 void LCD_clear(void)				//Clears LCD
 {
	 LCD_send_command(Lcd_clear);
 }

 void LCD_send_string(char* data)	//Outputs string to LCD
     6bc:	21 96       	adiw	r28, 0x01	; 1
 {
	while(*data)
	 {
		 LCD_send_char(*data++);
     6be:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <LCD_send_char>
	 LCD_send_command(Lcd_clear);
 }

 void LCD_send_string(char* data)	//Outputs string to LCD
 {
	while(*data)
     6c2:	89 91       	ld	r24, Y+
     6c4:	88 23       	and	r24, r24
     6c6:	d9 f7       	brne	.-10     	; 0x6be <LCD_send_string+0xe>
	 {
		 LCD_send_char(*data++);
	 }
	 
 }
     6c8:	df 91       	pop	r29
     6ca:	cf 91       	pop	r28
     6cc:	08 95       	ret

000006ce <LCD_goto_xy>:

 void LCD_goto_xy(uint8_t x, uint8_t y)	//Cursor to X Y position
 {
	 uint8_t DDRAMAddr;
	 // remap lines into proper order
	 switch(y)
     6ce:	62 30       	cpi	r22, 0x02	; 2
     6d0:	31 f0       	breq	.+12     	; 0x6de <LCD_goto_xy+0x10>
     6d2:	63 30       	cpi	r22, 0x03	; 3
     6d4:	31 f0       	breq	.+12     	; 0x6e2 <LCD_goto_xy+0x14>
     6d6:	61 30       	cpi	r22, 0x01	; 1
     6d8:	29 f4       	brne	.+10     	; 0x6e4 <LCD_goto_xy+0x16>
	 {
		 case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
		 case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
     6da:	80 5c       	subi	r24, 0xC0	; 192
     6dc:	03 c0       	rjmp	.+6      	; 0x6e4 <LCD_goto_xy+0x16>
		 case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
     6de:	8c 5e       	subi	r24, 0xEC	; 236
     6e0:	01 c0       	rjmp	.+2      	; 0x6e4 <LCD_goto_xy+0x16>
		 case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
     6e2:	8c 5a       	subi	r24, 0xAC	; 172
		 default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	 }
	 // set data address
	 LCD_send_command(1<<LCD_DDRAM | DDRAMAddr);
     6e4:	80 68       	ori	r24, 0x80	; 128
     6e6:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>

 }
     6ea:	08 95       	ret

000006ec <reverse>:
	 char t = *x; *x = *y; *y = t;
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
 {
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
	 while (i < j)
     6f4:	40 17       	cp	r20, r16
     6f6:	51 07       	cpc	r21, r17
     6f8:	62 07       	cpc	r22, r18
     6fa:	73 07       	cpc	r23, r19
     6fc:	c0 f4       	brcc	.+48     	; 0x72e <reverse+0x42>
 inline void swap(char *x, char *y) {
	 char t = *x; *x = *y; *y = t;
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
     6fe:	d8 01       	movw	r26, r16
     700:	11 96       	adiw	r26, 0x01	; 1
     702:	a8 0f       	add	r26, r24
     704:	b9 1f       	adc	r27, r25
     706:	fc 01       	movw	r30, r24
     708:	e4 0f       	add	r30, r20
     70a:	f5 1f       	adc	r31, r21
 {
	 while (i < j)
	 swap(&buffer[i++], &buffer[j--]);
     70c:	4f 5f       	subi	r20, 0xFF	; 255
     70e:	5f 4f       	sbci	r21, 0xFF	; 255
     710:	6f 4f       	sbci	r22, 0xFF	; 255
     712:	7f 4f       	sbci	r23, 0xFF	; 255
     714:	01 50       	subi	r16, 0x01	; 1
     716:	10 40       	sbci	r17, 0x00	; 0
     718:	20 40       	sbci	r18, 0x00	; 0
     71a:	30 40       	sbci	r19, 0x00	; 0

 /*---Modification----------------------------------------------------------------------------------------------*/

 // inline function to swap two numbers
 inline void swap(char *x, char *y) {
	 char t = *x; *x = *y; *y = t;
     71c:	c0 81       	ld	r28, Z
     71e:	de 91       	ld	r29, -X
     720:	d1 93       	st	Z+, r29
     722:	cc 93       	st	X, r28
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
 {
	 while (i < j)
     724:	40 17       	cp	r20, r16
     726:	51 07       	cpc	r21, r17
     728:	62 07       	cpc	r22, r18
     72a:	73 07       	cpc	r23, r19
     72c:	78 f3       	brcs	.-34     	; 0x70c <reverse+0x20>
	 swap(&buffer[i++], &buffer[j--]);

	 return buffer;
 }
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	1f 91       	pop	r17
     734:	0f 91       	pop	r16
     736:	08 95       	ret

00000738 <itoa_>:

 // Iterative function to implement itoa() function in C
 char* itoa_(uint32_t value, char* buffer, uint32_t base)
 {
     738:	4f 92       	push	r4
     73a:	5f 92       	push	r5
     73c:	6f 92       	push	r6
     73e:	7f 92       	push	r7
     740:	8f 92       	push	r8
     742:	9f 92       	push	r9
     744:	af 92       	push	r10
     746:	bf 92       	push	r11
     748:	cf 92       	push	r12
     74a:	df 92       	push	r13
     74c:	ef 92       	push	r14
     74e:	ff 92       	push	r15
     750:	0f 93       	push	r16
     752:	1f 93       	push	r17
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	6b 01       	movw	r12, r22
     75a:	7c 01       	movw	r14, r24
     75c:	2a 01       	movw	r4, r20
     75e:	48 01       	movw	r8, r16
     760:	59 01       	movw	r10, r18
	 // invalid input
	 if (base < 2 || base > 32)
     762:	d9 01       	movw	r26, r18
     764:	c8 01       	movw	r24, r16
     766:	02 97       	sbiw	r24, 0x02	; 2
     768:	a1 09       	sbc	r26, r1
     76a:	b1 09       	sbc	r27, r1
     76c:	8f 31       	cpi	r24, 0x1F	; 31
     76e:	91 05       	cpc	r25, r1
     770:	a1 05       	cpc	r26, r1
     772:	b1 05       	cpc	r27, r1
     774:	08 f0       	brcs	.+2      	; 0x778 <itoa_+0x40>
     776:	49 c0       	rjmp	.+146    	; 0x80a <itoa_+0xd2>
	 return buffer;

	 // consider absolute value of number
	 int n = abs(value);
     778:	96 01       	movw	r18, r12
     77a:	dd 20       	and	r13, r13
     77c:	1c f4       	brge	.+6      	; 0x784 <itoa_+0x4c>
     77e:	30 95       	com	r19
     780:	21 95       	neg	r18
     782:	3f 4f       	sbci	r19, 0xFF	; 255

	 int i = 0;
	 while (n)
     784:	21 15       	cp	r18, r1
     786:	31 05       	cpc	r19, r1
     788:	39 f1       	breq	.+78     	; 0x7d8 <itoa_+0xa0>
     78a:	e2 01       	movw	r28, r4
     78c:	01 e0       	ldi	r16, 0x01	; 1
     78e:	10 e0       	ldi	r17, 0x00	; 0
	 {
		 int r = n % base;
     790:	69 01       	movw	r12, r18
     792:	ee 24       	eor	r14, r14
     794:	d7 fc       	sbrc	r13, 7
     796:	e0 94       	com	r14
     798:	fe 2c       	mov	r15, r14
     79a:	c7 01       	movw	r24, r14
     79c:	b6 01       	movw	r22, r12
     79e:	a5 01       	movw	r20, r10
     7a0:	94 01       	movw	r18, r8
     7a2:	0e 94 72 2a 	call	0x54e4	; 0x54e4 <__udivmodsi4>

		 if (r >= 10)
     7a6:	6a 30       	cpi	r22, 0x0A	; 10
     7a8:	71 05       	cpc	r23, r1
     7aa:	24 f0       	brlt	.+8      	; 0x7b4 <itoa_+0x7c>
		 buffer[i++] = 65 + (r - 10);
     7ac:	69 5c       	subi	r22, 0xC9	; 201
     7ae:	68 83       	st	Y, r22
     7b0:	38 01       	movw	r6, r16
     7b2:	03 c0       	rjmp	.+6      	; 0x7ba <itoa_+0x82>
		 else
		 buffer[i++] = 48 + r;
     7b4:	60 5d       	subi	r22, 0xD0	; 208
     7b6:	68 83       	st	Y, r22
     7b8:	38 01       	movw	r6, r16

		 n = n / base;
     7ba:	c7 01       	movw	r24, r14
     7bc:	b6 01       	movw	r22, r12
     7be:	a5 01       	movw	r20, r10
     7c0:	94 01       	movw	r18, r8
     7c2:	0e 94 72 2a 	call	0x54e4	; 0x54e4 <__udivmodsi4>
     7c6:	0f 5f       	subi	r16, 0xFF	; 255
     7c8:	1f 4f       	sbci	r17, 0xFF	; 255
     7ca:	21 96       	adiw	r28, 0x01	; 1

	 // consider absolute value of number
	 int n = abs(value);

	 int i = 0;
	 while (n)
     7cc:	21 15       	cp	r18, r1
     7ce:	31 05       	cpc	r19, r1
     7d0:	f9 f6       	brne	.-66     	; 0x790 <itoa_+0x58>

		 n = n / base;
	 }

	 // if number is 0
	 if (i == 0)
     7d2:	61 14       	cp	r6, r1
     7d4:	71 04       	cpc	r7, r1
     7d6:	31 f4       	brne	.+12     	; 0x7e4 <itoa_+0xac>
	 buffer[i++] = '0';
     7d8:	80 e3       	ldi	r24, 0x30	; 48
     7da:	f2 01       	movw	r30, r4
     7dc:	80 83       	st	Z, r24
     7de:	66 24       	eor	r6, r6
     7e0:	77 24       	eor	r7, r7
     7e2:	63 94       	inc	r6
	 // is preceded with a minus sign (-)
	 // With any other base, value is always considered unsigned
	 if (value < 0 && base == 10)
	 buffer[i++] = '-';

	 buffer[i] = '\0'; // null terminate string
     7e4:	f2 01       	movw	r30, r4
     7e6:	e6 0d       	add	r30, r6
     7e8:	f7 1d       	adc	r31, r7
     7ea:	10 82       	st	Z, r1

	 // reverse the string and return it
	 return reverse(buffer, 0, i - 1);
     7ec:	08 94       	sec
     7ee:	61 08       	sbc	r6, r1
     7f0:	71 08       	sbc	r7, r1
     7f2:	83 01       	movw	r16, r6
     7f4:	22 27       	eor	r18, r18
     7f6:	17 fd       	sbrc	r17, 7
     7f8:	20 95       	com	r18
     7fa:	32 2f       	mov	r19, r18
     7fc:	c2 01       	movw	r24, r4
     7fe:	40 e0       	ldi	r20, 0x00	; 0
     800:	50 e0       	ldi	r21, 0x00	; 0
     802:	ba 01       	movw	r22, r20
     804:	0e 94 76 03 	call	0x6ec	; 0x6ec <reverse>
     808:	2c 01       	movw	r4, r24
 }
     80a:	84 2d       	mov	r24, r4
     80c:	95 2d       	mov	r25, r5
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	1f 91       	pop	r17
     814:	0f 91       	pop	r16
     816:	ff 90       	pop	r15
     818:	ef 90       	pop	r14
     81a:	df 90       	pop	r13
     81c:	cf 90       	pop	r12
     81e:	bf 90       	pop	r11
     820:	af 90       	pop	r10
     822:	9f 90       	pop	r9
     824:	8f 90       	pop	r8
     826:	7f 90       	pop	r7
     828:	6f 90       	pop	r6
     82a:	5f 90       	pop	r5
     82c:	4f 90       	pop	r4
     82e:	08 95       	ret

00000830 <gpioPortDirection>:
 * @param value: set the port value and takes the following values
 * 				- 0x00 -> Low
 * 				- 0xff -> High
 */

switch (u8_port)	
     830:	81 30       	cpi	r24, 0x01	; 1
     832:	49 f0       	breq	.+18     	; 0x846 <gpioPortDirection+0x16>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	28 f0       	brcs	.+10     	; 0x842 <gpioPortDirection+0x12>
     838:	82 30       	cpi	r24, 0x02	; 2
     83a:	39 f0       	breq	.+14     	; 0x84a <gpioPortDirection+0x1a>
     83c:	83 30       	cpi	r24, 0x03	; 3
     83e:	41 f4       	brne	.+16     	; 0x850 <gpioPortDirection+0x20>
     840:	06 c0       	rjmp	.+12     	; 0x84e <gpioPortDirection+0x1e>
{	case GPIOA:
	PORTA_DIR = u8_direction;
     842:	6a bb       	out	0x1a, r22	; 26
	break;
     844:	08 95       	ret
	case GPIOB:
	PORTB_DIR = u8_direction;
     846:	67 bb       	out	0x17, r22	; 23
	break;
     848:	08 95       	ret
	case GPIOC:
	PORTC_DIR = u8_direction;
     84a:	64 bb       	out	0x14, r22	; 20
	break;
     84c:	08 95       	ret
	case GPIOD:
	PORTD_DIR = u8_direction;
     84e:	61 bb       	out	0x11, r22	; 17
     850:	08 95       	ret

00000852 <gpioPortWrite>:
}

void gpioPortWrite(uint8_t u8_port, uint8_t u8_value)
{
	
switch (u8_port)	
     852:	81 30       	cpi	r24, 0x01	; 1
     854:	49 f0       	breq	.+18     	; 0x868 <__stack+0x9>
     856:	81 30       	cpi	r24, 0x01	; 1
     858:	28 f0       	brcs	.+10     	; 0x864 <__stack+0x5>
     85a:	82 30       	cpi	r24, 0x02	; 2
     85c:	39 f0       	breq	.+14     	; 0x86c <__stack+0xd>
     85e:	83 30       	cpi	r24, 0x03	; 3
     860:	41 f4       	brne	.+16     	; 0x872 <__stack+0x13>
     862:	06 c0       	rjmp	.+12     	; 0x870 <__stack+0x11>
{	case GPIOA:
	PORTA_DATA = u8_value;
     864:	6b bb       	out	0x1b, r22	; 27
	break;
     866:	08 95       	ret
	case GPIOB:
	PORTB_DATA = u8_value;
     868:	68 bb       	out	0x18, r22	; 24
	break;
     86a:	08 95       	ret
	case GPIOC:
	PORTC_DATA = u8_value;
     86c:	65 bb       	out	0x15, r22	; 21
	break;
     86e:	08 95       	ret
	case GPIOD:
	PORTD_DATA = u8_value;
     870:	62 bb       	out	0x12, r22	; 18
     872:	08 95       	ret

00000874 <gpioPortToggle>:
	
}
void gpioPortToggle(uint8_t u8_port)
{
	
switch (u8_port)	
     874:	81 30       	cpi	r24, 0x01	; 1
     876:	59 f0       	breq	.+22     	; 0x88e <gpioPortToggle+0x1a>
     878:	81 30       	cpi	r24, 0x01	; 1
     87a:	28 f0       	brcs	.+10     	; 0x886 <gpioPortToggle+0x12>
     87c:	82 30       	cpi	r24, 0x02	; 2
     87e:	59 f0       	breq	.+22     	; 0x896 <gpioPortToggle+0x22>
     880:	83 30       	cpi	r24, 0x03	; 3
     882:	81 f4       	brne	.+32     	; 0x8a4 <gpioPortToggle+0x30>
     884:	0c c0       	rjmp	.+24     	; 0x89e <gpioPortToggle+0x2a>
{	case GPIOA:
	PORTA_DATA ^= HIGH;
     886:	8b b3       	in	r24, 0x1b	; 27
     888:	80 95       	com	r24
     88a:	8b bb       	out	0x1b, r24	; 27
	break;
     88c:	08 95       	ret
	case GPIOB:
	PORTB_DATA ^= HIGH;
     88e:	88 b3       	in	r24, 0x18	; 24
     890:	80 95       	com	r24
     892:	88 bb       	out	0x18, r24	; 24
	break;
     894:	08 95       	ret
	case GPIOC:
	PORTC_DATA ^= HIGH;
     896:	85 b3       	in	r24, 0x15	; 21
     898:	80 95       	com	r24
     89a:	85 bb       	out	0x15, r24	; 21
	break;
     89c:	08 95       	ret
	case GPIOD:
	PORTD_DATA ^= HIGH;
     89e:	82 b3       	in	r24, 0x12	; 18
     8a0:	80 95       	com	r24
     8a2:	82 bb       	out	0x12, r24	; 18
     8a4:	08 95       	ret

000008a6 <gpioPortRead>:

uint8_t gpioPortRead(uint8_t u8_port)
{
	uint8_t U8_ret_Port_data=0;
	
switch (u8_port)	
     8a6:	81 30       	cpi	r24, 0x01	; 1
     8a8:	49 f0       	breq	.+18     	; 0x8bc <gpioPortRead+0x16>
     8aa:	81 30       	cpi	r24, 0x01	; 1
     8ac:	28 f0       	brcs	.+10     	; 0x8b8 <gpioPortRead+0x12>
     8ae:	82 30       	cpi	r24, 0x02	; 2
     8b0:	39 f0       	breq	.+14     	; 0x8c0 <gpioPortRead+0x1a>
     8b2:	83 30       	cpi	r24, 0x03	; 3
     8b4:	49 f4       	brne	.+18     	; 0x8c8 <gpioPortRead+0x22>
     8b6:	06 c0       	rjmp	.+12     	; 0x8c4 <gpioPortRead+0x1e>
{	case GPIOA:
	U8_ret_Port_data=PORTA_DATA & HIGH;
     8b8:	8b b3       	in	r24, 0x1b	; 27
	break;
     8ba:	08 95       	ret
	case GPIOB:
	U8_ret_Port_data=PORTB_DATA & HIGH;
     8bc:	88 b3       	in	r24, 0x18	; 24
	break;
     8be:	08 95       	ret
	case GPIOC:
	U8_ret_Port_data=PORTC_DATA & HIGH;
     8c0:	85 b3       	in	r24, 0x15	; 21
	break;
     8c2:	08 95       	ret
	case GPIOD:
	U8_ret_Port_data=PORTD_DATA & HIGH;
     8c4:	82 b3       	in	r24, 0x12	; 18
	break;
     8c6:	08 95       	ret
	
}

uint8_t gpioPortRead(uint8_t u8_port)
{
	uint8_t U8_ret_Port_data=0;
     8c8:	80 e0       	ldi	r24, 0x00	; 0
	break;
	
}

return 	U8_ret_Port_data;
}
     8ca:	08 95       	ret

000008cc <gpioPinDirection>:
 * 				- 0x00 -> Input
 * 				- 0xff -> Output
 */
void gpioPinDirection(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_direction)
{
switch(u8_direction){
     8cc:	44 23       	and	r20, r20
     8ce:	19 f0       	breq	.+6      	; 0x8d6 <gpioPinDirection+0xa>
     8d0:	4f 3f       	cpi	r20, 0xFF	; 255
     8d2:	d1 f5       	brne	.+116    	; 0x948 <gpioPinDirection+0x7c>
     8d4:	21 c0       	rjmp	.+66     	; 0x918 <gpioPinDirection+0x4c>
case INPUT:
{
switch (u8_port)	
     8d6:	81 30       	cpi	r24, 0x01	; 1
     8d8:	69 f0       	breq	.+26     	; 0x8f4 <gpioPinDirection+0x28>
     8da:	81 30       	cpi	r24, 0x01	; 1
     8dc:	28 f0       	brcs	.+10     	; 0x8e8 <gpioPinDirection+0x1c>
     8de:	82 30       	cpi	r24, 0x02	; 2
     8e0:	79 f0       	breq	.+30     	; 0x900 <gpioPinDirection+0x34>
     8e2:	83 30       	cpi	r24, 0x03	; 3
     8e4:	c9 f4       	brne	.+50     	; 0x918 <gpioPinDirection+0x4c>
     8e6:	12 c0       	rjmp	.+36     	; 0x90c <gpioPinDirection+0x40>
{	case GPIOA:
	PORTA_DIR &=(~u8_pins);   // 0b01111111
     8e8:	8a b3       	in	r24, 0x1a	; 26
     8ea:	96 2f       	mov	r25, r22
     8ec:	90 95       	com	r25
     8ee:	89 23       	and	r24, r25
     8f0:	8a bb       	out	0x1a, r24	; 26
     8f2:	1b c0       	rjmp	.+54     	; 0x92a <gpioPinDirection+0x5e>
	break;
	case GPIOB:
	PORTB_DIR &=(~u8_pins);
     8f4:	87 b3       	in	r24, 0x17	; 23
     8f6:	96 2f       	mov	r25, r22
     8f8:	90 95       	com	r25
     8fa:	89 23       	and	r24, r25
     8fc:	87 bb       	out	0x17, r24	; 23
     8fe:	19 c0       	rjmp	.+50     	; 0x932 <gpioPinDirection+0x66>
	break;
	case GPIOC:
	PORTC_DIR &=(~u8_pins);
     900:	84 b3       	in	r24, 0x14	; 20
     902:	96 2f       	mov	r25, r22
     904:	90 95       	com	r25
     906:	89 23       	and	r24, r25
     908:	84 bb       	out	0x14, r24	; 20
     90a:	17 c0       	rjmp	.+46     	; 0x93a <gpioPinDirection+0x6e>
	break;
	case GPIOD:
	PORTD_DIR &=(~u8_pins);
     90c:	81 b3       	in	r24, 0x11	; 17
     90e:	96 2f       	mov	r25, r22
     910:	90 95       	com	r25
     912:	89 23       	and	r24, r25
     914:	81 bb       	out	0x11, r24	; 17
     916:	15 c0       	rjmp	.+42     	; 0x942 <gpioPinDirection+0x76>
	break;
	
}
}
case OUTPUT:{
switch (u8_port)	
     918:	81 30       	cpi	r24, 0x01	; 1
     91a:	59 f0       	breq	.+22     	; 0x932 <gpioPinDirection+0x66>
     91c:	81 30       	cpi	r24, 0x01	; 1
     91e:	28 f0       	brcs	.+10     	; 0x92a <gpioPinDirection+0x5e>
     920:	82 30       	cpi	r24, 0x02	; 2
     922:	59 f0       	breq	.+22     	; 0x93a <gpioPinDirection+0x6e>
     924:	83 30       	cpi	r24, 0x03	; 3
     926:	81 f4       	brne	.+32     	; 0x948 <gpioPinDirection+0x7c>
     928:	0c c0       	rjmp	.+24     	; 0x942 <gpioPinDirection+0x76>
{	case GPIOA:
	PORTA_DIR |=(u8_pins);
     92a:	8a b3       	in	r24, 0x1a	; 26
     92c:	68 2b       	or	r22, r24
     92e:	6a bb       	out	0x1a, r22	; 26
	break;
     930:	08 95       	ret
	case GPIOB:
	PORTB_DIR |=(u8_pins);
     932:	87 b3       	in	r24, 0x17	; 23
     934:	68 2b       	or	r22, r24
     936:	67 bb       	out	0x17, r22	; 23
	break;
     938:	08 95       	ret
	case GPIOC:
	PORTC_DIR |=(u8_pins);
     93a:	84 b3       	in	r24, 0x14	; 20
     93c:	68 2b       	or	r22, r24
     93e:	64 bb       	out	0x14, r22	; 20
	break;
     940:	08 95       	ret
	case GPIOD:
	PORTD_DIR |=(u8_pins);
     942:	81 b3       	in	r24, 0x11	; 17
     944:	68 2b       	or	r22, r24
     946:	61 bb       	out	0x11, r22	; 17
     948:	08 95       	ret

0000094a <gpioPinWrite>:
	
	
}

void gpioPinWrite(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_value)
{switch(u8_value){
     94a:	44 23       	and	r20, r20
     94c:	19 f0       	breq	.+6      	; 0x954 <gpioPinWrite+0xa>
     94e:	4f 3f       	cpi	r20, 0xFF	; 255
     950:	b1 f5       	brne	.+108    	; 0x9be <gpioPinWrite+0x74>
     952:	1d c0       	rjmp	.+58     	; 0x98e <gpioPinWrite+0x44>
case LOW:
{
switch (u8_port)	
     954:	81 30       	cpi	r24, 0x01	; 1
     956:	61 f0       	breq	.+24     	; 0x970 <gpioPinWrite+0x26>
     958:	81 30       	cpi	r24, 0x01	; 1
     95a:	28 f0       	brcs	.+10     	; 0x966 <gpioPinWrite+0x1c>
     95c:	82 30       	cpi	r24, 0x02	; 2
     95e:	69 f0       	breq	.+26     	; 0x97a <gpioPinWrite+0x30>
     960:	83 30       	cpi	r24, 0x03	; 3
     962:	69 f5       	brne	.+90     	; 0x9be <gpioPinWrite+0x74>
     964:	0f c0       	rjmp	.+30     	; 0x984 <gpioPinWrite+0x3a>
{	case GPIOA:
	PORTA_DATA &= ~(u8_pins);   // 0b01111111
     966:	8b b3       	in	r24, 0x1b	; 27
     968:	60 95       	com	r22
     96a:	68 23       	and	r22, r24
     96c:	6b bb       	out	0x1b, r22	; 27
	break;
     96e:	08 95       	ret
	case GPIOB:
	PORTB_DATA &= ~(u8_pins);
     970:	88 b3       	in	r24, 0x18	; 24
     972:	60 95       	com	r22
     974:	68 23       	and	r22, r24
     976:	68 bb       	out	0x18, r22	; 24
	break;
     978:	08 95       	ret
	case GPIOC:
	PORTC_DATA &= ~(u8_pins);
     97a:	85 b3       	in	r24, 0x15	; 21
     97c:	60 95       	com	r22
     97e:	68 23       	and	r22, r24
     980:	65 bb       	out	0x15, r22	; 21
	break;
     982:	08 95       	ret
	case GPIOD:
	PORTD_DATA &= ~(u8_pins);
     984:	82 b3       	in	r24, 0x12	; 18
     986:	60 95       	com	r22
     988:	68 23       	and	r22, r24
     98a:	62 bb       	out	0x12, r22	; 18
	break;
     98c:	08 95       	ret
	
}
break;
}
case HIGH:{
switch (u8_port)	
     98e:	81 30       	cpi	r24, 0x01	; 1
     990:	59 f0       	breq	.+22     	; 0x9a8 <gpioPinWrite+0x5e>
     992:	81 30       	cpi	r24, 0x01	; 1
     994:	28 f0       	brcs	.+10     	; 0x9a0 <gpioPinWrite+0x56>
     996:	82 30       	cpi	r24, 0x02	; 2
     998:	59 f0       	breq	.+22     	; 0x9b0 <gpioPinWrite+0x66>
     99a:	83 30       	cpi	r24, 0x03	; 3
     99c:	81 f4       	brne	.+32     	; 0x9be <gpioPinWrite+0x74>
     99e:	0c c0       	rjmp	.+24     	; 0x9b8 <gpioPinWrite+0x6e>
{	case GPIOA:
	PORTA_DATA |=(u8_pins);
     9a0:	8b b3       	in	r24, 0x1b	; 27
     9a2:	68 2b       	or	r22, r24
     9a4:	6b bb       	out	0x1b, r22	; 27
	break;
     9a6:	08 95       	ret
	case GPIOB:
	PORTB_DATA |=(u8_pins);
     9a8:	88 b3       	in	r24, 0x18	; 24
     9aa:	68 2b       	or	r22, r24
     9ac:	68 bb       	out	0x18, r22	; 24
	break;
     9ae:	08 95       	ret
	case GPIOC:
	PORTC_DATA |=(u8_pins);
     9b0:	85 b3       	in	r24, 0x15	; 21
     9b2:	68 2b       	or	r22, r24
     9b4:	65 bb       	out	0x15, r22	; 21
	break;
     9b6:	08 95       	ret
	case GPIOD:
	PORTD_DATA |=(u8_pins);
     9b8:	82 b3       	in	r24, 0x12	; 18
     9ba:	68 2b       	or	r22, r24
     9bc:	62 bb       	out	0x12, r22	; 18
     9be:	08 95       	ret

000009c0 <gpioPinToggle>:
}

}
void gpioPinToggle(uint8_t u8_port, uint8_t u8_pins)
{
switch (u8_port)	
     9c0:	81 30       	cpi	r24, 0x01	; 1
     9c2:	59 f0       	breq	.+22     	; 0x9da <gpioPinToggle+0x1a>
     9c4:	81 30       	cpi	r24, 0x01	; 1
     9c6:	28 f0       	brcs	.+10     	; 0x9d2 <gpioPinToggle+0x12>
     9c8:	82 30       	cpi	r24, 0x02	; 2
     9ca:	59 f0       	breq	.+22     	; 0x9e2 <gpioPinToggle+0x22>
     9cc:	83 30       	cpi	r24, 0x03	; 3
     9ce:	81 f4       	brne	.+32     	; 0x9f0 <gpioPinToggle+0x30>
     9d0:	0c c0       	rjmp	.+24     	; 0x9ea <gpioPinToggle+0x2a>
{	case GPIOA:
	PORTA_DATA ^=(u8_pins);
     9d2:	8b b3       	in	r24, 0x1b	; 27
     9d4:	68 27       	eor	r22, r24
     9d6:	6b bb       	out	0x1b, r22	; 27
	break;
     9d8:	08 95       	ret
	case GPIOB:
	PORTB_DATA ^=(u8_pins);
     9da:	88 b3       	in	r24, 0x18	; 24
     9dc:	68 27       	eor	r22, r24
     9de:	68 bb       	out	0x18, r22	; 24
	break;
     9e0:	08 95       	ret
	case GPIOC:
	PORTC_DATA ^=(u8_pins);
     9e2:	85 b3       	in	r24, 0x15	; 21
     9e4:	68 27       	eor	r22, r24
     9e6:	65 bb       	out	0x15, r22	; 21
	break;
     9e8:	08 95       	ret
	case GPIOD:
	PORTD_DATA ^=(u8_pins);
     9ea:	82 b3       	in	r24, 0x12	; 18
     9ec:	68 27       	eor	r22, r24
     9ee:	62 bb       	out	0x12, r22	; 18
     9f0:	08 95       	ret

000009f2 <gpioPinRead>:
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
{
	uint8_t U8_ret_BIT_data = 0;
switch (u8_port)	
     9f2:	81 30       	cpi	r24, 0x01	; 1
     9f4:	51 f0       	breq	.+20     	; 0xa0a <gpioPinRead+0x18>
     9f6:	81 30       	cpi	r24, 0x01	; 1
     9f8:	28 f0       	brcs	.+10     	; 0xa04 <gpioPinRead+0x12>
     9fa:	82 30       	cpi	r24, 0x02	; 2
     9fc:	49 f0       	breq	.+18     	; 0xa10 <gpioPinRead+0x1e>
     9fe:	83 30       	cpi	r24, 0x03	; 3
     a00:	69 f4       	brne	.+26     	; 0xa1c <gpioPinRead+0x2a>
     a02:	09 c0       	rjmp	.+18     	; 0xa16 <gpioPinRead+0x24>
{	case GPIOA:
	U8_ret_BIT_data=(PORTA_PIN & u8_pin);
     a04:	89 b3       	in	r24, 0x19	; 25
     a06:	68 23       	and	r22, r24
	break;
     a08:	0a c0       	rjmp	.+20     	; 0xa1e <gpioPinRead+0x2c>
	case GPIOB:
	U8_ret_BIT_data=(PORTB_PIN & u8_pin);
     a0a:	86 b3       	in	r24, 0x16	; 22
     a0c:	68 23       	and	r22, r24
	break;
     a0e:	07 c0       	rjmp	.+14     	; 0xa1e <gpioPinRead+0x2c>
	case GPIOC:
	U8_ret_BIT_data=(PORTC_PIN & u8_pin);
     a10:	83 b3       	in	r24, 0x13	; 19
     a12:	68 23       	and	r22, r24
	break;
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <gpioPinRead+0x2c>
	case GPIOD:
	U8_ret_BIT_data=(PORTD_PIN & u8_pin);
     a16:	80 b3       	in	r24, 0x10	; 16
     a18:	68 23       	and	r22, r24
	break;
     a1a:	01 c0       	rjmp	.+2      	; 0xa1e <gpioPinRead+0x2c>
	
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
{
	uint8_t U8_ret_BIT_data = 0;
     a1c:	60 e0       	ldi	r22, 0x00	; 0
}
	
	
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	66 23       	and	r22, r22
     a22:	09 f4       	brne	.+2      	; 0xa26 <gpioPinRead+0x34>
     a24:	80 e0       	ldi	r24, 0x00	; 0
if(U8_ret_BIT_data > 0)
{
	U8_ret_BIT_data = 1;
}
return U8_ret_BIT_data;
     a26:	08 95       	ret

00000a28 <Led_Init>:
	LED_3

*/
void Led_Init(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     a28:	81 30       	cpi	r24, 0x01	; 1
     a2a:	69 f0       	breq	.+26     	; 0xa46 <Led_Init+0x1e>
     a2c:	81 30       	cpi	r24, 0x01	; 1
     a2e:	28 f0       	brcs	.+10     	; 0xa3a <Led_Init+0x12>
     a30:	82 30       	cpi	r24, 0x02	; 2
     a32:	79 f0       	breq	.+30     	; 0xa52 <Led_Init+0x2a>
     a34:	83 30       	cpi	r24, 0x03	; 3
     a36:	c1 f4       	brne	.+48     	; 0xa68 <Led_Init+0x40>
     a38:	12 c0       	rjmp	.+36     	; 0xa5e <Led_Init+0x36>
{
case LED_0:
gpioPinDirection(LED_0_GPIO,LED_0_BIT,HIGH);
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	60 e1       	ldi	r22, 0x10	; 16
     a3e:	4f ef       	ldi	r20, 0xFF	; 255
     a40:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
break;
     a44:	08 95       	ret

case LED_1:
gpioPinDirection(LED_1_GPIO,LED_1_BIT,HIGH);
     a46:	81 e0       	ldi	r24, 0x01	; 1
     a48:	60 e2       	ldi	r22, 0x20	; 32
     a4a:	4f ef       	ldi	r20, 0xFF	; 255
     a4c:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
break;
     a50:	08 95       	ret

case LED_2:
gpioPinDirection(LED_2_GPIO,LED_2_BIT,HIGH);
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	60 e4       	ldi	r22, 0x40	; 64
     a56:	4f ef       	ldi	r20, 0xFF	; 255
     a58:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
break;
     a5c:	08 95       	ret

case LED_3:
gpioPinDirection(LED_3_GPIO,LED_3_BIT,HIGH);
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	60 e8       	ldi	r22, 0x80	; 128
     a62:	4f ef       	ldi	r20, 0xFF	; 255
     a64:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
     a68:	08 95       	ret

00000a6a <Led_On>:
}


void Led_On(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     a6a:	81 30       	cpi	r24, 0x01	; 1
     a6c:	69 f0       	breq	.+26     	; 0xa88 <Led_On+0x1e>
     a6e:	81 30       	cpi	r24, 0x01	; 1
     a70:	28 f0       	brcs	.+10     	; 0xa7c <Led_On+0x12>
     a72:	82 30       	cpi	r24, 0x02	; 2
     a74:	79 f0       	breq	.+30     	; 0xa94 <Led_On+0x2a>
     a76:	83 30       	cpi	r24, 0x03	; 3
     a78:	c1 f4       	brne	.+48     	; 0xaaa <Led_On+0x40>
     a7a:	12 c0       	rjmp	.+36     	; 0xaa0 <Led_On+0x36>
{
case LED_0:
gpioPinWrite(LED_0_GPIO,LED_0_BIT,HIGH);
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	60 e1       	ldi	r22, 0x10	; 16
     a80:	4f ef       	ldi	r20, 0xFF	; 255
     a82:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     a86:	08 95       	ret

case LED_1:
gpioPinWrite(LED_1_GPIO,LED_1_BIT,HIGH);
     a88:	81 e0       	ldi	r24, 0x01	; 1
     a8a:	60 e2       	ldi	r22, 0x20	; 32
     a8c:	4f ef       	ldi	r20, 0xFF	; 255
     a8e:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     a92:	08 95       	ret

case LED_2:
gpioPinWrite(LED_2_GPIO,LED_2_BIT,HIGH);
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	60 e4       	ldi	r22, 0x40	; 64
     a98:	4f ef       	ldi	r20, 0xFF	; 255
     a9a:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     a9e:	08 95       	ret

case LED_3:
gpioPinWrite(LED_3_GPIO,LED_3_BIT,HIGH);
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	60 e8       	ldi	r22, 0x80	; 128
     aa4:	4f ef       	ldi	r20, 0xFF	; 255
     aa6:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
     aaa:	08 95       	ret

00000aac <Led_Off>:
}

void Led_Off(En_LedNumber_t en_led_id)
{

switch(en_led_id)
     aac:	81 30       	cpi	r24, 0x01	; 1
     aae:	69 f0       	breq	.+26     	; 0xaca <Led_Off+0x1e>
     ab0:	81 30       	cpi	r24, 0x01	; 1
     ab2:	28 f0       	brcs	.+10     	; 0xabe <Led_Off+0x12>
     ab4:	82 30       	cpi	r24, 0x02	; 2
     ab6:	79 f0       	breq	.+30     	; 0xad6 <Led_Off+0x2a>
     ab8:	83 30       	cpi	r24, 0x03	; 3
     aba:	c1 f4       	brne	.+48     	; 0xaec <Led_Off+0x40>
     abc:	12 c0       	rjmp	.+36     	; 0xae2 <Led_Off+0x36>
{
case LED_0:
gpioPinWrite(LED_0_GPIO,LED_0_BIT,LOW);
     abe:	81 e0       	ldi	r24, 0x01	; 1
     ac0:	60 e1       	ldi	r22, 0x10	; 16
     ac2:	40 e0       	ldi	r20, 0x00	; 0
     ac4:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     ac8:	08 95       	ret

case LED_1:
gpioPinWrite(LED_1_GPIO,LED_1_BIT,LOW);
     aca:	81 e0       	ldi	r24, 0x01	; 1
     acc:	60 e2       	ldi	r22, 0x20	; 32
     ace:	40 e0       	ldi	r20, 0x00	; 0
     ad0:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     ad4:	08 95       	ret

case LED_2:
gpioPinWrite(LED_2_GPIO,LED_2_BIT,LOW);
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	60 e4       	ldi	r22, 0x40	; 64
     ada:	40 e0       	ldi	r20, 0x00	; 0
     adc:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     ae0:	08 95       	ret

case LED_3:
gpioPinWrite(LED_3_GPIO,LED_3_BIT,LOW);
     ae2:	81 e0       	ldi	r24, 0x01	; 1
     ae4:	60 e8       	ldi	r22, 0x80	; 128
     ae6:	40 e0       	ldi	r20, 0x00	; 0
     ae8:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
     aec:	08 95       	ret

00000aee <Led_Toggle>:


}
void Led_Toggle(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     aee:	81 30       	cpi	r24, 0x01	; 1
     af0:	61 f0       	breq	.+24     	; 0xb0a <Led_Toggle+0x1c>
     af2:	81 30       	cpi	r24, 0x01	; 1
     af4:	28 f0       	brcs	.+10     	; 0xb00 <Led_Toggle+0x12>
     af6:	82 30       	cpi	r24, 0x02	; 2
     af8:	69 f0       	breq	.+26     	; 0xb14 <Led_Toggle+0x26>
     afa:	83 30       	cpi	r24, 0x03	; 3
     afc:	a1 f4       	brne	.+40     	; 0xb26 <Led_Toggle+0x38>
     afe:	0f c0       	rjmp	.+30     	; 0xb1e <Led_Toggle+0x30>
{
case LED_0:
gpioPinToggle(LED_0_GPIO,LED_0_BIT);
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	60 e1       	ldi	r22, 0x10	; 16
     b04:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
break;
     b08:	08 95       	ret

case LED_1:
gpioPinToggle(LED_1_GPIO,LED_1_BIT);
     b0a:	81 e0       	ldi	r24, 0x01	; 1
     b0c:	60 e2       	ldi	r22, 0x20	; 32
     b0e:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
break;
     b12:	08 95       	ret

case LED_2:
gpioPinToggle(LED_2_GPIO,LED_2_BIT);
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	60 e4       	ldi	r22, 0x40	; 64
     b18:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
break;
     b1c:	08 95       	ret

case LED_3:
gpioPinToggle(LED_3_GPIO,LED_3_BIT);
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	60 e8       	ldi	r22, 0x80	; 128
     b22:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
     b26:	08 95       	ret

00000b28 <Motor_Init>:
#include "motor.h"
static uint8_t gsv_is_Started=0;
static uint8_t gsv_is_intialized=0;
ERROR_STATUS Motor_Init(uint8_t Motor_Number)
{uint8_t Ret=0;
    switch(Motor_Number)
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	79 f0       	breq	.+30     	; 0xb4a <Motor_Init+0x22>
     b2c:	83 30       	cpi	r24, 0x03	; 3
     b2e:	c9 f0       	breq	.+50     	; 0xb62 <Motor_Init+0x3a>
     b30:	81 30       	cpi	r24, 0x01	; 1
     b32:	39 f5       	brne	.+78     	; 0xb82 <Motor_Init+0x5a>
    {
        case MOTOR_1:
        /*Enable PWM Bit...output*/
        /*IN1*/
        /*IN2*/
			gsv_is_intialized=MOTOR_1;
     b34:	80 93 fa 00 	sts	0x00FA, r24
			Ret=Pwm_Init(&PWM_Configuration_1A);
     b38:	82 ed       	ldi	r24, 0xD2	; 210
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
			Ret=DIO_init(&Motorone);
     b40:	88 e7       	ldi	r24, 0x78	; 120
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>

			  break;
     b48:	08 95       	ret

          case MOTOR_2:
				gsv_is_intialized=MOTOR_2;
     b4a:	82 e0       	ldi	r24, 0x02	; 2
     b4c:	80 93 fa 00 	sts	0x00FA, r24
				Ret=Pwm_Init(&PWM_Configuration_1B);
     b50:	80 ed       	ldi	r24, 0xD0	; 208
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
				Ret=DIO_init(&Motortwo);
     b58:	85 e7       	ldi	r24, 0x75	; 117
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
				break;
     b60:	08 95       	ret
				/*IN1*/
				/*IN2*/
				/*ENABLE PWM BIT FOR MOTOR 2*/
				/*IN3*/
				/*IN4*/
				gsv_is_intialized=ALL_MOTOR;
     b62:	83 e0       	ldi	r24, 0x03	; 3
     b64:	80 93 fa 00 	sts	0x00FA, r24
			Ret=Pwm_Init(&PWM_Configuration_1A);
     b68:	82 ed       	ldi	r24, 0xD2	; 210
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
			Ret=Pwm_Init(&PWM_Configuration_1B);
     b70:	80 ed       	ldi	r24, 0xD0	; 208
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
			Ret=DIO_init(&ALL_Motor);
     b78:	82 e7       	ldi	r24, 0x72	; 114
     b7a:	90 e0       	ldi	r25, 0x00	; 0
     b7c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
				break;
     b80:	08 95       	ret
			   }
      default:
      Ret=E_NOK;
     b82:	81 e0       	ldi	r24, 0x01	; 1
      break;
    }
return Ret;
}
     b84:	08 95       	ret

00000b86 <Motor_Direction>:

ERROR_STATUS Motor_Direction(uint8_t Motor_Number, uint8_t Motor_Direction)
{uint8_t Ret=0;

  switch(Motor_Number)
     b86:	82 30       	cpi	r24, 0x02	; 2
     b88:	79 f1       	breq	.+94     	; 0xbe8 <Motor_Direction+0x62>
     b8a:	83 30       	cpi	r24, 0x03	; 3
     b8c:	09 f4       	brne	.+2      	; 0xb90 <Motor_Direction+0xa>
     b8e:	55 c0       	rjmp	.+170    	; 0xc3a <Motor_Direction+0xb4>
     b90:	81 30       	cpi	r24, 0x01	; 1
     b92:	09 f0       	breq	.+2      	; 0xb96 <Motor_Direction+0x10>
     b94:	99 c0       	rjmp	.+306    	; 0xcc8 <Motor_Direction+0x142>
  {
  	case MOTOR_1:{
  	switch(Motor_Direction)
     b96:	61 30       	cpi	r22, 0x01	; 1
     b98:	31 f0       	breq	.+12     	; 0xba6 <Motor_Direction+0x20>
     b9a:	61 30       	cpi	r22, 0x01	; 1
     b9c:	d0 f0       	brcs	.+52     	; 0xbd2 <Motor_Direction+0x4c>
     b9e:	62 30       	cpi	r22, 0x02	; 2
     ba0:	09 f0       	breq	.+2      	; 0xba4 <Motor_Direction+0x1e>
     ba2:	94 c0       	rjmp	.+296    	; 0xccc <Motor_Direction+0x146>
     ba4:	0b c0       	rjmp	.+22     	; 0xbbc <Motor_Direction+0x36>
  	{
  		case MOTOR_FORWARD:
  		{
  			Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,HIGH);
     ba6:	83 e0       	ldi	r24, 0x03	; 3
     ba8:	64 e0       	ldi	r22, 0x04	; 4
     baa:	4f ef       	ldi	r20, 0xFF	; 255
     bac:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write (MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     bb0:	83 e0       	ldi	r24, 0x03	; 3
     bb2:	68 e0       	ldi	r22, 0x08	; 8
     bb4:	40 e0       	ldi	r20, 0x00	; 0
     bb6:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  			break;
     bba:	08 95       	ret
  		}
  		case MOTOR_BACKWARD:
  		{
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,HIGH);
     bbc:	83 e0       	ldi	r24, 0x03	; 3
     bbe:	68 e0       	ldi	r22, 0x08	; 8
     bc0:	4f ef       	ldi	r20, 0xFF	; 255
     bc2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
        Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     bc6:	83 e0       	ldi	r24, 0x03	; 3
     bc8:	64 e0       	ldi	r22, 0x04	; 4
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  			break;
     bd0:	08 95       	ret
  		}
  		case MOTOR_STOP:{Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     bd2:	83 e0       	ldi	r24, 0x03	; 3
     bd4:	64 e0       	ldi	r22, 0x04	; 4
     bd6:	40 e0       	ldi	r20, 0x00	; 0
     bd8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     bdc:	83 e0       	ldi	r24, 0x03	; 3
     bde:	68 e0       	ldi	r22, 0x08	; 8
     be0:	40 e0       	ldi	r20, 0x00	; 0
     be2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		break;}
     be6:	08 95       	ret
  	}
  		break;
  	}
  	case MOTOR_2:
  	{
  		switch(Motor_Direction)
     be8:	61 30       	cpi	r22, 0x01	; 1
     bea:	31 f0       	breq	.+12     	; 0xbf8 <Motor_Direction+0x72>
     bec:	61 30       	cpi	r22, 0x01	; 1
     bee:	d0 f0       	brcs	.+52     	; 0xc24 <Motor_Direction+0x9e>
     bf0:	62 30       	cpi	r22, 0x02	; 2
     bf2:	09 f0       	breq	.+2      	; 0xbf6 <Motor_Direction+0x70>
     bf4:	6d c0       	rjmp	.+218    	; 0xcd0 <Motor_Direction+0x14a>
     bf6:	0b c0       	rjmp	.+22     	; 0xc0e <Motor_Direction+0x88>
  		{
  			case MOTOR_FORWARD:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,HIGH);
     bf8:	83 e0       	ldi	r24, 0x03	; 3
     bfa:	60 e8       	ldi	r22, 0x80	; 128
     bfc:	4f ef       	ldi	r20, 0xFF	; 255
     bfe:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
          Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     c02:	83 e0       	ldi	r24, 0x03	; 3
     c04:	60 e4       	ldi	r22, 0x40	; 64
     c06:	40 e0       	ldi	r20, 0x00	; 0
     c08:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  				break;
     c0c:	08 95       	ret
  			}
  			case MOTOR_BACKWARD:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,HIGH);
     c0e:	83 e0       	ldi	r24, 0x03	; 3
     c10:	60 e4       	ldi	r22, 0x40	; 64
     c12:	4f ef       	ldi	r20, 0xFF	; 255
     c14:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     c18:	83 e0       	ldi	r24, 0x03	; 3
     c1a:	60 e8       	ldi	r22, 0x80	; 128
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  				break;
     c22:	08 95       	ret
  			}
  			case MOTOR_STOP:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     c24:	83 e0       	ldi	r24, 0x03	; 3
     c26:	60 e4       	ldi	r22, 0x40	; 64
     c28:	40 e0       	ldi	r20, 0x00	; 0
     c2a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  				Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     c2e:	83 e0       	ldi	r24, 0x03	; 3
     c30:	60 e8       	ldi	r22, 0x80	; 128
     c32:	40 e0       	ldi	r20, 0x00	; 0
     c34:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  				break;
     c38:	08 95       	ret

  		break;
  	}
  	case ALL_MOTOR:
  	{
  switch(Motor_Direction)
     c3a:	61 30       	cpi	r22, 0x01	; 1
     c3c:	31 f0       	breq	.+12     	; 0xc4a <Motor_Direction+0xc4>
     c3e:	61 30       	cpi	r22, 0x01	; 1
     c40:	70 f1       	brcs	.+92     	; 0xc9e <Motor_Direction+0x118>
     c42:	62 30       	cpi	r22, 0x02	; 2
     c44:	09 f0       	breq	.+2      	; 0xc48 <Motor_Direction+0xc2>
     c46:	46 c0       	rjmp	.+140    	; 0xcd4 <Motor_Direction+0x14e>
     c48:	15 c0       	rjmp	.+42     	; 0xc74 <Motor_Direction+0xee>
  {
  	case MOTOR_FORWARD:
  	{
  		Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,HIGH);
     c4a:	83 e0       	ldi	r24, 0x03	; 3
     c4c:	64 e0       	ldi	r22, 0x04	; 4
     c4e:	4f ef       	ldi	r20, 0xFF	; 255
     c50:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     c54:	83 e0       	ldi	r24, 0x03	; 3
     c56:	68 e0       	ldi	r22, 0x08	; 8
     c58:	40 e0       	ldi	r20, 0x00	; 0
     c5a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  	Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     c5e:	83 e0       	ldi	r24, 0x03	; 3
     c60:	60 e4       	ldi	r22, 0x40	; 64
     c62:	40 e0       	ldi	r20, 0x00	; 0
     c64:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,HIGH);
     c68:	83 e0       	ldi	r24, 0x03	; 3
     c6a:	60 e8       	ldi	r22, 0x80	; 128
     c6c:	4f ef       	ldi	r20, 0xFF	; 255
     c6e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  		break;
     c72:	08 95       	ret
  	}
  	case MOTOR_BACKWARD:
  	{

  		Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     c74:	83 e0       	ldi	r24, 0x03	; 3
     c76:	64 e0       	ldi	r22, 0x04	; 4
     c78:	40 e0       	ldi	r20, 0x00	; 0
     c7a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
      Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,HIGH);
     c7e:	83 e0       	ldi	r24, 0x03	; 3
     c80:	68 e0       	ldi	r22, 0x08	; 8
     c82:	4f ef       	ldi	r20, 0xFF	; 255
     c84:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,HIGH);
     c88:	83 e0       	ldi	r24, 0x03	; 3
     c8a:	60 e4       	ldi	r22, 0x40	; 64
     c8c:	4f ef       	ldi	r20, 0xFF	; 255
     c8e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     c92:	83 e0       	ldi	r24, 0x03	; 3
     c94:	60 e8       	ldi	r22, 0x80	; 128
     c96:	40 e0       	ldi	r20, 0x00	; 0
     c98:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  		break;	}
     c9c:	08 95       	ret
  	case MOTOR_STOP:
  	{
  			Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     c9e:	83 e0       	ldi	r24, 0x03	; 3
     ca0:	64 e0       	ldi	r22, 0x04	; 4
     ca2:	40 e0       	ldi	r20, 0x00	; 0
     ca4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     ca8:	83 e0       	ldi	r24, 0x03	; 3
     caa:	60 e4       	ldi	r22, 0x40	; 64
     cac:	40 e0       	ldi	r20, 0x00	; 0
     cae:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  			Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     cb2:	83 e0       	ldi	r24, 0x03	; 3
     cb4:	68 e0       	ldi	r22, 0x08	; 8
     cb6:	40 e0       	ldi	r20, 0x00	; 0
     cb8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     cbc:	83 e0       	ldi	r24, 0x03	; 3
     cbe:	60 e8       	ldi	r22, 0x80	; 128
     cc0:	40 e0       	ldi	r20, 0x00	; 0
     cc2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  		break;
     cc6:	08 95       	ret
    }
return Ret;
}

ERROR_STATUS Motor_Direction(uint8_t Motor_Number, uint8_t Motor_Direction)
{uint8_t Ret=0;
     cc8:	80 e0       	ldi	r24, 0x00	; 0
     cca:	08 95       	ret
     ccc:	80 e0       	ldi	r24, 0x00	; 0
     cce:	08 95       	ret
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	08 95       	ret
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);

  		break;
  	}
    default:
    Ret=E_NOK;
     cd4:	81 e0       	ldi	r24, 0x01	; 1



    }
return Ret;
}
     cd6:	08 95       	ret

00000cd8 <Motor_Start>:


ERROR_STATUS Motor_Start(uint8_t Motor_Number, uint8_t Mot_Speed)
{
  uint8_t Ret=0;
switch (Motor_Number) {
     cd8:	82 30       	cpi	r24, 0x02	; 2
     cda:	69 f0       	breq	.+26     	; 0xcf6 <Motor_Start+0x1e>
     cdc:	83 30       	cpi	r24, 0x03	; 3
     cde:	a9 f0       	breq	.+42     	; 0xd0a <Motor_Start+0x32>
     ce0:	81 30       	cpi	r24, 0x01	; 1
     ce2:	f1 f4       	brne	.+60     	; 0xd20 <Motor_Start+0x48>
  case MOTOR_1:
  {gsv_is_Started=MOTOR_1;
     ce4:	80 93 fb 00 	sts	0x00FB, r24
    Ret=Pwm_Start(PWM_CH1A,Mot_Speed,30);
     ce8:	2e e1       	ldi	r18, 0x1E	; 30
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	40 e0       	ldi	r20, 0x00	; 0
     cee:	50 e0       	ldi	r21, 0x00	; 0
     cf0:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
    break;
     cf4:	08 95       	ret
  }
  case MOTOR_2:
  {
    gsv_is_Started=MOTOR_2;
     cf6:	82 e0       	ldi	r24, 0x02	; 2
     cf8:	80 93 fb 00 	sts	0x00FB, r24
    Ret=Pwm_Start(PWM_CH1B,Mot_Speed,30);
     cfc:	2e e1       	ldi	r18, 0x1E	; 30
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	40 e0       	ldi	r20, 0x00	; 0
     d02:	50 e0       	ldi	r21, 0x00	; 0
     d04:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
    break;
     d08:	08 95       	ret
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    gsv_is_Started=MOTOR_1 | MOTOR_2;
     d0a:	83 e0       	ldi	r24, 0x03	; 3
     d0c:	80 93 fb 00 	sts	0x00FB, r24
    Ret=Pwm_Start(PWM_CH1B,Mot_Speed,30);
     d10:	82 e0       	ldi	r24, 0x02	; 2
     d12:	2e e1       	ldi	r18, 0x1E	; 30
     d14:	30 e0       	ldi	r19, 0x00	; 0
     d16:	40 e0       	ldi	r20, 0x00	; 0
     d18:	50 e0       	ldi	r21, 0x00	; 0
     d1a:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
    break;
     d1e:	08 95       	ret
  }
  default:
  Ret=E_NOK;
     d20:	81 e0       	ldi	r24, 0x01	; 1
  break;
}


return Ret;
}
     d22:	08 95       	ret

00000d24 <Motor_SpeedUpdate>:
ERROR_STATUS Motor_SpeedUpdate(uint8_t Motor_Number, uint8_t Speed)
{
  uint8_t Ret=0;

switch (Motor_Number) {
     d24:	82 30       	cpi	r24, 0x02	; 2
     d26:	79 f0       	breq	.+30     	; 0xd46 <Motor_SpeedUpdate+0x22>
     d28:	83 30       	cpi	r24, 0x03	; 3
     d2a:	c1 f0       	breq	.+48     	; 0xd5c <Motor_SpeedUpdate+0x38>
     d2c:	81 30       	cpi	r24, 0x01	; 1
     d2e:	11 f5       	brne	.+68     	; 0xd74 <Motor_SpeedUpdate+0x50>
  case MOTOR_1:
  { if(gsv_is_intialized == Motor_Number)
     d30:	80 91 fa 00 	lds	r24, 0x00FA
     d34:	81 30       	cpi	r24, 0x01	; 1
     d36:	01 f5       	brne	.+64     	; 0xd78 <Motor_SpeedUpdate+0x54>
    Ret=Pwm_Start(PWM_CH1A,Speed,30);
     d38:	2e e1       	ldi	r18, 0x1E	; 30
     d3a:	30 e0       	ldi	r19, 0x00	; 0
     d3c:	40 e0       	ldi	r20, 0x00	; 0
     d3e:	50 e0       	ldi	r21, 0x00	; 0
     d40:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
     d44:	08 95       	ret
    else{Ret=E_NOK;}
    break;
  }
  case MOTOR_2:
  {
    if(gsv_is_intialized == Motor_Number)
     d46:	80 91 fa 00 	lds	r24, 0x00FA
     d4a:	82 30       	cpi	r24, 0x02	; 2
     d4c:	b9 f4       	brne	.+46     	; 0xd7c <Motor_SpeedUpdate+0x58>
      Ret=Pwm_Start(PWM_CH1B,Speed,30);
     d4e:	2e e1       	ldi	r18, 0x1E	; 30
     d50:	30 e0       	ldi	r19, 0x00	; 0
     d52:	40 e0       	ldi	r20, 0x00	; 0
     d54:	50 e0       	ldi	r21, 0x00	; 0
     d56:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
     d5a:	08 95       	ret
      else{Ret=E_NOK;}
    break;
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    if(gsv_is_intialized == Motor_Number)
     d5c:	80 91 fa 00 	lds	r24, 0x00FA
     d60:	83 30       	cpi	r24, 0x03	; 3
     d62:	71 f4       	brne	.+28     	; 0xd80 <Motor_SpeedUpdate+0x5c>
        Ret=Pwm_Start(PWM_CH1B,Speed,30);
     d64:	82 e0       	ldi	r24, 0x02	; 2
     d66:	2e e1       	ldi	r18, 0x1E	; 30
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	40 e0       	ldi	r20, 0x00	; 0
     d6c:	50 e0       	ldi	r21, 0x00	; 0
     d6e:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
     d72:	08 95       	ret
        else{Ret=E_NOK;}
    break;
  }
  default:
  Ret=E_NOK;
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	08 95       	ret

switch (Motor_Number) {
  case MOTOR_1:
  { if(gsv_is_intialized == Motor_Number)
    Ret=Pwm_Start(PWM_CH1A,Speed,30);
    else{Ret=E_NOK;}
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	08 95       	ret
  }
  case MOTOR_2:
  {
    if(gsv_is_intialized == Motor_Number)
      Ret=Pwm_Start(PWM_CH1B,Speed,30);
      else{Ret=E_NOK;}
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	08 95       	ret
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    if(gsv_is_intialized == Motor_Number)
        Ret=Pwm_Start(PWM_CH1B,Speed,30);
        else{Ret=E_NOK;}
     d80:	81 e0       	ldi	r24, 0x01	; 1
  Ret=E_NOK;
  break;
}

return Ret;
}
     d82:	08 95       	ret

00000d84 <Motor_Stop>:

ERROR_STATUS Motor_Stop(uint8_t Motor_Number)
{
	uint8_t Ret=0;
	switch(Motor_Number)
     d84:	81 30       	cpi	r24, 0x01	; 1
     d86:	19 f0       	breq	.+6      	; 0xd8e <Motor_Stop+0xa>
     d88:	82 30       	cpi	r24, 0x02	; 2
     d8a:	49 f4       	brne	.+18     	; 0xd9e <Motor_Stop+0x1a>
     d8c:	04 c0       	rjmp	.+8      	; 0xd96 <Motor_Stop+0x12>
	{
		case MOTOR_1 :
		Ret=Pwm_Stop(PWM_CH1A);
     d8e:	81 e0       	ldi	r24, 0x01	; 1
     d90:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <Pwm_Stop>
		break;
     d94:	08 95       	ret
		case MOTOR_2:
		Ret=Pwm_Stop(PWM_CH1B);
     d96:	82 e0       	ldi	r24, 0x02	; 2
     d98:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <Pwm_Stop>
		break;
     d9c:	08 95       	ret
		default:
		Ret=E_NOK;
     d9e:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}


	return Ret;
}
     da0:	08 95       	ret

00000da2 <Motor_GetStatus>:

 ERROR_STATUS Motor_GetStatus(uint8_t Motor_Number, uint8_t* Mot_status)
 {
	 if(gsv_is_intialized == Motor_Number)
     da2:	90 91 fa 00 	lds	r25, 0x00FA
     da6:	98 17       	cp	r25, r24
     da8:	21 f4       	brne	.+8      	; 0xdb2 <Motor_GetStatus+0x10>
		*Mot_status=1;
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	fb 01       	movw	r30, r22
     dae:	80 83       	st	Z, r24
     db0:	08 95       	ret
	 else
	 {
		*Mot_status=0;
     db2:	fb 01       	movw	r30, r22
     db4:	10 82       	st	Z, r1
	 }
	 
 }
     db6:	08 95       	ret

00000db8 <SwDelay_ms>:
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     db8:	dc 01       	movw	r26, r24
     dba:	cb 01       	movw	r24, r22
	uint8_t counter_256;
	uint8_t counter_21;
	while (n)
     dbc:	00 97       	sbiw	r24, 0x00	; 0
     dbe:	a1 05       	cpc	r26, r1
     dc0:	b1 05       	cpc	r27, r1
     dc2:	61 f4       	brne	.+24     	; 0xddc <SwDelay_ms+0x24>
     dc4:	08 95       	ret
     dc6:	21 50       	subi	r18, 0x01	; 1
		counter_21 = 21;
		while (counter_21)
		{
			/* every 256 branch costs 48 micro seconds */
			counter_256 = 255;
			while (counter_256)
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <SwDelay_ms+0xe>
     dca:	31 50       	subi	r19, 0x01	; 1
	uint8_t counter_21;
	while (n)
	{
		/* every 21 repetition of the 256 branches costs almost 1 milli second as: 48 micro x 21 = 1.008 milli second*/
		counter_21 = 21;
		while (counter_21)
     dcc:	11 f0       	breq	.+4      	; 0xdd2 <SwDelay_ms+0x1a>
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     dce:	24 2f       	mov	r18, r20
     dd0:	fa cf       	rjmp	.-12     	; 0xdc6 <SwDelay_ms+0xe>
			{
				counter_256--;
			}
			counter_21--;
		}
		n--;
     dd2:	01 97       	sbiw	r24, 0x01	; 1
     dd4:	a1 09       	sbc	r26, r1
     dd6:	b1 09       	sbc	r27, r1
 */
void SwDelay_ms(uint32_t n)
{
	uint8_t counter_256;
	uint8_t counter_21;
	while (n)
     dd8:	19 f4       	brne	.+6      	; 0xde0 <SwDelay_ms+0x28>
     dda:	08 95       	ret
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     ddc:	55 e1       	ldi	r21, 0x15	; 21
     dde:	4f ef       	ldi	r20, 0xFF	; 255
     de0:	35 2f       	mov	r19, r21
     de2:	f5 cf       	rjmp	.-22     	; 0xdce <SwDelay_ms+0x16>

00000de4 <SwDelay_us>:
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32_t n)
{
     de4:	dc 01       	movw	r26, r24
     de6:	cb 01       	movw	r24, r22
	while (n)
     de8:	00 97       	sbiw	r24, 0x00	; 0
     dea:	a1 05       	cpc	r26, r1
     dec:	b1 05       	cpc	r27, r1
     dee:	21 f0       	breq	.+8      	; 0xdf8 <SwDelay_us+0x14>
	{
		n--;
     df0:	01 97       	sbiw	r24, 0x01	; 1
     df2:	a1 09       	sbc	r26, r1
     df4:	b1 09       	sbc	r27, r1
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32_t n)
{
	while (n)
     df6:	e1 f7       	brne	.-8      	; 0xdf0 <SwDelay_us+0xc>
     df8:	08 95       	ret

00000dfa <Us_Init>:
 *                                                                                                  *
 ***************************************************************************************************/

ERROR_STATUS Us_Init(void)
{uint8_t Ret;
Ret=DIO_init(&US_Configuration);
     dfa:	8b e7       	ldi	r24, 0x7B	; 123
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
Ret=Icu_Init(&ICU_Configuration);
     e02:	8a ec       	ldi	r24, 0xCA	; 202
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	0e 94 37 0c 	call	0x186e	; 0x186e <Icu_Init>
return Ret;
}
     e0a:	08 95       	ret

00000e0c <Us_Trigger>:
ERROR_STATUS Us_Trigger(void)
{uint8_t Ret=0;
Ret=DIO_Write(GPIOC,BIT4,HIGH);
     e0c:	82 e0       	ldi	r24, 0x02	; 2
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	60 e1       	ldi	r22, 0x10	; 16
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	4f ef       	ldi	r20, 0xFF	; 255
     e16:	50 e0       	ldi	r21, 0x00	; 0
     e18:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/***********************************************/
Timer_Start(TIMER_CH0,10);
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	6a e0       	ldi	r22, 0x0A	; 10
     e20:	70 e0       	ldi	r23, 0x00	; 0
     e22:	0e 94 94 10 	call	0x2128	; 0x2128 <Timer_Start>
/**********************************************/
Ret=DIO_Write(GPIOC,BIT4,LOW);
     e26:	82 e0       	ldi	r24, 0x02	; 2
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	60 e1       	ldi	r22, 0x10	; 16
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	40 e0       	ldi	r20, 0x00	; 0
     e30:	50 e0       	ldi	r21, 0x00	; 0
     e32:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
return Ret;	
}
     e36:	08 95       	ret

00000e38 <Us_GetDistance>:


ERROR_STATUS Us_GetDistance(uint16_t *Distance)
{uint8_t Ret=0;
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
     e40:	00 d0       	rcall	.+0      	; 0xe42 <Us_GetDistance+0xa>
     e42:	00 d0       	rcall	.+0      	; 0xe44 <Us_GetDistance+0xc>
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	8c 01       	movw	r16, r24
	uint32_t u32l_Time;
	Ret=Icu_ReadTime(ICU_CH2,ICU_RISE_TO_FALL,&u32l_Time);
     e4a:	82 e0       	ldi	r24, 0x02	; 2
     e4c:	61 e0       	ldi	r22, 0x01	; 1
     e4e:	ae 01       	movw	r20, r28
     e50:	4f 5f       	subi	r20, 0xFF	; 255
     e52:	5f 4f       	sbci	r21, 0xFF	; 255
     e54:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <Icu_ReadTime>
	*Distance=u32l_Time;
     e58:	29 81       	ldd	r18, Y+1	; 0x01
     e5a:	3a 81       	ldd	r19, Y+2	; 0x02
     e5c:	f8 01       	movw	r30, r16
     e5e:	31 83       	std	Z+1, r19	; 0x01
     e60:	20 83       	st	Z, r18
	return Ret;
}
     e62:	0f 90       	pop	r0
     e64:	0f 90       	pop	r0
     e66:	0f 90       	pop	r0
     e68:	0f 90       	pop	r0
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	1f 91       	pop	r17
     e70:	0f 91       	pop	r16
     e72:	08 95       	ret

00000e74 <G_interrupt_Enable>:
ptr_to_Fun TWI_I2C;
ptr_to_Fun SPM_RDY;

void G_interrupt_Enable(void)
{
 SREG |=(0x80);
     e74:	8f b7       	in	r24, 0x3f	; 63
     e76:	80 68       	ori	r24, 0x80	; 128
     e78:	8f bf       	out	0x3f, r24	; 63
}
     e7a:	08 95       	ret

00000e7c <EX_interrupt_enable2>:
void EX_interrupt_enable2(void)
{
CLEAR_BIT(PORTB_DIR,2);/*Input*/
     e7c:	ba 98       	cbi	0x17, 2	; 23
SET_BIT(PORTB_DATA,2);/*Pullup*/
     e7e:	c2 9a       	sbi	0x18, 2	; 24
SET_BIT(GICR,INT2);/*EXT2*/
     e80:	8b b7       	in	r24, 0x3b	; 59
     e82:	80 62       	ori	r24, 0x20	; 32
     e84:	8b bf       	out	0x3b, r24	; 59
SET_BIT(MCUCSR,6);/*Rising*/
     e86:	84 b7       	in	r24, 0x34	; 52
     e88:	80 64       	ori	r24, 0x40	; 64
     e8a:	84 bf       	out	0x34, r24	; 52
}
     e8c:	08 95       	ret

00000e8e <EX_interrupt_enable1>:
void EX_interrupt_enable1(void)
{
	CLEAR_BIT(PORTD_DIR,3);
     e8e:	8b 98       	cbi	0x11, 3	; 17
	SET_BIT(PORTD_DATA,3);
     e90:	93 9a       	sbi	0x12, 3	; 18
	SET_BIT(GICR,INT1);
     e92:	8b b7       	in	r24, 0x3b	; 59
     e94:	80 68       	ori	r24, 0x80	; 128
     e96:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(MCUCR,2);/*Any logical change*/
     e98:	85 b7       	in	r24, 0x35	; 53
     e9a:	84 60       	ori	r24, 0x04	; 4
     e9c:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR,3);
     e9e:	85 b7       	in	r24, 0x35	; 53
     ea0:	87 7f       	andi	r24, 0xF7	; 247
     ea2:	85 bf       	out	0x35, r24	; 53
}
     ea4:	08 95       	ret

00000ea6 <EX_interrupt_enable0>:
void EX_interrupt_enable0(void)
{
	CLEAR_BIT(PORTD_DIR,2);
     ea6:	8a 98       	cbi	0x11, 2	; 17
	SET_BIT(PORTD_DATA,2);
     ea8:	92 9a       	sbi	0x12, 2	; 18
	SET_BIT(GICR,INT0);
     eaa:	8b b7       	in	r24, 0x3b	; 59
     eac:	80 64       	ori	r24, 0x40	; 64
     eae:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(MCUCR,0);/*Any logical change*/
     eb0:	85 b7       	in	r24, 0x35	; 53
     eb2:	81 60       	ori	r24, 0x01	; 1
     eb4:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR,1);
     eb6:	85 b7       	in	r24, 0x35	; 53
     eb8:	8d 7f       	andi	r24, 0xFD	; 253
     eba:	85 bf       	out	0x35, r24	; 53
	
}
     ebc:	08 95       	ret

00000ebe <G_interrupt_Disable>:
void G_interrupt_Disable(void)
{
CLEAR_BIT(SREG,7);
     ebe:	8f b7       	in	r24, 0x3f	; 63
     ec0:	8f 77       	andi	r24, 0x7F	; 127
     ec2:	8f bf       	out	0x3f, r24	; 63
}
     ec4:	08 95       	ret

00000ec6 <__vector_1>:
void __vector_1(void) __attribute__((signal));
void __vector_1(void)
{
     ec6:	1f 92       	push	r1
     ec8:	0f 92       	push	r0
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	0f 92       	push	r0
     ece:	11 24       	eor	r1, r1
     ed0:	2f 93       	push	r18
     ed2:	3f 93       	push	r19
     ed4:	4f 93       	push	r20
     ed6:	5f 93       	push	r21
     ed8:	6f 93       	push	r22
     eda:	7f 93       	push	r23
     edc:	8f 93       	push	r24
     ede:	9f 93       	push	r25
     ee0:	af 93       	push	r26
     ee2:	bf 93       	push	r27
     ee4:	ef 93       	push	r30
     ee6:	ff 93       	push	r31
  INT0_external_interrupt();
     ee8:	e0 91 8d 05 	lds	r30, 0x058D
     eec:	f0 91 8e 05 	lds	r31, 0x058E
     ef0:	09 95       	icall
}
     ef2:	ff 91       	pop	r31
     ef4:	ef 91       	pop	r30
     ef6:	bf 91       	pop	r27
     ef8:	af 91       	pop	r26
     efa:	9f 91       	pop	r25
     efc:	8f 91       	pop	r24
     efe:	7f 91       	pop	r23
     f00:	6f 91       	pop	r22
     f02:	5f 91       	pop	r21
     f04:	4f 91       	pop	r20
     f06:	3f 91       	pop	r19
     f08:	2f 91       	pop	r18
     f0a:	0f 90       	pop	r0
     f0c:	0f be       	out	0x3f, r0	; 63
     f0e:	0f 90       	pop	r0
     f10:	1f 90       	pop	r1
     f12:	18 95       	reti

00000f14 <__vector_2>:


void __vector_2(void) __attribute__((signal));
void __vector_2(void)
{
     f14:	1f 92       	push	r1
     f16:	0f 92       	push	r0
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	0f 92       	push	r0
     f1c:	11 24       	eor	r1, r1
     f1e:	2f 93       	push	r18
     f20:	3f 93       	push	r19
     f22:	4f 93       	push	r20
     f24:	5f 93       	push	r21
     f26:	6f 93       	push	r22
     f28:	7f 93       	push	r23
     f2a:	8f 93       	push	r24
     f2c:	9f 93       	push	r25
     f2e:	af 93       	push	r26
     f30:	bf 93       	push	r27
     f32:	ef 93       	push	r30
     f34:	ff 93       	push	r31
  INT1_external_interrupt();
     f36:	e0 91 95 05 	lds	r30, 0x0595
     f3a:	f0 91 96 05 	lds	r31, 0x0596
     f3e:	09 95       	icall
}
     f40:	ff 91       	pop	r31
     f42:	ef 91       	pop	r30
     f44:	bf 91       	pop	r27
     f46:	af 91       	pop	r26
     f48:	9f 91       	pop	r25
     f4a:	8f 91       	pop	r24
     f4c:	7f 91       	pop	r23
     f4e:	6f 91       	pop	r22
     f50:	5f 91       	pop	r21
     f52:	4f 91       	pop	r20
     f54:	3f 91       	pop	r19
     f56:	2f 91       	pop	r18
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	0f 90       	pop	r0
     f5e:	1f 90       	pop	r1
     f60:	18 95       	reti

00000f62 <__vector_3>:


void __vector_3(void) __attribute__((signal));
void __vector_3(void)
{
     f62:	1f 92       	push	r1
     f64:	0f 92       	push	r0
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	0f 92       	push	r0
     f6a:	11 24       	eor	r1, r1
     f6c:	2f 93       	push	r18
     f6e:	3f 93       	push	r19
     f70:	4f 93       	push	r20
     f72:	5f 93       	push	r21
     f74:	6f 93       	push	r22
     f76:	7f 93       	push	r23
     f78:	8f 93       	push	r24
     f7a:	9f 93       	push	r25
     f7c:	af 93       	push	r26
     f7e:	bf 93       	push	r27
     f80:	ef 93       	push	r30
     f82:	ff 93       	push	r31
  INT2_external_interrupt();
     f84:	e0 91 85 05 	lds	r30, 0x0585
     f88:	f0 91 86 05 	lds	r31, 0x0586
     f8c:	09 95       	icall
}
     f8e:	ff 91       	pop	r31
     f90:	ef 91       	pop	r30
     f92:	bf 91       	pop	r27
     f94:	af 91       	pop	r26
     f96:	9f 91       	pop	r25
     f98:	8f 91       	pop	r24
     f9a:	7f 91       	pop	r23
     f9c:	6f 91       	pop	r22
     f9e:	5f 91       	pop	r21
     fa0:	4f 91       	pop	r20
     fa2:	3f 91       	pop	r19
     fa4:	2f 91       	pop	r18
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63
     faa:	0f 90       	pop	r0
     fac:	1f 90       	pop	r1
     fae:	18 95       	reti

00000fb0 <__vector_4>:


void __vector_4(void) __attribute__((signal));
void __vector_4(void)
{
     fb0:	1f 92       	push	r1
     fb2:	0f 92       	push	r0
     fb4:	0f b6       	in	r0, 0x3f	; 63
     fb6:	0f 92       	push	r0
     fb8:	11 24       	eor	r1, r1
     fba:	2f 93       	push	r18
     fbc:	3f 93       	push	r19
     fbe:	4f 93       	push	r20
     fc0:	5f 93       	push	r21
     fc2:	6f 93       	push	r22
     fc4:	7f 93       	push	r23
     fc6:	8f 93       	push	r24
     fc8:	9f 93       	push	r25
     fca:	af 93       	push	r26
     fcc:	bf 93       	push	r27
     fce:	ef 93       	push	r30
     fd0:	ff 93       	push	r31
TIMER2COMP();
     fd2:	e0 91 9b 05 	lds	r30, 0x059B
     fd6:	f0 91 9c 05 	lds	r31, 0x059C
     fda:	09 95       	icall
}
     fdc:	ff 91       	pop	r31
     fde:	ef 91       	pop	r30
     fe0:	bf 91       	pop	r27
     fe2:	af 91       	pop	r26
     fe4:	9f 91       	pop	r25
     fe6:	8f 91       	pop	r24
     fe8:	7f 91       	pop	r23
     fea:	6f 91       	pop	r22
     fec:	5f 91       	pop	r21
     fee:	4f 91       	pop	r20
     ff0:	3f 91       	pop	r19
     ff2:	2f 91       	pop	r18
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	0f 90       	pop	r0
     ffa:	1f 90       	pop	r1
     ffc:	18 95       	reti

00000ffe <__vector_5>:


void __vector_5(void) __attribute__((signal));
void __vector_5(void)
{
     ffe:	1f 92       	push	r1
    1000:	0f 92       	push	r0
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	0f 92       	push	r0
    1006:	11 24       	eor	r1, r1
    1008:	2f 93       	push	r18
    100a:	3f 93       	push	r19
    100c:	4f 93       	push	r20
    100e:	5f 93       	push	r21
    1010:	6f 93       	push	r22
    1012:	7f 93       	push	r23
    1014:	8f 93       	push	r24
    1016:	9f 93       	push	r25
    1018:	af 93       	push	r26
    101a:	bf 93       	push	r27
    101c:	ef 93       	push	r30
    101e:	ff 93       	push	r31
  TIMER2OVF();
    1020:	e0 91 7b 05 	lds	r30, 0x057B
    1024:	f0 91 7c 05 	lds	r31, 0x057C
    1028:	09 95       	icall
}
    102a:	ff 91       	pop	r31
    102c:	ef 91       	pop	r30
    102e:	bf 91       	pop	r27
    1030:	af 91       	pop	r26
    1032:	9f 91       	pop	r25
    1034:	8f 91       	pop	r24
    1036:	7f 91       	pop	r23
    1038:	6f 91       	pop	r22
    103a:	5f 91       	pop	r21
    103c:	4f 91       	pop	r20
    103e:	3f 91       	pop	r19
    1040:	2f 91       	pop	r18
    1042:	0f 90       	pop	r0
    1044:	0f be       	out	0x3f, r0	; 63
    1046:	0f 90       	pop	r0
    1048:	1f 90       	pop	r1
    104a:	18 95       	reti

0000104c <__vector_6>:

void __vector_6(void) __attribute__((signal));
void __vector_6(void)
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	11 24       	eor	r1, r1
    1056:	2f 93       	push	r18
    1058:	3f 93       	push	r19
    105a:	4f 93       	push	r20
    105c:	5f 93       	push	r21
    105e:	6f 93       	push	r22
    1060:	7f 93       	push	r23
    1062:	8f 93       	push	r24
    1064:	9f 93       	push	r25
    1066:	af 93       	push	r26
    1068:	bf 93       	push	r27
    106a:	ef 93       	push	r30
    106c:	ff 93       	push	r31
  TIMER1CAPT();
    106e:	e0 91 97 05 	lds	r30, 0x0597
    1072:	f0 91 98 05 	lds	r31, 0x0598
    1076:	09 95       	icall
}
    1078:	ff 91       	pop	r31
    107a:	ef 91       	pop	r30
    107c:	bf 91       	pop	r27
    107e:	af 91       	pop	r26
    1080:	9f 91       	pop	r25
    1082:	8f 91       	pop	r24
    1084:	7f 91       	pop	r23
    1086:	6f 91       	pop	r22
    1088:	5f 91       	pop	r21
    108a:	4f 91       	pop	r20
    108c:	3f 91       	pop	r19
    108e:	2f 91       	pop	r18
    1090:	0f 90       	pop	r0
    1092:	0f be       	out	0x3f, r0	; 63
    1094:	0f 90       	pop	r0
    1096:	1f 90       	pop	r1
    1098:	18 95       	reti

0000109a <__vector_7>:

void __vector_7(void) __attribute__((signal));
void __vector_7(void)
{
    109a:	1f 92       	push	r1
    109c:	0f 92       	push	r0
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	0f 92       	push	r0
    10a2:	11 24       	eor	r1, r1
    10a4:	2f 93       	push	r18
    10a6:	3f 93       	push	r19
    10a8:	4f 93       	push	r20
    10aa:	5f 93       	push	r21
    10ac:	6f 93       	push	r22
    10ae:	7f 93       	push	r23
    10b0:	8f 93       	push	r24
    10b2:	9f 93       	push	r25
    10b4:	af 93       	push	r26
    10b6:	bf 93       	push	r27
    10b8:	ef 93       	push	r30
    10ba:	ff 93       	push	r31
TIMER1COMPA();
    10bc:	e0 91 81 05 	lds	r30, 0x0581
    10c0:	f0 91 82 05 	lds	r31, 0x0582
    10c4:	09 95       	icall
}
    10c6:	ff 91       	pop	r31
    10c8:	ef 91       	pop	r30
    10ca:	bf 91       	pop	r27
    10cc:	af 91       	pop	r26
    10ce:	9f 91       	pop	r25
    10d0:	8f 91       	pop	r24
    10d2:	7f 91       	pop	r23
    10d4:	6f 91       	pop	r22
    10d6:	5f 91       	pop	r21
    10d8:	4f 91       	pop	r20
    10da:	3f 91       	pop	r19
    10dc:	2f 91       	pop	r18
    10de:	0f 90       	pop	r0
    10e0:	0f be       	out	0x3f, r0	; 63
    10e2:	0f 90       	pop	r0
    10e4:	1f 90       	pop	r1
    10e6:	18 95       	reti

000010e8 <__vector_8>:

void __vector_8(void) __attribute__((signal));
void __vector_8(void)
{
    10e8:	1f 92       	push	r1
    10ea:	0f 92       	push	r0
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	0f 92       	push	r0
    10f0:	11 24       	eor	r1, r1
    10f2:	2f 93       	push	r18
    10f4:	3f 93       	push	r19
    10f6:	4f 93       	push	r20
    10f8:	5f 93       	push	r21
    10fa:	6f 93       	push	r22
    10fc:	7f 93       	push	r23
    10fe:	8f 93       	push	r24
    1100:	9f 93       	push	r25
    1102:	af 93       	push	r26
    1104:	bf 93       	push	r27
    1106:	ef 93       	push	r30
    1108:	ff 93       	push	r31
  TIMER1COMPB();
    110a:	e0 91 7f 05 	lds	r30, 0x057F
    110e:	f0 91 80 05 	lds	r31, 0x0580
    1112:	09 95       	icall
}
    1114:	ff 91       	pop	r31
    1116:	ef 91       	pop	r30
    1118:	bf 91       	pop	r27
    111a:	af 91       	pop	r26
    111c:	9f 91       	pop	r25
    111e:	8f 91       	pop	r24
    1120:	7f 91       	pop	r23
    1122:	6f 91       	pop	r22
    1124:	5f 91       	pop	r21
    1126:	4f 91       	pop	r20
    1128:	3f 91       	pop	r19
    112a:	2f 91       	pop	r18
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	0f 90       	pop	r0
    1132:	1f 90       	pop	r1
    1134:	18 95       	reti

00001136 <__vector_9>:

void __vector_9(void) __attribute__((signal));
void __vector_9(void)
{
    1136:	1f 92       	push	r1
    1138:	0f 92       	push	r0
    113a:	0f b6       	in	r0, 0x3f	; 63
    113c:	0f 92       	push	r0
    113e:	11 24       	eor	r1, r1
    1140:	2f 93       	push	r18
    1142:	3f 93       	push	r19
    1144:	4f 93       	push	r20
    1146:	5f 93       	push	r21
    1148:	6f 93       	push	r22
    114a:	7f 93       	push	r23
    114c:	8f 93       	push	r24
    114e:	9f 93       	push	r25
    1150:	af 93       	push	r26
    1152:	bf 93       	push	r27
    1154:	ef 93       	push	r30
    1156:	ff 93       	push	r31
  TIMER1OVF();
    1158:	e0 91 99 05 	lds	r30, 0x0599
    115c:	f0 91 9a 05 	lds	r31, 0x059A
    1160:	09 95       	icall
}
    1162:	ff 91       	pop	r31
    1164:	ef 91       	pop	r30
    1166:	bf 91       	pop	r27
    1168:	af 91       	pop	r26
    116a:	9f 91       	pop	r25
    116c:	8f 91       	pop	r24
    116e:	7f 91       	pop	r23
    1170:	6f 91       	pop	r22
    1172:	5f 91       	pop	r21
    1174:	4f 91       	pop	r20
    1176:	3f 91       	pop	r19
    1178:	2f 91       	pop	r18
    117a:	0f 90       	pop	r0
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	0f 90       	pop	r0
    1180:	1f 90       	pop	r1
    1182:	18 95       	reti

00001184 <__vector_10>:

void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
    1184:	1f 92       	push	r1
    1186:	0f 92       	push	r0
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	0f 92       	push	r0
    118c:	11 24       	eor	r1, r1
    118e:	2f 93       	push	r18
    1190:	3f 93       	push	r19
    1192:	4f 93       	push	r20
    1194:	5f 93       	push	r21
    1196:	6f 93       	push	r22
    1198:	7f 93       	push	r23
    119a:	8f 93       	push	r24
    119c:	9f 93       	push	r25
    119e:	af 93       	push	r26
    11a0:	bf 93       	push	r27
    11a2:	ef 93       	push	r30
    11a4:	ff 93       	push	r31

  TIMER0COMP();
    11a6:	e0 91 91 05 	lds	r30, 0x0591
    11aa:	f0 91 92 05 	lds	r31, 0x0592
    11ae:	09 95       	icall
}
    11b0:	ff 91       	pop	r31
    11b2:	ef 91       	pop	r30
    11b4:	bf 91       	pop	r27
    11b6:	af 91       	pop	r26
    11b8:	9f 91       	pop	r25
    11ba:	8f 91       	pop	r24
    11bc:	7f 91       	pop	r23
    11be:	6f 91       	pop	r22
    11c0:	5f 91       	pop	r21
    11c2:	4f 91       	pop	r20
    11c4:	3f 91       	pop	r19
    11c6:	2f 91       	pop	r18
    11c8:	0f 90       	pop	r0
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	0f 90       	pop	r0
    11ce:	1f 90       	pop	r1
    11d0:	18 95       	reti

000011d2 <__vector_11>:

void __vector_11(void) __attribute__((signal));
void __vector_11(void)
{
    11d2:	1f 92       	push	r1
    11d4:	0f 92       	push	r0
    11d6:	0f b6       	in	r0, 0x3f	; 63
    11d8:	0f 92       	push	r0
    11da:	11 24       	eor	r1, r1
    11dc:	2f 93       	push	r18
    11de:	3f 93       	push	r19
    11e0:	4f 93       	push	r20
    11e2:	5f 93       	push	r21
    11e4:	6f 93       	push	r22
    11e6:	7f 93       	push	r23
    11e8:	8f 93       	push	r24
    11ea:	9f 93       	push	r25
    11ec:	af 93       	push	r26
    11ee:	bf 93       	push	r27
    11f0:	ef 93       	push	r30
    11f2:	ff 93       	push	r31

  TIMER0OVF_INT();
    11f4:	e0 91 7e 00 	lds	r30, 0x007E
    11f8:	f0 91 7f 00 	lds	r31, 0x007F
    11fc:	09 95       	icall
}
    11fe:	ff 91       	pop	r31
    1200:	ef 91       	pop	r30
    1202:	bf 91       	pop	r27
    1204:	af 91       	pop	r26
    1206:	9f 91       	pop	r25
    1208:	8f 91       	pop	r24
    120a:	7f 91       	pop	r23
    120c:	6f 91       	pop	r22
    120e:	5f 91       	pop	r21
    1210:	4f 91       	pop	r20
    1212:	3f 91       	pop	r19
    1214:	2f 91       	pop	r18
    1216:	0f 90       	pop	r0
    1218:	0f be       	out	0x3f, r0	; 63
    121a:	0f 90       	pop	r0
    121c:	1f 90       	pop	r1
    121e:	18 95       	reti

00001220 <__vector_12>:

void __vector_12(void) __attribute__((signal));
void __vector_12(void)
{
    1220:	1f 92       	push	r1
    1222:	0f 92       	push	r0
    1224:	0f b6       	in	r0, 0x3f	; 63
    1226:	0f 92       	push	r0
    1228:	11 24       	eor	r1, r1
    122a:	2f 93       	push	r18
    122c:	3f 93       	push	r19
    122e:	4f 93       	push	r20
    1230:	5f 93       	push	r21
    1232:	6f 93       	push	r22
    1234:	7f 93       	push	r23
    1236:	8f 93       	push	r24
    1238:	9f 93       	push	r25
    123a:	af 93       	push	r26
    123c:	bf 93       	push	r27
    123e:	ef 93       	push	r30
    1240:	ff 93       	push	r31
  SPI_STC();
    1242:	e0 91 83 05 	lds	r30, 0x0583
    1246:	f0 91 84 05 	lds	r31, 0x0584
    124a:	09 95       	icall
}
    124c:	ff 91       	pop	r31
    124e:	ef 91       	pop	r30
    1250:	bf 91       	pop	r27
    1252:	af 91       	pop	r26
    1254:	9f 91       	pop	r25
    1256:	8f 91       	pop	r24
    1258:	7f 91       	pop	r23
    125a:	6f 91       	pop	r22
    125c:	5f 91       	pop	r21
    125e:	4f 91       	pop	r20
    1260:	3f 91       	pop	r19
    1262:	2f 91       	pop	r18
    1264:	0f 90       	pop	r0
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	0f 90       	pop	r0
    126a:	1f 90       	pop	r1
    126c:	18 95       	reti

0000126e <__vector_13>:

void __vector_13(void) __attribute__((signal));
void __vector_13(void)
{
    126e:	1f 92       	push	r1
    1270:	0f 92       	push	r0
    1272:	0f b6       	in	r0, 0x3f	; 63
    1274:	0f 92       	push	r0
    1276:	11 24       	eor	r1, r1
    1278:	2f 93       	push	r18
    127a:	3f 93       	push	r19
    127c:	4f 93       	push	r20
    127e:	5f 93       	push	r21
    1280:	6f 93       	push	r22
    1282:	7f 93       	push	r23
    1284:	8f 93       	push	r24
    1286:	9f 93       	push	r25
    1288:	af 93       	push	r26
    128a:	bf 93       	push	r27
    128c:	ef 93       	push	r30
    128e:	ff 93       	push	r31
  USART_RXC();
    1290:	e0 91 79 05 	lds	r30, 0x0579
    1294:	f0 91 7a 05 	lds	r31, 0x057A
    1298:	09 95       	icall
}
    129a:	ff 91       	pop	r31
    129c:	ef 91       	pop	r30
    129e:	bf 91       	pop	r27
    12a0:	af 91       	pop	r26
    12a2:	9f 91       	pop	r25
    12a4:	8f 91       	pop	r24
    12a6:	7f 91       	pop	r23
    12a8:	6f 91       	pop	r22
    12aa:	5f 91       	pop	r21
    12ac:	4f 91       	pop	r20
    12ae:	3f 91       	pop	r19
    12b0:	2f 91       	pop	r18
    12b2:	0f 90       	pop	r0
    12b4:	0f be       	out	0x3f, r0	; 63
    12b6:	0f 90       	pop	r0
    12b8:	1f 90       	pop	r1
    12ba:	18 95       	reti

000012bc <__vector_14>:

void __vector_14(void) __attribute__((signal));
void __vector_14(void)
{
    12bc:	1f 92       	push	r1
    12be:	0f 92       	push	r0
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	0f 92       	push	r0
    12c4:	11 24       	eor	r1, r1
    12c6:	2f 93       	push	r18
    12c8:	3f 93       	push	r19
    12ca:	4f 93       	push	r20
    12cc:	5f 93       	push	r21
    12ce:	6f 93       	push	r22
    12d0:	7f 93       	push	r23
    12d2:	8f 93       	push	r24
    12d4:	9f 93       	push	r25
    12d6:	af 93       	push	r26
    12d8:	bf 93       	push	r27
    12da:	ef 93       	push	r30
    12dc:	ff 93       	push	r31
  USART_UDRE();
    12de:	e0 91 93 05 	lds	r30, 0x0593
    12e2:	f0 91 94 05 	lds	r31, 0x0594
    12e6:	09 95       	icall
}
    12e8:	ff 91       	pop	r31
    12ea:	ef 91       	pop	r30
    12ec:	bf 91       	pop	r27
    12ee:	af 91       	pop	r26
    12f0:	9f 91       	pop	r25
    12f2:	8f 91       	pop	r24
    12f4:	7f 91       	pop	r23
    12f6:	6f 91       	pop	r22
    12f8:	5f 91       	pop	r21
    12fa:	4f 91       	pop	r20
    12fc:	3f 91       	pop	r19
    12fe:	2f 91       	pop	r18
    1300:	0f 90       	pop	r0
    1302:	0f be       	out	0x3f, r0	; 63
    1304:	0f 90       	pop	r0
    1306:	1f 90       	pop	r1
    1308:	18 95       	reti

0000130a <__vector_15>:

void __vector_15(void) __attribute__((signal));
void __vector_15(void)
{
    130a:	1f 92       	push	r1
    130c:	0f 92       	push	r0
    130e:	0f b6       	in	r0, 0x3f	; 63
    1310:	0f 92       	push	r0
    1312:	11 24       	eor	r1, r1
    1314:	2f 93       	push	r18
    1316:	3f 93       	push	r19
    1318:	4f 93       	push	r20
    131a:	5f 93       	push	r21
    131c:	6f 93       	push	r22
    131e:	7f 93       	push	r23
    1320:	8f 93       	push	r24
    1322:	9f 93       	push	r25
    1324:	af 93       	push	r26
    1326:	bf 93       	push	r27
    1328:	ef 93       	push	r30
    132a:	ff 93       	push	r31
  USART_TXC();
    132c:	e0 91 8f 05 	lds	r30, 0x058F
    1330:	f0 91 90 05 	lds	r31, 0x0590
    1334:	09 95       	icall
}
    1336:	ff 91       	pop	r31
    1338:	ef 91       	pop	r30
    133a:	bf 91       	pop	r27
    133c:	af 91       	pop	r26
    133e:	9f 91       	pop	r25
    1340:	8f 91       	pop	r24
    1342:	7f 91       	pop	r23
    1344:	6f 91       	pop	r22
    1346:	5f 91       	pop	r21
    1348:	4f 91       	pop	r20
    134a:	3f 91       	pop	r19
    134c:	2f 91       	pop	r18
    134e:	0f 90       	pop	r0
    1350:	0f be       	out	0x3f, r0	; 63
    1352:	0f 90       	pop	r0
    1354:	1f 90       	pop	r1
    1356:	18 95       	reti

00001358 <__vector_16>:

void __vector_16(void) __attribute__((signal));
void __vector_16(void)
{
    1358:	1f 92       	push	r1
    135a:	0f 92       	push	r0
    135c:	0f b6       	in	r0, 0x3f	; 63
    135e:	0f 92       	push	r0
    1360:	11 24       	eor	r1, r1
    1362:	2f 93       	push	r18
    1364:	3f 93       	push	r19
    1366:	4f 93       	push	r20
    1368:	5f 93       	push	r21
    136a:	6f 93       	push	r22
    136c:	7f 93       	push	r23
    136e:	8f 93       	push	r24
    1370:	9f 93       	push	r25
    1372:	af 93       	push	r26
    1374:	bf 93       	push	r27
    1376:	ef 93       	push	r30
    1378:	ff 93       	push	r31
  ADC_INT();
    137a:	e0 91 89 05 	lds	r30, 0x0589
    137e:	f0 91 8a 05 	lds	r31, 0x058A
    1382:	09 95       	icall
}
    1384:	ff 91       	pop	r31
    1386:	ef 91       	pop	r30
    1388:	bf 91       	pop	r27
    138a:	af 91       	pop	r26
    138c:	9f 91       	pop	r25
    138e:	8f 91       	pop	r24
    1390:	7f 91       	pop	r23
    1392:	6f 91       	pop	r22
    1394:	5f 91       	pop	r21
    1396:	4f 91       	pop	r20
    1398:	3f 91       	pop	r19
    139a:	2f 91       	pop	r18
    139c:	0f 90       	pop	r0
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	0f 90       	pop	r0
    13a2:	1f 90       	pop	r1
    13a4:	18 95       	reti

000013a6 <__vector_17>:

void __vector_17(void) __attribute__((signal));
void __vector_17(void)
{
    13a6:	1f 92       	push	r1
    13a8:	0f 92       	push	r0
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	0f 92       	push	r0
    13ae:	11 24       	eor	r1, r1
    13b0:	2f 93       	push	r18
    13b2:	3f 93       	push	r19
    13b4:	4f 93       	push	r20
    13b6:	5f 93       	push	r21
    13b8:	6f 93       	push	r22
    13ba:	7f 93       	push	r23
    13bc:	8f 93       	push	r24
    13be:	9f 93       	push	r25
    13c0:	af 93       	push	r26
    13c2:	bf 93       	push	r27
    13c4:	ef 93       	push	r30
    13c6:	ff 93       	push	r31
  EE_RDY();
    13c8:	e0 91 8b 05 	lds	r30, 0x058B
    13cc:	f0 91 8c 05 	lds	r31, 0x058C
    13d0:	09 95       	icall
}
    13d2:	ff 91       	pop	r31
    13d4:	ef 91       	pop	r30
    13d6:	bf 91       	pop	r27
    13d8:	af 91       	pop	r26
    13da:	9f 91       	pop	r25
    13dc:	8f 91       	pop	r24
    13de:	7f 91       	pop	r23
    13e0:	6f 91       	pop	r22
    13e2:	5f 91       	pop	r21
    13e4:	4f 91       	pop	r20
    13e6:	3f 91       	pop	r19
    13e8:	2f 91       	pop	r18
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	0f 90       	pop	r0
    13f0:	1f 90       	pop	r1
    13f2:	18 95       	reti

000013f4 <__vector_18>:

void __vector_18(void) __attribute__((signal));
void __vector_18(void)
{
    13f4:	1f 92       	push	r1
    13f6:	0f 92       	push	r0
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	0f 92       	push	r0
    13fc:	11 24       	eor	r1, r1
    13fe:	2f 93       	push	r18
    1400:	3f 93       	push	r19
    1402:	4f 93       	push	r20
    1404:	5f 93       	push	r21
    1406:	6f 93       	push	r22
    1408:	7f 93       	push	r23
    140a:	8f 93       	push	r24
    140c:	9f 93       	push	r25
    140e:	af 93       	push	r26
    1410:	bf 93       	push	r27
    1412:	ef 93       	push	r30
    1414:	ff 93       	push	r31
  ANA_COMP();
    1416:	e0 91 87 05 	lds	r30, 0x0587
    141a:	f0 91 88 05 	lds	r31, 0x0588
    141e:	09 95       	icall
}
    1420:	ff 91       	pop	r31
    1422:	ef 91       	pop	r30
    1424:	bf 91       	pop	r27
    1426:	af 91       	pop	r26
    1428:	9f 91       	pop	r25
    142a:	8f 91       	pop	r24
    142c:	7f 91       	pop	r23
    142e:	6f 91       	pop	r22
    1430:	5f 91       	pop	r21
    1432:	4f 91       	pop	r20
    1434:	3f 91       	pop	r19
    1436:	2f 91       	pop	r18
    1438:	0f 90       	pop	r0
    143a:	0f be       	out	0x3f, r0	; 63
    143c:	0f 90       	pop	r0
    143e:	1f 90       	pop	r1
    1440:	18 95       	reti

00001442 <__vector_19>:

void __vector_19(void) __attribute__((signal));
void __vector_19(void)
{
    1442:	1f 92       	push	r1
    1444:	0f 92       	push	r0
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	0f 92       	push	r0
    144a:	11 24       	eor	r1, r1
    144c:	2f 93       	push	r18
    144e:	3f 93       	push	r19
    1450:	4f 93       	push	r20
    1452:	5f 93       	push	r21
    1454:	6f 93       	push	r22
    1456:	7f 93       	push	r23
    1458:	8f 93       	push	r24
    145a:	9f 93       	push	r25
    145c:	af 93       	push	r26
    145e:	bf 93       	push	r27
    1460:	ef 93       	push	r30
    1462:	ff 93       	push	r31
  TWI_I2C();
    1464:	e0 91 77 05 	lds	r30, 0x0577
    1468:	f0 91 78 05 	lds	r31, 0x0578
    146c:	09 95       	icall
}
    146e:	ff 91       	pop	r31
    1470:	ef 91       	pop	r30
    1472:	bf 91       	pop	r27
    1474:	af 91       	pop	r26
    1476:	9f 91       	pop	r25
    1478:	8f 91       	pop	r24
    147a:	7f 91       	pop	r23
    147c:	6f 91       	pop	r22
    147e:	5f 91       	pop	r21
    1480:	4f 91       	pop	r20
    1482:	3f 91       	pop	r19
    1484:	2f 91       	pop	r18
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	0f 90       	pop	r0
    148c:	1f 90       	pop	r1
    148e:	18 95       	reti

00001490 <__vector_20>:

void __vector_20(void) __attribute__((signal));
void __vector_20(void)
{
    1490:	1f 92       	push	r1
    1492:	0f 92       	push	r0
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	0f 92       	push	r0
    1498:	11 24       	eor	r1, r1
    149a:	2f 93       	push	r18
    149c:	3f 93       	push	r19
    149e:	4f 93       	push	r20
    14a0:	5f 93       	push	r21
    14a2:	6f 93       	push	r22
    14a4:	7f 93       	push	r23
    14a6:	8f 93       	push	r24
    14a8:	9f 93       	push	r25
    14aa:	af 93       	push	r26
    14ac:	bf 93       	push	r27
    14ae:	ef 93       	push	r30
    14b0:	ff 93       	push	r31
  SPM_RDY();
    14b2:	e0 91 7d 05 	lds	r30, 0x057D
    14b6:	f0 91 7e 05 	lds	r31, 0x057E
    14ba:	09 95       	icall
}
    14bc:	ff 91       	pop	r31
    14be:	ef 91       	pop	r30
    14c0:	bf 91       	pop	r27
    14c2:	af 91       	pop	r26
    14c4:	9f 91       	pop	r25
    14c6:	8f 91       	pop	r24
    14c8:	7f 91       	pop	r23
    14ca:	6f 91       	pop	r22
    14cc:	5f 91       	pop	r21
    14ce:	4f 91       	pop	r20
    14d0:	3f 91       	pop	r19
    14d2:	2f 91       	pop	r18
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	0f 90       	pop	r0
    14da:	1f 90       	pop	r1
    14dc:	18 95       	reti

000014de <ADC_read_int>:
}
void ADC_read_int(void)
{


    14de:	08 95       	ret

000014e0 <ADC_INIT>:
#include "ADC.h"
static uint8_t arr_counter_of_ptr=0;
static ptr_to_Fun ADC_R[8]={ADC_Read0,ADC_Read1,ADC_Read2,ADC_Read3,ADC_Read4,ADC_Read5,ADC_Read6,ADC_Read7};
uint16_t u16_ADC_readings_Channel[8];
ERROR_STATUS ADC_INIT(ADC_Cfg_s *ADC_info)
{
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	ec 01       	movw	r28, r24
	uint8_t ret_error=E_OK;
	
	ADMUX |= (ADC_info->u8_voltage_refrences) ;
    14e6:	97 b1       	in	r25, 0x07	; 7
    14e8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ea:	89 2b       	or	r24, r25
    14ec:	87 b9       	out	0x07, r24	; 7
	if ((ADC_info ->u8_Channel_Number) != ADC_MULTIPLE_CHANNELS)
    14ee:	88 81       	ld	r24, Y
    14f0:	8f 3f       	cpi	r24, 0xFF	; 255
    14f2:	39 f0       	breq	.+14     	; 0x1502 <ADC_INIT+0x22>
	{
		ADMUX &= 0xf0;
    14f4:	87 b1       	in	r24, 0x07	; 7
    14f6:	80 7f       	andi	r24, 0xF0	; 240
    14f8:	87 b9       	out	0x07, r24	; 7
		ADMUX |=(ADC_info ->u8_Channel_Number);
    14fa:	97 b1       	in	r25, 0x07	; 7
    14fc:	88 81       	ld	r24, Y
    14fe:	89 2b       	or	r24, r25
    1500:	87 b9       	out	0x07, r24	; 7
	}
	ADMUX |= (ADC_info->u8_ten_bit_arrangment);
    1502:	97 b1       	in	r25, 0x07	; 7
    1504:	8b 81       	ldd	r24, Y+3	; 0x03
    1506:	89 2b       	or	r24, r25
    1508:	87 b9       	out	0x07, r24	; 7
	G_interrupt_Enable();
    150a:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
	ADCSRA |= (ADC_info ->u8_polling_interrupt);
    150e:	96 b1       	in	r25, 0x06	; 6
    1510:	8c 81       	ldd	r24, Y+4	; 0x04
    1512:	89 2b       	or	r24, r25
    1514:	86 b9       	out	0x06, r24	; 6
	ADC_INT = ADC_read_int;
    1516:	8f e6       	ldi	r24, 0x6F	; 111
    1518:	9a e0       	ldi	r25, 0x0A	; 10
    151a:	90 93 8a 05 	sts	0x058A, r25
    151e:	80 93 89 05 	sts	0x0589, r24
	ADCSRA |=(ADC_info->u8_Prescaler);
    1522:	96 b1       	in	r25, 0x06	; 6
    1524:	89 81       	ldd	r24, Y+1	; 0x01
    1526:	89 2b       	or	r24, r25
    1528:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 0x80;/*ADC ENABLE*/
    152a:	37 9a       	sbi	0x06, 7	; 6
	ADCSRA |= 0x40;//start conversion
    152c:	36 9a       	sbi	0x06, 6	; 6
	return ret_error;
}
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	df 91       	pop	r29
    1532:	cf 91       	pop	r28
    1534:	08 95       	ret

00001536 <ADC_Read7>:
	u16_ADC_readings_Channel[6]  = (low_adc + (ADCH << 8));
}
void ADC_Read7(void)
{
	uint8_t low_adc=0;
ADC_INIT(&ADC_Cnfiguration7);
    1536:	80 e9       	ldi	r24, 0x90	; 144
    1538:	90 e0       	ldi	r25, 0x00	; 0
    153a:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
ADCSRA |= 0x40;
    153e:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    1540:	86 b1       	in	r24, 0x06	; 6
    1542:	84 ff       	sbrs	r24, 4
    1544:	fd cf       	rjmp	.-6      	; 0x1540 <ADC_Read7+0xa>
low_adc=ADCL;
    1546:	24 b1       	in	r18, 0x04	; 4
    1548:	35 b1       	in	r19, 0x05	; 5
u16_ADC_readings_Channel[7]  = (low_adc + (ADCH << 8));
    154a:	85 b1       	in	r24, 0x05	; 5
    154c:	96 b1       	in	r25, 0x06	; 6
    154e:	98 2f       	mov	r25, r24
    1550:	88 27       	eor	r24, r24
    1552:	82 0f       	add	r24, r18
    1554:	91 1d       	adc	r25, r1
    1556:	90 93 ac 05 	sts	0x05AC, r25
    155a:	80 93 ab 05 	sts	0x05AB, r24
}
    155e:	08 95       	ret

00001560 <ADC_Read6>:
}

void ADC_Read6(void)
{
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration6);
    1560:	85 e9       	ldi	r24, 0x95	; 149
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    1568:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    156a:	86 b1       	in	r24, 0x06	; 6
    156c:	84 ff       	sbrs	r24, 4
    156e:	fd cf       	rjmp	.-6      	; 0x156a <ADC_Read6+0xa>
	low_adc=ADCL;
    1570:	24 b1       	in	r18, 0x04	; 4
    1572:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[6]  = (low_adc + (ADCH << 8));
    1574:	85 b1       	in	r24, 0x05	; 5
    1576:	96 b1       	in	r25, 0x06	; 6
    1578:	98 2f       	mov	r25, r24
    157a:	88 27       	eor	r24, r24
    157c:	82 0f       	add	r24, r18
    157e:	91 1d       	adc	r25, r1
    1580:	90 93 aa 05 	sts	0x05AA, r25
    1584:	80 93 a9 05 	sts	0x05A9, r24
}
    1588:	08 95       	ret

0000158a <ADC_Read5>:

}
void ADC_Read5(void)
{
	uint8_t low_adc=0;
ADC_INIT(&ADC_Cnfiguration5);
    158a:	8a e9       	ldi	r24, 0x9A	; 154
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
ADCSRA |= 0x40;
    1592:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    1594:	86 b1       	in	r24, 0x06	; 6
    1596:	84 ff       	sbrs	r24, 4
    1598:	fd cf       	rjmp	.-6      	; 0x1594 <ADC_Read5+0xa>
low_adc=ADCL;
    159a:	24 b1       	in	r18, 0x04	; 4
    159c:	35 b1       	in	r19, 0x05	; 5
u16_ADC_readings_Channel[5]  = (low_adc + (ADCH << 8));
    159e:	85 b1       	in	r24, 0x05	; 5
    15a0:	96 b1       	in	r25, 0x06	; 6
    15a2:	98 2f       	mov	r25, r24
    15a4:	88 27       	eor	r24, r24
    15a6:	82 0f       	add	r24, r18
    15a8:	91 1d       	adc	r25, r1
    15aa:	90 93 a8 05 	sts	0x05A8, r25
    15ae:	80 93 a7 05 	sts	0x05A7, r24
}
    15b2:	08 95       	ret

000015b4 <ADC_Read4>:
u16_ADC_readings_Channel[3]  = (low_adc + (ADCH << 8));
}
void ADC_Read4(void)
{
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration4);
    15b4:	8f e9       	ldi	r24, 0x9F	; 159
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    15bc:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    15be:	86 b1       	in	r24, 0x06	; 6
    15c0:	84 ff       	sbrs	r24, 4
    15c2:	fd cf       	rjmp	.-6      	; 0x15be <ADC_Read4+0xa>
	low_adc=ADCL;
    15c4:	24 b1       	in	r18, 0x04	; 4
    15c6:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[4]  =(low_adc + (ADCH << 8));
    15c8:	85 b1       	in	r24, 0x05	; 5
    15ca:	96 b1       	in	r25, 0x06	; 6
    15cc:	98 2f       	mov	r25, r24
    15ce:	88 27       	eor	r24, r24
    15d0:	82 0f       	add	r24, r18
    15d2:	91 1d       	adc	r25, r1
    15d4:	90 93 a6 05 	sts	0x05A6, r25
    15d8:	80 93 a5 05 	sts	0x05A5, r24

}
    15dc:	08 95       	ret

000015de <ADC_Read3>:
	u16_ADC_readings_Channel[2]  = (low_adc + (ADCH << 8));
}
void ADC_Read3(void)
{
	uint8_t low_adc=0;
ADC_INIT(&ADC_Cnfiguration3);
    15de:	84 ea       	ldi	r24, 0xA4	; 164
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
ADCSRA |= 0x40;
    15e6:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    15e8:	86 b1       	in	r24, 0x06	; 6
    15ea:	84 ff       	sbrs	r24, 4
    15ec:	fd cf       	rjmp	.-6      	; 0x15e8 <ADC_Read3+0xa>
low_adc=ADCL;
    15ee:	24 b1       	in	r18, 0x04	; 4
    15f0:	35 b1       	in	r19, 0x05	; 5
u16_ADC_readings_Channel[3]  = (low_adc + (ADCH << 8));
    15f2:	85 b1       	in	r24, 0x05	; 5
    15f4:	96 b1       	in	r25, 0x06	; 6
    15f6:	98 2f       	mov	r25, r24
    15f8:	88 27       	eor	r24, r24
    15fa:	82 0f       	add	r24, r18
    15fc:	91 1d       	adc	r25, r1
    15fe:	90 93 a4 05 	sts	0x05A4, r25
    1602:	80 93 a3 05 	sts	0x05A3, r24
}
    1606:	08 95       	ret

00001608 <ADC_Read2>:
	low_adc=ADCL;
	u16_ADC_readings_Channel[1]  =(low_adc + (ADCH << 8));
}
void ADC_Read2(void){
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration2);
    1608:	89 ea       	ldi	r24, 0xA9	; 169
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    1610:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1612:	86 b1       	in	r24, 0x06	; 6
    1614:	84 ff       	sbrs	r24, 4
    1616:	fd cf       	rjmp	.-6      	; 0x1612 <ADC_Read2+0xa>
	u16_ADC_readings_Channel[2]  = (low_adc + (ADCH << 8));
    1618:	85 b1       	in	r24, 0x05	; 5
    161a:	96 b1       	in	r25, 0x06	; 6
    161c:	10 92 a1 05 	sts	0x05A1, r1
    1620:	80 93 a2 05 	sts	0x05A2, r24
}
    1624:	08 95       	ret

00001626 <ADC_Read1>:
	u16_ADC_readings_Channel[0]  = (low_adc + (ADCH << 8));

}
void ADC_Read1(void){
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration1);
    1626:	8e ea       	ldi	r24, 0xAE	; 174
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    162e:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1630:	86 b1       	in	r24, 0x06	; 6
    1632:	84 ff       	sbrs	r24, 4
    1634:	fd cf       	rjmp	.-6      	; 0x1630 <ADC_Read1+0xa>
	low_adc=ADCL;
    1636:	24 b1       	in	r18, 0x04	; 4
    1638:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[1]  =(low_adc + (ADCH << 8));
    163a:	85 b1       	in	r24, 0x05	; 5
    163c:	96 b1       	in	r25, 0x06	; 6
    163e:	98 2f       	mov	r25, r24
    1640:	88 27       	eor	r24, r24
    1642:	82 0f       	add	r24, r18
    1644:	91 1d       	adc	r25, r1
    1646:	90 93 a0 05 	sts	0x05A0, r25
    164a:	80 93 9f 05 	sts	0x059F, r24
}
    164e:	08 95       	ret

00001650 <ADC_Read0>:
	return ret_error;
}
void ADC_Read0(void)
{
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration0);
    1650:	83 eb       	ldi	r24, 0xB3	; 179
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    1658:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    165a:	86 b1       	in	r24, 0x06	; 6
    165c:	84 ff       	sbrs	r24, 4
    165e:	fd cf       	rjmp	.-6      	; 0x165a <ADC_Read0+0xa>
	low_adc=ADCL;
    1660:	24 b1       	in	r18, 0x04	; 4
    1662:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[0]  = (low_adc + (ADCH << 8));
    1664:	85 b1       	in	r24, 0x05	; 5
    1666:	96 b1       	in	r25, 0x06	; 6
    1668:	98 2f       	mov	r25, r24
    166a:	88 27       	eor	r24, r24
    166c:	82 0f       	add	r24, r18
    166e:	91 1d       	adc	r25, r1
    1670:	90 93 9e 05 	sts	0x059E, r25
    1674:	80 93 9d 05 	sts	0x059D, r24

}
    1678:	08 95       	ret

0000167a <adc_read>:
while (!(READBIT(ADCSRA,ADIF)));
low_adc=ADCL;
u16_ADC_readings_Channel[7]  = (low_adc + (ADCH << 8));
}
void adc_read(void){
	if (arr_counter_of_ptr < 8)
    167a:	e0 91 fc 00 	lds	r30, 0x00FC
    167e:	e8 30       	cpi	r30, 0x08	; 8
    1680:	78 f4       	brcc	.+30     	; 0x16a0 <adc_read+0x26>
	{
		ADC_R[arr_counter_of_ptr]();
    1682:	f0 e0       	ldi	r31, 0x00	; 0
    1684:	ee 0f       	add	r30, r30
    1686:	ff 1f       	adc	r31, r31
    1688:	e0 58       	subi	r30, 0x80	; 128
    168a:	ff 4f       	sbci	r31, 0xFF	; 255
    168c:	01 90       	ld	r0, Z+
    168e:	f0 81       	ld	r31, Z
    1690:	e0 2d       	mov	r30, r0
    1692:	09 95       	icall
			arr_counter_of_ptr++;
    1694:	80 91 fc 00 	lds	r24, 0x00FC
    1698:	8f 5f       	subi	r24, 0xFF	; 255
    169a:	80 93 fc 00 	sts	0x00FC, r24
    169e:	08 95       	ret
	}else{arr_counter_of_ptr=0;}
    16a0:	10 92 fc 00 	sts	0x00FC, r1
    16a4:	08 95       	ret

000016a6 <DIO_init>:
*Description: This function can set the direction of a full port, a nibble
* 			  or even one pin.
*/

ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{	
    16a6:	fc 01       	movw	r30, r24
	uint8_t RET=0;
	if (DIO_info== NULL)
    16a8:	00 97       	sbiw	r24, 0x00	; 0
    16aa:	09 f4       	brne	.+2      	; 0x16ae <DIO_init+0x8>
    16ac:	50 c0       	rjmp	.+160    	; 0x174e <DIO_init+0xa8>
	{
		RET=NULL_PTR+DIO_MODULE;
		
	}else{
		switch(DIO_info->dir)
    16ae:	82 81       	ldd	r24, Z+2	; 0x02
    16b0:	88 23       	and	r24, r24
    16b2:	21 f0       	breq	.+8      	; 0x16bc <DIO_init+0x16>
    16b4:	8f 3f       	cpi	r24, 0xFF	; 255
    16b6:	09 f0       	breq	.+2      	; 0x16ba <DIO_init+0x14>
    16b8:	4c c0       	rjmp	.+152    	; 0x1752 <DIO_init+0xac>
    16ba:	27 c0       	rjmp	.+78     	; 0x170a <DIO_init+0x64>
			{	
		case INPUT:
		     	switch(DIO_info ->GPIO)
    16bc:	80 81       	ld	r24, Z
    16be:	81 30       	cpi	r24, 0x01	; 1
    16c0:	79 f0       	breq	.+30     	; 0x16e0 <DIO_init+0x3a>
    16c2:	81 30       	cpi	r24, 0x01	; 1
    16c4:	30 f0       	brcs	.+12     	; 0x16d2 <DIO_init+0x2c>
    16c6:	82 30       	cpi	r24, 0x02	; 2
    16c8:	91 f0       	breq	.+36     	; 0x16ee <DIO_init+0x48>
    16ca:	83 30       	cpi	r24, 0x03	; 3
    16cc:	09 f0       	breq	.+2      	; 0x16d0 <DIO_init+0x2a>
    16ce:	43 c0       	rjmp	.+134    	; 0x1756 <DIO_init+0xb0>
    16d0:	15 c0       	rjmp	.+42     	; 0x16fc <DIO_init+0x56>
		 		{
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
    16d2:	9a b3       	in	r25, 0x1a	; 26
    16d4:	81 81       	ldd	r24, Z+1	; 0x01
    16d6:	80 95       	com	r24
    16d8:	89 23       	and	r24, r25
    16da:	8a bb       	out	0x1a, r24	; 26
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    16dc:	80 e0       	ldi	r24, 0x00	; 0
		case INPUT:
		     	switch(DIO_info ->GPIO)
		 		{
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
					break;
    16de:	08 95       	ret
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
    16e0:	97 b3       	in	r25, 0x17	; 23
    16e2:	81 81       	ldd	r24, Z+1	; 0x01
    16e4:	80 95       	com	r24
    16e6:	89 23       	and	r24, r25
    16e8:	87 bb       	out	0x17, r24	; 23
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    16ea:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
					break;
    16ec:	08 95       	ret
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
    16ee:	94 b3       	in	r25, 0x14	; 20
    16f0:	81 81       	ldd	r24, Z+1	; 0x01
    16f2:	80 95       	com	r24
    16f4:	89 23       	and	r24, r25
    16f6:	84 bb       	out	0x14, r24	; 20
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    16f8:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
					break;
    16fa:	08 95       	ret
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
    16fc:	91 b3       	in	r25, 0x11	; 17
    16fe:	81 81       	ldd	r24, Z+1	; 0x01
    1700:	80 95       	com	r24
    1702:	89 23       	and	r24, r25
    1704:	81 bb       	out	0x11, r24	; 17
					break;
					RET=E_OK;
				}
				RET=E_OK;
    1706:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
    1708:	08 95       	ret
				}
				RET=E_OK;
				break;

		case OUTPUT:
			  switch(DIO_info ->GPIO)
    170a:	80 81       	ld	r24, Z
    170c:	81 30       	cpi	r24, 0x01	; 1
    170e:	69 f0       	breq	.+26     	; 0x172a <DIO_init+0x84>
    1710:	81 30       	cpi	r24, 0x01	; 1
    1712:	28 f0       	brcs	.+10     	; 0x171e <DIO_init+0x78>
    1714:	82 30       	cpi	r24, 0x02	; 2
    1716:	79 f0       	breq	.+30     	; 0x1736 <DIO_init+0x90>
    1718:	83 30       	cpi	r24, 0x03	; 3
    171a:	f9 f4       	brne	.+62     	; 0x175a <DIO_init+0xb4>
    171c:	12 c0       	rjmp	.+36     	; 0x1742 <DIO_init+0x9c>
			  {
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
    171e:	9a b3       	in	r25, 0x1a	; 26
    1720:	81 81       	ldd	r24, Z+1	; 0x01
    1722:	89 2b       	or	r24, r25
    1724:	8a bb       	out	0x1a, r24	; 26
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1726:	80 e0       	ldi	r24, 0x00	; 0
		case OUTPUT:
			  switch(DIO_info ->GPIO)
			  {
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
				  break;
    1728:	08 95       	ret
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
    172a:	97 b3       	in	r25, 0x17	; 23
    172c:	81 81       	ldd	r24, Z+1	; 0x01
    172e:	89 2b       	or	r24, r25
    1730:	87 bb       	out	0x17, r24	; 23
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1732:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
				  break;
    1734:	08 95       	ret
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
    1736:	94 b3       	in	r25, 0x14	; 20
    1738:	81 81       	ldd	r24, Z+1	; 0x01
    173a:	89 2b       	or	r24, r25
    173c:	84 bb       	out	0x14, r24	; 20
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    173e:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
				  break;
    1740:	08 95       	ret
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
    1742:	91 b3       	in	r25, 0x11	; 17
    1744:	81 81       	ldd	r24, Z+1	; 0x01
    1746:	89 2b       	or	r24, r25
    1748:	81 bb       	out	0x11, r24	; 17
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    174a:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
    174c:	08 95       	ret
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{	
	uint8_t RET=0;
	if (DIO_info== NULL)
	{
		RET=NULL_PTR+DIO_MODULE;
    174e:	86 e1       	ldi	r24, 0x16	; 22
    1750:	08 95       	ret
			  }
			  RET=E_OK;
			  break;

			default:
			RET=E_NOK;
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	08 95       	ret
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	08 95       	ret
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    175a:	80 e0       	ldi	r24, 0x00	; 0
			RET=E_NOK;
	}
	
}	
return RET;
}
    175c:	08 95       	ret

0000175e <DIO_Write>:

ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{uint8_t Ret=0;
switch(value){
    175e:	44 23       	and	r20, r20
    1760:	21 f0       	breq	.+8      	; 0x176a <DIO_Write+0xc>
    1762:	4f 3f       	cpi	r20, 0xFF	; 255
    1764:	09 f0       	breq	.+2      	; 0x1768 <DIO_Write+0xa>
    1766:	3f c0       	rjmp	.+126    	; 0x17e6 <DIO_Write+0x88>
    1768:	21 c0       	rjmp	.+66     	; 0x17ac <DIO_Write+0x4e>
case LOW:
{
switch (GPIO)
    176a:	81 30       	cpi	r24, 0x01	; 1
    176c:	69 f0       	breq	.+26     	; 0x1788 <DIO_Write+0x2a>
    176e:	81 30       	cpi	r24, 0x01	; 1
    1770:	28 f0       	brcs	.+10     	; 0x177c <DIO_Write+0x1e>
    1772:	82 30       	cpi	r24, 0x02	; 2
    1774:	79 f0       	breq	.+30     	; 0x1794 <DIO_Write+0x36>
    1776:	83 30       	cpi	r24, 0x03	; 3
    1778:	c1 f5       	brne	.+112    	; 0x17ea <DIO_Write+0x8c>
    177a:	12 c0       	rjmp	.+36     	; 0x17a0 <DIO_Write+0x42>
{	case GPIOA:
	PORTA_DATA &= ~(pins);   // 0b01111111
    177c:	8b b3       	in	r24, 0x1b	; 27
    177e:	60 95       	com	r22
    1780:	68 23       	and	r22, r24
    1782:	6b bb       	out	0x1b, r22	; 27
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    1784:	80 e0       	ldi	r24, 0x00	; 0
{
switch (GPIO)
{	case GPIOA:
	PORTA_DATA &= ~(pins);   // 0b01111111
Ret=E_OK;
	break;
    1786:	08 95       	ret
	case GPIOB:
	PORTB_DATA &= ~(pins);
    1788:	88 b3       	in	r24, 0x18	; 24
    178a:	60 95       	com	r22
    178c:	68 23       	and	r22, r24
    178e:	68 bb       	out	0x18, r22	; 24
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    1790:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOB:
	PORTB_DATA &= ~(pins);
Ret=E_OK;
	break;
    1792:	08 95       	ret
	case GPIOC:
	PORTC_DATA &= ~(pins);
    1794:	85 b3       	in	r24, 0x15	; 21
    1796:	60 95       	com	r22
    1798:	68 23       	and	r22, r24
    179a:	65 bb       	out	0x15, r22	; 21
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    179c:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOC:
	PORTC_DATA &= ~(pins);
Ret=E_OK;
	break;
    179e:	08 95       	ret
	case GPIOD:
	PORTD_DATA &= ~(pins);
    17a0:	82 b3       	in	r24, 0x12	; 18
    17a2:	60 95       	com	r22
    17a4:	68 23       	and	r22, r24
    17a6:	62 bb       	out	0x12, r22	; 18
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    17a8:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOD:
	PORTD_DATA &= ~(pins);
	Ret=E_OK;
	break;
    17aa:	08 95       	ret
	}
Ret=E_OK;
break;
}
case HIGH:{
switch (GPIO)
    17ac:	81 30       	cpi	r24, 0x01	; 1
    17ae:	61 f0       	breq	.+24     	; 0x17c8 <DIO_Write+0x6a>
    17b0:	81 30       	cpi	r24, 0x01	; 1
    17b2:	28 f0       	brcs	.+10     	; 0x17be <DIO_Write+0x60>
    17b4:	82 30       	cpi	r24, 0x02	; 2
    17b6:	69 f0       	breq	.+26     	; 0x17d2 <DIO_Write+0x74>
    17b8:	83 30       	cpi	r24, 0x03	; 3
    17ba:	c9 f4       	brne	.+50     	; 0x17ee <DIO_Write+0x90>
    17bc:	0f c0       	rjmp	.+30     	; 0x17dc <DIO_Write+0x7e>
{	case GPIOA:
	PORTA_DATA |=(pins);
    17be:	8b b3       	in	r24, 0x1b	; 27
    17c0:	68 2b       	or	r22, r24
    17c2:	6b bb       	out	0x1b, r22	; 27
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17c4:	80 e0       	ldi	r24, 0x00	; 0
case HIGH:{
switch (GPIO)
{	case GPIOA:
	PORTA_DATA |=(pins);
Ret=E_OK;
	break;
    17c6:	08 95       	ret
	case GPIOB:
	PORTB_DATA |=(pins);
    17c8:	88 b3       	in	r24, 0x18	; 24
    17ca:	68 2b       	or	r22, r24
    17cc:	68 bb       	out	0x18, r22	; 24
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17ce:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOB:
	PORTB_DATA |=(pins);
Ret=E_OK;
	break;
    17d0:	08 95       	ret
	case GPIOC:
	PORTC_DATA |=(pins);
    17d2:	85 b3       	in	r24, 0x15	; 21
    17d4:	68 2b       	or	r22, r24
    17d6:	65 bb       	out	0x15, r22	; 21
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17d8:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOC:
	PORTC_DATA |=(pins);
Ret=E_OK;
	break;
    17da:	08 95       	ret
	case GPIOD:
	PORTD_DATA |=(pins);
    17dc:	82 b3       	in	r24, 0x12	; 18
    17de:	68 2b       	or	r22, r24
    17e0:	62 bb       	out	0x12, r22	; 18
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17e2:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOD:
	PORTD_DATA |=(pins);
Ret=E_OK;
	break;
    17e4:	08 95       	ret
}
Ret=E_OK;
break;
}
default:
Ret=E_NOK;
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	08 95       	ret
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    17ea:	80 e0       	ldi	r24, 0x00	; 0
    17ec:	08 95       	ret
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17ee:	80 e0       	ldi	r24, 0x00	; 0
default:
Ret=E_NOK;
break;
}
return Ret;
}
    17f0:	08 95       	ret

000017f2 <DIO_Read>:


ERROR_STATUS DIO_Read (uint8_t GPIO,uint8_t pins, uint8_t *data)
{
    17f2:	fa 01       	movw	r30, r20

switch (GPIO)
    17f4:	81 30       	cpi	r24, 0x01	; 1
    17f6:	59 f0       	breq	.+22     	; 0x180e <DIO_Read+0x1c>
    17f8:	81 30       	cpi	r24, 0x01	; 1
    17fa:	28 f0       	brcs	.+10     	; 0x1806 <DIO_Read+0x14>
    17fc:	82 30       	cpi	r24, 0x02	; 2
    17fe:	59 f0       	breq	.+22     	; 0x1816 <DIO_Read+0x24>
    1800:	83 30       	cpi	r24, 0x03	; 3
    1802:	81 f4       	brne	.+32     	; 0x1824 <DIO_Read+0x32>
    1804:	0c c0       	rjmp	.+24     	; 0x181e <DIO_Read+0x2c>
{	case GPIOA:
	*data=(PORTA_PIN & pins);
    1806:	89 b3       	in	r24, 0x19	; 25
    1808:	68 23       	and	r22, r24
    180a:	60 83       	st	Z, r22
	break;
    180c:	0b c0       	rjmp	.+22     	; 0x1824 <DIO_Read+0x32>
	case GPIOB:
	*data=(PORTB_PIN & pins);
    180e:	86 b3       	in	r24, 0x16	; 22
    1810:	68 23       	and	r22, r24
    1812:	60 83       	st	Z, r22
	break;
    1814:	07 c0       	rjmp	.+14     	; 0x1824 <DIO_Read+0x32>
	case GPIOC:
	*data=(PORTC_PIN & pins);
    1816:	83 b3       	in	r24, 0x13	; 19
    1818:	68 23       	and	r22, r24
    181a:	60 83       	st	Z, r22
	break;
    181c:	03 c0       	rjmp	.+6      	; 0x1824 <DIO_Read+0x32>
	case GPIOD:
	*data=(PORTD_PIN & pins);
    181e:	80 b3       	in	r24, 0x10	; 16
    1820:	68 23       	and	r22, r24
    1822:	60 83       	st	Z, r22
	break;
}
if(*data > 0)
    1824:	80 81       	ld	r24, Z
    1826:	88 23       	and	r24, r24
    1828:	11 f0       	breq	.+4      	; 0x182e <DIO_Read+0x3c>
{
	*data = HIGH;
    182a:	8f ef       	ldi	r24, 0xFF	; 255
    182c:	80 83       	st	Z, r24
}


}
    182e:	08 95       	ret

00001830 <DIO_Toggle>:
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{
uint8_t ret=0;
	switch (GPIO)
    1830:	81 30       	cpi	r24, 0x01	; 1
    1832:	61 f0       	breq	.+24     	; 0x184c <DIO_Toggle+0x1c>
    1834:	81 30       	cpi	r24, 0x01	; 1
    1836:	28 f0       	brcs	.+10     	; 0x1842 <DIO_Toggle+0x12>
    1838:	82 30       	cpi	r24, 0x02	; 2
    183a:	69 f0       	breq	.+26     	; 0x1856 <DIO_Toggle+0x26>
    183c:	83 30       	cpi	r24, 0x03	; 3
    183e:	a9 f4       	brne	.+42     	; 0x186a <DIO_Toggle+0x3a>
    1840:	0f c0       	rjmp	.+30     	; 0x1860 <DIO_Toggle+0x30>
	{	case GPIOA:
		PORTA_DATA ^=(pins);
    1842:	8b b3       	in	r24, 0x1b	; 27
    1844:	68 27       	eor	r22, r24
    1846:	6b bb       	out	0x1b, r22	; 27
		ret=E_OK;
    1848:	80 e0       	ldi	r24, 0x00	; 0
		break;
    184a:	08 95       	ret
		case GPIOB:
		PORTB_DATA ^=(pins);
    184c:	88 b3       	in	r24, 0x18	; 24
    184e:	68 27       	eor	r22, r24
    1850:	68 bb       	out	0x18, r22	; 24
ret=E_OK;
    1852:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1854:	08 95       	ret
		case GPIOC:
		PORTC_DATA ^=(pins);
    1856:	85 b3       	in	r24, 0x15	; 21
    1858:	68 27       	eor	r22, r24
    185a:	65 bb       	out	0x15, r22	; 21
ret=E_OK;
    185c:	80 e0       	ldi	r24, 0x00	; 0
		break;
    185e:	08 95       	ret
		case GPIOD:
		PORTD_DATA ^=(pins);
    1860:	82 b3       	in	r24, 0x12	; 18
    1862:	68 27       	eor	r22, r24
    1864:	62 bb       	out	0x12, r22	; 18
ret=E_OK;
    1866:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1868:	08 95       	ret
		default:
		ret=E_NOK;
    186a:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}

return ret;
}
    186c:	08 95       	ret

0000186e <Icu_Init>:
static volatile uint32_t u32_Time_rising_edge=0;
static volatile uint32_t u32_Time_faling_edge=0;
static volatile uint32_t Timer_High=0;
static volatile uint32_t Timer_Low=0;
ERROR_STATUS Icu_Init(Icu_cfg_s * Icu_Cfg)
{
    186e:	cf 93       	push	r28
    1870:	df 93       	push	r29
    1872:	ec 01       	movw	r28, r24
	uint8_t Ret=0;
//Enable Global int
G_interrupt_Enable();
    1874:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
//Enable EXTI
switch(Icu_Cfg->ICU_Ch_No)
    1878:	88 81       	ld	r24, Y
    187a:	81 30       	cpi	r24, 0x01	; 1
    187c:	41 f0       	breq	.+16     	; 0x188e <Icu_Init+0x20>
    187e:	81 30       	cpi	r24, 0x01	; 1
    1880:	18 f0       	brcs	.+6      	; 0x1888 <Icu_Init+0x1a>
    1882:	82 30       	cpi	r24, 0x02	; 2
    1884:	49 f4       	brne	.+18     	; 0x1898 <Icu_Init+0x2a>
    1886:	06 c0       	rjmp	.+12     	; 0x1894 <Icu_Init+0x26>
{
case ICU_CH0:
EX_interrupt_enable0();
    1888:	0e 94 53 07 	call	0xea6	; 0xea6 <EX_interrupt_enable0>
break;
    188c:	05 c0       	rjmp	.+10     	; 0x1898 <Icu_Init+0x2a>
case ICU_CH1:
EX_interrupt_enable1();
    188e:	0e 94 47 07 	call	0xe8e	; 0xe8e <EX_interrupt_enable1>
break;
    1892:	02 c0       	rjmp	.+4      	; 0x1898 <Icu_Init+0x2a>
case ICU_CH2:
EX_interrupt_enable2();
    1894:	0e 94 3e 07 	call	0xe7c	; 0xe7c <EX_interrupt_enable2>
break;
}

switch(Icu_Cfg->ICU_Ch_Timer)
    1898:	89 81       	ldd	r24, Y+1	; 0x01
    189a:	81 30       	cpi	r24, 0x01	; 1
    189c:	51 f0       	breq	.+20     	; 0x18b2 <Icu_Init+0x44>
    189e:	81 30       	cpi	r24, 0x01	; 1
    18a0:	18 f0       	brcs	.+6      	; 0x18a8 <Icu_Init+0x3a>
    18a2:	82 30       	cpi	r24, 0x02	; 2
    18a4:	89 f4       	brne	.+34     	; 0x18c8 <Icu_Init+0x5a>
    18a6:	0c c0       	rjmp	.+24     	; 0x18c0 <Icu_Init+0x52>
{
	case ICU_TIMER_CH0:
		//Enable Timer0
		TCCR0=0x05;
    18a8:	85 e0       	ldi	r24, 0x05	; 5
    18aa:	83 bf       	out	0x33, r24	; 51
		TIMSK=0x01;
    18ac:	81 e0       	ldi	r24, 0x01	; 1
    18ae:	89 bf       	out	0x39, r24	; 57
		break;
    18b0:	0b c0       	rjmp	.+22     	; 0x18c8 <Icu_Init+0x5a>
	case ICU_TIMER_CH1:
		TCCR1=0x0005;
    18b2:	85 e0       	ldi	r24, 0x05	; 5
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	9f bd       	out	0x2f, r25	; 47
    18b8:	8e bd       	out	0x2e, r24	; 46
		TIMSK=0x04;
    18ba:	84 e0       	ldi	r24, 0x04	; 4
    18bc:	89 bf       	out	0x39, r24	; 57
		break;
    18be:	04 c0       	rjmp	.+8      	; 0x18c8 <Icu_Init+0x5a>
	case ICU_TIMER_CH2:
		TCCR2=0x07;
    18c0:	87 e0       	ldi	r24, 0x07	; 7
    18c2:	85 bd       	out	0x25, r24	; 37
		TIMSK=0x04;
    18c4:	84 e0       	ldi	r24, 0x04	; 4
    18c6:	89 bf       	out	0x39, r24	; 57
		break;
}

return Ret;
}
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	df 91       	pop	r29
    18cc:	cf 91       	pop	r28
    18ce:	08 95       	ret

000018d0 <Icu_ReadTime>:
 * 				  - E_OK : successful									   *
 *				  - E_NOK : not successful								   *
 * Description	: calculates the time between 2 edges				       *
 ***************************************************************************/
ERROR_STATUS Icu_ReadTime(uint8_t Icu_Channel, uint8_t Icu_EdgeToEdge, uint32_t * Icu_Time)
{
    18d0:	0f 93       	push	r16
    18d2:	1f 93       	push	r17
uint8_t Ret=0;
switch(Icu_Channel)
    18d4:	81 30       	cpi	r24, 0x01	; 1
    18d6:	49 f0       	breq	.+18     	; 0x18ea <Icu_ReadTime+0x1a>
    18d8:	81 30       	cpi	r24, 0x01	; 1
    18da:	18 f0       	brcs	.+6      	; 0x18e2 <Icu_ReadTime+0x12>
    18dc:	82 30       	cpi	r24, 0x02	; 2
    18de:	71 f4       	brne	.+28     	; 0x18fc <Icu_ReadTime+0x2c>
    18e0:	0a c0       	rjmp	.+20     	; 0x18f6 <Icu_ReadTime+0x26>
{
	case ICU_TIMER_CH0:
	TCCR0|=0x03;
    18e2:	83 b7       	in	r24, 0x33	; 51
    18e4:	83 60       	ori	r24, 0x03	; 3
    18e6:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
	break;
    18e8:	09 c0       	rjmp	.+18     	; 0x18fc <Icu_ReadTime+0x2c>
	case ICU_TIMER_CH1:
	TCCR1|=0x0005;
    18ea:	8e b5       	in	r24, 0x2e	; 46
    18ec:	9f b5       	in	r25, 0x2f	; 47
    18ee:	85 60       	ori	r24, 0x05	; 5
    18f0:	9f bd       	out	0x2f, r25	; 47
    18f2:	8e bd       	out	0x2e, r24	; 46
	Ret=E_OK;	
	break;
    18f4:	03 c0       	rjmp	.+6      	; 0x18fc <Icu_ReadTime+0x2c>
	case ICU_TIMER_CH2:
	TCCR2|=0x07;
    18f6:	85 b5       	in	r24, 0x25	; 37
    18f8:	87 60       	ori	r24, 0x07	; 7
    18fa:	85 bd       	out	0x25, r24	; 37
	default:
	Ret=E_NOK;
	break;
}  

switch(Icu_EdgeToEdge)
    18fc:	61 30       	cpi	r22, 0x01	; 1
    18fe:	01 f1       	breq	.+64     	; 0x1940 <Icu_ReadTime+0x70>
    1900:	61 30       	cpi	r22, 0x01	; 1
    1902:	18 f0       	brcs	.+6      	; 0x190a <Icu_ReadTime+0x3a>
    1904:	62 30       	cpi	r22, 0x02	; 2
    1906:	d1 f5       	brne	.+116    	; 0x197c <Icu_ReadTime+0xac>
    1908:	2a c0       	rjmp	.+84     	; 0x195e <Icu_ReadTime+0x8e>
{
	case ICU_RISE_TO_RISE:
	*Icu_Time=Timer_High+Timer_Low;
    190a:	80 91 01 01 	lds	r24, 0x0101
    190e:	90 91 02 01 	lds	r25, 0x0102
    1912:	a0 91 03 01 	lds	r26, 0x0103
    1916:	b0 91 04 01 	lds	r27, 0x0104
    191a:	00 91 fd 00 	lds	r16, 0x00FD
    191e:	10 91 fe 00 	lds	r17, 0x00FE
    1922:	20 91 ff 00 	lds	r18, 0x00FF
    1926:	30 91 00 01 	lds	r19, 0x0100
    192a:	80 0f       	add	r24, r16
    192c:	91 1f       	adc	r25, r17
    192e:	a2 1f       	adc	r26, r18
    1930:	b3 1f       	adc	r27, r19
    1932:	fa 01       	movw	r30, r20
    1934:	80 83       	st	Z, r24
    1936:	91 83       	std	Z+1, r25	; 0x01
    1938:	a2 83       	std	Z+2, r26	; 0x02
    193a:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    193c:	80 e0       	ldi	r24, 0x00	; 0
	break;
    193e:	1f c0       	rjmp	.+62     	; 0x197e <Icu_ReadTime+0xae>
	case ICU_RISE_TO_FALL:
	*Icu_Time=Timer_High;
    1940:	80 91 01 01 	lds	r24, 0x0101
    1944:	90 91 02 01 	lds	r25, 0x0102
    1948:	a0 91 03 01 	lds	r26, 0x0103
    194c:	b0 91 04 01 	lds	r27, 0x0104
    1950:	fa 01       	movw	r30, r20
    1952:	80 83       	st	Z, r24
    1954:	91 83       	std	Z+1, r25	; 0x01
    1956:	a2 83       	std	Z+2, r26	; 0x02
    1958:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    195a:	80 e0       	ldi	r24, 0x00	; 0
	break;
    195c:	10 c0       	rjmp	.+32     	; 0x197e <Icu_ReadTime+0xae>
	case ICU_FALE_TO_RISE:
	*Icu_Time=Timer_Low;
    195e:	80 91 fd 00 	lds	r24, 0x00FD
    1962:	90 91 fe 00 	lds	r25, 0x00FE
    1966:	a0 91 ff 00 	lds	r26, 0x00FF
    196a:	b0 91 00 01 	lds	r27, 0x0100
    196e:	fa 01       	movw	r30, r20
    1970:	80 83       	st	Z, r24
    1972:	91 83       	std	Z+1, r25	; 0x01
    1974:	a2 83       	std	Z+2, r26	; 0x02
    1976:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    1978:	80 e0       	ldi	r24, 0x00	; 0
	break;
    197a:	01 c0       	rjmp	.+2      	; 0x197e <Icu_ReadTime+0xae>
	
	default:
	Ret=E_NOK;
    197c:	81 e0       	ldi	r24, 0x01	; 1
	break;
}

return Ret;
}
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	08 95       	ret

00001984 <EXTI>:
void EXTI(void)
{	u32_sgv_TimerVal=(uint32_t)TCNT0+((uint32_t)u8_ovf_happend*255);
    1984:	cf 93       	push	r28
    1986:	c2 b7       	in	r28, 0x32	; 50
    1988:	60 91 0d 01 	lds	r22, 0x010D
    198c:	70 e0       	ldi	r23, 0x00	; 0
    198e:	80 e0       	ldi	r24, 0x00	; 0
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	2f ef       	ldi	r18, 0xFF	; 255
    1994:	30 e0       	ldi	r19, 0x00	; 0
    1996:	40 e0       	ldi	r20, 0x00	; 0
    1998:	50 e0       	ldi	r21, 0x00	; 0
    199a:	0e 94 3f 2a 	call	0x547e	; 0x547e <__mulsi3>
    199e:	dc 01       	movw	r26, r24
    19a0:	cb 01       	movw	r24, r22
    19a2:	8c 0f       	add	r24, r28
    19a4:	91 1d       	adc	r25, r1
    19a6:	a1 1d       	adc	r26, r1
    19a8:	b1 1d       	adc	r27, r1
    19aa:	80 93 0e 01 	sts	0x010E, r24
    19ae:	90 93 0f 01 	sts	0x010F, r25
    19b2:	a0 93 10 01 	sts	0x0110, r26
    19b6:	b0 93 11 01 	sts	0x0111, r27
	u8_ovf_happend=0;
    19ba:	10 92 0d 01 	sts	0x010D, r1
		if(READBIT(MCUCSR,6))
    19be:	84 b7       	in	r24, 0x34	; 52
    19c0:	82 95       	swap	r24
    19c2:	86 95       	lsr	r24
    19c4:	86 95       	lsr	r24
    19c6:	83 70       	andi	r24, 0x03	; 3
    19c8:	80 ff       	sbrs	r24, 0
    19ca:	30 c0       	rjmp	.+96     	; 0x1a2c <EXTI+0xa8>
		{
		u32_Time_rising_edge=u32_sgv_TimerVal;
    19cc:	80 91 0e 01 	lds	r24, 0x010E
    19d0:	90 91 0f 01 	lds	r25, 0x010F
    19d4:	a0 91 10 01 	lds	r26, 0x0110
    19d8:	b0 91 11 01 	lds	r27, 0x0111
    19dc:	80 93 09 01 	sts	0x0109, r24
    19e0:	90 93 0a 01 	sts	0x010A, r25
    19e4:	a0 93 0b 01 	sts	0x010B, r26
    19e8:	b0 93 0c 01 	sts	0x010C, r27
		Timer_Low = u32_Time_rising_edge - u32_Time_faling_edge;
    19ec:	80 91 09 01 	lds	r24, 0x0109
    19f0:	90 91 0a 01 	lds	r25, 0x010A
    19f4:	a0 91 0b 01 	lds	r26, 0x010B
    19f8:	b0 91 0c 01 	lds	r27, 0x010C
    19fc:	40 91 05 01 	lds	r20, 0x0105
    1a00:	50 91 06 01 	lds	r21, 0x0106
    1a04:	60 91 07 01 	lds	r22, 0x0107
    1a08:	70 91 08 01 	lds	r23, 0x0108
    1a0c:	84 1b       	sub	r24, r20
    1a0e:	95 0b       	sbc	r25, r21
    1a10:	a6 0b       	sbc	r26, r22
    1a12:	b7 0b       	sbc	r27, r23
    1a14:	80 93 fd 00 	sts	0x00FD, r24
    1a18:	90 93 fe 00 	sts	0x00FE, r25
    1a1c:	a0 93 ff 00 	sts	0x00FF, r26
    1a20:	b0 93 00 01 	sts	0x0100, r27
		/*****************************************/	
		CLEAR_BIT(MCUCSR,6);   /*Make it falling*/
    1a24:	84 b7       	in	r24, 0x34	; 52
    1a26:	8f 7b       	andi	r24, 0xBF	; 191
    1a28:	84 bf       	out	0x34, r24	; 52
    1a2a:	2f c0       	rjmp	.+94     	; 0x1a8a <EXTI+0x106>
		/***************************************/
		}else{
			u32_Time_faling_edge=u32_sgv_TimerVal;
    1a2c:	80 91 0e 01 	lds	r24, 0x010E
    1a30:	90 91 0f 01 	lds	r25, 0x010F
    1a34:	a0 91 10 01 	lds	r26, 0x0110
    1a38:	b0 91 11 01 	lds	r27, 0x0111
    1a3c:	80 93 05 01 	sts	0x0105, r24
    1a40:	90 93 06 01 	sts	0x0106, r25
    1a44:	a0 93 07 01 	sts	0x0107, r26
    1a48:	b0 93 08 01 	sts	0x0108, r27
			Timer_High =u32_Time_faling_edge - u32_Time_rising_edge;
    1a4c:	80 91 05 01 	lds	r24, 0x0105
    1a50:	90 91 06 01 	lds	r25, 0x0106
    1a54:	a0 91 07 01 	lds	r26, 0x0107
    1a58:	b0 91 08 01 	lds	r27, 0x0108
    1a5c:	40 91 09 01 	lds	r20, 0x0109
    1a60:	50 91 0a 01 	lds	r21, 0x010A
    1a64:	60 91 0b 01 	lds	r22, 0x010B
    1a68:	70 91 0c 01 	lds	r23, 0x010C
    1a6c:	84 1b       	sub	r24, r20
    1a6e:	95 0b       	sbc	r25, r21
    1a70:	a6 0b       	sbc	r26, r22
    1a72:	b7 0b       	sbc	r27, r23
    1a74:	80 93 01 01 	sts	0x0101, r24
    1a78:	90 93 02 01 	sts	0x0102, r25
    1a7c:	a0 93 03 01 	sts	0x0103, r26
    1a80:	b0 93 04 01 	sts	0x0104, r27
			/*********************************/	
			SET_BIT(MCUCSR,6);		/*Make it Rising*/
    1a84:	84 b7       	in	r24, 0x34	; 52
    1a86:	80 64       	ori	r24, 0x40	; 64
    1a88:	84 bf       	out	0x34, r24	; 52
			/********************************/
			}	

//UDR=Timer_High;
}/*
    1a8a:	cf 91       	pop	r28
    1a8c:	08 95       	ret

00001a8e <pushButtonGetStatus>:

En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id)
{
	static uint8_t u8_Button_press[3];
static uint8_t u8_S_button_status[3];
switch(en_butotn_id)
    1a8e:	81 30       	cpi	r24, 0x01	; 1
    1a90:	c1 f0       	breq	.+48     	; 0x1ac2 <pushButtonGetStatus+0x34>
    1a92:	81 30       	cpi	r24, 0x01	; 1
    1a94:	18 f0       	brcs	.+6      	; 0x1a9c <pushButtonGetStatus+0xe>
    1a96:	82 30       	cpi	r24, 0x02	; 2
    1a98:	d1 f5       	brne	.+116    	; 0x1b0e <pushButtonGetStatus+0x80>
    1a9a:	26 c0       	rjmp	.+76     	; 0x1ae8 <pushButtonGetStatus+0x5a>
{
case BTN_0:
{DIO_Read(BTN_0_GPIO,BTN_0_BIT,&(u8_Button_press[0]));
    1a9c:	82 e0       	ldi	r24, 0x02	; 2
    1a9e:	61 e0       	ldi	r22, 0x01	; 1
    1aa0:	42 e1       	ldi	r20, 0x12	; 18
    1aa2:	51 e0       	ldi	r21, 0x01	; 1
    1aa4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
if( u8_Button_press[0]== Pressed)
    1aa8:	80 91 12 01 	lds	r24, 0x0112
    1aac:	81 30       	cpi	r24, 0x01	; 1
    1aae:	81 f5       	brne	.+96     	; 0x1b10 <pushButtonGetStatus+0x82>
{ 
	(u8_S_button_status[0])++;
    1ab0:	90 91 15 01 	lds	r25, 0x0115
    1ab4:	9f 5f       	subi	r25, 0xFF	; 255
    1ab6:	90 93 15 01 	sts	0x0115, r25
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1aba:	93 33       	cpi	r25, 0x33	; 51
    1abc:	70 f5       	brcc	.+92     	; 0x1b1a <pushButtonGetStatus+0x8c>
    1abe:	80 e0       	ldi	r24, 0x00	; 0
    1ac0:	08 95       	ret
	else {return Released;}
}else{return Released;}
break;
}
case BTN_1:
{DIO_Read(BTN_1_GPIO,BTN_1_BIT,&(u8_Button_press[1]));
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	64 e0       	ldi	r22, 0x04	; 4
    1ac6:	43 e1       	ldi	r20, 0x13	; 19
    1ac8:	51 e0       	ldi	r21, 0x01	; 1
    1aca:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
if( u8_Button_press[1] == Pressed)
    1ace:	80 91 13 01 	lds	r24, 0x0113
    1ad2:	81 30       	cpi	r24, 0x01	; 1
    1ad4:	f9 f4       	brne	.+62     	; 0x1b14 <pushButtonGetStatus+0x86>
{
	(u8_S_button_status[0])++;
    1ad6:	90 91 15 01 	lds	r25, 0x0115
    1ada:	9f 5f       	subi	r25, 0xFF	; 255
    1adc:	90 93 15 01 	sts	0x0115, r25
	(u8_S_button_status[0])++;
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1ae0:	93 33       	cpi	r25, 0x33	; 51
    1ae2:	d8 f4       	brcc	.+54     	; 0x1b1a <pushButtonGetStatus+0x8c>
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	08 95       	ret
	else {return Released;}
}else{return Released;}
break;
}
case BTN_2:
{DIO_Read(BTN_2_GPIO,BTN_2_BIT,&(u8_Button_press[2]));
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	64 e0       	ldi	r22, 0x04	; 4
    1aec:	44 e1       	ldi	r20, 0x14	; 20
    1aee:	51 e0       	ldi	r21, 0x01	; 1
    1af0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
if((u8_Button_press[2])== Pressed)
    1af4:	80 91 14 01 	lds	r24, 0x0114
    1af8:	81 30       	cpi	r24, 0x01	; 1
    1afa:	71 f4       	brne	.+28     	; 0x1b18 <pushButtonGetStatus+0x8a>
{	(u8_S_button_status[1])++;
    1afc:	90 91 16 01 	lds	r25, 0x0116
    1b00:	9f 5f       	subi	r25, 0xFF	; 255
    1b02:	90 93 16 01 	sts	0x0116, r25
	(u8_S_button_status[0])++;
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1b06:	95 31       	cpi	r25, 0x15	; 21
    1b08:	40 f4       	brcc	.+16     	; 0x1b1a <pushButtonGetStatus+0x8c>
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	08 95       	ret
    1b0e:	08 95       	ret
	else {return Released;}
}else{return Released;}
    1b10:	80 e0       	ldi	r24, 0x00	; 0
    1b12:	08 95       	ret
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
return Pressed;
	else {return Released;}
}else{return Released;}
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	08 95       	ret
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[1]) > 20)
	return Pressed;
else {return Released;}
}else{return Released;}
    1b18:	80 e0       	ldi	r24, 0x00	; 0


	}


}
    1b1a:	08 95       	ret

00001b1c <Pwm_Init>:
/*                                                                               */
/* Description: initialize the PWM configuration                                 */
/*********************************************************************************/

ERROR_STATUS Pwm_Init(Pwm_Cfg_s *Pwm_Cfg)
{uint8_t Ret=0;
    1b1c:	fc 01       	movw	r30, r24
	switch(Pwm_Cfg->Channel)
    1b1e:	80 81       	ld	r24, Z
    1b20:	81 30       	cpi	r24, 0x01	; 1
    1b22:	61 f0       	breq	.+24     	; 0x1b3c <Pwm_Init+0x20>
    1b24:	81 30       	cpi	r24, 0x01	; 1
    1b26:	28 f0       	brcs	.+10     	; 0x1b32 <Pwm_Init+0x16>
    1b28:	82 30       	cpi	r24, 0x02	; 2
    1b2a:	81 f0       	breq	.+32     	; 0x1b4c <Pwm_Init+0x30>
    1b2c:	83 30       	cpi	r24, 0x03	; 3
    1b2e:	d9 f4       	brne	.+54     	; 0x1b66 <Pwm_Init+0x4a>
    1b30:	15 c0       	rjmp	.+42     	; 0x1b5c <Pwm_Init+0x40>
		{
			case PWM_CH0:
			TCCR0|=T0_PWM_FAST |T0_NON_INVERTING;
    1b32:	83 b7       	in	r24, 0x33	; 51
    1b34:	88 66       	ori	r24, 0x68	; 104
    1b36:	83 bf       	out	0x33, r24	; 51
			Ret=E_OK;
    1b38:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b3a:	16 c0       	rjmp	.+44     	; 0x1b68 <Pwm_Init+0x4c>

			case PWM_CH1A:
			TCCR1 |= T1_PWM_Phase_8 | T1_OC1A_OC1B|0x0020;
    1b3c:	8e b5       	in	r24, 0x2e	; 46
    1b3e:	9f b5       	in	r25, 0x2f	; 47
    1b40:	80 62       	ori	r24, 0x20	; 32
    1b42:	91 6a       	ori	r25, 0xA1	; 161
    1b44:	9f bd       	out	0x2f, r25	; 47
    1b46:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
    1b48:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b4a:	0e c0       	rjmp	.+28     	; 0x1b68 <Pwm_Init+0x4c>

			case PWM_CH1B:
			TCCR1 |= T1_PWM_Phase_8 | T1_OC1A_OC1B;
    1b4c:	8e b5       	in	r24, 0x2e	; 46
    1b4e:	9f b5       	in	r25, 0x2f	; 47
    1b50:	80 62       	ori	r24, 0x20	; 32
    1b52:	91 6a       	ori	r25, 0xA1	; 161
    1b54:	9f bd       	out	0x2f, r25	; 47
    1b56:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
    1b58:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b5a:	06 c0       	rjmp	.+12     	; 0x1b68 <Pwm_Init+0x4c>


			case PWM_CH2:
			TCCR2 |=T2_PWM_FAST |T2_NON_INVERTING;
    1b5c:	85 b5       	in	r24, 0x25	; 37
    1b5e:	88 66       	ori	r24, 0x68	; 104
    1b60:	85 bd       	out	0x25, r24	; 37
			Ret=E_OK;
    1b62:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b64:	01 c0       	rjmp	.+2      	; 0x1b68 <Pwm_Init+0x4c>
			default:
			Ret=E_NOK;
    1b66:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
	sgl_Prescaler=Pwm_Cfg->Prescaler;
    1b68:	91 81       	ldd	r25, Z+1	; 0x01
    1b6a:	90 93 18 01 	sts	0x0118, r25
	u32g_T1_Prescaler=en_prescal;
	OCR1A =u16_outputCompareA;
	OCR1B =u16_outputCompareB;
	TCNT1=u16_initialValue;
	*/
}
    1b6e:	08 95       	ret

00001b70 <Pwm_Start>:
/*-------------------------------------------------------                        */
/*((all this calculations are for phase correct mode))                           */
/*all this calculation for F_CPU 16MHz                                           */
/*********************************************************************************/
ERROR_STATUS Pwm_Start(uint8_t Channel,uint8_t Duty,uint32_t Frequncy)
{uint8_t Ret=0;
    1b70:	cf 92       	push	r12
    1b72:	df 92       	push	r13
    1b74:	ef 92       	push	r14
    1b76:	ff 92       	push	r15
    1b78:	0f 93       	push	r16
    1b7a:	1f 93       	push	r17
    1b7c:	89 01       	movw	r16, r18
    1b7e:	9a 01       	movw	r18, r20
	float dutyReal;
uint32_t pwm_time_on = MAX_HOLD;

if(Frequncy <= 31372 && Frequncy > 3921 )
    1b80:	0f 2e       	mov	r0, r31
    1b82:	fe ea       	ldi	r31, 0xAE	; 174
    1b84:	cf 2e       	mov	r12, r31
    1b86:	f0 ef       	ldi	r31, 0xF0	; 240
    1b88:	df 2e       	mov	r13, r31
    1b8a:	ff ef       	ldi	r31, 0xFF	; 255
    1b8c:	ef 2e       	mov	r14, r31
    1b8e:	ff ef       	ldi	r31, 0xFF	; 255
    1b90:	ff 2e       	mov	r15, r31
    1b92:	f0 2d       	mov	r31, r0
    1b94:	c0 0e       	add	r12, r16
    1b96:	d1 1e       	adc	r13, r17
    1b98:	e2 1e       	adc	r14, r18
    1b9a:	f3 1e       	adc	r15, r19
    1b9c:	9b e3       	ldi	r25, 0x3B	; 59
    1b9e:	c9 16       	cp	r12, r25
    1ba0:	9b e6       	ldi	r25, 0x6B	; 107
    1ba2:	d9 06       	cpc	r13, r25
    1ba4:	90 e0       	ldi	r25, 0x00	; 0
    1ba6:	e9 06       	cpc	r14, r25
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	f9 06       	cpc	r15, r25
    1bac:	18 f4       	brcc	.+6      	; 0x1bb4 <Pwm_Start+0x44>
	sgl_Prescaler=PWM_PRESCALER_NO;
    1bae:	10 92 18 01 	sts	0x0118, r1
    1bb2:	a2 c0       	rjmp	.+324    	; 0x1cf8 <Pwm_Start+0x188>
else if(Frequncy <= 3921 && Frequncy > 980)
    1bb4:	0f 2e       	mov	r0, r31
    1bb6:	fb e2       	ldi	r31, 0x2B	; 43
    1bb8:	cf 2e       	mov	r12, r31
    1bba:	fc ef       	ldi	r31, 0xFC	; 252
    1bbc:	df 2e       	mov	r13, r31
    1bbe:	ff ef       	ldi	r31, 0xFF	; 255
    1bc0:	ef 2e       	mov	r14, r31
    1bc2:	ff ef       	ldi	r31, 0xFF	; 255
    1bc4:	ff 2e       	mov	r15, r31
    1bc6:	f0 2d       	mov	r31, r0
    1bc8:	c0 0e       	add	r12, r16
    1bca:	d1 1e       	adc	r13, r17
    1bcc:	e2 1e       	adc	r14, r18
    1bce:	f3 1e       	adc	r15, r19
    1bd0:	9d e7       	ldi	r25, 0x7D	; 125
    1bd2:	c9 16       	cp	r12, r25
    1bd4:	9b e0       	ldi	r25, 0x0B	; 11
    1bd6:	d9 06       	cpc	r13, r25
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	e9 06       	cpc	r14, r25
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	f9 06       	cpc	r15, r25
    1be0:	20 f4       	brcc	.+8      	; 0x1bea <Pwm_Start+0x7a>
	sgl_Prescaler=PWM_PRESCALER_8;
    1be2:	91 e0       	ldi	r25, 0x01	; 1
    1be4:	90 93 18 01 	sts	0x0118, r25
    1be8:	a5 c0       	rjmp	.+330    	; 0x1d34 <Pwm_Start+0x1c4>
else if(Frequncy <= 980 && Frequncy > 490)
    1bea:	0f 2e       	mov	r0, r31
    1bec:	f5 e1       	ldi	r31, 0x15	; 21
    1bee:	cf 2e       	mov	r12, r31
    1bf0:	fe ef       	ldi	r31, 0xFE	; 254
    1bf2:	df 2e       	mov	r13, r31
    1bf4:	ff ef       	ldi	r31, 0xFF	; 255
    1bf6:	ef 2e       	mov	r14, r31
    1bf8:	ff ef       	ldi	r31, 0xFF	; 255
    1bfa:	ff 2e       	mov	r15, r31
    1bfc:	f0 2d       	mov	r31, r0
    1bfe:	c0 0e       	add	r12, r16
    1c00:	d1 1e       	adc	r13, r17
    1c02:	e2 1e       	adc	r14, r18
    1c04:	f3 1e       	adc	r15, r19
    1c06:	9a ee       	ldi	r25, 0xEA	; 234
    1c08:	c9 16       	cp	r12, r25
    1c0a:	91 e0       	ldi	r25, 0x01	; 1
    1c0c:	d9 06       	cpc	r13, r25
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	e9 06       	cpc	r14, r25
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	f9 06       	cpc	r15, r25
    1c16:	20 f4       	brcc	.+8      	; 0x1c20 <Pwm_Start+0xb0>
	sgl_Prescaler=PWM_PRESCALER_32;
    1c18:	92 e0       	ldi	r25, 0x02	; 2
    1c1a:	90 93 18 01 	sts	0x0118, r25
    1c1e:	a1 c0       	rjmp	.+322    	; 0x1d62 <Pwm_Start+0x1f2>
else if(Frequncy <= 490 && Frequncy > 245)
    1c20:	0f 2e       	mov	r0, r31
    1c22:	fa e0       	ldi	r31, 0x0A	; 10
    1c24:	cf 2e       	mov	r12, r31
    1c26:	ff ef       	ldi	r31, 0xFF	; 255
    1c28:	df 2e       	mov	r13, r31
    1c2a:	ff ef       	ldi	r31, 0xFF	; 255
    1c2c:	ef 2e       	mov	r14, r31
    1c2e:	ff ef       	ldi	r31, 0xFF	; 255
    1c30:	ff 2e       	mov	r15, r31
    1c32:	f0 2d       	mov	r31, r0
    1c34:	c0 0e       	add	r12, r16
    1c36:	d1 1e       	adc	r13, r17
    1c38:	e2 1e       	adc	r14, r18
    1c3a:	f3 1e       	adc	r15, r19
    1c3c:	95 ef       	ldi	r25, 0xF5	; 245
    1c3e:	c9 16       	cp	r12, r25
    1c40:	d1 04       	cpc	r13, r1
    1c42:	e1 04       	cpc	r14, r1
    1c44:	f1 04       	cpc	r15, r1
    1c46:	20 f4       	brcc	.+8      	; 0x1c50 <Pwm_Start+0xe0>
	sgl_Prescaler=PWM_PRESCALER_64;
    1c48:	93 e0       	ldi	r25, 0x03	; 3
    1c4a:	90 93 18 01 	sts	0x0118, r25
    1c4e:	90 c0       	rjmp	.+288    	; 0x1d70 <Pwm_Start+0x200>
else if(Frequncy <= 245 && Frequncy > 122)
    1c50:	0f 2e       	mov	r0, r31
    1c52:	f5 e8       	ldi	r31, 0x85	; 133
    1c54:	cf 2e       	mov	r12, r31
    1c56:	ff ef       	ldi	r31, 0xFF	; 255
    1c58:	df 2e       	mov	r13, r31
    1c5a:	ff ef       	ldi	r31, 0xFF	; 255
    1c5c:	ef 2e       	mov	r14, r31
    1c5e:	ff ef       	ldi	r31, 0xFF	; 255
    1c60:	ff 2e       	mov	r15, r31
    1c62:	f0 2d       	mov	r31, r0
    1c64:	c0 0e       	add	r12, r16
    1c66:	d1 1e       	adc	r13, r17
    1c68:	e2 1e       	adc	r14, r18
    1c6a:	f3 1e       	adc	r15, r19
    1c6c:	9b e7       	ldi	r25, 0x7B	; 123
    1c6e:	c9 16       	cp	r12, r25
    1c70:	d1 04       	cpc	r13, r1
    1c72:	e1 04       	cpc	r14, r1
    1c74:	f1 04       	cpc	r15, r1
    1c76:	20 f4       	brcc	.+8      	; 0x1c80 <Pwm_Start+0x110>
	sgl_Prescaler=PWM_PRESCALER_128;
    1c78:	94 e0       	ldi	r25, 0x04	; 4
    1c7a:	90 93 18 01 	sts	0x0118, r25
    1c7e:	a5 c0       	rjmp	.+330    	; 0x1dca <Pwm_Start+0x25a>
else if(Frequncy <= 122 && Frequncy > 31)
    1c80:	0f 2e       	mov	r0, r31
    1c82:	f0 ee       	ldi	r31, 0xE0	; 224
    1c84:	cf 2e       	mov	r12, r31
    1c86:	ff ef       	ldi	r31, 0xFF	; 255
    1c88:	df 2e       	mov	r13, r31
    1c8a:	ff ef       	ldi	r31, 0xFF	; 255
    1c8c:	ef 2e       	mov	r14, r31
    1c8e:	ff ef       	ldi	r31, 0xFF	; 255
    1c90:	ff 2e       	mov	r15, r31
    1c92:	f0 2d       	mov	r31, r0
    1c94:	c0 0e       	add	r12, r16
    1c96:	d1 1e       	adc	r13, r17
    1c98:	e2 1e       	adc	r14, r18
    1c9a:	f3 1e       	adc	r15, r19
    1c9c:	9b e5       	ldi	r25, 0x5B	; 91
    1c9e:	c9 16       	cp	r12, r25
    1ca0:	d1 04       	cpc	r13, r1
    1ca2:	e1 04       	cpc	r14, r1
    1ca4:	f1 04       	cpc	r15, r1
    1ca6:	20 f4       	brcc	.+8      	; 0x1cb0 <Pwm_Start+0x140>
	sgl_Prescaler=PWM_PRESCALER_256;
    1ca8:	95 e0       	ldi	r25, 0x05	; 5
    1caa:	90 93 18 01 	sts	0x0118, r25
    1cae:	77 c0       	rjmp	.+238    	; 0x1d9e <Pwm_Start+0x22e>
else if(Frequncy <= 31 && Frequncy > 0)
    1cb0:	01 50       	subi	r16, 0x01	; 1
    1cb2:	10 40       	sbci	r17, 0x00	; 0
    1cb4:	20 40       	sbci	r18, 0x00	; 0
    1cb6:	30 40       	sbci	r19, 0x00	; 0
    1cb8:	0f 31       	cpi	r16, 0x1F	; 31
    1cba:	11 05       	cpc	r17, r1
    1cbc:	21 05       	cpc	r18, r1
    1cbe:	31 05       	cpc	r19, r1
    1cc0:	20 f4       	brcc	.+8      	; 0x1cca <Pwm_Start+0x15a>
	sgl_Prescaler=PWM_PRESCALER_1024;
    1cc2:	96 e0       	ldi	r25, 0x06	; 6
    1cc4:	90 93 18 01 	sts	0x0118, r25
    1cc8:	86 c0       	rjmp	.+268    	; 0x1dd6 <Pwm_Start+0x266>
else{Ret=E_NOK;}
switch(sgl_Prescaler)
    1cca:	90 91 18 01 	lds	r25, 0x0118
    1cce:	93 30       	cpi	r25, 0x03	; 3
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <Pwm_Start+0x164>
    1cd2:	4e c0       	rjmp	.+156    	; 0x1d70 <Pwm_Start+0x200>
    1cd4:	94 30       	cpi	r25, 0x04	; 4
    1cd6:	30 f4       	brcc	.+12     	; 0x1ce4 <Pwm_Start+0x174>
    1cd8:	91 30       	cpi	r25, 0x01	; 1
    1cda:	61 f1       	breq	.+88     	; 0x1d34 <Pwm_Start+0x1c4>
    1cdc:	92 30       	cpi	r25, 0x02	; 2
    1cde:	08 f0       	brcs	.+2      	; 0x1ce2 <Pwm_Start+0x172>
    1ce0:	40 c0       	rjmp	.+128    	; 0x1d62 <Pwm_Start+0x1f2>
    1ce2:	0a c0       	rjmp	.+20     	; 0x1cf8 <Pwm_Start+0x188>
    1ce4:	95 30       	cpi	r25, 0x05	; 5
    1ce6:	09 f4       	brne	.+2      	; 0x1cea <Pwm_Start+0x17a>
    1ce8:	5a c0       	rjmp	.+180    	; 0x1d9e <Pwm_Start+0x22e>
    1cea:	95 30       	cpi	r25, 0x05	; 5
    1cec:	08 f4       	brcc	.+2      	; 0x1cf0 <Pwm_Start+0x180>
    1cee:	6d c0       	rjmp	.+218    	; 0x1dca <Pwm_Start+0x25a>
    1cf0:	96 30       	cpi	r25, 0x06	; 6
    1cf2:	09 f0       	breq	.+2      	; 0x1cf6 <Pwm_Start+0x186>
    1cf4:	8d c0       	rjmp	.+282    	; 0x1e10 <Pwm_Start+0x2a0>
    1cf6:	6f c0       	rjmp	.+222    	; 0x1dd6 <Pwm_Start+0x266>
{
	case PWM_PRESCALER_NO:
	{
		switch(Channel)
    1cf8:	81 30       	cpi	r24, 0x01	; 1
    1cfa:	61 f0       	breq	.+24     	; 0x1d14 <Pwm_Start+0x1a4>
    1cfc:	81 30       	cpi	r24, 0x01	; 1
    1cfe:	30 f0       	brcs	.+12     	; 0x1d0c <Pwm_Start+0x19c>
    1d00:	82 30       	cpi	r24, 0x02	; 2
    1d02:	71 f0       	breq	.+28     	; 0x1d20 <Pwm_Start+0x1b0>
    1d04:	83 30       	cpi	r24, 0x03	; 3
    1d06:	09 f0       	breq	.+2      	; 0x1d0a <Pwm_Start+0x19a>
    1d08:	83 c0       	rjmp	.+262    	; 0x1e10 <Pwm_Start+0x2a0>
    1d0a:	10 c0       	rjmp	.+32     	; 0x1d2c <Pwm_Start+0x1bc>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_NO_CONFIG;
    1d0c:	83 b7       	in	r24, 0x33	; 51
    1d0e:	81 60       	ori	r24, 0x01	; 1
    1d10:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d12:	88 c0       	rjmp	.+272    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			{
			TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1d14:	8e b5       	in	r24, 0x2e	; 46
    1d16:	9f b5       	in	r25, 0x2f	; 47
    1d18:	81 60       	ori	r24, 0x01	; 1
    1d1a:	9f bd       	out	0x2f, r25	; 47
    1d1c:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
			break;
    1d1e:	98 c0       	rjmp	.+304    	; 0x1e50 <Pwm_Start+0x2e0>
			}			
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1d20:	8e b5       	in	r24, 0x2e	; 46
    1d22:	9f b5       	in	r25, 0x2f	; 47
    1d24:	81 60       	ori	r24, 0x01	; 1
    1d26:	9f bd       	out	0x2f, r25	; 47
    1d28:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1d2a:	ad c0       	rjmp	.+346    	; 0x1e86 <Pwm_Start+0x316>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_NO_CONFIG;
    1d2c:	85 b5       	in	r24, 0x25	; 37
    1d2e:	81 60       	ori	r24, 0x01	; 1
    1d30:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d32:	c4 c0       	rjmp	.+392    	; 0x1ebc <Pwm_Start+0x34c>
	}

	
	case PWM_PRESCALER_8:
	{
		switch(Channel)
    1d34:	83 30       	cpi	r24, 0x03	; 3
    1d36:	18 f4       	brcc	.+6      	; 0x1d3e <Pwm_Start+0x1ce>
    1d38:	81 30       	cpi	r24, 0x01	; 1
    1d3a:	48 f4       	brcc	.+18     	; 0x1d4e <Pwm_Start+0x1de>
    1d3c:	04 c0       	rjmp	.+8      	; 0x1d46 <Pwm_Start+0x1d6>
    1d3e:	83 30       	cpi	r24, 0x03	; 3
    1d40:	09 f0       	breq	.+2      	; 0x1d44 <Pwm_Start+0x1d4>
    1d42:	66 c0       	rjmp	.+204    	; 0x1e10 <Pwm_Start+0x2a0>
    1d44:	0a c0       	rjmp	.+20     	; 0x1d5a <Pwm_Start+0x1ea>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_8_CONFIG;
    1d46:	83 b7       	in	r24, 0x33	; 51
    1d48:	82 60       	ori	r24, 0x02	; 2
    1d4a:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d4c:	6b c0       	rjmp	.+214    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_8_CONFIG;
    1d4e:	2e b5       	in	r18, 0x2e	; 46
    1d50:	3f b5       	in	r19, 0x2f	; 47
    1d52:	22 60       	ori	r18, 0x02	; 2
    1d54:	3f bd       	out	0x2f, r19	; 47
    1d56:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1d58:	5b c0       	rjmp	.+182    	; 0x1e10 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_8_CONFIG;
    1d5a:	85 b5       	in	r24, 0x25	; 37
    1d5c:	82 60       	ori	r24, 0x02	; 2
    1d5e:	85 bd       	out	0x25, r24	; 37
			Ret=E_OK;	
				break;
    1d60:	ad c0       	rjmp	.+346    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_32:
	{
		switch(Channel)
    1d62:	83 30       	cpi	r24, 0x03	; 3
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <Pwm_Start+0x1f8>
    1d66:	54 c0       	rjmp	.+168    	; 0x1e10 <Pwm_Start+0x2a0>
		{
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_32_CONFIG_T2;
    1d68:	85 b5       	in	r24, 0x25	; 37
    1d6a:	83 60       	ori	r24, 0x03	; 3
    1d6c:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d6e:	a6 c0       	rjmp	.+332    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_64:
	{
		switch(Channel)
    1d70:	83 30       	cpi	r24, 0x03	; 3
    1d72:	18 f4       	brcc	.+6      	; 0x1d7a <Pwm_Start+0x20a>
    1d74:	81 30       	cpi	r24, 0x01	; 1
    1d76:	48 f4       	brcc	.+18     	; 0x1d8a <Pwm_Start+0x21a>
    1d78:	04 c0       	rjmp	.+8      	; 0x1d82 <Pwm_Start+0x212>
    1d7a:	83 30       	cpi	r24, 0x03	; 3
    1d7c:	09 f0       	breq	.+2      	; 0x1d80 <Pwm_Start+0x210>
    1d7e:	48 c0       	rjmp	.+144    	; 0x1e10 <Pwm_Start+0x2a0>
    1d80:	0a c0       	rjmp	.+20     	; 0x1d96 <Pwm_Start+0x226>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_64_CONFIG;
    1d82:	83 b7       	in	r24, 0x33	; 51
    1d84:	83 60       	ori	r24, 0x03	; 3
    1d86:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d88:	4d c0       	rjmp	.+154    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_64_CONFIG;
    1d8a:	2e b5       	in	r18, 0x2e	; 46
    1d8c:	3f b5       	in	r19, 0x2f	; 47
    1d8e:	23 60       	ori	r18, 0x03	; 3
    1d90:	3f bd       	out	0x2f, r19	; 47
    1d92:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1d94:	3d c0       	rjmp	.+122    	; 0x1e10 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_64_CONFIG_T2;
    1d96:	85 b5       	in	r24, 0x25	; 37
    1d98:	84 60       	ori	r24, 0x04	; 4
    1d9a:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d9c:	8f c0       	rjmp	.+286    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_256:
	{
		switch(Channel)
    1d9e:	83 30       	cpi	r24, 0x03	; 3
    1da0:	18 f4       	brcc	.+6      	; 0x1da8 <Pwm_Start+0x238>
    1da2:	81 30       	cpi	r24, 0x01	; 1
    1da4:	40 f4       	brcc	.+16     	; 0x1db6 <Pwm_Start+0x246>
    1da6:	03 c0       	rjmp	.+6      	; 0x1dae <Pwm_Start+0x23e>
    1da8:	83 30       	cpi	r24, 0x03	; 3
    1daa:	91 f5       	brne	.+100    	; 0x1e10 <Pwm_Start+0x2a0>
    1dac:	0a c0       	rjmp	.+20     	; 0x1dc2 <Pwm_Start+0x252>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_64_CONFIG;
    1dae:	83 b7       	in	r24, 0x33	; 51
    1db0:	83 60       	ori	r24, 0x03	; 3
    1db2:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1db4:	37 c0       	rjmp	.+110    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_64_CONFIG;
    1db6:	2e b5       	in	r18, 0x2e	; 46
    1db8:	3f b5       	in	r19, 0x2f	; 47
    1dba:	23 60       	ori	r18, 0x03	; 3
    1dbc:	3f bd       	out	0x2f, r19	; 47
    1dbe:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1dc0:	27 c0       	rjmp	.+78     	; 0x1e10 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_64_CONFIG_T2;
    1dc2:	85 b5       	in	r24, 0x25	; 37
    1dc4:	84 60       	ori	r24, 0x04	; 4
    1dc6:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1dc8:	79 c0       	rjmp	.+242    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_128:
	{
		switch(Channel)
    1dca:	83 30       	cpi	r24, 0x03	; 3
    1dcc:	09 f5       	brne	.+66     	; 0x1e10 <Pwm_Start+0x2a0>
		{
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_128_CONFIG_T2;
    1dce:	85 b5       	in	r24, 0x25	; 37
    1dd0:	85 60       	ori	r24, 0x05	; 5
    1dd2:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1dd4:	73 c0       	rjmp	.+230    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_1024:
	{
		switch(Channel)
    1dd6:	81 30       	cpi	r24, 0x01	; 1
    1dd8:	59 f0       	breq	.+22     	; 0x1df0 <Pwm_Start+0x280>
    1dda:	81 30       	cpi	r24, 0x01	; 1
    1ddc:	28 f0       	brcs	.+10     	; 0x1de8 <Pwm_Start+0x278>
    1dde:	82 30       	cpi	r24, 0x02	; 2
    1de0:	69 f0       	breq	.+26     	; 0x1dfc <Pwm_Start+0x28c>
    1de2:	83 30       	cpi	r24, 0x03	; 3
    1de4:	a9 f4       	brne	.+42     	; 0x1e10 <Pwm_Start+0x2a0>
    1de6:	10 c0       	rjmp	.+32     	; 0x1e08 <Pwm_Start+0x298>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_1024_CONFIG;
    1de8:	83 b7       	in	r24, 0x33	; 51
    1dea:	85 60       	ori	r24, 0x05	; 5
    1dec:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1dee:	1a c0       	rjmp	.+52     	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			{	TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1df0:	8e b5       	in	r24, 0x2e	; 46
    1df2:	9f b5       	in	r25, 0x2f	; 47
    1df4:	81 60       	ori	r24, 0x01	; 1
    1df6:	9f bd       	out	0x2f, r25	; 47
    1df8:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1dfa:	2a c0       	rjmp	.+84     	; 0x1e50 <Pwm_Start+0x2e0>
			}
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_1024_CONFIG;
    1dfc:	8e b5       	in	r24, 0x2e	; 46
    1dfe:	9f b5       	in	r25, 0x2f	; 47
    1e00:	85 60       	ori	r24, 0x05	; 5
    1e02:	9f bd       	out	0x2f, r25	; 47
    1e04:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1e06:	3f c0       	rjmp	.+126    	; 0x1e86 <Pwm_Start+0x316>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_1024_CONFIG_T2;
    1e08:	85 b5       	in	r24, 0x25	; 37
    1e0a:	87 60       	ori	r24, 0x07	; 7
    1e0c:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1e0e:	56 c0       	rjmp	.+172    	; 0x1ebc <Pwm_Start+0x34c>

	
	
}

switch(Channel)
    1e10:	81 30       	cpi	r24, 0x01	; 1
    1e12:	f1 f0       	breq	.+60     	; 0x1e50 <Pwm_Start+0x2e0>
    1e14:	81 30       	cpi	r24, 0x01	; 1
    1e16:	30 f0       	brcs	.+12     	; 0x1e24 <Pwm_Start+0x2b4>
    1e18:	82 30       	cpi	r24, 0x02	; 2
    1e1a:	a9 f1       	breq	.+106    	; 0x1e86 <Pwm_Start+0x316>
    1e1c:	83 30       	cpi	r24, 0x03	; 3
    1e1e:	09 f0       	breq	.+2      	; 0x1e22 <Pwm_Start+0x2b2>
    1e20:	63 c0       	rjmp	.+198    	; 0x1ee8 <Pwm_Start+0x378>
    1e22:	4c c0       	rjmp	.+152    	; 0x1ebc <Pwm_Start+0x34c>
		{
			case PWM_CH0:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	80 e0       	ldi	r24, 0x00	; 0
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	0e 94 4e 29 	call	0x529c	; 0x529c <__floatunsisf>
    1e2e:	20 e0       	ldi	r18, 0x00	; 0
    1e30:	30 e0       	ldi	r19, 0x00	; 0
    1e32:	48 ec       	ldi	r20, 0xC8	; 200
    1e34:	52 e4       	ldi	r21, 0x42	; 66
    1e36:	0e 94 ba 28 	call	0x5174	; 0x5174 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1e3a:	20 e0       	ldi	r18, 0x00	; 0
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	4f e7       	ldi	r20, 0x7F	; 127
    1e40:	53 e4       	ldi	r21, 0x43	; 67
    1e42:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <__mulsf3>
    1e46:	0e 94 22 29 	call	0x5244	; 0x5244 <__fixunssfsi>
			OCR0=pwm_time_on;
    1e4a:	6c bf       	out	0x3c, r22	; 60
			Ret=E_OK;
    1e4c:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1e4e:	4d c0       	rjmp	.+154    	; 0x1eea <Pwm_Start+0x37a>
			}			
			case PWM_CH1A:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1e50:	70 e0       	ldi	r23, 0x00	; 0
    1e52:	80 e0       	ldi	r24, 0x00	; 0
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	0e 94 4e 29 	call	0x529c	; 0x529c <__floatunsisf>
    1e5a:	20 e0       	ldi	r18, 0x00	; 0
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	48 ec       	ldi	r20, 0xC8	; 200
    1e60:	52 e4       	ldi	r21, 0x42	; 66
    1e62:	0e 94 ba 28 	call	0x5174	; 0x5174 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1e66:	20 e0       	ldi	r18, 0x00	; 0
    1e68:	30 e0       	ldi	r19, 0x00	; 0
    1e6a:	4f e7       	ldi	r20, 0x7F	; 127
    1e6c:	53 e4       	ldi	r21, 0x43	; 67
    1e6e:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <__mulsf3>
    1e72:	0e 94 22 29 	call	0x5244	; 0x5244 <__fixunssfsi>
    1e76:	dc 01       	movw	r26, r24
    1e78:	cb 01       	movw	r24, r22
			OCR1A=pwm_time_on;
    1e7a:	9b bd       	out	0x2b, r25	; 43
    1e7c:	8a bd       	out	0x2a, r24	; 42
			OCR1B=pwm_time_on;
    1e7e:	99 bd       	out	0x29, r25	; 41
    1e80:	88 bd       	out	0x28, r24	; 40
			Ret=E_OK;
    1e82:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1e84:	32 c0       	rjmp	.+100    	; 0x1eea <Pwm_Start+0x37a>
			}			
			case PWM_CH1B:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1e86:	70 e0       	ldi	r23, 0x00	; 0
    1e88:	80 e0       	ldi	r24, 0x00	; 0
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	0e 94 4e 29 	call	0x529c	; 0x529c <__floatunsisf>
    1e90:	20 e0       	ldi	r18, 0x00	; 0
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	48 ec       	ldi	r20, 0xC8	; 200
    1e96:	52 e4       	ldi	r21, 0x42	; 66
    1e98:	0e 94 ba 28 	call	0x5174	; 0x5174 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1e9c:	20 e0       	ldi	r18, 0x00	; 0
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	4f e7       	ldi	r20, 0x7F	; 127
    1ea2:	53 e4       	ldi	r21, 0x43	; 67
    1ea4:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <__mulsf3>
    1ea8:	0e 94 22 29 	call	0x5244	; 0x5244 <__fixunssfsi>
    1eac:	dc 01       	movw	r26, r24
    1eae:	cb 01       	movw	r24, r22
			OCR1A=pwm_time_on;
    1eb0:	9b bd       	out	0x2b, r25	; 43
    1eb2:	8a bd       	out	0x2a, r24	; 42
			OCR1B=pwm_time_on;
    1eb4:	99 bd       	out	0x29, r25	; 41
    1eb6:	88 bd       	out	0x28, r24	; 40
			Ret=E_OK;
    1eb8:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1eba:	17 c0       	rjmp	.+46     	; 0x1eea <Pwm_Start+0x37a>
			}
			case PWM_CH2:{
			pwm_time_on=MAX_HOLD;	
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1ebc:	70 e0       	ldi	r23, 0x00	; 0
    1ebe:	80 e0       	ldi	r24, 0x00	; 0
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	0e 94 4e 29 	call	0x529c	; 0x529c <__floatunsisf>
    1ec6:	20 e0       	ldi	r18, 0x00	; 0
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	48 ec       	ldi	r20, 0xC8	; 200
    1ecc:	52 e4       	ldi	r21, 0x42	; 66
    1ece:	0e 94 ba 28 	call	0x5174	; 0x5174 <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1ed2:	20 e0       	ldi	r18, 0x00	; 0
    1ed4:	30 e0       	ldi	r19, 0x00	; 0
    1ed6:	4f e7       	ldi	r20, 0x7F	; 127
    1ed8:	53 e4       	ldi	r21, 0x43	; 67
    1eda:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <__mulsf3>
    1ede:	0e 94 22 29 	call	0x5244	; 0x5244 <__fixunssfsi>
			OCR2=pwm_time_on;
    1ee2:	63 bd       	out	0x23, r22	; 35
			Ret=E_OK;
    1ee4:	80 e0       	ldi	r24, 0x00	; 0
			}			
			break;
    1ee6:	01 c0       	rjmp	.+2      	; 0x1eea <Pwm_Start+0x37a>
			default:
			Ret=E_NOK;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
sgl_is_started=1;
    1eea:	91 e0       	ldi	r25, 0x01	; 1
    1eec:	90 93 19 01 	sts	0x0119, r25
return Ret;
}
    1ef0:	1f 91       	pop	r17
    1ef2:	0f 91       	pop	r16
    1ef4:	ff 90       	pop	r15
    1ef6:	ef 90       	pop	r14
    1ef8:	df 90       	pop	r13
    1efa:	cf 90       	pop	r12
    1efc:	08 95       	ret

00001efe <Pwm_Update>:


ERROR_STATUS Pwm_Update(uint8_t Channel,uint8_t Duty,uint32_t Frequncy)
{
uint8_t Ret=0;
if (sgl_is_started == 1)
    1efe:	90 91 19 01 	lds	r25, 0x0119
    1f02:	91 30       	cpi	r25, 0x01	; 1
    1f04:	21 f4       	brne	.+8      	; 0x1f0e <Pwm_Update+0x10>
{
	Pwm_Start( Channel,Duty,Frequncy);
    1f06:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
Ret=E_OK;
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	08 95       	ret
}else{Ret=E_NOK;}
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
	

return Ret;
}
    1f10:	08 95       	ret

00001f12 <Pwm_Stop>:
/*********************************************************************************/

ERROR_STATUS Pwm_Stop(uint8_t Channel)
{
uint8_t Ret=0;
switch(Channel)
    1f12:	83 30       	cpi	r24, 0x03	; 3
    1f14:	18 f4       	brcc	.+6      	; 0x1f1c <Pwm_Stop+0xa>
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	48 f4       	brcc	.+18     	; 0x1f2c <Pwm_Stop+0x1a>
    1f1a:	03 c0       	rjmp	.+6      	; 0x1f22 <Pwm_Stop+0x10>
    1f1c:	83 30       	cpi	r24, 0x03	; 3
    1f1e:	81 f4       	brne	.+32     	; 0x1f40 <Pwm_Stop+0x2e>
    1f20:	0a c0       	rjmp	.+20     	; 0x1f36 <Pwm_Stop+0x24>
{
	case PWM_CH0:
	TCCR0 &=TIMER_STOPT02;
    1f22:	83 b7       	in	r24, 0x33	; 51
    1f24:	88 7f       	andi	r24, 0xF8	; 248
    1f26:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
    1f28:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1f2a:	08 95       	ret

	case PWM_CH1A:
	case PWM_CH1B:
	TCCR0 &=TIMER_STOPT1;
    1f2c:	83 b7       	in	r24, 0x33	; 51
    1f2e:	88 7f       	andi	r24, 0xF8	; 248
    1f30:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
    1f32:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1f34:	08 95       	ret


	case PWM_CH2:
	TCCR2 &=TIMER_STOPT02;
    1f36:	85 b5       	in	r24, 0x25	; 37
    1f38:	88 7f       	andi	r24, 0xF8	; 248
    1f3a:	85 bd       	out	0x25, r24	; 37
	Ret=E_OK;
    1f3c:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1f3e:	08 95       	ret
	default:
	Ret=E_NOK;
    1f40:	81 e0       	ldi	r24, 0x01	; 1
	break;
}

return Ret;
}
    1f42:	08 95       	ret

00001f44 <Timer_Init>:
 *
 */
 static uint8_t prescaler_value=0;
 
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{uint8_t Ret=E_OK;
    1f44:	1f 93       	push	r17
    1f46:	cf 93       	push	r28
    1f48:	df 93       	push	r29
    1f4a:	ec 01       	movw	r28, r24
prescaler_value=Timer_cfg->Timer_Prescaler;
    1f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4e:	80 93 1a 01 	sts	0x011A, r24
if (Timer_cfg==NULL)
    1f52:	20 97       	sbiw	r28, 0x00	; 0
    1f54:	11 f0       	breq	.+4      	; 0x1f5a <Timer_Init+0x16>
 *
 */
 static uint8_t prescaler_value=0;
 
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{uint8_t Ret=E_OK;
    1f56:	10 e0       	ldi	r17, 0x00	; 0
    1f58:	01 c0       	rjmp	.+2      	; 0x1f5c <Timer_Init+0x18>
prescaler_value=Timer_cfg->Timer_Prescaler;
if (Timer_cfg==NULL)
{
	Ret=TIMER_MODULE+NULL_PTR;
    1f5a:	10 e2       	ldi	r17, 0x20	; 32
}
switch (Timer_cfg->Timer_CH_NO) {
    1f5c:	88 81       	ld	r24, Y
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <Timer_Init+0x20>
    1f62:	4c c0       	rjmp	.+152    	; 0x1ffc <Timer_Init+0xb8>
    1f64:	81 30       	cpi	r24, 0x01	; 1
    1f66:	20 f0       	brcs	.+8      	; 0x1f70 <Timer_Init+0x2c>
    1f68:	82 30       	cpi	r24, 0x02	; 2
    1f6a:	09 f0       	breq	.+2      	; 0x1f6e <Timer_Init+0x2a>
    1f6c:	d8 c0       	rjmp	.+432    	; 0x211e <Timer_Init+0x1da>
    1f6e:	93 c0       	rjmp	.+294    	; 0x2096 <Timer_Init+0x152>
/*************************************************************************/
/*                             TIMER 0                                   */
/*************************************************************************/
    case TIMER_CH0:
        {
  TCCR0 |=T0_NORMAL_MODE;
    1f70:	83 b7       	in	r24, 0x33	; 51
    1f72:	83 bf       	out	0x33, r24	; 51
  
          switch (Timer_cfg->Timer_Mode) {
    1f74:	89 81       	ldd	r24, Y+1	; 0x01
    1f76:	81 30       	cpi	r24, 0x01	; 1
    1f78:	b9 f0       	breq	.+46     	; 0x1fa8 <Timer_Init+0x64>
    1f7a:	81 30       	cpi	r24, 0x01	; 1
    1f7c:	18 f0       	brcs	.+6      	; 0x1f84 <Timer_Init+0x40>
    1f7e:	82 30       	cpi	r24, 0x02	; 2
    1f80:	e1 f5       	brne	.+120    	; 0x1ffa <Timer_Init+0xb6>
    1f82:	26 c0       	rjmp	.+76     	; 0x1fd0 <Timer_Init+0x8c>
          case TIMER_MODE:
              {
                switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    1f84:	8a 81       	ldd	r24, Y+2	; 0x02
    1f86:	88 23       	and	r24, r24
    1f88:	19 f0       	breq	.+6      	; 0x1f90 <Timer_Init+0x4c>
    1f8a:	81 30       	cpi	r24, 0x01	; 1
    1f8c:	59 f4       	brne	.+22     	; 0x1fa4 <Timer_Init+0x60>
    1f8e:	04 c0       	rjmp	.+8      	; 0x1f98 <Timer_Init+0x54>
				{
                    case TIMER_POLLING_MODE:
                        {/*Disable interrupts for T0 without effecting any other timer*/
                         /*without Disabling Global interrupt*/
                        TIMSK &=T0_INTERRUPT_DISABLE;
    1f90:	89 b7       	in	r24, 0x39	; 57
    1f92:	8c 7f       	andi	r24, 0xFC	; 252
    1f94:	89 bf       	out	0x39, r24	; 57
                            break;
    1f96:	32 c0       	rjmp	.+100    	; 0x1ffc <Timer_Init+0xb8>
                         }
                                  case TIMER_INTERRUPT_MODE:
                                  { /*Enable Global INTERRUPT
                                    Enable Timer0 interrupt
                                    */
                                    G_interrupt_Enable();
    1f98:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                                    TIMSK |= T0_INTERRUPT_NORMAL;
    1f9c:	89 b7       	in	r24, 0x39	; 57
    1f9e:	81 60       	ori	r24, 0x01	; 1
    1fa0:	89 bf       	out	0x39, r24	; 57
                                    break;
    1fa2:	2c c0       	rjmp	.+88     	; 0x1ffc <Timer_Init+0xb8>
                                  }
                                  default :
                                  Ret+=E_NOK;
    1fa4:	1f 5f       	subi	r17, 0xFF	; 255
								  break;
    1fa6:	2a c0       	rjmp	.+84     	; 0x1ffc <Timer_Init+0xb8>
/*                             TIMER 0 As a COUNTER_RISING_MODE          */
/*************************************************************************/

                          case COUNTER_RISING_MODE:
                            {
                                  TCCR0 |=T0_COUNTER_RISING_MODE_CONFIG;
    1fa8:	83 b7       	in	r24, 0x33	; 51
    1faa:	8d 60       	ori	r24, 0x0D	; 13
    1fac:	83 bf       	out	0x33, r24	; 51
                                    switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1fae:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb0:	88 23       	and	r24, r24
    1fb2:	19 f0       	breq	.+6      	; 0x1fba <Timer_Init+0x76>
    1fb4:	81 30       	cpi	r24, 0x01	; 1
    1fb6:	59 f4       	brne	.+22     	; 0x1fce <Timer_Init+0x8a>
    1fb8:	04 c0       	rjmp	.+8      	; 0x1fc2 <Timer_Init+0x7e>
                                        case TIMER_POLLING_MODE:
                                          {
            /*Disable interrupts for T0 without effecting any other timer*/
              /*without Disabling Global interrupt*/
                                            TIMSK &=T0_INTERRUPT_DISABLE;
    1fba:	89 b7       	in	r24, 0x39	; 57
    1fbc:	8c 7f       	andi	r24, 0xFC	; 252
    1fbe:	89 bf       	out	0x39, r24	; 57
                                            break;
    1fc0:	07 c0       	rjmp	.+14     	; 0x1fd0 <Timer_Init+0x8c>

                                          case TIMER_INTERRUPT_MODE:
                                           /*Enable Global INTERRUPT
                                              Enable Timer0 interrupt
                                              */
                                              G_interrupt_Enable();
    1fc2:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                                              TIMSK |= T0_INTERRUPT_NORMAL;
    1fc6:	89 b7       	in	r24, 0x39	; 57
    1fc8:	81 60       	ori	r24, 0x01	; 1
    1fca:	89 bf       	out	0x39, r24	; 57
                                              break;
    1fcc:	01 c0       	rjmp	.+2      	; 0x1fd0 <Timer_Init+0x8c>

                                          default :
                                          Ret+=E_NOK;
    1fce:	1f 5f       	subi	r17, 0xFF	; 255
/*                             TIMER 0 As a COUNTER_FALLING_MODE         */
/*************************************************************************/

                                    case COUNTER_FALLING_MODE:
                                    {
                                        TCCR0 |=T0_COUNTER_FALLING_MODE_CONFIG;
    1fd0:	83 b7       	in	r24, 0x33	; 51
    1fd2:	8c 60       	ori	r24, 0x0C	; 12
    1fd4:	83 bf       	out	0x33, r24	; 51
                                          switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fd8:	88 23       	and	r24, r24
    1fda:	19 f0       	breq	.+6      	; 0x1fe2 <Timer_Init+0x9e>
    1fdc:	81 30       	cpi	r24, 0x01	; 1
    1fde:	59 f4       	brne	.+22     	; 0x1ff6 <Timer_Init+0xb2>
    1fe0:	04 c0       	rjmp	.+8      	; 0x1fea <Timer_Init+0xa6>
                                              case TIMER_POLLING_MODE:
                                                {

            /*Disable interrupts for T0 without effecting any other timer*/
                /*without Disabling Global interrupt*/
                                                  TIMSK &=T0_INTERRUPT_DISABLE;
    1fe2:	89 b7       	in	r24, 0x39	; 57
    1fe4:	8c 7f       	andi	r24, 0xFC	; 252
    1fe6:	89 bf       	out	0x39, r24	; 57

                                                  break;
    1fe8:	09 c0       	rjmp	.+18     	; 0x1ffc <Timer_Init+0xb8>
                                                case TIMER_INTERRUPT_MODE:
                                                  {
                                                    /*Enable Global INTERRUPT
                                                    Enable Timer0 interrupt
                                                    */
                                                    G_interrupt_Enable();
    1fea:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                                                    TIMSK |= T0_INTERRUPT_NORMAL;
    1fee:	89 b7       	in	r24, 0x39	; 57
    1ff0:	81 60       	ori	r24, 0x01	; 1
    1ff2:	89 bf       	out	0x39, r24	; 57

                                                    break;
    1ff4:	03 c0       	rjmp	.+6      	; 0x1ffc <Timer_Init+0xb8>
                                                  }
                                                  default:
                                                  Ret+=E_NOK;
    1ff6:	1f 5f       	subi	r17, 0xFF	; 255
												  break;
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <Timer_Init+0xb8>
                                                }
                                      break;
                                      }
                                      default:
                                      Ret+=E_NOK;
    1ffa:	1f 5f       	subi	r17, 0xFF	; 255
/*************************************************************************/

    case TIMER_CH1:
        {

    switch (Timer_cfg->Timer_Mode)
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	81 30       	cpi	r24, 0x01	; 1
    2000:	d1 f0       	breq	.+52     	; 0x2036 <Timer_Init+0xf2>
    2002:	81 30       	cpi	r24, 0x01	; 1
    2004:	20 f0       	brcs	.+8      	; 0x200e <Timer_Init+0xca>
    2006:	82 30       	cpi	r24, 0x02	; 2
    2008:	09 f0       	breq	.+2      	; 0x200c <Timer_Init+0xc8>
    200a:	43 c0       	rjmp	.+134    	; 0x2092 <Timer_Init+0x14e>
    200c:	2b c0       	rjmp	.+86     	; 0x2064 <Timer_Init+0x120>
    {
      case TIMER_MODE:
      {
        TCCR1 = T1_NORMAL_MODE_CONFIG;
    200e:	1f bc       	out	0x2f, r1	; 47
    2010:	1e bc       	out	0x2e, r1	; 46
              switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    2012:	8a 81       	ldd	r24, Y+2	; 0x02
    2014:	88 23       	and	r24, r24
    2016:	19 f0       	breq	.+6      	; 0x201e <Timer_Init+0xda>
    2018:	81 30       	cpi	r24, 0x01	; 1
    201a:	59 f4       	brne	.+22     	; 0x2032 <Timer_Init+0xee>
    201c:	04 c0       	rjmp	.+8      	; 0x2026 <Timer_Init+0xe2>
              case TIMER_POLLING_MODE:
                {
                  /*Disable interrupts for T1 without effecting any other timer*/
                   /*without Disabling Global interrupt*/
                  TIMSK &=T1_INTERRUPT_DISABLE;
    201e:	89 b7       	in	r24, 0x39	; 57
    2020:	83 7c       	andi	r24, 0xC3	; 195
    2022:	89 bf       	out	0x39, r24	; 57

                break;
    2024:	7c c0       	rjmp	.+248    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2026:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    202a:	89 b7       	in	r24, 0x39	; 57
    202c:	84 60       	ori	r24, 0x04	; 4
    202e:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */
                break;
    2030:	76 c0       	rjmp	.+236    	; 0x211e <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    2032:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    2034:	74 c0       	rjmp	.+232    	; 0x211e <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_RISING_MODE:
      {
            TCCR1|=T1_COUNTER_RISING_MODE_CONFIG;
    2036:	8e b5       	in	r24, 0x2e	; 46
    2038:	9f b5       	in	r25, 0x2f	; 47
    203a:	87 60       	ori	r24, 0x07	; 7
    203c:	9f bd       	out	0x2f, r25	; 47
    203e:	8e bd       	out	0x2e, r24	; 46

            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    2040:	8a 81       	ldd	r24, Y+2	; 0x02
    2042:	88 23       	and	r24, r24
    2044:	19 f0       	breq	.+6      	; 0x204c <Timer_Init+0x108>
    2046:	81 30       	cpi	r24, 0x01	; 1
    2048:	59 f4       	brne	.+22     	; 0x2060 <Timer_Init+0x11c>
    204a:	04 c0       	rjmp	.+8      	; 0x2054 <Timer_Init+0x110>
              case TIMER_POLLING_MODE:
              {
                /*Disable interrupts for T1 without effecting any other timer*/
                 /*without Disabling Global interrupt*/
                TIMSK &=T1_INTERRUPT_DISABLE;
    204c:	89 b7       	in	r24, 0x39	; 57
    204e:	83 7c       	andi	r24, 0xC3	; 195
    2050:	89 bf       	out	0x39, r24	; 57

                break;
    2052:	65 c0       	rjmp	.+202    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2054:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    2058:	89 b7       	in	r24, 0x39	; 57
    205a:	84 60       	ori	r24, 0x04	; 4
    205c:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */
                break;
    205e:	5f c0       	rjmp	.+190    	; 0x211e <Timer_Init+0x1da>
              }
              default:
              Ret+=E_NOK;
    2060:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    2062:	5d c0       	rjmp	.+186    	; 0x211e <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_FALLING_MODE:
      {
            TCCR1|=T1_COUNTER_FALLING_MODE_CONFIG;
    2064:	8e b5       	in	r24, 0x2e	; 46
    2066:	9f b5       	in	r25, 0x2f	; 47
    2068:	86 60       	ori	r24, 0x06	; 6
    206a:	9f bd       	out	0x2f, r25	; 47
    206c:	8e bd       	out	0x2e, r24	; 46
            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    206e:	8a 81       	ldd	r24, Y+2	; 0x02
    2070:	88 23       	and	r24, r24
    2072:	19 f0       	breq	.+6      	; 0x207a <Timer_Init+0x136>
    2074:	81 30       	cpi	r24, 0x01	; 1
    2076:	59 f4       	brne	.+22     	; 0x208e <Timer_Init+0x14a>
    2078:	04 c0       	rjmp	.+8      	; 0x2082 <Timer_Init+0x13e>
              case TIMER_POLLING_MODE:
              {
                /*Disable interrupts for T1 without effecting any other timer*/
                 /*without Disabling Global interrupt*/
                TIMSK &=T1_INTERRUPT_DISABLE;
    207a:	89 b7       	in	r24, 0x39	; 57
    207c:	83 7c       	andi	r24, 0xC3	; 195
    207e:	89 bf       	out	0x39, r24	; 57
                break;
    2080:	4e c0       	rjmp	.+156    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2082:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    2086:	89 b7       	in	r24, 0x39	; 57
    2088:	84 60       	ori	r24, 0x04	; 4
    208a:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */

                break;
    208c:	48 c0       	rjmp	.+144    	; 0x211e <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    208e:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    2090:	46 c0       	rjmp	.+140    	; 0x211e <Timer_Init+0x1da>
            }
      break;
      }
      default :
      Ret+=E_NOK;
    2092:	1f 5f       	subi	r17, 0xFF	; 255
    break;
    2094:	44 c0       	rjmp	.+136    	; 0x211e <Timer_Init+0x1da>
  /*                             TIMER 2                                   */
  /*************************************************************************/

  case TIMER_CH2:
  {
TCCR2 |=T2_NORMAL_MODE_CONFIG;
    2096:	85 b5       	in	r24, 0x25	; 37
    2098:	85 bd       	out	0x25, r24	; 37
    switch (Timer_cfg->Timer_Mode) {
    209a:	89 81       	ldd	r24, Y+1	; 0x01
    209c:	88 23       	and	r24, r24
    209e:	19 f0       	breq	.+6      	; 0x20a6 <Timer_Init+0x162>
    20a0:	81 30       	cpi	r24, 0x01	; 1
    20a2:	e1 f5       	brne	.+120    	; 0x211c <Timer_Init+0x1d8>
    20a4:	12 c0       	rjmp	.+36     	; 0x20ca <Timer_Init+0x186>
      case TIMER_MODE:
      {
            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    20a6:	8a 81       	ldd	r24, Y+2	; 0x02
    20a8:	88 23       	and	r24, r24
    20aa:	19 f0       	breq	.+6      	; 0x20b2 <Timer_Init+0x16e>
    20ac:	81 30       	cpi	r24, 0x01	; 1
    20ae:	59 f4       	brne	.+22     	; 0x20c6 <Timer_Init+0x182>
    20b0:	04 c0       	rjmp	.+8      	; 0x20ba <Timer_Init+0x176>
              case TIMER_POLLING_MODE:
              {
                  TIMSK &= T2_INTERRUPT_DISABLE;
    20b2:	89 b7       	in	r24, 0x39	; 57
    20b4:	8f 73       	andi	r24, 0x3F	; 63
    20b6:	89 bf       	out	0x39, r24	; 57
                break;
    20b8:	32 c0       	rjmp	.+100    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    20ba:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                  TIMSK|=T2_INTERRUPT_NORMAL;
    20be:	89 b7       	in	r24, 0x39	; 57
    20c0:	80 6c       	ori	r24, 0xC0	; 192
    20c2:	89 bf       	out	0x39, r24	; 57

                break;
    20c4:	2c c0       	rjmp	.+88     	; 0x211e <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    20c6:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    20c8:	2a c0       	rjmp	.+84     	; 0x211e <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_RISING_MODE:
      {
          ASSR |=0x08;
    20ca:	82 b5       	in	r24, 0x22	; 34
    20cc:	88 60       	ori	r24, 0x08	; 8
    20ce:	82 bd       	out	0x22, r24	; 34
            switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    20d0:	8a 81       	ldd	r24, Y+2	; 0x02
    20d2:	81 30       	cpi	r24, 0x01	; 1
    20d4:	49 f0       	breq	.+18     	; 0x20e8 <Timer_Init+0x1a4>
    20d6:	81 30       	cpi	r24, 0x01	; 1
    20d8:	18 f0       	brcs	.+6      	; 0x20e0 <Timer_Init+0x19c>
    20da:	82 30       	cpi	r24, 0x02	; 2
    20dc:	f9 f4       	brne	.+62     	; 0x211c <Timer_Init+0x1d8>
    20de:	0a c0       	rjmp	.+20     	; 0x20f4 <Timer_Init+0x1b0>
            {
              case TIMER_POLLING_MODE:
              {
                TIMSK &= T2_INTERRUPT_DISABLE;
    20e0:	89 b7       	in	r24, 0x39	; 57
    20e2:	8f 73       	andi	r24, 0x3F	; 63
    20e4:	89 bf       	out	0x39, r24	; 57

                break;
    20e6:	1a c0       	rjmp	.+52     	; 0x211c <Timer_Init+0x1d8>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    20e8:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                  TIMSK|=T2_INTERRUPT_NORMAL;
    20ec:	89 b7       	in	r24, 0x39	; 57
    20ee:	80 6c       	ori	r24, 0xC0	; 192
    20f0:	89 bf       	out	0x39, r24	; 57
                break;
    20f2:	14 c0       	rjmp	.+40     	; 0x211c <Timer_Init+0x1d8>
              }
              case COUNTER_FALLING_MODE:
              {
                  ASSR |=0x08;
    20f4:	82 b5       	in	r24, 0x22	; 34
    20f6:	88 60       	ori	r24, 0x08	; 8
    20f8:	82 bd       	out	0x22, r24	; 34
                    switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    20fa:	8a 81       	ldd	r24, Y+2	; 0x02
    20fc:	88 23       	and	r24, r24
    20fe:	19 f0       	breq	.+6      	; 0x2106 <Timer_Init+0x1c2>
    2100:	81 30       	cpi	r24, 0x01	; 1
    2102:	59 f4       	brne	.+22     	; 0x211a <Timer_Init+0x1d6>
    2104:	04 c0       	rjmp	.+8      	; 0x210e <Timer_Init+0x1ca>
                    {
                      case TIMER_POLLING_MODE:
                      {
                        TIMSK &= T2_INTERRUPT_DISABLE;
    2106:	89 b7       	in	r24, 0x39	; 57
    2108:	8f 73       	andi	r24, 0x3F	; 63
    210a:	89 bf       	out	0x39, r24	; 57

                        break;
    210c:	07 c0       	rjmp	.+14     	; 0x211c <Timer_Init+0x1d8>
                      }
                      case TIMER_INTERRUPT_MODE:
                      {
                        G_interrupt_Enable();
    210e:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                          TIMSK|=T2_INTERRUPT_NORMAL;
    2112:	89 b7       	in	r24, 0x39	; 57
    2114:	80 6c       	ori	r24, 0xC0	; 192
    2116:	89 bf       	out	0x39, r24	; 57
                        break;
    2118:	01 c0       	rjmp	.+2      	; 0x211c <Timer_Init+0x1d8>
                      }

              default :
              Ret+=E_NOK;
    211a:	1f 5f       	subi	r17, 0xFF	; 255
            }
        break;
            }
            }
  default:
  Ret+=E_NOK;
    211c:	1f 5f       	subi	r17, 0xFF	; 255
}
 }

}
return Ret;
}
    211e:	81 2f       	mov	r24, r17
    2120:	df 91       	pop	r29
    2122:	cf 91       	pop	r28
    2124:	1f 91       	pop	r17
    2126:	08 95       	ret

00002128 <Timer_Start>:
 * Description: This function strats the needed timer.
 *
 */
ERROR_STATUS Timer_Start(uint8_t Timer_CH_NO, uint16_t Timer_Count){
uint8_t Ret;
switch (Timer_CH_NO) {
    2128:	81 30       	cpi	r24, 0x01	; 1
    212a:	09 f4       	brne	.+2      	; 0x212e <Timer_Start+0x6>
    212c:	4f c0       	rjmp	.+158    	; 0x21cc <Timer_Start+0xa4>
    212e:	81 30       	cpi	r24, 0x01	; 1
    2130:	20 f0       	brcs	.+8      	; 0x213a <Timer_Start+0x12>
    2132:	82 30       	cpi	r24, 0x02	; 2
    2134:	09 f0       	breq	.+2      	; 0x2138 <Timer_Start+0x10>
    2136:	f3 c0       	rjmp	.+486    	; 0x231e <Timer_Start+0x1f6>
    2138:	97 c0       	rjmp	.+302    	; 0x2268 <Timer_Start+0x140>
case TIMER_CH0:{
/***********************************************************************************************************************/
switch(prescaler_value){
    213a:	80 91 1a 01 	lds	r24, 0x011A
    213e:	84 30       	cpi	r24, 0x04	; 4
    2140:	21 f1       	breq	.+72     	; 0x218a <Timer_Start+0x62>
    2142:	85 30       	cpi	r24, 0x05	; 5
    2144:	30 f4       	brcc	.+12     	; 0x2152 <Timer_Start+0x2a>
    2146:	81 30       	cpi	r24, 0x01	; 1
    2148:	51 f0       	breq	.+20     	; 0x215e <Timer_Start+0x36>
    214a:	82 30       	cpi	r24, 0x02	; 2
    214c:	09 f0       	breq	.+2      	; 0x2150 <Timer_Start+0x28>
    214e:	e9 c0       	rjmp	.+466    	; 0x2322 <Timer_Start+0x1fa>
    2150:	11 c0       	rjmp	.+34     	; 0x2174 <Timer_Start+0x4c>
    2152:	86 30       	cpi	r24, 0x06	; 6
    2154:	29 f1       	breq	.+74     	; 0x21a0 <Timer_Start+0x78>
    2156:	87 30       	cpi	r24, 0x07	; 7
    2158:	09 f0       	breq	.+2      	; 0x215c <Timer_Start+0x34>
    215a:	e3 c0       	rjmp	.+454    	; 0x2322 <Timer_Start+0x1fa>
    215c:	2c c0       	rjmp	.+88     	; 0x21b6 <Timer_Start+0x8e>
case TIMER_PRESCALER_NO :{
if(Timer_Count < MAX0){
    215e:	6f 3f       	cpi	r22, 0xFF	; 255
    2160:	71 05       	cpc	r23, r1
    2162:	08 f0       	brcs	.+2      	; 0x2166 <Timer_Start+0x3e>
    2164:	e0 c0       	rjmp	.+448    	; 0x2326 <Timer_Start+0x1fe>
TCCR0 |=TIMER_PRESCALER_NO;
    2166:	83 b7       	in	r24, 0x33	; 51
    2168:	81 60       	ori	r24, 0x01	; 1
    216a:	83 bf       	out	0x33, r24	; 51
TCNT0 =	MAX0 - Timer_Count;
    216c:	60 95       	com	r22
    216e:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_8 :{
if(Timer_Count < MAX0){
    2174:	6f 3f       	cpi	r22, 0xFF	; 255
    2176:	71 05       	cpc	r23, r1
    2178:	08 f0       	brcs	.+2      	; 0x217c <Timer_Start+0x54>
    217a:	d7 c0       	rjmp	.+430    	; 0x232a <Timer_Start+0x202>
TCCR0 |=TIMER0_PRESCALER_8_CONFIG;
    217c:	83 b7       	in	r24, 0x33	; 51
    217e:	82 60       	ori	r24, 0x02	; 2
    2180:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    2182:	60 95       	com	r22
    2184:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2186:	80 e0       	ldi	r24, 0x00	; 0
    2188:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_64 :{
if(Timer_Count < MAX0){
    218a:	6f 3f       	cpi	r22, 0xFF	; 255
    218c:	71 05       	cpc	r23, r1
    218e:	08 f0       	brcs	.+2      	; 0x2192 <Timer_Start+0x6a>
    2190:	ce c0       	rjmp	.+412    	; 0x232e <Timer_Start+0x206>
TCCR0 |=TIMER0_PRESCALER_64_CONFIG;
    2192:	83 b7       	in	r24, 0x33	; 51
    2194:	83 60       	ori	r24, 0x03	; 3
    2196:	83 bf       	out	0x33, r24	; 51
TCNT0 = MAX0 - Timer_Count;
    2198:	60 95       	com	r22
    219a:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    219c:	80 e0       	ldi	r24, 0x00	; 0
    219e:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_256 :{
if(Timer_Count < MAX0){
    21a0:	6f 3f       	cpi	r22, 0xFF	; 255
    21a2:	71 05       	cpc	r23, r1
    21a4:	08 f0       	brcs	.+2      	; 0x21a8 <Timer_Start+0x80>
    21a6:	c5 c0       	rjmp	.+394    	; 0x2332 <Timer_Start+0x20a>
TCCR0 |=TIMER0_PRESCALER_256_CONFIG;
    21a8:	83 b7       	in	r24, 0x33	; 51
    21aa:	84 60       	ori	r24, 0x04	; 4
    21ac:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    21ae:	60 95       	com	r22
    21b0:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    21b2:	80 e0       	ldi	r24, 0x00	; 0
    21b4:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_1024 :{
if(Timer_Count < MAX0){
    21b6:	6f 3f       	cpi	r22, 0xFF	; 255
    21b8:	71 05       	cpc	r23, r1
    21ba:	08 f0       	brcs	.+2      	; 0x21be <Timer_Start+0x96>
    21bc:	bc c0       	rjmp	.+376    	; 0x2336 <Timer_Start+0x20e>
TCCR0 |=TIMER0_PRESCALER_1024_CONFIG;
    21be:	83 b7       	in	r24, 0x33	; 51
    21c0:	85 60       	ori	r24, 0x05	; 5
    21c2:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    21c4:	60 95       	com	r22
    21c6:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    21c8:	80 e0       	ldi	r24, 0x00	; 0
    21ca:	08 95       	ret
break;
}
case TIMER_CH1:{

  switch(prescaler_value){
    21cc:	80 91 1a 01 	lds	r24, 0x011A
    21d0:	84 30       	cpi	r24, 0x04	; 4
    21d2:	31 f1       	breq	.+76     	; 0x2220 <Timer_Start+0xf8>
    21d4:	85 30       	cpi	r24, 0x05	; 5
    21d6:	30 f4       	brcc	.+12     	; 0x21e4 <Timer_Start+0xbc>
    21d8:	81 30       	cpi	r24, 0x01	; 1
    21da:	51 f0       	breq	.+20     	; 0x21f0 <Timer_Start+0xc8>
    21dc:	82 30       	cpi	r24, 0x02	; 2
    21de:	09 f0       	breq	.+2      	; 0x21e2 <Timer_Start+0xba>
    21e0:	ac c0       	rjmp	.+344    	; 0x233a <Timer_Start+0x212>
    21e2:	12 c0       	rjmp	.+36     	; 0x2208 <Timer_Start+0xe0>
    21e4:	86 30       	cpi	r24, 0x06	; 6
    21e6:	41 f1       	breq	.+80     	; 0x2238 <Timer_Start+0x110>
    21e8:	87 30       	cpi	r24, 0x07	; 7
    21ea:	09 f0       	breq	.+2      	; 0x21ee <Timer_Start+0xc6>
    21ec:	a6 c0       	rjmp	.+332    	; 0x233a <Timer_Start+0x212>
    21ee:	30 c0       	rjmp	.+96     	; 0x2250 <Timer_Start+0x128>
  case TIMER_PRESCALER_NO :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER_PRESCALER_NO;
    21f0:	8e b5       	in	r24, 0x2e	; 46
    21f2:	9f b5       	in	r25, 0x2f	; 47
    21f4:	81 60       	ori	r24, 0x01	; 1
    21f6:	9f bd       	out	0x2f, r25	; 47
    21f8:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    21fa:	70 95       	com	r23
    21fc:	61 95       	neg	r22
    21fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2200:	7d bd       	out	0x2d, r23	; 45
    2202:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2204:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret=E_NOK;
  }
  break;
    2206:	08 95       	ret
  }
  case TIMER_PRESCALER_8 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_8_CONFIG;
    2208:	8e b5       	in	r24, 0x2e	; 46
    220a:	9f b5       	in	r25, 0x2f	; 47
    220c:	82 60       	ori	r24, 0x02	; 2
    220e:	9f bd       	out	0x2f, r25	; 47
    2210:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2212:	70 95       	com	r23
    2214:	61 95       	neg	r22
    2216:	7f 4f       	sbci	r23, 0xFF	; 255
    2218:	7d bd       	out	0x2d, r23	; 45
    221a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    221c:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret= E_NOK;
  }
  break;
    221e:	08 95       	ret
  }
  case TIMER_PRESCALER_64 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_64_CONFIG;
    2220:	8e b5       	in	r24, 0x2e	; 46
    2222:	9f b5       	in	r25, 0x2f	; 47
    2224:	83 60       	ori	r24, 0x03	; 3
    2226:	9f bd       	out	0x2f, r25	; 47
    2228:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    222a:	70 95       	com	r23
    222c:	61 95       	neg	r22
    222e:	7f 4f       	sbci	r23, 0xFF	; 255
    2230:	7d bd       	out	0x2d, r23	; 45
    2232:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2234:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret= E_NOK;
  }
  break;
    2236:	08 95       	ret
  }
  case TIMER_PRESCALER_256 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_256_CONFIG;
    2238:	8e b5       	in	r24, 0x2e	; 46
    223a:	9f b5       	in	r25, 0x2f	; 47
    223c:	84 60       	ori	r24, 0x04	; 4
    223e:	9f bd       	out	0x2f, r25	; 47
    2240:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2242:	70 95       	com	r23
    2244:	61 95       	neg	r22
    2246:	7f 4f       	sbci	r23, 0xFF	; 255
    2248:	7d bd       	out	0x2d, r23	; 45
    224a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    224c:	80 e0       	ldi	r24, 0x00	; 0
  }else
  {
  Ret= E_NOK;

  }
  break;
    224e:	08 95       	ret
  }
  case TIMER_PRESCALER_1024 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_1024_CONFIG;
    2250:	8e b5       	in	r24, 0x2e	; 46
    2252:	9f b5       	in	r25, 0x2f	; 47
    2254:	85 60       	ori	r24, 0x05	; 5
    2256:	9f bd       	out	0x2f, r25	; 47
    2258:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    225a:	70 95       	com	r23
    225c:	61 95       	neg	r22
    225e:	7f 4f       	sbci	r23, 0xFF	; 255
    2260:	7d bd       	out	0x2d, r23	; 45
    2262:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2264:	80 e0       	ldi	r24, 0x00	; 0
  }else
  {
  Ret= E_NOK;

  }
  break;
    2266:	08 95       	ret
	break;
}
case TIMER_CH2:
	{
  
		switch(prescaler_value){
    2268:	80 91 1a 01 	lds	r24, 0x011A
    226c:	84 30       	cpi	r24, 0x04	; 4
    226e:	79 f1       	breq	.+94     	; 0x22ce <Timer_Start+0x1a6>
    2270:	85 30       	cpi	r24, 0x05	; 5
    2272:	40 f4       	brcc	.+16     	; 0x2284 <Timer_Start+0x15c>
    2274:	82 30       	cpi	r24, 0x02	; 2
    2276:	c9 f0       	breq	.+50     	; 0x22aa <Timer_Start+0x182>
    2278:	83 30       	cpi	r24, 0x03	; 3
    227a:	10 f5       	brcc	.+68     	; 0x22c0 <Timer_Start+0x198>
    227c:	81 30       	cpi	r24, 0x01	; 1
    227e:	09 f0       	breq	.+2      	; 0x2282 <Timer_Start+0x15a>
    2280:	5e c0       	rjmp	.+188    	; 0x233e <Timer_Start+0x216>
    2282:	08 c0       	rjmp	.+16     	; 0x2294 <Timer_Start+0x16c>
    2284:	86 30       	cpi	r24, 0x06	; 6
    2286:	b9 f1       	breq	.+110    	; 0x22f6 <Timer_Start+0x1ce>
    2288:	86 30       	cpi	r24, 0x06	; 6
    228a:	58 f1       	brcs	.+86     	; 0x22e2 <Timer_Start+0x1ba>
    228c:	87 30       	cpi	r24, 0x07	; 7
    228e:	09 f0       	breq	.+2      	; 0x2292 <Timer_Start+0x16a>
    2290:	56 c0       	rjmp	.+172    	; 0x233e <Timer_Start+0x216>
    2292:	3b c0       	rjmp	.+118    	; 0x230a <Timer_Start+0x1e2>
   
		  case TIMER_PRESCALER_NO :
			{
    
				if(Timer_Count < MAX0){
    2294:	6f 3f       	cpi	r22, 0xFF	; 255
    2296:	71 05       	cpc	r23, r1
    2298:	08 f0       	brcs	.+2      	; 0x229c <Timer_Start+0x174>
    229a:	53 c0       	rjmp	.+166    	; 0x2342 <Timer_Start+0x21a>
     
			      TCCR2 |= TIMER_PRESCALER_NO;
    229c:	85 b5       	in	r24, 0x25	; 37
    229e:	81 60       	ori	r24, 0x01	; 1
    22a0:	85 bd       	out	0x25, r24	; 37
		      
				  TCNT2 = MAX2 - Timer_Count;
    22a2:	60 95       	com	r22
    22a4:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	08 95       	ret
			break;
			}

case TIMER_PRESCALER_8 :
  {
          if(Timer_Count < MAX0)
    22aa:	6f 3f       	cpi	r22, 0xFF	; 255
    22ac:	71 05       	cpc	r23, r1
    22ae:	08 f0       	brcs	.+2      	; 0x22b2 <Timer_Start+0x18a>
    22b0:	4a c0       	rjmp	.+148    	; 0x2346 <Timer_Start+0x21e>
            {
           TCCR2 |=TIMER_PRESCALER_8;
    22b2:	85 b5       	in	r24, 0x25	; 37
    22b4:	82 60       	ori	r24, 0x02	; 2
    22b6:	85 bd       	out	0x25, r24	; 37
           TCNT2 =MAX2 - Timer_Count;
    22b8:	60 95       	com	r22
    22ba:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22bc:	80 e0       	ldi	r24, 0x00	; 0
    22be:	08 95       	ret
  }
  case TIMER_PRESCALER_32:
  {
    if(Timer_Count < MAX1)
         {
         TCCR2 |=TIMER_PRESCALER_32;
    22c0:	85 b5       	in	r24, 0x25	; 37
    22c2:	83 60       	ori	r24, 0x03	; 3
    22c4:	85 bd       	out	0x25, r24	; 37
         TCNT2 =MAX2 - Timer_Count;
    22c6:	60 95       	com	r22
    22c8:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22ca:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
    Ret=E_NOK;
  }

    break;
    22cc:	08 95       	ret
  }
  case TIMER_PRESCALER_64 :
  {
       if(Timer_Count < MAX2)
    22ce:	6f 3f       	cpi	r22, 0xFF	; 255
    22d0:	71 05       	cpc	r23, r1
    22d2:	d8 f5       	brcc	.+118    	; 0x234a <Timer_Start+0x222>
       {
       TCCR2 |=TIMER_PRESCALER_64;
    22d4:	85 b5       	in	r24, 0x25	; 37
    22d6:	84 60       	ori	r24, 0x04	; 4
    22d8:	85 bd       	out	0x25, r24	; 37
       TCNT2 =MAX2 - Timer_Count;
    22da:	60 95       	com	r22
    22dc:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22de:	80 e0       	ldi	r24, 0x00	; 0
    22e0:	08 95       	ret
  Ret=E_NOK;
  }
  break;
  }
  case TIMER_PRESCALER_128 :{
  if(Timer_Count < MAX2){
    22e2:	6f 3f       	cpi	r22, 0xFF	; 255
    22e4:	71 05       	cpc	r23, r1
    22e6:	98 f5       	brcc	.+102    	; 0x234e <Timer_Start+0x226>
  TCCR2 |= TIMER_PRESCALER_128;
    22e8:	85 b5       	in	r24, 0x25	; 37
    22ea:	85 60       	ori	r24, 0x05	; 5
    22ec:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    22ee:	60 95       	com	r22
    22f0:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22f2:	80 e0       	ldi	r24, 0x00	; 0
    22f4:	08 95       	ret
  Ret= E_NOK;
    }
  break;
  }
  case TIMER_PRESCALER_256 :{
  if(Timer_Count < MAX2){
    22f6:	6f 3f       	cpi	r22, 0xFF	; 255
    22f8:	71 05       	cpc	r23, r1
    22fa:	58 f5       	brcc	.+86     	; 0x2352 <Timer_Start+0x22a>
  TCCR2 |= TIMER_PRESCALER_256;
    22fc:	85 b5       	in	r24, 0x25	; 37
    22fe:	86 60       	ori	r24, 0x06	; 6
    2300:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    2302:	60 95       	com	r22
    2304:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    2306:	80 e0       	ldi	r24, 0x00	; 0
    2308:	08 95       	ret

  }
  break;
  }
  case TIMER_PRESCALER_1024 :{
  if(Timer_Count < MAX2){
    230a:	6f 3f       	cpi	r22, 0xFF	; 255
    230c:	71 05       	cpc	r23, r1
    230e:	18 f5       	brcc	.+70     	; 0x2356 <Timer_Start+0x22e>
  TCCR2 |=TIMER_PRESCALER_1024;
    2310:	85 b5       	in	r24, 0x25	; 37
    2312:	87 60       	ori	r24, 0x07	; 7
    2314:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    2316:	60 95       	com	r22
    2318:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    231a:	80 e0       	ldi	r24, 0x00	; 0
    231c:	08 95       	ret
break;
}
default:
Ret= E_NOK;
    231e:	81 e0       	ldi	r24, 0x01	; 1
    2320:	08 95       	ret
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2322:	80 e0       	ldi	r24, 0x00	; 0
    2324:	08 95       	ret
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	08 95       	ret
    232a:	80 e0       	ldi	r24, 0x00	; 0
    232c:	08 95       	ret
    232e:	80 e0       	ldi	r24, 0x00	; 0
    2330:	08 95       	ret
    2332:	80 e0       	ldi	r24, 0x00	; 0
    2334:	08 95       	ret
    2336:	80 e0       	ldi	r24, 0x00	; 0
    2338:	08 95       	ret
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    233a:	80 e0       	ldi	r24, 0x00	; 0
    233c:	08 95       	ret
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    233e:	80 e0       	ldi	r24, 0x00	; 0
    2340:	08 95       	ret
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	08 95       	ret
    2346:	80 e0       	ldi	r24, 0x00	; 0
    2348:	08 95       	ret
    234a:	80 e0       	ldi	r24, 0x00	; 0
    234c:	08 95       	ret
    234e:	80 e0       	ldi	r24, 0x00	; 0
    2350:	08 95       	ret
    2352:	80 e0       	ldi	r24, 0x00	; 0
    2354:	08 95       	ret
    2356:	80 e0       	ldi	r24, 0x00	; 0
Ret= E_NOK;
break;
}
return Ret;

}
    2358:	08 95       	ret

0000235a <Timer_Stop>:
 * Description: This function stops the needed timer.
 *
 */
ERROR_STATUS Timer_Stop(uint8_t Timer_CH_NO)
{uint8_t Ret;
switch (Timer_CH_NO) {
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	51 f0       	breq	.+20     	; 0x2372 <Timer_Stop+0x18>
    235e:	81 30       	cpi	r24, 0x01	; 1
    2360:	18 f0       	brcs	.+6      	; 0x2368 <Timer_Stop+0xe>
    2362:	82 30       	cpi	r24, 0x02	; 2
    2364:	91 f4       	brne	.+36     	; 0x238a <Timer_Stop+0x30>
    2366:	0c c0       	rjmp	.+24     	; 0x2380 <Timer_Stop+0x26>
  case TIMER_CH0:
  {
		TCCR0 &=0xF8;
    2368:	83 b7       	in	r24, 0x33	; 51
    236a:	88 7f       	andi	r24, 0xF8	; 248
    236c:	83 bf       	out	0x33, r24	; 51
		Ret=E_OK;
    236e:	80 e0       	ldi	r24, 0x00	; 0
		break;
    2370:	08 95       	ret
  }
  case TIMER_CH1:
  {
	     TCCR1 &=0xFFF8;
    2372:	8e b5       	in	r24, 0x2e	; 46
    2374:	9f b5       	in	r25, 0x2f	; 47
    2376:	88 7f       	andi	r24, 0xF8	; 248
    2378:	9f bd       	out	0x2f, r25	; 47
    237a:	8e bd       	out	0x2e, r24	; 46
		 Ret=E_OK;
    237c:	80 e0       	ldi	r24, 0x00	; 0
		 break;
    237e:	08 95       	ret
  }
  case TIMER_CH2:
    {
		 TCCR2 &= 0xF8;
    2380:	85 b5       	in	r24, 0x25	; 37
    2382:	88 7f       	andi	r24, 0xF8	; 248
    2384:	85 bd       	out	0x25, r24	; 37
		 Ret=E_OK;
    2386:	80 e0       	ldi	r24, 0x00	; 0
		 break;
    2388:	08 95       	ret
    }
  default :
  Ret=E_NOK;
    238a:	81 e0       	ldi	r24, 0x01	; 1
  break;
}

return Ret;

}
    238c:	08 95       	ret

0000238e <Timer_GetStatus>:
 * Description: This function is used to return if the flag of the timer is raised or not.
 *
 */
ERROR_STATUS Timer_GetStatus(uint8_t Timer_CH_NO,uint8_t* Data)
{
  switch (Timer_CH_NO) {
    238e:	81 30       	cpi	r24, 0x01	; 1
    2390:	59 f0       	breq	.+22     	; 0x23a8 <Timer_GetStatus+0x1a>
    2392:	81 30       	cpi	r24, 0x01	; 1
    2394:	18 f0       	brcs	.+6      	; 0x239c <Timer_GetStatus+0xe>
    2396:	82 30       	cpi	r24, 0x02	; 2
    2398:	c9 f4       	brne	.+50     	; 0x23cc <Timer_GetStatus+0x3e>
    239a:	0e c0       	rjmp	.+28     	; 0x23b8 <Timer_GetStatus+0x2a>
    case TIMER_CH0:
    {
  *Data =((TIFR>>TOV0)&1);
    239c:	88 b7       	in	r24, 0x38	; 56
    239e:	81 70       	andi	r24, 0x01	; 1
    23a0:	fb 01       	movw	r30, r22
    23a2:	80 83       	st	Z, r24
    return E_OK;
    23a4:	80 e0       	ldi	r24, 0x00	; 0
    23a6:	08 95       	ret
    }
    case TIMER_CH1:
    {
    *Data =((TIFR>>TOV1)&1);
    23a8:	88 b7       	in	r24, 0x38	; 56
    23aa:	86 95       	lsr	r24
    23ac:	86 95       	lsr	r24
    23ae:	81 70       	andi	r24, 0x01	; 1
    23b0:	fb 01       	movw	r30, r22
    23b2:	80 83       	st	Z, r24
    return E_OK;
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	08 95       	ret
    }
     case TIMER_CH2:
      {
  *Data =((TIFR>>TOV2)&1);
    23b8:	88 b7       	in	r24, 0x38	; 56
    23ba:	82 95       	swap	r24
    23bc:	86 95       	lsr	r24
    23be:	86 95       	lsr	r24
    23c0:	83 70       	andi	r24, 0x03	; 3
    23c2:	81 70       	andi	r24, 0x01	; 1
    23c4:	fb 01       	movw	r30, r22
    23c6:	80 83       	st	Z, r24
    return E_OK;
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	08 95       	ret
      }
    default :
    return E_NOK;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
  }
}
    23ce:	08 95       	ret

000023d0 <Timer_GetValue>:
 * Return: The error status of the function.
 * Description: This function is used to return the value of the timer.
 *
 */
ERROR_STATUS Timer_GetValue(uint8_t Timer_CH_NO, uint16_t* Data)
{
    23d0:	fb 01       	movw	r30, r22
	uint8_t Ret=0;
	switch (Timer_CH_NO) {
    23d2:	81 30       	cpi	r24, 0x01	; 1
    23d4:	51 f0       	breq	.+20     	; 0x23ea <Timer_GetValue+0x1a>
    23d6:	81 30       	cpi	r24, 0x01	; 1
    23d8:	18 f0       	brcs	.+6      	; 0x23e0 <Timer_GetValue+0x10>
    23da:	82 30       	cpi	r24, 0x02	; 2
    23dc:	89 f4       	brne	.+34     	; 0x2400 <Timer_GetValue+0x30>
    23de:	0b c0       	rjmp	.+22     	; 0x23f6 <Timer_GetValue+0x26>
		case TIMER_CH0:
		{
			*Data =TCNT0;
    23e0:	82 b7       	in	r24, 0x32	; 50
    23e2:	80 83       	st	Z, r24
    23e4:	11 82       	std	Z+1, r1	; 0x01
			Ret= E_OK;
    23e6:	80 e0       	ldi	r24, 0x00	; 0
			break;
    23e8:	08 95       	ret
		}
		case TIMER_CH1:
		{
			*Data =TCNT1;
    23ea:	8c b5       	in	r24, 0x2c	; 44
    23ec:	9d b5       	in	r25, 0x2d	; 45
    23ee:	91 83       	std	Z+1, r25	; 0x01
    23f0:	80 83       	st	Z, r24
			Ret= E_OK;
    23f2:	80 e0       	ldi	r24, 0x00	; 0
			break;
    23f4:	08 95       	ret
		}
		case TIMER_CH2:
		{
			*Data =TCNT2;
    23f6:	84 b5       	in	r24, 0x24	; 36
    23f8:	80 83       	st	Z, r24
    23fa:	11 82       	std	Z+1, r1	; 0x01
			Ret = E_OK;
    23fc:	80 e0       	ldi	r24, 0x00	; 0
			break;
    23fe:	08 95       	ret
		}
		default :
		Ret= E_NOK;
    2400:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
return Ret;

}
    2402:	08 95       	ret

00002404 <Uart_Init>:
uint8_t BufferRequested[Buffer_Size];
//volatile uint8_t u8_index=0;
volatile uint8_t buf_is_full=0;
/****************************************************************************************************************************************/
void Uart_Init(En_BAUD_Rate Baud_rate,En_Stop_config Stop_bits_num, EN_Parity parity_Bit,EN_Data_Size data_num_bits,EN_UartMode uart_mode)
{
    2404:	0f 93       	push	r16
uint8_t Buffer=0;
switch (Baud_rate) {
    2406:	83 33       	cpi	r24, 0x33	; 51
    2408:	71 f0       	breq	.+28     	; 0x2426 <Uart_Init+0x22>
    240a:	84 33       	cpi	r24, 0x34	; 52
    240c:	18 f4       	brcc	.+6      	; 0x2414 <Uart_Init+0x10>
    240e:	89 31       	cpi	r24, 0x19	; 25
    2410:	79 f4       	brne	.+30     	; 0x2430 <Uart_Init+0x2c>
    2412:	0c c0       	rjmp	.+24     	; 0x242c <Uart_Init+0x28>
    2414:	84 34       	cpi	r24, 0x44	; 68
    2416:	21 f0       	breq	.+8      	; 0x2420 <Uart_Init+0x1c>
    2418:	87 36       	cpi	r24, 0x67	; 103
    241a:	51 f4       	brne	.+20     	; 0x2430 <Uart_Init+0x2c>
  case Baud9600:
  UBRRL=Baud9600;
    241c:	89 b9       	out	0x09, r24	; 9
  break;
    241e:	08 c0       	rjmp	.+16     	; 0x2430 <Uart_Init+0x2c>
  case Baud14400:
  UBRRL=Baud14400;
    2420:	84 e4       	ldi	r24, 0x44	; 68
    2422:	89 b9       	out	0x09, r24	; 9
  break;
    2424:	05 c0       	rjmp	.+10     	; 0x2430 <Uart_Init+0x2c>
  case Baud19200:
  UBRRL=Baud19200;
    2426:	83 e3       	ldi	r24, 0x33	; 51
    2428:	89 b9       	out	0x09, r24	; 9
  break;
    242a:	02 c0       	rjmp	.+4      	; 0x2430 <Uart_Init+0x2c>
  case Baud38400:
  UBRRL=Baud38400;
    242c:	89 e1       	ldi	r24, 0x19	; 25
    242e:	89 b9       	out	0x09, r24	; 9
  break;
}
switch (Stop_bits_num) {
    2430:	66 23       	and	r22, r22
    2432:	31 f0       	breq	.+12     	; 0x2440 <Uart_Init+0x3c>
    2434:	61 30       	cpi	r22, 0x01	; 1
    2436:	11 f0       	breq	.+4      	; 0x243c <Uart_Init+0x38>
//volatile uint8_t u8_index=0;
volatile uint8_t buf_is_full=0;
/****************************************************************************************************************************************/
void Uart_Init(En_BAUD_Rate Baud_rate,En_Stop_config Stop_bits_num, EN_Parity parity_Bit,EN_Data_Size data_num_bits,EN_UartMode uart_mode)
{
uint8_t Buffer=0;
    2438:	80 e0       	ldi	r24, 0x00	; 0
    243a:	03 c0       	rjmp	.+6      	; 0x2442 <Uart_Init+0x3e>
  break;
}
case TwoStopBits:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,USBS);
    243c:	88 e8       	ldi	r24, 0x88	; 136
  break;
    243e:	01 c0       	rjmp	.+2      	; 0x2442 <Uart_Init+0x3e>
  break;
}
switch (Stop_bits_num) {
case OneStopBit:
{ SET_BIT(Buffer,URSEL);
  CLEAR_BIT(Buffer,USBS);
    2440:	80 e8       	ldi	r24, 0x80	; 128
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,USBS);
  break;
}
}
switch (data_num_bits)
    2442:	22 30       	cpi	r18, 0x02	; 2
    2444:	a1 f0       	breq	.+40     	; 0x246e <Uart_Init+0x6a>
    2446:	23 30       	cpi	r18, 0x03	; 3
    2448:	28 f4       	brcc	.+10     	; 0x2454 <Uart_Init+0x50>
    244a:	22 23       	and	r18, r18
    244c:	41 f0       	breq	.+16     	; 0x245e <Uart_Init+0x5a>
    244e:	21 30       	cpi	r18, 0x01	; 1
    2450:	b9 f4       	brne	.+46     	; 0x2480 <Uart_Init+0x7c>
    2452:	09 c0       	rjmp	.+18     	; 0x2466 <Uart_Init+0x62>
    2454:	23 30       	cpi	r18, 0x03	; 3
    2456:	79 f0       	breq	.+30     	; 0x2476 <Uart_Init+0x72>
    2458:	24 30       	cpi	r18, 0x04	; 4
    245a:	91 f4       	brne	.+36     	; 0x2480 <Uart_Init+0x7c>
    245c:	0f c0       	rjmp	.+30     	; 0x247c <Uart_Init+0x78>
{
case FiveBits:
{
SET_BIT(Buffer,URSEL);
    245e:	80 68       	ori	r24, 0x80	; 128
CLEAR_BIT(Buffer,UCSZ0);
CLEAR_BIT(Buffer,UCSZ1);
    2460:	89 7f       	andi	r24, 0xF9	; 249
CLEAR_BIT(UCSRB,UCSZ2);
    2462:	52 98       	cbi	0x0a, 2	; 10
break;
    2464:	0d c0       	rjmp	.+26     	; 0x2480 <Uart_Init+0x7c>
}
case SexBits:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,UCSZ0);
    2466:	82 68       	ori	r24, 0x82	; 130
  CLEAR_BIT(Buffer,UCSZ1);
    2468:	8b 7f       	andi	r24, 0xFB	; 251
  CLEAR_BIT(UCSRB,UCSZ2);
    246a:	52 98       	cbi	0x0a, 2	; 10
  break;
    246c:	09 c0       	rjmp	.+18     	; 0x2480 <Uart_Init+0x7c>
}
case SevenBits:
{
  SET_BIT(Buffer,URSEL);
  CLEAR_BIT(Buffer,UCSZ0);
    246e:	89 77       	andi	r24, 0x79	; 121
  SET_BIT(Buffer,UCSZ1);
    2470:	84 68       	ori	r24, 0x84	; 132
  CLEAR_BIT(UCSRB,UCSZ2);
    2472:	52 98       	cbi	0x0a, 2	; 10
  break;
    2474:	05 c0       	rjmp	.+10     	; 0x2480 <Uart_Init+0x7c>
}
case EightBits:
{   SET_BIT(Buffer,URSEL);
    SET_BIT(Buffer,UCSZ0);
    SET_BIT(Buffer,UCSZ1);
    2476:	86 68       	ori	r24, 0x86	; 134
    CLEAR_BIT(UCSRB,UCSZ2);
    2478:	52 98       	cbi	0x0a, 2	; 10
break;
    247a:	02 c0       	rjmp	.+4      	; 0x2480 <Uart_Init+0x7c>
}

case NineBits:
{   SET_BIT(Buffer,URSEL);
	SET_BIT(Buffer,UCSZ0);
	SET_BIT(Buffer,UCSZ1);
    247c:	86 68       	ori	r24, 0x86	; 134
	SET_BIT(UCSRB,UCSZ2);
    247e:	52 9a       	sbi	0x0a, 2	; 10
	break;
}

}

switch (uart_mode) {
    2480:	00 23       	and	r16, r16
    2482:	19 f0       	breq	.+6      	; 0x248a <Uart_Init+0x86>
    2484:	01 30       	cpi	r16, 0x01	; 1
    2486:	29 f4       	brne	.+10     	; 0x2492 <Uart_Init+0x8e>
    2488:	03 c0       	rjmp	.+6      	; 0x2490 <Uart_Init+0x8c>
  case ASynchronous:
  {
  SET_BIT(Buffer,URSEL);
    248a:	80 68       	ori	r24, 0x80	; 128
  CLEAR_BIT(Buffer,UMSEL);
    248c:	8f 7b       	andi	r24, 0xBF	; 191
  break;
    248e:	01 c0       	rjmp	.+2      	; 0x2492 <Uart_Init+0x8e>
  }
case Synchronous:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,UMSEL);
    2490:	80 6c       	ori	r24, 0xC0	; 192
  break;
}
}
switch (parity_Bit) {
    2492:	41 30       	cpi	r20, 0x01	; 1
    2494:	41 f0       	breq	.+16     	; 0x24a6 <Uart_Init+0xa2>
    2496:	41 30       	cpi	r20, 0x01	; 1
    2498:	18 f0       	brcs	.+6      	; 0x24a0 <Uart_Init+0x9c>
    249a:	42 30       	cpi	r20, 0x02	; 2
    249c:	41 f4       	brne	.+16     	; 0x24ae <Uart_Init+0xaa>
    249e:	06 c0       	rjmp	.+12     	; 0x24ac <Uart_Init+0xa8>
  case NoParity:
{
SET_BIT(Buffer,URSEL);
    24a0:	80 68       	ori	r24, 0x80	; 128
CLEAR_BIT(Buffer,UPM0);
CLEAR_BIT(Buffer,UPM1);
    24a2:	8f 7c       	andi	r24, 0xCF	; 207
  break;
    24a4:	04 c0       	rjmp	.+8      	; 0x24ae <Uart_Init+0xaa>
}
case EvenParity:
{
SET_BIT(Buffer,URSEL);
CLEAR_BIT(Buffer,UPM0);
    24a6:	8f 74       	andi	r24, 0x4F	; 79
SET_BIT(Buffer,UPM1);
    24a8:	80 6a       	ori	r24, 0xA0	; 160
break;
    24aa:	01 c0       	rjmp	.+2      	; 0x24ae <Uart_Init+0xaa>
}
case OddParity:
{
SET_BIT(Buffer,URSEL);
SET_BIT(Buffer,UPM1);
SET_BIT(Buffer,UPM0);
    24ac:	80 6b       	ori	r24, 0xB0	; 176
}


}

UCSRC=Buffer;
    24ae:	80 bd       	out	0x20, r24	; 32
SET_BIT(UCSRB,TXEN);/*TXEN*/
    24b0:	53 9a       	sbi	0x0a, 3	; 10
SET_BIT(UCSRB,RXEN);/*RXEN*/
    24b2:	54 9a       	sbi	0x0a, 4	; 10
}
    24b4:	0f 91       	pop	r16
    24b6:	08 95       	ret

000024b8 <UartTransmitPooling>:
void UartTransmitPooling(uint8_t Data)
{
while( !( UCSRA & (1<<UDRE)));
    24b8:	5d 9b       	sbis	0x0b, 5	; 11
    24ba:	fe cf       	rjmp	.-4      	; 0x24b8 <UartTransmitPooling>
UDR=Data;
    24bc:	8c b9       	out	0x0c, r24	; 12
}
    24be:	08 95       	ret

000024c0 <UartRecievePooling>:
uint8_t UartRecievePooling(void)
{
	uint8_t data=0;
while (!( UCSRA & (1 << RXC)));/* Wait until new data receive*/
    24c0:	5f 9b       	sbis	0x0b, 7	; 11
    24c2:	fe cf       	rjmp	.-4      	; 0x24c0 <UartRecievePooling>
data=UDR;
    24c4:	8c b1       	in	r24, 0x0c	; 12
return data;									/* Get and return received data */
}
    24c6:	08 95       	ret

000024c8 <Enable_communication_interrupt>:


void Enable_communication_interrupt(void)
{
G_interrupt_Enable();
    24c8:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
SET_BIT(UCSRB,RXCIE);
    24cc:	57 9a       	sbi	0x0a, 7	; 10
SET_BIT(UCSRB,TXCIE);
    24ce:	56 9a       	sbi	0x0a, 6	; 10
SET_BIT(SPCR,SPIE);
    24d0:	6f 9a       	sbi	0x0d, 7	; 13
}
    24d2:	08 95       	ret

000024d4 <UartRecieveInterrupt>:
//  buf_is_full=1;
//  u16_index=0;
//      }
/*if(u8_index<Buffer_Size)
{
  */u8_DATA=UDR;/*
    24d4:	8c b1       	in	r24, 0x0c	; 12
    24d6:	80 93 ad 05 	sts	0x05AD, r24
  u8_index++;
}
  else{
    u8_index=0;
  }*/
}
    24da:	08 95       	ret

000024dc <UartTransmitInterrupt>:
{
/*When void Uart_tryansmitfirstbyte(uint8_t data) sends first byte before while(1) we start here sendine the next bytes
gU8_Data_transmited is shared with void UartTransmitdataInt(uint8_t data_to_transmit)
that changes its data
*/
UDR=u8_DATA;
    24dc:	80 91 ad 05 	lds	r24, 0x05AD
    24e0:	8c b9       	out	0x0c, r24	; 12
//G_interrupt_Enable();
//u8_DATA ^=0xFF;
}
    24e2:	08 95       	ret

000024e4 <UartTransmitdataInt>:
void UartTransmitdataInt(uint8_t data_to_transmit)
{
	  u8_DATA=data_to_transmit;
    24e4:	80 93 ad 05 	sts	0x05AD, r24
}
    24e8:	08 95       	ret

000024ea <Uart_tryansmitfirstbyte>:

void Uart_tryansmitfirstbyte(uint8_t data)
{
UDR=data;
    24ea:	8c b9       	out	0x0c, r24	; 12
}
    24ec:	08 95       	ret

000024ee <Uart_De_Init>:
void Uart_De_Init(void)
{
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
    24ee:	53 98       	cbi	0x0a, 3	; 10
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/
    24f0:	54 98       	cbi	0x0a, 4	; 10

}
    24f2:	08 95       	ret

000024f4 <uart_transmit_u16>:

void uart_transmit_u16(uint16_t sixtee_bits_var)
{
    24f4:	ef 92       	push	r14
    24f6:	ff 92       	push	r15
    24f8:	0f 93       	push	r16
    24fa:	1f 93       	push	r17
    24fc:	cf 93       	push	r28
    24fe:	df 93       	push	r29
    2500:	e4 e2       	ldi	r30, 0x24	; 36
    2502:	f1 e0       	ldi	r31, 0x01	; 1
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/

}

void uart_transmit_u16(uint16_t sixtee_bits_var)
    2504:	0f 2e       	mov	r0, r31
    2506:	fb ef       	ldi	r31, 0xFB	; 251
    2508:	ef 2e       	mov	r14, r31
    250a:	ff ef       	ldi	r31, 0xFF	; 255
    250c:	ff 2e       	mov	r15, r31
    250e:	f0 2d       	mov	r31, r0
    2510:	ee 0e       	add	r14, r30
    2512:	ff 1e       	adc	r15, r31
    2514:	ef 01       	movw	r28, r30
    2516:	24 97       	sbiw	r28, 0x04	; 4
uint8_t buffer_index=0;

for (i=4;i>0;i--)
{
	
	transmit_buffer[i]=sixtee_bits_var%10;
    2518:	2a e0       	ldi	r18, 0x0A	; 10
    251a:	30 e0       	ldi	r19, 0x00	; 0
    251c:	b9 01       	movw	r22, r18
    251e:	0e 94 5e 2a 	call	0x54bc	; 0x54bc <__udivmodhi4>
    2522:	82 93       	st	-Z, r24
	sixtee_bits_var/=10;
    2524:	86 2f       	mov	r24, r22
    2526:	97 2f       	mov	r25, r23
void uart_transmit_u16(uint16_t sixtee_bits_var)
{
uint8_t i=5;
uint8_t buffer_index=0;

for (i=4;i>0;i--)
    2528:	ec 17       	cp	r30, r28
    252a:	fd 07       	cpc	r31, r29
    252c:	b9 f7       	brne	.-18     	; 0x251c <uart_transmit_u16+0x28>
	
	transmit_buffer[i]=sixtee_bits_var%10;
	sixtee_bits_var/=10;

}
	transmit_buffer[i]=sixtee_bits_var;
    252e:	60 93 1f 01 	sts	0x011F, r22
    2532:	0f e1       	ldi	r16, 0x1F	; 31
    2534:	11 e0       	ldi	r17, 0x01	; 1
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/

}

void uart_transmit_u16(uint16_t sixtee_bits_var)
    2536:	e7 01       	movw	r28, r14
    2538:	25 96       	adiw	r28, 0x05	; 5

}
	transmit_buffer[i]=sixtee_bits_var;

	for(buffer_index=0;buffer_index < 5;buffer_index++)
	UartTransmitPooling(transmit_buffer[buffer_index]+48);
    253a:	f8 01       	movw	r30, r16
    253c:	81 91       	ld	r24, Z+
    253e:	8f 01       	movw	r16, r30
    2540:	80 5d       	subi	r24, 0xD0	; 208
    2542:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	sixtee_bits_var/=10;

}
	transmit_buffer[i]=sixtee_bits_var;

	for(buffer_index=0;buffer_index < 5;buffer_index++)
    2546:	0c 17       	cp	r16, r28
    2548:	1d 07       	cpc	r17, r29
    254a:	b9 f7       	brne	.-18     	; 0x253a <uart_transmit_u16+0x46>
	UartTransmitPooling(transmit_buffer[buffer_index]+48);



    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	ff 90       	pop	r15
    2556:	ef 90       	pop	r14
    2558:	08 95       	ret

0000255a <debug>:
}

void debug(void)
{

	UartTransmitPooling('B');
    255a:	82 e4       	ldi	r24, 0x42	; 66
    255c:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(PORTB_DATA);
    2560:	88 b3       	in	r24, 0x18	; 24
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('C');
    2568:	83 e4       	ldi	r24, 0x43	; 67
    256a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(PORTC_DATA);
    256e:	85 b3       	in	r24, 0x15	; 21
    2570:	90 e0       	ldi	r25, 0x00	; 0
    2572:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('D');
    2576:	84 e4       	ldi	r24, 0x44	; 68
    2578:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(PORTD_DATA);
    257c:	82 b3       	in	r24, 0x12	; 18
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
}
    2584:	08 95       	ret

00002586 <alarm_flashing>:
	
}

void alarm_flashing(void)
{
	if (u8_plastic_state == FIRST_SAFE_POS || u8_plastic_state == SECOND_SAFE_POS)
    2586:	80 91 28 01 	lds	r24, 0x0128
    258a:	81 50       	subi	r24, 0x01	; 1
    258c:	82 30       	cpi	r24, 0x02	; 2
    258e:	20 f4       	brcc	.+8      	; 0x2598 <alarm_flashing+0x12>
	{
		DIO_Toggle(GPIOB, BIT4);
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	60 e1       	ldi	r22, 0x10	; 16
    2594:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
    2598:	08 95       	ret

0000259a <plastic_breaker_loop>:

void plastic_breaker_loop(void)
{
	static uint8_t on_state = 0, off_state = 0, sw1_state = 0, sw2_state = 0;
	/*check if on pressed*/
	DIO_Read(GPIOB, BIT1, &on_state);
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	62 e0       	ldi	r22, 0x02	; 2
    259e:	44 e2       	ldi	r20, 0x24	; 36
    25a0:	51 e0       	ldi	r21, 0x01	; 1
    25a2:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	DIO_Read(GPIOB, BIT2, &off_state);
    25a6:	81 e0       	ldi	r24, 0x01	; 1
    25a8:	64 e0       	ldi	r22, 0x04	; 4
    25aa:	45 e2       	ldi	r20, 0x25	; 37
    25ac:	51 e0       	ldi	r21, 0x01	; 1
    25ae:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	DIO_Read(GPIOD, BIT2, &sw1_state);
    25b2:	83 e0       	ldi	r24, 0x03	; 3
    25b4:	64 e0       	ldi	r22, 0x04	; 4
    25b6:	46 e2       	ldi	r20, 0x26	; 38
    25b8:	51 e0       	ldi	r21, 0x01	; 1
    25ba:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	DIO_Read(GPIOD, BIT3, &sw2_state);
    25be:	83 e0       	ldi	r24, 0x03	; 3
    25c0:	68 e0       	ldi	r22, 0x08	; 8
    25c2:	47 e2       	ldi	r20, 0x27	; 39
    25c4:	51 e0       	ldi	r21, 0x01	; 1
    25c6:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	if ((on_state == HIGH && off_state == LOW && sw2_state == HIGH && sw1_state == HIGH) && (u8_plastic_state == NO_ACTION_PLAS))
    25ca:	80 91 24 01 	lds	r24, 0x0124
    25ce:	8f 3f       	cpi	r24, 0xFF	; 255
    25d0:	d1 f4       	brne	.+52     	; 0x2606 <plastic_breaker_loop+0x6c>
    25d2:	80 91 25 01 	lds	r24, 0x0125
    25d6:	88 23       	and	r24, r24
    25d8:	b1 f4       	brne	.+44     	; 0x2606 <plastic_breaker_loop+0x6c>
    25da:	80 91 27 01 	lds	r24, 0x0127
    25de:	8f 3f       	cpi	r24, 0xFF	; 255
    25e0:	91 f4       	brne	.+36     	; 0x2606 <plastic_breaker_loop+0x6c>
    25e2:	80 91 26 01 	lds	r24, 0x0126
    25e6:	8f 3f       	cpi	r24, 0xFF	; 255
    25e8:	09 f0       	breq	.+2      	; 0x25ec <plastic_breaker_loop+0x52>
    25ea:	76 c0       	rjmp	.+236    	; 0x26d8 <plastic_breaker_loop+0x13e>
    25ec:	80 91 28 01 	lds	r24, 0x0128
    25f0:	88 23       	and	r24, r24
    25f2:	09 f0       	breq	.+2      	; 0x25f6 <plastic_breaker_loop+0x5c>
    25f4:	71 c0       	rjmp	.+226    	; 0x26d8 <plastic_breaker_loop+0x13e>
	{
		/*ALARM_START*/
		DIO_Write(GPIOB, BIT4, HIGH);
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	60 e1       	ldi	r22, 0x10	; 16
    25fa:	4f ef       	ldi	r20, 0xFF	; 255
    25fc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		u8_plastic_state = FIRST_SAFE_POS;
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	80 93 28 01 	sts	0x0128, r24
	}
	if (on_state == LOW && u8_plastic_state == FIRST_SAFE_POS)
    2606:	80 91 24 01 	lds	r24, 0x0124
    260a:	88 23       	and	r24, r24
    260c:	39 f4       	brne	.+14     	; 0x261c <plastic_breaker_loop+0x82>
    260e:	80 91 28 01 	lds	r24, 0x0128
    2612:	81 30       	cpi	r24, 0x01	; 1
    2614:	19 f4       	brne	.+6      	; 0x261c <plastic_breaker_loop+0x82>
	{
		u8_plastic_state = SECOND_SAFE_POS;
    2616:	82 e0       	ldi	r24, 0x02	; 2
    2618:	80 93 28 01 	sts	0x0128, r24
	}

	if ((sw2_state == HIGH && sw1_state == HIGH && off_state == LOW && on_state == HIGH) && (u8_plastic_state == SECOND_SAFE_POS))
    261c:	80 91 27 01 	lds	r24, 0x0127
    2620:	8f 3f       	cpi	r24, 0xFF	; 255
    2622:	a1 f5       	brne	.+104    	; 0x268c <plastic_breaker_loop+0xf2>
    2624:	90 91 26 01 	lds	r25, 0x0126
    2628:	9f 3f       	cpi	r25, 0xFF	; 255
    262a:	81 f5       	brne	.+96     	; 0x268c <plastic_breaker_loop+0xf2>
    262c:	90 91 25 01 	lds	r25, 0x0125
    2630:	99 23       	and	r25, r25
    2632:	61 f5       	brne	.+88     	; 0x268c <plastic_breaker_loop+0xf2>
    2634:	90 91 24 01 	lds	r25, 0x0124
    2638:	9f 3f       	cpi	r25, 0xFF	; 255
    263a:	41 f5       	brne	.+80     	; 0x268c <plastic_breaker_loop+0xf2>
    263c:	90 91 28 01 	lds	r25, 0x0128
    2640:	92 30       	cpi	r25, 0x02	; 2
    2642:	21 f5       	brne	.+72     	; 0x268c <plastic_breaker_loop+0xf2>
	{
		/*MOTOR_WORKING_START*/
		//SwDelay_ms(3000);
		u16_delay++;
    2644:	80 91 29 01 	lds	r24, 0x0129
    2648:	90 91 2a 01 	lds	r25, 0x012A
    264c:	01 96       	adiw	r24, 0x01	; 1
    264e:	90 93 2a 01 	sts	0x012A, r25
    2652:	80 93 29 01 	sts	0x0129, r24
		DIO_Write(GPIOB, BIT4, LOW);
    2656:	81 e0       	ldi	r24, 0x01	; 1
    2658:	60 e1       	ldi	r22, 0x10	; 16
    265a:	40 e0       	ldi	r20, 0x00	; 0
    265c:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT5, HIGH);
    2660:	81 e0       	ldi	r24, 0x01	; 1
    2662:	60 e2       	ldi	r22, 0x20	; 32
    2664:	4f ef       	ldi	r20, 0xFF	; 255
    2666:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
				DIO_Write(GPIOB, BIT7, LOW);
    266a:	81 e0       	ldi	r24, 0x01	; 1
    266c:	60 e8       	ldi	r22, 0x80	; 128
    266e:	40 e0       	ldi	r20, 0x00	; 0
    2670:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT6, HIGH);
    2674:	81 e0       	ldi	r24, 0x01	; 1
    2676:	60 e4       	ldi	r22, 0x40	; 64
    2678:	4f ef       	ldi	r20, 0xFF	; 255
    267a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		u8_plastic_state = MOTOR_WORKING_STAR;
    267e:	83 e0       	ldi	r24, 0x03	; 3
    2680:	80 93 28 01 	sts	0x0128, r24
	}
	if ((sw2_state == HIGH && sw1_state == HIGH && off_state == LOW && on_state == HIGH) && (u8_plastic_state == SECOND_SAFE_POS) &&(u8_plastic_state==MOTOR_WORKING_STAR && u16_delay >= 1000))
    2684:	80 91 27 01 	lds	r24, 0x0127
    2688:	8f 3f       	cpi	r24, 0xFF	; 255
    268a:	29 f4       	brne	.+10     	; 0x2696 <plastic_breaker_loop+0xfc>
		DIO_Write(GPIOB, BIT7, HIGH);
		u8_plastic_state = MOTOR_WORKING_DELTA;
	
	}

		if (((u8_plastic_state == MOTOR_WORKING_DELTA || u8_plastic_state == MOTOR_WORKING_STAR) && (off_state == HIGH)) || ((u8_plastic_state == MOTOR_WORKING_DELTA || u8_plastic_state == MOTOR_WORKING_STAR) && (sw1_state == LOW || sw2_state == LOW)))
    268c:	90 91 28 01 	lds	r25, 0x0128
    2690:	93 50       	subi	r25, 0x03	; 3
    2692:	92 30       	cpi	r25, 0x02	; 2
    2694:	20 f5       	brcc	.+72     	; 0x26de <plastic_breaker_loop+0x144>
    2696:	90 91 25 01 	lds	r25, 0x0125
    269a:	9f 3f       	cpi	r25, 0xFF	; 255
    269c:	31 f0       	breq	.+12     	; 0x26aa <plastic_breaker_loop+0x110>
    269e:	90 91 26 01 	lds	r25, 0x0126
    26a2:	99 23       	and	r25, r25
    26a4:	11 f0       	breq	.+4      	; 0x26aa <plastic_breaker_loop+0x110>
    26a6:	88 23       	and	r24, r24
    26a8:	d1 f4       	brne	.+52     	; 0x26de <plastic_breaker_loop+0x144>
		{

			/*turn off the machine*/
			DIO_Write(GPIOB, BIT4, LOW);
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	60 e1       	ldi	r22, 0x10	; 16
    26ae:	40 e0       	ldi	r20, 0x00	; 0
    26b0:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			DIO_Write(GPIOB, BIT5, LOW);
    26b4:	81 e0       	ldi	r24, 0x01	; 1
    26b6:	60 e2       	ldi	r22, 0x20	; 32
    26b8:	40 e0       	ldi	r20, 0x00	; 0
    26ba:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			DIO_Write(GPIOB, BIT6, LOW);
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	60 e4       	ldi	r22, 0x40	; 64
    26c2:	40 e0       	ldi	r20, 0x00	; 0
    26c4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			DIO_Write(GPIOB, BIT7, LOW);
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	60 e8       	ldi	r22, 0x80	; 128
    26cc:	40 e0       	ldi	r20, 0x00	; 0
    26ce:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			u8_plastic_state = NO_ACTION_PLAS;
    26d2:	10 92 28 01 	sts	0x0128, r1
    26d6:	08 95       	ret
	if (on_state == LOW && u8_plastic_state == FIRST_SAFE_POS)
	{
		u8_plastic_state = SECOND_SAFE_POS;
	}

	if ((sw2_state == HIGH && sw1_state == HIGH && off_state == LOW && on_state == HIGH) && (u8_plastic_state == SECOND_SAFE_POS))
    26d8:	80 91 27 01 	lds	r24, 0x0127
    26dc:	a3 cf       	rjmp	.-186    	; 0x2624 <plastic_breaker_loop+0x8a>
    26de:	08 95       	ret

000026e0 <badawy_machine_init>:
/*Badawy machine init */
static uint8_t u8_plastic_state = NO_ACTION_PLAS;
static uint16_t u16_delay = 0 ;

void badawy_machine_init(void)
{
    26e0:	0f 93       	push	r16
	Uart_Init(Baud9600, OneStopBit, NoParity, EightBits, ASynchronous);
    26e2:	87 e6       	ldi	r24, 0x67	; 103
    26e4:	60 e0       	ldi	r22, 0x00	; 0
    26e6:	40 e0       	ldi	r20, 0x00	; 0
    26e8:	23 e0       	ldi	r18, 0x03	; 3
    26ea:	00 e0       	ldi	r16, 0x00	; 0
    26ec:	0e 94 02 12 	call	0x2404	; 0x2404 <Uart_Init>
	DIO_init(&Dio_configurationB);
    26f0:	84 ec       	ldi	r24, 0xC4	; 196
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
	DIO_init(&Dio_configurationC);
    26f8:	81 ec       	ldi	r24, 0xC1	; 193
    26fa:	90 e0       	ldi	r25, 0x00	; 0
    26fc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
	DIO_init(&Dio_configurationD);
    2700:	8e eb       	ldi	r24, 0xBE	; 190
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
	SOS_Init(&TMU_Configuration);
    2708:	8b ee       	ldi	r24, 0xEB	; 235
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	0e 94 ca 27 	call	0x4f94	; 0x4f94 <SOS_Init>
	SOS_Create_Task(Read_Time_Task, 1, 1, 5);
    2710:	80 eb       	ldi	r24, 0xB0	; 176
    2712:	90 e0       	ldi	r25, 0x00	; 0
    2714:	61 e0       	ldi	r22, 0x01	; 1
    2716:	41 e0       	ldi	r20, 0x01	; 1
    2718:	25 e0       	ldi	r18, 0x05	; 5
    271a:	30 e0       	ldi	r19, 0x00	; 0
    271c:	0e 94 1d 28 	call	0x503a	; 0x503a <SOS_Create_Task>
	SOS_Create_Task(update_timing, 1, 4, 1);
    2720:	83 e2       	ldi	r24, 0x23	; 35
    2722:	91 e0       	ldi	r25, 0x01	; 1
    2724:	61 e0       	ldi	r22, 0x01	; 1
    2726:	44 e0       	ldi	r20, 0x04	; 4
    2728:	21 e0       	ldi	r18, 0x01	; 1
    272a:	30 e0       	ldi	r19, 0x00	; 0
    272c:	0e 94 1d 28 	call	0x503a	; 0x503a <SOS_Create_Task>
	SOS_Create_Task(Push_Task1, 1, 3, 2);
    2730:	80 ea       	ldi	r24, 0xA0	; 160
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	61 e0       	ldi	r22, 0x01	; 1
    2736:	43 e0       	ldi	r20, 0x03	; 3
    2738:	22 e0       	ldi	r18, 0x02	; 2
    273a:	30 e0       	ldi	r19, 0x00	; 0
    273c:	0e 94 1d 28 	call	0x503a	; 0x503a <SOS_Create_Task>
}
    2740:	0f 91       	pop	r16
    2742:	08 95       	ret

00002744 <plastic_breaker_init>:
	uart_transmit_u16(PORTC_DATA);
	UartTransmitPooling('D');
	uart_transmit_u16(PORTD_DATA);
}
void plastic_breaker_init(void)
{
    2744:	0f 93       	push	r16
	Uart_Init(Baud9600, OneStopBit, NoParity, EightBits, ASynchronous);
    2746:	87 e6       	ldi	r24, 0x67	; 103
    2748:	60 e0       	ldi	r22, 0x00	; 0
    274a:	40 e0       	ldi	r20, 0x00	; 0
    274c:	23 e0       	ldi	r18, 0x03	; 3
    274e:	00 e0       	ldi	r16, 0x00	; 0
    2750:	0e 94 02 12 	call	0x2404	; 0x2404 <Uart_Init>
	init_fun_plastic();
    2754:	0e 94 67 00 	call	0xce	; 0xce <init_fun_plastic>
	SOS_Init(&TMU_Configuration);
    2758:	8b ee       	ldi	r24, 0xEB	; 235
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	0e 94 ca 27 	call	0x4f94	; 0x4f94 <SOS_Init>
	SOS_Create_Task(plastic_breaker_loop, 1, 1, 5);
    2760:	8d ec       	ldi	r24, 0xCD	; 205
    2762:	92 e1       	ldi	r25, 0x12	; 18
    2764:	61 e0       	ldi	r22, 0x01	; 1
    2766:	41 e0       	ldi	r20, 0x01	; 1
    2768:	25 e0       	ldi	r18, 0x05	; 5
    276a:	30 e0       	ldi	r19, 0x00	; 0
    276c:	0e 94 1d 28 	call	0x503a	; 0x503a <SOS_Create_Task>
	SOS_Create_Task(alarm_flashing, 1, 2, 100);
    2770:	83 ec       	ldi	r24, 0xC3	; 195
    2772:	92 e1       	ldi	r25, 0x12	; 18
    2774:	61 e0       	ldi	r22, 0x01	; 1
    2776:	42 e0       	ldi	r20, 0x02	; 2
    2778:	24 e6       	ldi	r18, 0x64	; 100
    277a:	30 e0       	ldi	r19, 0x00	; 0
    277c:	0e 94 1d 28 	call	0x503a	; 0x503a <SOS_Create_Task>
	SOS_Create_Task(debug, 1, 3, 10);
    2780:	8d ea       	ldi	r24, 0xAD	; 173
    2782:	92 e1       	ldi	r25, 0x12	; 18
    2784:	61 e0       	ldi	r22, 0x01	; 1
    2786:	43 e0       	ldi	r20, 0x03	; 3
    2788:	2a e0       	ldi	r18, 0x0A	; 10
    278a:	30 e0       	ldi	r19, 0x00	; 0
    278c:	0e 94 1d 28 	call	0x503a	; 0x503a <SOS_Create_Task>
}
    2790:	0f 91       	pop	r16
    2792:	08 95       	ret

00002794 <main>:

int main(void)
{
	plastic_breaker_init();
    2794:	0e 94 a2 13 	call	0x2744	; 0x2744 <plastic_breaker_init>
	/*badawy_machine_init();*/
	
	while (1)
	{
		SOS_Run();
    2798:	0e 94 3a 28 	call	0x5074	; 0x5074 <SOS_Run>
    279c:	fd cf       	rjmp	.-6      	; 0x2798 <main+0x4>

0000279e <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    279e:	44 23       	and	r20, r20
    27a0:	41 f4       	brne	.+16     	; 0x27b2 <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    27a2:	68 23       	and	r22, r24
    27a4:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
    27a6:	81 e0       	ldi	r24, 0x01	; 1
    27a8:	61 15       	cp	r22, r1
    27aa:	71 05       	cpc	r23, r1
    27ac:	51 f4       	brne	.+20     	; 0x27c2 <prvTestWaitCondition+0x24>
    27ae:	80 e0       	ldi	r24, 0x00	; 0
    27b0:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    27b2:	9b 01       	movw	r18, r22
    27b4:	28 23       	and	r18, r24
    27b6:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	62 17       	cp	r22, r18
    27bc:	73 07       	cpc	r23, r19
    27be:	09 f0       	breq	.+2      	; 0x27c2 <prvTestWaitCondition+0x24>
    27c0:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
    27c2:	08 95       	ret

000027c4 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    27c4:	cf 93       	push	r28
    27c6:	df 93       	push	r29
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    27c8:	8b e0       	ldi	r24, 0x0B	; 11
    27ca:	90 e0       	ldi	r25, 0x00	; 0
    27cc:	0e 94 78 15 	call	0x2af0	; 0x2af0 <pvPortMalloc>
    27d0:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
    27d2:	00 97       	sbiw	r24, 0x00	; 0
    27d4:	31 f0       	breq	.+12     	; 0x27e2 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
    27d6:	fc 01       	movw	r30, r24
    27d8:	11 92       	st	Z+, r1
    27da:	11 92       	st	Z+, r1
    27dc:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    27de:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
	}
    27e2:	8c 2f       	mov	r24, r28
    27e4:	9d 2f       	mov	r25, r29
    27e6:	df 91       	pop	r29
    27e8:	cf 91       	pop	r28
    27ea:	08 95       	ret

000027ec <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    27ec:	af 92       	push	r10
    27ee:	bf 92       	push	r11
    27f0:	cf 92       	push	r12
    27f2:	df 92       	push	r13
    27f4:	ef 92       	push	r14
    27f6:	ff 92       	push	r15
    27f8:	0f 93       	push	r16
    27fa:	1f 93       	push	r17
    27fc:	cf 93       	push	r28
    27fe:	df 93       	push	r29
    2800:	5c 01       	movw	r10, r24
    2802:	6b 01       	movw	r12, r22
    2804:	e4 2e       	mov	r14, r20
    2806:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2808:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    280c:	f5 01       	movw	r30, r10
    280e:	c0 81       	ld	r28, Z
    2810:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2812:	ce 01       	movw	r24, r28
    2814:	b6 01       	movw	r22, r12
    2816:	4f 2d       	mov	r20, r15
    2818:	0e 94 cf 13 	call	0x279e	; 0x279e <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
    281c:	88 23       	and	r24, r24
    281e:	51 f0       	breq	.+20     	; 0x2834 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2820:	ee 20       	and	r14, r14
    2822:	01 f1       	breq	.+64     	; 0x2864 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2824:	c0 94       	com	r12
    2826:	d0 94       	com	r13
    2828:	cc 22       	and	r12, r28
    282a:	dd 22       	and	r13, r29
    282c:	f5 01       	movw	r30, r10
    282e:	d1 82       	std	Z+1, r13	; 0x01
    2830:	c0 82       	st	Z, r12
    2832:	18 c0       	rjmp	.+48     	; 0x2864 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2834:	01 15       	cp	r16, r1
    2836:	11 05       	cpc	r17, r1
    2838:	a9 f0       	breq	.+42     	; 0x2864 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    283a:	ee 20       	and	r14, r14
    283c:	19 f4       	brne	.+6      	; 0x2844 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
    283e:	60 e0       	ldi	r22, 0x00	; 0
    2840:	70 e0       	ldi	r23, 0x00	; 0
    2842:	02 c0       	rjmp	.+4      	; 0x2848 <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2844:	60 e0       	ldi	r22, 0x00	; 0
    2846:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2848:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    284a:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    284c:	6c 29       	or	r22, r12
    284e:	7d 29       	or	r23, r13
    2850:	c5 01       	movw	r24, r10
    2852:	02 96       	adiw	r24, 0x02	; 2
    2854:	a8 01       	movw	r20, r16
    2856:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    285a:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
    285e:	88 23       	and	r24, r24
    2860:	39 f4       	brne	.+14     	; 0x2870 <xEventGroupWaitBits+0x84>
    2862:	04 c0       	rjmp	.+8      	; 0x286c <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2864:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    2868:	ce 01       	movw	r24, r28
    286a:	21 c0       	rjmp	.+66     	; 0x28ae <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    286c:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2870:	0e 94 5f 25 	call	0x4abe	; 0x4abe <uxTaskResetEventItemValue>
    2874:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2876:	91 fd       	sbrc	r25, 1
    2878:	18 c0       	rjmp	.+48     	; 0x28aa <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
    287a:	0f b6       	in	r0, 0x3f	; 63
    287c:	f8 94       	cli
    287e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2880:	f5 01       	movw	r30, r10
    2882:	c0 81       	ld	r28, Z
    2884:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2886:	ce 01       	movw	r24, r28
    2888:	b6 01       	movw	r22, r12
    288a:	4f 2d       	mov	r20, r15
    288c:	0e 94 cf 13 	call	0x279e	; 0x279e <prvTestWaitCondition>
    2890:	88 23       	and	r24, r24
    2892:	49 f0       	breq	.+18     	; 0x28a6 <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
    2894:	ee 20       	and	r14, r14
    2896:	39 f0       	breq	.+14     	; 0x28a6 <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2898:	c0 94       	com	r12
    289a:	d0 94       	com	r13
    289c:	cc 22       	and	r12, r28
    289e:	dd 22       	and	r13, r29
    28a0:	f5 01       	movw	r30, r10
    28a2:	d1 82       	std	Z+1, r13	; 0x01
    28a4:	c0 82       	st	Z, r12
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
			}
			taskEXIT_CRITICAL();
    28a6:	0f 90       	pop	r0
    28a8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    28aa:	ce 01       	movw	r24, r28
    28ac:	90 70       	andi	r25, 0x00	; 0

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
}
    28ae:	df 91       	pop	r29
    28b0:	cf 91       	pop	r28
    28b2:	1f 91       	pop	r17
    28b4:	0f 91       	pop	r16
    28b6:	ff 90       	pop	r15
    28b8:	ef 90       	pop	r14
    28ba:	df 90       	pop	r13
    28bc:	cf 90       	pop	r12
    28be:	bf 90       	pop	r11
    28c0:	af 90       	pop	r10
    28c2:	08 95       	ret

000028c4 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    28c4:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    28c6:	0f b6       	in	r0, 0x3f	; 63
    28c8:	f8 94       	cli
    28ca:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    28cc:	80 81       	ld	r24, Z
    28ce:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    28d0:	60 95       	com	r22
    28d2:	70 95       	com	r23
    28d4:	68 23       	and	r22, r24
    28d6:	79 23       	and	r23, r25
    28d8:	71 83       	std	Z+1, r23	; 0x01
    28da:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
    28dc:	0f 90       	pop	r0
    28de:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    28e0:	08 95       	ret

000028e2 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    28e2:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    28e4:	80 81       	ld	r24, Z
    28e6:	91 81       	ldd	r25, Z+1	; 0x01
    28e8:	08 95       	ret

000028ea <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    28ea:	af 92       	push	r10
    28ec:	bf 92       	push	r11
    28ee:	cf 92       	push	r12
    28f0:	df 92       	push	r13
    28f2:	ef 92       	push	r14
    28f4:	ff 92       	push	r15
    28f6:	0f 93       	push	r16
    28f8:	1f 93       	push	r17
    28fa:	cf 93       	push	r28
    28fc:	df 93       	push	r29
    28fe:	8c 01       	movw	r16, r24
    2900:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2902:	0f 2e       	mov	r0, r31
    2904:	f5 e0       	ldi	r31, 0x05	; 5
    2906:	cf 2e       	mov	r12, r31
    2908:	dd 24       	eor	r13, r13
    290a:	f0 2d       	mov	r31, r0
    290c:	c8 0e       	add	r12, r24
    290e:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
    2910:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2914:	d8 01       	movw	r26, r16
    2916:	17 96       	adiw	r26, 0x07	; 7
    2918:	ed 91       	ld	r30, X+
    291a:	fc 91       	ld	r31, X
    291c:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    291e:	8d 91       	ld	r24, X+
    2920:	9c 91       	ld	r25, X
    2922:	11 97       	sbiw	r26, 0x01	; 1
    2924:	8c 2b       	or	r24, r28
    2926:	9d 2b       	or	r25, r29
    2928:	11 96       	adiw	r26, 0x01	; 1
    292a:	9c 93       	st	X, r25
    292c:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    292e:	ce 16       	cp	r12, r30
    2930:	df 06       	cpc	r13, r31
    2932:	c1 f1       	breq	.+112    	; 0x29a4 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2934:	aa 24       	eor	r10, r10
    2936:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    2938:	ff 24       	eor	r15, r15
    293a:	f3 94       	inc	r15
    293c:	ee 24       	eor	r14, r14
    293e:	01 c0       	rjmp	.+2      	; 0x2942 <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2940:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
    2942:	c2 81       	ldd	r28, Z+2	; 0x02
    2944:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2946:	80 81       	ld	r24, Z
    2948:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    294a:	bc 01       	movw	r22, r24
    294c:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    294e:	9c 01       	movw	r18, r24
    2950:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2952:	92 fd       	sbrc	r25, 2
    2954:	0b c0       	rjmp	.+22     	; 0x296c <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2956:	d8 01       	movw	r26, r16
    2958:	8d 91       	ld	r24, X+
    295a:	9c 91       	ld	r25, X
    295c:	11 97       	sbiw	r26, 0x01	; 1
    295e:	82 23       	and	r24, r18
    2960:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
    2962:	4f 2d       	mov	r20, r15
    2964:	00 97       	sbiw	r24, 0x00	; 0
    2966:	69 f4       	brne	.+26     	; 0x2982 <xEventGroupSetBits+0x98>
    2968:	4e 2d       	mov	r20, r14
    296a:	0b c0       	rjmp	.+22     	; 0x2982 <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    296c:	d8 01       	movw	r26, r16
    296e:	8d 91       	ld	r24, X+
    2970:	9c 91       	ld	r25, X
    2972:	11 97       	sbiw	r26, 0x01	; 1
    2974:	82 23       	and	r24, r18
    2976:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    2978:	4f 2d       	mov	r20, r15
    297a:	28 17       	cp	r18, r24
    297c:	39 07       	cpc	r19, r25
    297e:	09 f0       	breq	.+2      	; 0x2982 <xEventGroupSetBits+0x98>
    2980:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    2982:	44 23       	and	r20, r20
    2984:	59 f0       	breq	.+22     	; 0x299c <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2986:	70 ff       	sbrs	r23, 0
    2988:	02 c0       	rjmp	.+4      	; 0x298e <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    298a:	a2 2a       	or	r10, r18
    298c:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    298e:	d8 01       	movw	r26, r16
    2990:	6d 91       	ld	r22, X+
    2992:	7c 91       	ld	r23, X
    2994:	72 60       	ori	r23, 0x02	; 2
    2996:	cf 01       	movw	r24, r30
    2998:	0e 94 d6 24 	call	0x49ac	; 0x49ac <vTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    299c:	cc 16       	cp	r12, r28
    299e:	dd 06       	cpc	r13, r29
    29a0:	79 f6       	brne	.-98     	; 0x2940 <xEventGroupSetBits+0x56>
    29a2:	02 c0       	rjmp	.+4      	; 0x29a8 <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    29a4:	aa 24       	eor	r10, r10
    29a6:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    29a8:	c5 01       	movw	r24, r10
    29aa:	80 95       	com	r24
    29ac:	90 95       	com	r25
    29ae:	f8 01       	movw	r30, r16
    29b0:	a0 80       	ld	r10, Z
    29b2:	b1 80       	ldd	r11, Z+1	; 0x01
    29b4:	a8 22       	and	r10, r24
    29b6:	b9 22       	and	r11, r25
    29b8:	b1 82       	std	Z+1, r11	; 0x01
    29ba:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
    29bc:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
    29c0:	d8 01       	movw	r26, r16
    29c2:	8c 91       	ld	r24, X
    29c4:	11 96       	adiw	r26, 0x01	; 1
    29c6:	9c 91       	ld	r25, X
    29c8:	11 97       	sbiw	r26, 0x01	; 1
    29ca:	df 91       	pop	r29
    29cc:	cf 91       	pop	r28
    29ce:	1f 91       	pop	r17
    29d0:	0f 91       	pop	r16
    29d2:	ff 90       	pop	r15
    29d4:	ef 90       	pop	r14
    29d6:	df 90       	pop	r13
    29d8:	cf 90       	pop	r12
    29da:	bf 90       	pop	r11
    29dc:	af 90       	pop	r10
    29de:	08 95       	ret

000029e0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    29e0:	af 92       	push	r10
    29e2:	bf 92       	push	r11
    29e4:	cf 92       	push	r12
    29e6:	df 92       	push	r13
    29e8:	ef 92       	push	r14
    29ea:	ff 92       	push	r15
    29ec:	0f 93       	push	r16
    29ee:	1f 93       	push	r17
    29f0:	cf 93       	push	r28
    29f2:	df 93       	push	r29
    29f4:	6c 01       	movw	r12, r24
    29f6:	eb 01       	movw	r28, r22
    29f8:	7a 01       	movw	r14, r20
    29fa:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    29fc:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2a00:	f6 01       	movw	r30, r12
    2a02:	00 81       	ld	r16, Z
    2a04:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2a06:	c6 01       	movw	r24, r12
    2a08:	be 01       	movw	r22, r28
    2a0a:	0e 94 75 14 	call	0x28ea	; 0x28ea <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2a0e:	c0 2b       	or	r28, r16
    2a10:	d1 2b       	or	r29, r17
    2a12:	c7 01       	movw	r24, r14
    2a14:	8c 23       	and	r24, r28
    2a16:	9d 23       	and	r25, r29
    2a18:	8e 15       	cp	r24, r14
    2a1a:	9f 05       	cpc	r25, r15
    2a1c:	51 f4       	brne	.+20     	; 0x2a32 <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2a1e:	80 95       	com	r24
    2a20:	90 95       	com	r25
    2a22:	f6 01       	movw	r30, r12
    2a24:	20 81       	ld	r18, Z
    2a26:	31 81       	ldd	r19, Z+1	; 0x01
    2a28:	82 23       	and	r24, r18
    2a2a:	93 23       	and	r25, r19
    2a2c:	91 83       	std	Z+1, r25	; 0x01
    2a2e:	80 83       	st	Z, r24
    2a30:	12 c0       	rjmp	.+36     	; 0x2a56 <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2a32:	a1 14       	cp	r10, r1
    2a34:	b1 04       	cpc	r11, r1
    2a36:	61 f0       	breq	.+24     	; 0x2a50 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2a38:	b7 01       	movw	r22, r14
    2a3a:	75 60       	ori	r23, 0x05	; 5
    2a3c:	c6 01       	movw	r24, r12
    2a3e:	02 96       	adiw	r24, 0x02	; 2
    2a40:	a5 01       	movw	r20, r10
    2a42:	0e 94 72 24 	call	0x48e4	; 0x48e4 <vTaskPlaceOnUnorderedEventList>
				uxReturn = pxEventBits->uxEventBits;
				xTimeoutOccurred = pdTRUE;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2a46:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
    2a4a:	88 23       	and	r24, r24
    2a4c:	49 f4       	brne	.+18     	; 0x2a60 <xEventGroupSync+0x80>
    2a4e:	06 c0       	rjmp	.+12     	; 0x2a5c <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2a50:	f6 01       	movw	r30, r12
    2a52:	c0 81       	ld	r28, Z
    2a54:	d1 81       	ldd	r29, Z+1	; 0x01
				xTimeoutOccurred = pdTRUE;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2a56:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    2a5a:	1c c0       	rjmp	.+56     	; 0x2a94 <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2a5c:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2a60:	0e 94 5f 25 	call	0x4abe	; 0x4abe <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2a64:	91 fd       	sbrc	r25, 1
    2a66:	14 c0       	rjmp	.+40     	; 0x2a90 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2a68:	0f b6       	in	r0, 0x3f	; 63
    2a6a:	f8 94       	cli
    2a6c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2a6e:	f6 01       	movw	r30, r12
    2a70:	80 81       	ld	r24, Z
    2a72:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2a74:	97 01       	movw	r18, r14
    2a76:	28 23       	and	r18, r24
    2a78:	39 23       	and	r19, r25
    2a7a:	2e 15       	cp	r18, r14
    2a7c:	3f 05       	cpc	r19, r15
    2a7e:	31 f4       	brne	.+12     	; 0x2a8c <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2a80:	20 95       	com	r18
    2a82:	30 95       	com	r19
    2a84:	28 23       	and	r18, r24
    2a86:	39 23       	and	r19, r25
    2a88:	31 83       	std	Z+1, r19	; 0x01
    2a8a:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2a8c:	0f 90       	pop	r0
    2a8e:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2a90:	ec 01       	movw	r28, r24
    2a92:	d0 70       	andi	r29, 0x00	; 0

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
}
    2a94:	8c 2f       	mov	r24, r28
    2a96:	9d 2f       	mov	r25, r29
    2a98:	df 91       	pop	r29
    2a9a:	cf 91       	pop	r28
    2a9c:	1f 91       	pop	r17
    2a9e:	0f 91       	pop	r16
    2aa0:	ff 90       	pop	r15
    2aa2:	ef 90       	pop	r14
    2aa4:	df 90       	pop	r13
    2aa6:	cf 90       	pop	r12
    2aa8:	bf 90       	pop	r11
    2aaa:	af 90       	pop	r10
    2aac:	08 95       	ret

00002aae <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2aae:	cf 93       	push	r28
    2ab0:	df 93       	push	r29
    2ab2:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
    2ab4:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aba:	88 23       	and	r24, r24
    2abc:	49 f0       	breq	.+18     	; 0x2ad0 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2abe:	8f 81       	ldd	r24, Y+7	; 0x07
    2ac0:	98 85       	ldd	r25, Y+8	; 0x08
    2ac2:	60 e0       	ldi	r22, 0x00	; 0
    2ac4:	72 e0       	ldi	r23, 0x02	; 2
    2ac6:	0e 94 d6 24 	call	0x49ac	; 0x49ac <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2aca:	8a 81       	ldd	r24, Y+2	; 0x02
    2acc:	88 23       	and	r24, r24
    2ace:	b9 f7       	brne	.-18     	; 0x2abe <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2ad0:	ce 01       	movw	r24, r28
    2ad2:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2ad6:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
}
    2ada:	df 91       	pop	r29
    2adc:	cf 91       	pop	r28
    2ade:	08 95       	ret

00002ae0 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2ae0:	ba 01       	movw	r22, r20
    2ae2:	0e 94 75 14 	call	0x28ea	; 0x28ea <xEventGroupSetBits>
}
    2ae6:	08 95       	ret

00002ae8 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2ae8:	ba 01       	movw	r22, r20
    2aea:	0e 94 62 14 	call	0x28c4	; 0x28c4 <xEventGroupClearBits>
}
    2aee:	08 95       	ret

00002af0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2af0:	cf 93       	push	r28
    2af2:	df 93       	push	r29
    2af4:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2af6:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2afa:	80 91 2b 01 	lds	r24, 0x012B
    2afe:	90 91 2c 01 	lds	r25, 0x012C
    2b02:	00 97       	sbiw	r24, 0x00	; 0
    2b04:	31 f4       	brne	.+12     	; 0x2b12 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2b06:	8e e2       	ldi	r24, 0x2E	; 46
    2b08:	91 e0       	ldi	r25, 0x01	; 1
    2b0a:	90 93 2c 01 	sts	0x012C, r25
    2b0e:	80 93 2b 01 	sts	0x012B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2b12:	20 91 15 05 	lds	r18, 0x0515
    2b16:	30 91 16 05 	lds	r19, 0x0516
    2b1a:	ce 01       	movw	r24, r28
    2b1c:	82 0f       	add	r24, r18
    2b1e:	93 1f       	adc	r25, r19
    2b20:	43 e0       	ldi	r20, 0x03	; 3
    2b22:	87 3e       	cpi	r24, 0xE7	; 231
    2b24:	94 07       	cpc	r25, r20
    2b26:	70 f4       	brcc	.+28     	; 0x2b44 <pvPortMalloc+0x54>
    2b28:	28 17       	cp	r18, r24
    2b2a:	39 07       	cpc	r19, r25
    2b2c:	70 f4       	brcc	.+28     	; 0x2b4a <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2b2e:	c0 91 2b 01 	lds	r28, 0x012B
    2b32:	d0 91 2c 01 	lds	r29, 0x012C
    2b36:	c2 0f       	add	r28, r18
    2b38:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2b3a:	90 93 16 05 	sts	0x0516, r25
    2b3e:	80 93 15 05 	sts	0x0515, r24
    2b42:	05 c0       	rjmp	.+10     	; 0x2b4e <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2b44:	c0 e0       	ldi	r28, 0x00	; 0
    2b46:	d0 e0       	ldi	r29, 0x00	; 0
    2b48:	02 c0       	rjmp	.+4      	; 0x2b4e <pvPortMalloc+0x5e>
    2b4a:	c0 e0       	ldi	r28, 0x00	; 0
    2b4c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2b4e:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2b52:	8c 2f       	mov	r24, r28
    2b54:	9d 2f       	mov	r25, r29
    2b56:	df 91       	pop	r29
    2b58:	cf 91       	pop	r28
    2b5a:	08 95       	ret

00002b5c <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2b5c:	08 95       	ret

00002b5e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2b5e:	10 92 16 05 	sts	0x0516, r1
    2b62:	10 92 15 05 	sts	0x0515, r1
}
    2b66:	08 95       	ret

00002b68 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2b68:	20 91 15 05 	lds	r18, 0x0515
    2b6c:	30 91 16 05 	lds	r19, 0x0516
    2b70:	87 ee       	ldi	r24, 0xE7	; 231
    2b72:	93 e0       	ldi	r25, 0x03	; 3
    2b74:	82 1b       	sub	r24, r18
    2b76:	93 0b       	sbc	r25, r19
}
    2b78:	08 95       	ret

00002b7a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2b7a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2b7c:	03 96       	adiw	r24, 0x03	; 3
    2b7e:	92 83       	std	Z+2, r25	; 0x02
    2b80:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2b82:	2f ef       	ldi	r18, 0xFF	; 255
    2b84:	3f ef       	ldi	r19, 0xFF	; 255
    2b86:	34 83       	std	Z+4, r19	; 0x04
    2b88:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2b8a:	96 83       	std	Z+6, r25	; 0x06
    2b8c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2b8e:	90 87       	std	Z+8, r25	; 0x08
    2b90:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2b92:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2b94:	08 95       	ret

00002b96 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2b96:	fc 01       	movw	r30, r24
    2b98:	11 86       	std	Z+9, r1	; 0x09
    2b9a:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2b9c:	08 95       	ret

00002b9e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2b9e:	cf 93       	push	r28
    2ba0:	df 93       	push	r29
    2ba2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2ba4:	dc 01       	movw	r26, r24
    2ba6:	11 96       	adiw	r26, 0x01	; 1
    2ba8:	cd 91       	ld	r28, X+
    2baa:	dc 91       	ld	r29, X
    2bac:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2bae:	d3 83       	std	Z+3, r29	; 0x03
    2bb0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2bb2:	2c 81       	ldd	r18, Y+4	; 0x04
    2bb4:	3d 81       	ldd	r19, Y+5	; 0x05
    2bb6:	35 83       	std	Z+5, r19	; 0x05
    2bb8:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2bba:	ac 81       	ldd	r26, Y+4	; 0x04
    2bbc:	bd 81       	ldd	r27, Y+5	; 0x05
    2bbe:	13 96       	adiw	r26, 0x03	; 3
    2bc0:	7c 93       	st	X, r23
    2bc2:	6e 93       	st	-X, r22
    2bc4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    2bc6:	7d 83       	std	Y+5, r23	; 0x05
    2bc8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2bca:	91 87       	std	Z+9, r25	; 0x09
    2bcc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2bce:	fc 01       	movw	r30, r24
    2bd0:	20 81       	ld	r18, Z
    2bd2:	2f 5f       	subi	r18, 0xFF	; 255
    2bd4:	20 83       	st	Z, r18
}
    2bd6:	df 91       	pop	r29
    2bd8:	cf 91       	pop	r28
    2bda:	08 95       	ret

00002bdc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2bdc:	cf 93       	push	r28
    2bde:	df 93       	push	r29
    2be0:	ac 01       	movw	r20, r24
    2be2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2be4:	28 81       	ld	r18, Y
    2be6:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2be8:	8f ef       	ldi	r24, 0xFF	; 255
    2bea:	2f 3f       	cpi	r18, 0xFF	; 255
    2bec:	38 07       	cpc	r19, r24
    2bee:	21 f4       	brne	.+8      	; 0x2bf8 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2bf0:	fa 01       	movw	r30, r20
    2bf2:	a7 81       	ldd	r26, Z+7	; 0x07
    2bf4:	b0 85       	ldd	r27, Z+8	; 0x08
    2bf6:	0d c0       	rjmp	.+26     	; 0x2c12 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2bf8:	da 01       	movw	r26, r20
    2bfa:	13 96       	adiw	r26, 0x03	; 3
    2bfc:	01 c0       	rjmp	.+2      	; 0x2c00 <vListInsert+0x24>
    2bfe:	df 01       	movw	r26, r30
    2c00:	12 96       	adiw	r26, 0x02	; 2
    2c02:	ed 91       	ld	r30, X+
    2c04:	fc 91       	ld	r31, X
    2c06:	13 97       	sbiw	r26, 0x03	; 3
    2c08:	80 81       	ld	r24, Z
    2c0a:	91 81       	ldd	r25, Z+1	; 0x01
    2c0c:	28 17       	cp	r18, r24
    2c0e:	39 07       	cpc	r19, r25
    2c10:	b0 f7       	brcc	.-20     	; 0x2bfe <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2c12:	12 96       	adiw	r26, 0x02	; 2
    2c14:	ed 91       	ld	r30, X+
    2c16:	fc 91       	ld	r31, X
    2c18:	13 97       	sbiw	r26, 0x03	; 3
    2c1a:	fb 83       	std	Y+3, r31	; 0x03
    2c1c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2c1e:	d5 83       	std	Z+5, r29	; 0x05
    2c20:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2c22:	bd 83       	std	Y+5, r27	; 0x05
    2c24:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2c26:	13 96       	adiw	r26, 0x03	; 3
    2c28:	dc 93       	st	X, r29
    2c2a:	ce 93       	st	-X, r28
    2c2c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2c2e:	59 87       	std	Y+9, r21	; 0x09
    2c30:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    2c32:	fa 01       	movw	r30, r20
    2c34:	80 81       	ld	r24, Z
    2c36:	8f 5f       	subi	r24, 0xFF	; 255
    2c38:	80 83       	st	Z, r24
}
    2c3a:	df 91       	pop	r29
    2c3c:	cf 91       	pop	r28
    2c3e:	08 95       	ret

00002c40 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2c40:	cf 93       	push	r28
    2c42:	df 93       	push	r29
    2c44:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2c46:	c0 85       	ldd	r28, Z+8	; 0x08
    2c48:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2c4a:	a2 81       	ldd	r26, Z+2	; 0x02
    2c4c:	b3 81       	ldd	r27, Z+3	; 0x03
    2c4e:	84 81       	ldd	r24, Z+4	; 0x04
    2c50:	95 81       	ldd	r25, Z+5	; 0x05
    2c52:	15 96       	adiw	r26, 0x05	; 5
    2c54:	9c 93       	st	X, r25
    2c56:	8e 93       	st	-X, r24
    2c58:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2c5a:	a4 81       	ldd	r26, Z+4	; 0x04
    2c5c:	b5 81       	ldd	r27, Z+5	; 0x05
    2c5e:	82 81       	ldd	r24, Z+2	; 0x02
    2c60:	93 81       	ldd	r25, Z+3	; 0x03
    2c62:	13 96       	adiw	r26, 0x03	; 3
    2c64:	9c 93       	st	X, r25
    2c66:	8e 93       	st	-X, r24
    2c68:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2c6a:	a9 81       	ldd	r26, Y+1	; 0x01
    2c6c:	ba 81       	ldd	r27, Y+2	; 0x02
    2c6e:	ae 17       	cp	r26, r30
    2c70:	bf 07       	cpc	r27, r31
    2c72:	31 f4       	brne	.+12     	; 0x2c80 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2c74:	14 96       	adiw	r26, 0x04	; 4
    2c76:	8d 91       	ld	r24, X+
    2c78:	9c 91       	ld	r25, X
    2c7a:	15 97       	sbiw	r26, 0x05	; 5
    2c7c:	9a 83       	std	Y+2, r25	; 0x02
    2c7e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2c80:	11 86       	std	Z+9, r1	; 0x09
    2c82:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2c84:	88 81       	ld	r24, Y
    2c86:	81 50       	subi	r24, 0x01	; 1
    2c88:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
    2c8a:	88 81       	ld	r24, Y
}
    2c8c:	df 91       	pop	r29
    2c8e:	cf 91       	pop	r28
    2c90:	08 95       	ret

00002c92 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2c92:	21 e1       	ldi	r18, 0x11	; 17
    2c94:	fc 01       	movw	r30, r24
    2c96:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2c98:	31 97       	sbiw	r30, 0x01	; 1
    2c9a:	32 e2       	ldi	r19, 0x22	; 34
    2c9c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2c9e:	fc 01       	movw	r30, r24
    2ca0:	32 97       	sbiw	r30, 0x02	; 2
    2ca2:	a3 e3       	ldi	r26, 0x33	; 51
    2ca4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2ca6:	fc 01       	movw	r30, r24
    2ca8:	33 97       	sbiw	r30, 0x03	; 3
    2caa:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2cac:	fc 01       	movw	r30, r24
    2cae:	34 97       	sbiw	r30, 0x04	; 4
    2cb0:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2cb2:	fc 01       	movw	r30, r24
    2cb4:	35 97       	sbiw	r30, 0x05	; 5
    2cb6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2cb8:	fc 01       	movw	r30, r24
    2cba:	36 97       	sbiw	r30, 0x06	; 6
    2cbc:	60 e8       	ldi	r22, 0x80	; 128
    2cbe:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	37 97       	sbiw	r30, 0x07	; 7
    2cc4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2cc6:	fc 01       	movw	r30, r24
    2cc8:	38 97       	sbiw	r30, 0x08	; 8
    2cca:	62 e0       	ldi	r22, 0x02	; 2
    2ccc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2cce:	fc 01       	movw	r30, r24
    2cd0:	39 97       	sbiw	r30, 0x09	; 9
    2cd2:	63 e0       	ldi	r22, 0x03	; 3
    2cd4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2cd6:	fc 01       	movw	r30, r24
    2cd8:	3a 97       	sbiw	r30, 0x0a	; 10
    2cda:	64 e0       	ldi	r22, 0x04	; 4
    2cdc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2cde:	fc 01       	movw	r30, r24
    2ce0:	3b 97       	sbiw	r30, 0x0b	; 11
    2ce2:	65 e0       	ldi	r22, 0x05	; 5
    2ce4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2ce6:	fc 01       	movw	r30, r24
    2ce8:	3c 97       	sbiw	r30, 0x0c	; 12
    2cea:	66 e0       	ldi	r22, 0x06	; 6
    2cec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2cee:	fc 01       	movw	r30, r24
    2cf0:	3d 97       	sbiw	r30, 0x0d	; 13
    2cf2:	67 e0       	ldi	r22, 0x07	; 7
    2cf4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2cf6:	fc 01       	movw	r30, r24
    2cf8:	3e 97       	sbiw	r30, 0x0e	; 14
    2cfa:	68 e0       	ldi	r22, 0x08	; 8
    2cfc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2cfe:	fc 01       	movw	r30, r24
    2d00:	3f 97       	sbiw	r30, 0x0f	; 15
    2d02:	69 e0       	ldi	r22, 0x09	; 9
    2d04:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2d06:	fc 01       	movw	r30, r24
    2d08:	70 97       	sbiw	r30, 0x10	; 16
    2d0a:	60 e1       	ldi	r22, 0x10	; 16
    2d0c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2d0e:	fc 01       	movw	r30, r24
    2d10:	71 97       	sbiw	r30, 0x11	; 17
    2d12:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2d14:	fc 01       	movw	r30, r24
    2d16:	72 97       	sbiw	r30, 0x12	; 18
    2d18:	22 e1       	ldi	r18, 0x12	; 18
    2d1a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	73 97       	sbiw	r30, 0x13	; 19
    2d20:	23 e1       	ldi	r18, 0x13	; 19
    2d22:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2d24:	fc 01       	movw	r30, r24
    2d26:	74 97       	sbiw	r30, 0x14	; 20
    2d28:	24 e1       	ldi	r18, 0x14	; 20
    2d2a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2d2c:	fc 01       	movw	r30, r24
    2d2e:	75 97       	sbiw	r30, 0x15	; 21
    2d30:	25 e1       	ldi	r18, 0x15	; 21
    2d32:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2d34:	fc 01       	movw	r30, r24
    2d36:	76 97       	sbiw	r30, 0x16	; 22
    2d38:	26 e1       	ldi	r18, 0x16	; 22
    2d3a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	77 97       	sbiw	r30, 0x17	; 23
    2d40:	27 e1       	ldi	r18, 0x17	; 23
    2d42:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2d44:	fc 01       	movw	r30, r24
    2d46:	78 97       	sbiw	r30, 0x18	; 24
    2d48:	28 e1       	ldi	r18, 0x18	; 24
    2d4a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2d4c:	fc 01       	movw	r30, r24
    2d4e:	79 97       	sbiw	r30, 0x19	; 25
    2d50:	29 e1       	ldi	r18, 0x19	; 25
    2d52:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2d54:	fc 01       	movw	r30, r24
    2d56:	7a 97       	sbiw	r30, 0x1a	; 26
    2d58:	20 e2       	ldi	r18, 0x20	; 32
    2d5a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2d5c:	fc 01       	movw	r30, r24
    2d5e:	7b 97       	sbiw	r30, 0x1b	; 27
    2d60:	21 e2       	ldi	r18, 0x21	; 33
    2d62:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2d64:	fc 01       	movw	r30, r24
    2d66:	7c 97       	sbiw	r30, 0x1c	; 28
    2d68:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2d6a:	fc 01       	movw	r30, r24
    2d6c:	7d 97       	sbiw	r30, 0x1d	; 29
    2d6e:	23 e2       	ldi	r18, 0x23	; 35
    2d70:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d72:	fc 01       	movw	r30, r24
    2d74:	7e 97       	sbiw	r30, 0x1e	; 30
    2d76:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d78:	fc 01       	movw	r30, r24
    2d7a:	7f 97       	sbiw	r30, 0x1f	; 31
    2d7c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2d7e:	fc 01       	movw	r30, r24
    2d80:	b0 97       	sbiw	r30, 0x20	; 32
    2d82:	26 e2       	ldi	r18, 0x26	; 38
    2d84:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2d86:	fc 01       	movw	r30, r24
    2d88:	b1 97       	sbiw	r30, 0x21	; 33
    2d8a:	27 e2       	ldi	r18, 0x27	; 39
    2d8c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2d8e:	fc 01       	movw	r30, r24
    2d90:	b2 97       	sbiw	r30, 0x22	; 34
    2d92:	28 e2       	ldi	r18, 0x28	; 40
    2d94:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2d96:	fc 01       	movw	r30, r24
    2d98:	b3 97       	sbiw	r30, 0x23	; 35
    2d9a:	29 e2       	ldi	r18, 0x29	; 41
    2d9c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2d9e:	fc 01       	movw	r30, r24
    2da0:	b4 97       	sbiw	r30, 0x24	; 36
    2da2:	20 e3       	ldi	r18, 0x30	; 48
    2da4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2da6:	fc 01       	movw	r30, r24
    2da8:	b5 97       	sbiw	r30, 0x25	; 37
    2daa:	21 e3       	ldi	r18, 0x31	; 49
    2dac:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2dae:	86 97       	sbiw	r24, 0x26	; 38
}
    2db0:	08 95       	ret

00002db2 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2db2:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    2db4:	89 ef       	ldi	r24, 0xF9	; 249
    2db6:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2db8:	8b e0       	ldi	r24, 0x0B	; 11
    2dba:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2dbc:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2dbe:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    2dc0:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2dc2:	a0 91 17 05 	lds	r26, 0x0517
    2dc6:	b0 91 18 05 	lds	r27, 0x0518
    2dca:	cd 91       	ld	r28, X+
    2dcc:	cd bf       	out	0x3d, r28	; 61
    2dce:	dd 91       	ld	r29, X+
    2dd0:	de bf       	out	0x3e, r29	; 62
    2dd2:	ff 91       	pop	r31
    2dd4:	ef 91       	pop	r30
    2dd6:	df 91       	pop	r29
    2dd8:	cf 91       	pop	r28
    2dda:	bf 91       	pop	r27
    2ddc:	af 91       	pop	r26
    2dde:	9f 91       	pop	r25
    2de0:	8f 91       	pop	r24
    2de2:	7f 91       	pop	r23
    2de4:	6f 91       	pop	r22
    2de6:	5f 91       	pop	r21
    2de8:	4f 91       	pop	r20
    2dea:	3f 91       	pop	r19
    2dec:	2f 91       	pop	r18
    2dee:	1f 91       	pop	r17
    2df0:	0f 91       	pop	r16
    2df2:	ff 90       	pop	r15
    2df4:	ef 90       	pop	r14
    2df6:	df 90       	pop	r13
    2df8:	cf 90       	pop	r12
    2dfa:	bf 90       	pop	r11
    2dfc:	af 90       	pop	r10
    2dfe:	9f 90       	pop	r9
    2e00:	8f 90       	pop	r8
    2e02:	7f 90       	pop	r7
    2e04:	6f 90       	pop	r6
    2e06:	5f 90       	pop	r5
    2e08:	4f 90       	pop	r4
    2e0a:	3f 90       	pop	r3
    2e0c:	2f 90       	pop	r2
    2e0e:	1f 90       	pop	r1
    2e10:	0f 90       	pop	r0
    2e12:	0f be       	out	0x3f, r0	; 63
    2e14:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2e16:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2e18:	81 e0       	ldi	r24, 0x01	; 1
    2e1a:	08 95       	ret

00002e1c <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2e1c:	08 95       	ret

00002e1e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2e1e:	0f 92       	push	r0
    2e20:	0f b6       	in	r0, 0x3f	; 63
    2e22:	f8 94       	cli
    2e24:	0f 92       	push	r0
    2e26:	1f 92       	push	r1
    2e28:	11 24       	eor	r1, r1
    2e2a:	2f 92       	push	r2
    2e2c:	3f 92       	push	r3
    2e2e:	4f 92       	push	r4
    2e30:	5f 92       	push	r5
    2e32:	6f 92       	push	r6
    2e34:	7f 92       	push	r7
    2e36:	8f 92       	push	r8
    2e38:	9f 92       	push	r9
    2e3a:	af 92       	push	r10
    2e3c:	bf 92       	push	r11
    2e3e:	cf 92       	push	r12
    2e40:	df 92       	push	r13
    2e42:	ef 92       	push	r14
    2e44:	ff 92       	push	r15
    2e46:	0f 93       	push	r16
    2e48:	1f 93       	push	r17
    2e4a:	2f 93       	push	r18
    2e4c:	3f 93       	push	r19
    2e4e:	4f 93       	push	r20
    2e50:	5f 93       	push	r21
    2e52:	6f 93       	push	r22
    2e54:	7f 93       	push	r23
    2e56:	8f 93       	push	r24
    2e58:	9f 93       	push	r25
    2e5a:	af 93       	push	r26
    2e5c:	bf 93       	push	r27
    2e5e:	cf 93       	push	r28
    2e60:	df 93       	push	r29
    2e62:	ef 93       	push	r30
    2e64:	ff 93       	push	r31
    2e66:	a0 91 17 05 	lds	r26, 0x0517
    2e6a:	b0 91 18 05 	lds	r27, 0x0518
    2e6e:	0d b6       	in	r0, 0x3d	; 61
    2e70:	0d 92       	st	X+, r0
    2e72:	0e b6       	in	r0, 0x3e	; 62
    2e74:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2e76:	0e 94 04 24 	call	0x4808	; 0x4808 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2e7a:	a0 91 17 05 	lds	r26, 0x0517
    2e7e:	b0 91 18 05 	lds	r27, 0x0518
    2e82:	cd 91       	ld	r28, X+
    2e84:	cd bf       	out	0x3d, r28	; 61
    2e86:	dd 91       	ld	r29, X+
    2e88:	de bf       	out	0x3e, r29	; 62
    2e8a:	ff 91       	pop	r31
    2e8c:	ef 91       	pop	r30
    2e8e:	df 91       	pop	r29
    2e90:	cf 91       	pop	r28
    2e92:	bf 91       	pop	r27
    2e94:	af 91       	pop	r26
    2e96:	9f 91       	pop	r25
    2e98:	8f 91       	pop	r24
    2e9a:	7f 91       	pop	r23
    2e9c:	6f 91       	pop	r22
    2e9e:	5f 91       	pop	r21
    2ea0:	4f 91       	pop	r20
    2ea2:	3f 91       	pop	r19
    2ea4:	2f 91       	pop	r18
    2ea6:	1f 91       	pop	r17
    2ea8:	0f 91       	pop	r16
    2eaa:	ff 90       	pop	r15
    2eac:	ef 90       	pop	r14
    2eae:	df 90       	pop	r13
    2eb0:	cf 90       	pop	r12
    2eb2:	bf 90       	pop	r11
    2eb4:	af 90       	pop	r10
    2eb6:	9f 90       	pop	r9
    2eb8:	8f 90       	pop	r8
    2eba:	7f 90       	pop	r7
    2ebc:	6f 90       	pop	r6
    2ebe:	5f 90       	pop	r5
    2ec0:	4f 90       	pop	r4
    2ec2:	3f 90       	pop	r3
    2ec4:	2f 90       	pop	r2
    2ec6:	1f 90       	pop	r1
    2ec8:	0f 90       	pop	r0
    2eca:	0f be       	out	0x3f, r0	; 63
    2ecc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ece:	08 95       	ret

00002ed0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2ed0:	0f 92       	push	r0
    2ed2:	0f b6       	in	r0, 0x3f	; 63
    2ed4:	f8 94       	cli
    2ed6:	0f 92       	push	r0
    2ed8:	1f 92       	push	r1
    2eda:	11 24       	eor	r1, r1
    2edc:	2f 92       	push	r2
    2ede:	3f 92       	push	r3
    2ee0:	4f 92       	push	r4
    2ee2:	5f 92       	push	r5
    2ee4:	6f 92       	push	r6
    2ee6:	7f 92       	push	r7
    2ee8:	8f 92       	push	r8
    2eea:	9f 92       	push	r9
    2eec:	af 92       	push	r10
    2eee:	bf 92       	push	r11
    2ef0:	cf 92       	push	r12
    2ef2:	df 92       	push	r13
    2ef4:	ef 92       	push	r14
    2ef6:	ff 92       	push	r15
    2ef8:	0f 93       	push	r16
    2efa:	1f 93       	push	r17
    2efc:	2f 93       	push	r18
    2efe:	3f 93       	push	r19
    2f00:	4f 93       	push	r20
    2f02:	5f 93       	push	r21
    2f04:	6f 93       	push	r22
    2f06:	7f 93       	push	r23
    2f08:	8f 93       	push	r24
    2f0a:	9f 93       	push	r25
    2f0c:	af 93       	push	r26
    2f0e:	bf 93       	push	r27
    2f10:	cf 93       	push	r28
    2f12:	df 93       	push	r29
    2f14:	ef 93       	push	r30
    2f16:	ff 93       	push	r31
    2f18:	a0 91 17 05 	lds	r26, 0x0517
    2f1c:	b0 91 18 05 	lds	r27, 0x0518
    2f20:	0d b6       	in	r0, 0x3d	; 61
    2f22:	0d 92       	st	X+, r0
    2f24:	0e b6       	in	r0, 0x3e	; 62
    2f26:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2f28:	0e 94 b2 22 	call	0x4564	; 0x4564 <xTaskIncrementTick>
    2f2c:	88 23       	and	r24, r24
    2f2e:	11 f0       	breq	.+4      	; 0x2f34 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2f30:	0e 94 04 24 	call	0x4808	; 0x4808 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2f34:	a0 91 17 05 	lds	r26, 0x0517
    2f38:	b0 91 18 05 	lds	r27, 0x0518
    2f3c:	cd 91       	ld	r28, X+
    2f3e:	cd bf       	out	0x3d, r28	; 61
    2f40:	dd 91       	ld	r29, X+
    2f42:	de bf       	out	0x3e, r29	; 62
    2f44:	ff 91       	pop	r31
    2f46:	ef 91       	pop	r30
    2f48:	df 91       	pop	r29
    2f4a:	cf 91       	pop	r28
    2f4c:	bf 91       	pop	r27
    2f4e:	af 91       	pop	r26
    2f50:	9f 91       	pop	r25
    2f52:	8f 91       	pop	r24
    2f54:	7f 91       	pop	r23
    2f56:	6f 91       	pop	r22
    2f58:	5f 91       	pop	r21
    2f5a:	4f 91       	pop	r20
    2f5c:	3f 91       	pop	r19
    2f5e:	2f 91       	pop	r18
    2f60:	1f 91       	pop	r17
    2f62:	0f 91       	pop	r16
    2f64:	ff 90       	pop	r15
    2f66:	ef 90       	pop	r14
    2f68:	df 90       	pop	r13
    2f6a:	cf 90       	pop	r12
    2f6c:	bf 90       	pop	r11
    2f6e:	af 90       	pop	r10
    2f70:	9f 90       	pop	r9
    2f72:	8f 90       	pop	r8
    2f74:	7f 90       	pop	r7
    2f76:	6f 90       	pop	r6
    2f78:	5f 90       	pop	r5
    2f7a:	4f 90       	pop	r4
    2f7c:	3f 90       	pop	r3
    2f7e:	2f 90       	pop	r2
    2f80:	1f 90       	pop	r1
    2f82:	0f 90       	pop	r0
    2f84:	0f be       	out	0x3f, r0	; 63
    2f86:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2f88:	08 95       	ret

00002f8a <SIG_OUTPUT_COMPARE1A>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2f8a:	0e 94 68 17 	call	0x2ed0	; 0x2ed0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2f8e:	18 95       	reti

00002f90 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2f90:	0f b6       	in	r0, 0x3f	; 63
    2f92:	f8 94       	cli
    2f94:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2f96:	fc 01       	movw	r30, r24
    2f98:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2f9a:	0f 90       	pop	r0
    2f9c:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
    2f9e:	81 e0       	ldi	r24, 0x01	; 1
    2fa0:	91 11       	cpse	r25, r1
    2fa2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    2fa4:	08 95       	ret

00002fa6 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2fa6:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2fa8:	44 8d       	ldd	r20, Z+28	; 0x1c
    2faa:	44 23       	and	r20, r20
    2fac:	c1 f0       	breq	.+48     	; 0x2fde <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2fae:	26 81       	ldd	r18, Z+6	; 0x06
    2fb0:	37 81       	ldd	r19, Z+7	; 0x07
    2fb2:	24 0f       	add	r18, r20
    2fb4:	31 1d       	adc	r19, r1
    2fb6:	37 83       	std	Z+7, r19	; 0x07
    2fb8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2fba:	a4 81       	ldd	r26, Z+4	; 0x04
    2fbc:	b5 81       	ldd	r27, Z+5	; 0x05
    2fbe:	2a 17       	cp	r18, r26
    2fc0:	3b 07       	cpc	r19, r27
    2fc2:	20 f0       	brcs	.+8      	; 0x2fcc <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2fc4:	20 81       	ld	r18, Z
    2fc6:	31 81       	ldd	r19, Z+1	; 0x01
    2fc8:	37 83       	std	Z+7, r19	; 0x07
    2fca:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2fcc:	36 81       	ldd	r19, Z+6	; 0x06
    2fce:	27 81       	ldd	r18, Z+7	; 0x07
    2fd0:	86 2f       	mov	r24, r22
    2fd2:	97 2f       	mov	r25, r23
    2fd4:	63 2f       	mov	r22, r19
    2fd6:	72 2f       	mov	r23, r18
    2fd8:	50 e0       	ldi	r21, 0x00	; 0
    2fda:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>
    2fde:	08 95       	ret

00002fe0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2fe0:	0f 93       	push	r16
    2fe2:	1f 93       	push	r17
    2fe4:	cf 93       	push	r28
    2fe6:	df 93       	push	r29
    2fe8:	ec 01       	movw	r28, r24
    2fea:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2fec:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2fee:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2ff0:	44 23       	and	r20, r20
    2ff2:	b9 f1       	breq	.+110    	; 0x3062 <prvCopyDataToQueue+0x82>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2ff4:	11 23       	and	r17, r17
    2ff6:	b1 f4       	brne	.+44     	; 0x3024 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    2ffa:	9b 81       	ldd	r25, Y+3	; 0x03
    2ffc:	50 e0       	ldi	r21, 0x00	; 0
    2ffe:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3002:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3004:	8a 81       	ldd	r24, Y+2	; 0x02
    3006:	9b 81       	ldd	r25, Y+3	; 0x03
    3008:	82 0f       	add	r24, r18
    300a:	91 1d       	adc	r25, r1
    300c:	9b 83       	std	Y+3, r25	; 0x03
    300e:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3010:	2c 81       	ldd	r18, Y+4	; 0x04
    3012:	3d 81       	ldd	r19, Y+5	; 0x05
    3014:	82 17       	cp	r24, r18
    3016:	93 07       	cpc	r25, r19
    3018:	20 f1       	brcs	.+72     	; 0x3062 <prvCopyDataToQueue+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    301a:	88 81       	ld	r24, Y
    301c:	99 81       	ldd	r25, Y+1	; 0x01
    301e:	9b 83       	std	Y+3, r25	; 0x03
    3020:	8a 83       	std	Y+2, r24	; 0x02
    3022:	1f c0       	rjmp	.+62     	; 0x3062 <prvCopyDataToQueue+0x82>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3024:	8e 81       	ldd	r24, Y+6	; 0x06
    3026:	9f 81       	ldd	r25, Y+7	; 0x07
    3028:	50 e0       	ldi	r21, 0x00	; 0
    302a:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    302e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3030:	50 e0       	ldi	r21, 0x00	; 0
    3032:	50 95       	com	r21
    3034:	41 95       	neg	r20
    3036:	5f 4f       	sbci	r21, 0xFF	; 255
    3038:	8e 81       	ldd	r24, Y+6	; 0x06
    303a:	9f 81       	ldd	r25, Y+7	; 0x07
    303c:	84 0f       	add	r24, r20
    303e:	95 1f       	adc	r25, r21
    3040:	9f 83       	std	Y+7, r25	; 0x07
    3042:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3044:	28 81       	ld	r18, Y
    3046:	39 81       	ldd	r19, Y+1	; 0x01
    3048:	82 17       	cp	r24, r18
    304a:	93 07       	cpc	r25, r19
    304c:	30 f4       	brcc	.+12     	; 0x305a <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    304e:	8c 81       	ldd	r24, Y+4	; 0x04
    3050:	9d 81       	ldd	r25, Y+5	; 0x05
    3052:	84 0f       	add	r24, r20
    3054:	95 1f       	adc	r25, r21
    3056:	9f 83       	std	Y+7, r25	; 0x07
    3058:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    305a:	12 30       	cpi	r17, 0x02	; 2
    305c:	11 f4       	brne	.+4      	; 0x3062 <prvCopyDataToQueue+0x82>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    305e:	01 11       	cpse	r16, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3060:	01 50       	subi	r16, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3062:	0f 5f       	subi	r16, 0xFF	; 255
    3064:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
    3066:	80 e0       	ldi	r24, 0x00	; 0
    3068:	df 91       	pop	r29
    306a:	cf 91       	pop	r28
    306c:	1f 91       	pop	r17
    306e:	0f 91       	pop	r16
    3070:	08 95       	ret

00003072 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3072:	ef 92       	push	r14
    3074:	ff 92       	push	r15
    3076:	0f 93       	push	r16
    3078:	1f 93       	push	r17
    307a:	cf 93       	push	r28
    307c:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    307e:	0f b6       	in	r0, 0x3f	; 63
    3080:	f8 94       	cli
    3082:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3084:	fc 01       	movw	r30, r24
    3086:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3088:	1c 16       	cp	r1, r28
    308a:	cc f4       	brge	.+50     	; 0x30be <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    308c:	81 89       	ldd	r24, Z+17	; 0x11
    308e:	88 23       	and	r24, r24
    3090:	31 f4       	brne	.+12     	; 0x309e <prvUnlockQueue+0x2c>
    3092:	15 c0       	rjmp	.+42     	; 0x30be <prvUnlockQueue+0x4c>
    3094:	f8 01       	movw	r30, r16
    3096:	81 89       	ldd	r24, Z+17	; 0x11
    3098:	88 23       	and	r24, r24
    309a:	41 f4       	brne	.+16     	; 0x30ac <prvUnlockQueue+0x3a>
    309c:	10 c0       	rjmp	.+32     	; 0x30be <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    309e:	0f 2e       	mov	r0, r31
    30a0:	f1 e1       	ldi	r31, 0x11	; 17
    30a2:	ef 2e       	mov	r14, r31
    30a4:	ff 24       	eor	r15, r15
    30a6:	f0 2d       	mov	r31, r0
    30a8:	e0 0e       	add	r14, r16
    30aa:	f1 1e       	adc	r15, r17
    30ac:	c7 01       	movw	r24, r14
    30ae:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    30b2:	88 23       	and	r24, r24
    30b4:	11 f0       	breq	.+4      	; 0x30ba <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    30b6:	0e 94 56 25 	call	0x4aac	; 0x4aac <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    30ba:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    30bc:	59 f7       	brne	.-42     	; 0x3094 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    30be:	8f ef       	ldi	r24, 0xFF	; 255
    30c0:	f8 01       	movw	r30, r16
    30c2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    30c4:	0f 90       	pop	r0
    30c6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	f8 94       	cli
    30cc:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    30ce:	f8 01       	movw	r30, r16
    30d0:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    30d2:	1c 16       	cp	r1, r28
    30d4:	c4 f4       	brge	.+48     	; 0x3106 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30d6:	80 85       	ldd	r24, Z+8	; 0x08
    30d8:	88 23       	and	r24, r24
    30da:	31 f4       	brne	.+12     	; 0x30e8 <prvUnlockQueue+0x76>
    30dc:	14 c0       	rjmp	.+40     	; 0x3106 <prvUnlockQueue+0x94>
    30de:	f8 01       	movw	r30, r16
    30e0:	80 85       	ldd	r24, Z+8	; 0x08
    30e2:	88 23       	and	r24, r24
    30e4:	39 f4       	brne	.+14     	; 0x30f4 <prvUnlockQueue+0x82>
    30e6:	0f c0       	rjmp	.+30     	; 0x3106 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30e8:	ee 24       	eor	r14, r14
    30ea:	ff 24       	eor	r15, r15
    30ec:	68 94       	set
    30ee:	e3 f8       	bld	r14, 3
    30f0:	e0 0e       	add	r14, r16
    30f2:	f1 1e       	adc	r15, r17
    30f4:	c7 01       	movw	r24, r14
    30f6:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    30fa:	88 23       	and	r24, r24
    30fc:	11 f0       	breq	.+4      	; 0x3102 <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
    30fe:	0e 94 56 25 	call	0x4aac	; 0x4aac <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3102:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3104:	61 f7       	brne	.-40     	; 0x30de <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3106:	8f ef       	ldi	r24, 0xFF	; 255
    3108:	f8 01       	movw	r30, r16
    310a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    310c:	0f 90       	pop	r0
    310e:	0f be       	out	0x3f, r0	; 63
}
    3110:	cf 91       	pop	r28
    3112:	1f 91       	pop	r17
    3114:	0f 91       	pop	r16
    3116:	ff 90       	pop	r15
    3118:	ef 90       	pop	r14
    311a:	08 95       	ret

0000311c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    311c:	cf 93       	push	r28
    311e:	df 93       	push	r29
    3120:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3122:	0f b6       	in	r0, 0x3f	; 63
    3124:	f8 94       	cli
    3126:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3128:	48 81       	ld	r20, Y
    312a:	59 81       	ldd	r21, Y+1	; 0x01
    312c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    312e:	ec 8d       	ldd	r30, Y+28	; 0x1c
    3130:	30 e0       	ldi	r19, 0x00	; 0
    3132:	f0 e0       	ldi	r31, 0x00	; 0
    3134:	2e 9f       	mul	r18, r30
    3136:	c0 01       	movw	r24, r0
    3138:	2f 9f       	mul	r18, r31
    313a:	90 0d       	add	r25, r0
    313c:	3e 9f       	mul	r19, r30
    313e:	90 0d       	add	r25, r0
    3140:	11 24       	eor	r1, r1
    3142:	84 0f       	add	r24, r20
    3144:	95 1f       	adc	r25, r21
    3146:	9d 83       	std	Y+5, r25	; 0x05
    3148:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    314a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    314c:	5b 83       	std	Y+3, r21	; 0x03
    314e:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3150:	c9 01       	movw	r24, r18
    3152:	01 97       	sbiw	r24, 0x01	; 1
    3154:	8e 9f       	mul	r24, r30
    3156:	90 01       	movw	r18, r0
    3158:	8f 9f       	mul	r24, r31
    315a:	30 0d       	add	r19, r0
    315c:	9e 9f       	mul	r25, r30
    315e:	30 0d       	add	r19, r0
    3160:	11 24       	eor	r1, r1
    3162:	24 0f       	add	r18, r20
    3164:	35 1f       	adc	r19, r21
    3166:	3f 83       	std	Y+7, r19	; 0x07
    3168:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    316a:	8f ef       	ldi	r24, 0xFF	; 255
    316c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    316e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3170:	66 23       	and	r22, r22
    3172:	61 f4       	brne	.+24     	; 0x318c <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3174:	88 85       	ldd	r24, Y+8	; 0x08
    3176:	88 23       	and	r24, r24
    3178:	89 f0       	breq	.+34     	; 0x319c <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    317a:	ce 01       	movw	r24, r28
    317c:	08 96       	adiw	r24, 0x08	; 8
    317e:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    3182:	88 23       	and	r24, r24
    3184:	59 f0       	breq	.+22     	; 0x319c <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3186:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    318a:	08 c0       	rjmp	.+16     	; 0x319c <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    318c:	ce 01       	movw	r24, r28
    318e:	08 96       	adiw	r24, 0x08	; 8
    3190:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3194:	ce 01       	movw	r24, r28
    3196:	41 96       	adiw	r24, 0x11	; 17
    3198:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    319c:	0f 90       	pop	r0
    319e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    31a0:	81 e0       	ldi	r24, 0x01	; 1
    31a2:	df 91       	pop	r29
    31a4:	cf 91       	pop	r28
    31a6:	08 95       	ret

000031a8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    31a8:	0f 93       	push	r16
    31aa:	1f 93       	push	r17
    31ac:	cf 93       	push	r28
    31ae:	df 93       	push	r29
    31b0:	08 2f       	mov	r16, r24
    31b2:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    31b4:	66 23       	and	r22, r22
    31b6:	21 f0       	breq	.+8      	; 0x31c0 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    31b8:	68 9f       	mul	r22, r24
    31ba:	c0 01       	movw	r24, r0
    31bc:	11 24       	eor	r1, r1
    31be:	02 c0       	rjmp	.+4      	; 0x31c4 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    31c0:	80 e0       	ldi	r24, 0x00	; 0
    31c2:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    31c4:	4f 96       	adiw	r24, 0x1f	; 31
    31c6:	0e 94 78 15 	call	0x2af0	; 0x2af0 <pvPortMalloc>
    31ca:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    31cc:	00 97       	sbiw	r24, 0x00	; 0
    31ce:	71 f0       	breq	.+28     	; 0x31ec <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    31d0:	11 23       	and	r17, r17
    31d2:	19 f4       	brne	.+6      	; 0x31da <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    31d4:	99 83       	std	Y+1, r25	; 0x01
    31d6:	88 83       	st	Y, r24
    31d8:	03 c0       	rjmp	.+6      	; 0x31e0 <xQueueGenericCreate+0x38>
		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    31da:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    31dc:	99 83       	std	Y+1, r25	; 0x01
    31de:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    31e0:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    31e2:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    31e4:	ce 01       	movw	r24, r28
    31e6:	61 e0       	ldi	r22, 0x01	; 1
    31e8:	0e 94 8e 18 	call	0x311c	; 0x311c <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    31ec:	8c 2f       	mov	r24, r28
    31ee:	9d 2f       	mov	r25, r29
    31f0:	df 91       	pop	r29
    31f2:	cf 91       	pop	r28
    31f4:	1f 91       	pop	r17
    31f6:	0f 91       	pop	r16
    31f8:	08 95       	ret

000031fa <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    31fa:	8f 92       	push	r8
    31fc:	9f 92       	push	r9
    31fe:	bf 92       	push	r11
    3200:	cf 92       	push	r12
    3202:	df 92       	push	r13
    3204:	ef 92       	push	r14
    3206:	ff 92       	push	r15
    3208:	0f 93       	push	r16
    320a:	1f 93       	push	r17
    320c:	cf 93       	push	r28
    320e:	df 93       	push	r29
    3210:	00 d0       	rcall	.+0      	; 0x3212 <xQueueGenericSend+0x18>
    3212:	00 d0       	rcall	.+0      	; 0x3214 <xQueueGenericSend+0x1a>
    3214:	0f 92       	push	r0
    3216:	cd b7       	in	r28, 0x3d	; 61
    3218:	de b7       	in	r29, 0x3e	; 62
    321a:	8c 01       	movw	r16, r24
    321c:	4b 01       	movw	r8, r22
    321e:	5d 83       	std	Y+5, r21	; 0x05
    3220:	4c 83       	std	Y+4, r20	; 0x04
    3222:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3224:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3226:	bb 24       	eor	r11, r11
    3228:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    322a:	cc 24       	eor	r12, r12
    322c:	dd 24       	eor	r13, r13
    322e:	68 94       	set
    3230:	c3 f8       	bld	r12, 3
    3232:	c8 0e       	add	r12, r24
    3234:	d9 1e       	adc	r13, r25
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3236:	0f b6       	in	r0, 0x3f	; 63
    3238:	f8 94       	cli
    323a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    323c:	f8 01       	movw	r30, r16
    323e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3240:	83 8d       	ldd	r24, Z+27	; 0x1b
    3242:	98 17       	cp	r25, r24
    3244:	18 f0       	brcs	.+6      	; 0x324c <xQueueGenericSend+0x52>
    3246:	f2 e0       	ldi	r31, 0x02	; 2
    3248:	ef 16       	cp	r14, r31
    324a:	d1 f4       	brne	.+52     	; 0x3280 <xQueueGenericSend+0x86>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    324c:	c8 01       	movw	r24, r16
    324e:	b4 01       	movw	r22, r8
    3250:	4e 2d       	mov	r20, r14
    3252:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3256:	f8 01       	movw	r30, r16
    3258:	91 89       	ldd	r25, Z+17	; 0x11
    325a:	99 23       	and	r25, r25
    325c:	49 f0       	breq	.+18     	; 0x3270 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    325e:	c8 01       	movw	r24, r16
    3260:	41 96       	adiw	r24, 0x11	; 17
    3262:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    3266:	88 23       	and	r24, r24
    3268:	39 f0       	breq	.+14     	; 0x3278 <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    326a:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    326e:	04 c0       	rjmp	.+8      	; 0x3278 <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3270:	88 23       	and	r24, r24
    3272:	11 f0       	breq	.+4      	; 0x3278 <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3274:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3278:	0f 90       	pop	r0
    327a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    327c:	81 e0       	ldi	r24, 0x01	; 1
    327e:	52 c0       	rjmp	.+164    	; 0x3324 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3280:	8c 81       	ldd	r24, Y+4	; 0x04
    3282:	9d 81       	ldd	r25, Y+5	; 0x05
    3284:	00 97       	sbiw	r24, 0x00	; 0
    3286:	21 f4       	brne	.+8      	; 0x3290 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3288:	0f 90       	pop	r0
    328a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    328c:	80 e0       	ldi	r24, 0x00	; 0
    328e:	4a c0       	rjmp	.+148    	; 0x3324 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    3290:	ff 20       	and	r15, r15
    3292:	29 f4       	brne	.+10     	; 0x329e <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3294:	ce 01       	movw	r24, r28
    3296:	01 96       	adiw	r24, 0x01	; 1
    3298:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    329c:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    329e:	0f 90       	pop	r0
    32a0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    32a2:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    32a6:	0f b6       	in	r0, 0x3f	; 63
    32a8:	f8 94       	cli
    32aa:	0f 92       	push	r0
    32ac:	f8 01       	movw	r30, r16
    32ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    32b0:	8f 3f       	cpi	r24, 0xFF	; 255
    32b2:	09 f4       	brne	.+2      	; 0x32b6 <xQueueGenericSend+0xbc>
    32b4:	15 8e       	std	Z+29, r1	; 0x1d
    32b6:	f8 01       	movw	r30, r16
    32b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    32ba:	8f 3f       	cpi	r24, 0xFF	; 255
    32bc:	09 f4       	brne	.+2      	; 0x32c0 <xQueueGenericSend+0xc6>
    32be:	16 8e       	std	Z+30, r1	; 0x1e
    32c0:	0f 90       	pop	r0
    32c2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    32c4:	ce 01       	movw	r24, r28
    32c6:	01 96       	adiw	r24, 0x01	; 1
    32c8:	be 01       	movw	r22, r28
    32ca:	6c 5f       	subi	r22, 0xFC	; 252
    32cc:	7f 4f       	sbci	r23, 0xFF	; 255
    32ce:	0e 94 29 25 	call	0x4a52	; 0x4a52 <xTaskCheckForTimeOut>
    32d2:	88 23       	and	r24, r24
    32d4:	09 f5       	brne	.+66     	; 0x3318 <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    32d6:	0f b6       	in	r0, 0x3f	; 63
    32d8:	f8 94       	cli
    32da:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    32dc:	f8 01       	movw	r30, r16
    32de:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    32e0:	0f 90       	pop	r0
    32e2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    32e4:	f8 01       	movw	r30, r16
    32e6:	83 8d       	ldd	r24, Z+27	; 0x1b
    32e8:	98 17       	cp	r25, r24
    32ea:	81 f4       	brne	.+32     	; 0x330c <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    32ec:	6c 81       	ldd	r22, Y+4	; 0x04
    32ee:	7d 81       	ldd	r23, Y+5	; 0x05
    32f0:	c6 01       	movw	r24, r12
    32f2:	0e 94 60 24 	call	0x48c0	; 0x48c0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    32f6:	c8 01       	movw	r24, r16
    32f8:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    32fc:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    3300:	88 23       	and	r24, r24
    3302:	09 f0       	breq	.+2      	; 0x3306 <xQueueGenericSend+0x10c>
    3304:	98 cf       	rjmp	.-208    	; 0x3236 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    3306:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    330a:	95 cf       	rjmp	.-214    	; 0x3236 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    330c:	c8 01       	movw	r24, r16
    330e:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3312:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    3316:	8f cf       	rjmp	.-226    	; 0x3236 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3318:	c8 01       	movw	r24, r16
    331a:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    331e:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3322:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    3324:	0f 90       	pop	r0
    3326:	0f 90       	pop	r0
    3328:	0f 90       	pop	r0
    332a:	0f 90       	pop	r0
    332c:	0f 90       	pop	r0
    332e:	df 91       	pop	r29
    3330:	cf 91       	pop	r28
    3332:	1f 91       	pop	r17
    3334:	0f 91       	pop	r16
    3336:	ff 90       	pop	r15
    3338:	ef 90       	pop	r14
    333a:	df 90       	pop	r13
    333c:	cf 90       	pop	r12
    333e:	bf 90       	pop	r11
    3340:	9f 90       	pop	r9
    3342:	8f 90       	pop	r8
    3344:	08 95       	ret

00003346 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3346:	ef 92       	push	r14
    3348:	ff 92       	push	r15
    334a:	0f 93       	push	r16
    334c:	1f 93       	push	r17
    334e:	cf 93       	push	r28
    3350:	8c 01       	movw	r16, r24
    3352:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3354:	fc 01       	movw	r30, r24
    3356:	92 8d       	ldd	r25, Z+26	; 0x1a
    3358:	83 8d       	ldd	r24, Z+27	; 0x1b
    335a:	98 17       	cp	r25, r24
    335c:	10 f0       	brcs	.+4      	; 0x3362 <xQueueGenericSendFromISR+0x1c>
    335e:	22 30       	cpi	r18, 0x02	; 2
    3360:	f1 f4       	brne	.+60     	; 0x339e <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3362:	f8 01       	movw	r30, r16
    3364:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3366:	c8 01       	movw	r24, r16
    3368:	42 2f       	mov	r20, r18
    336a:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    336e:	cf 3f       	cpi	r28, 0xFF	; 255
    3370:	89 f4       	brne	.+34     	; 0x3394 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3372:	f8 01       	movw	r30, r16
    3374:	81 89       	ldd	r24, Z+17	; 0x11
    3376:	88 23       	and	r24, r24
    3378:	a1 f0       	breq	.+40     	; 0x33a2 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    337a:	c8 01       	movw	r24, r16
    337c:	41 96       	adiw	r24, 0x11	; 17
    337e:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    3382:	88 23       	and	r24, r24
    3384:	81 f0       	breq	.+32     	; 0x33a6 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3386:	e1 14       	cp	r14, r1
    3388:	f1 04       	cpc	r15, r1
    338a:	79 f0       	breq	.+30     	; 0x33aa <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    338c:	81 e0       	ldi	r24, 0x01	; 1
    338e:	f7 01       	movw	r30, r14
    3390:	80 83       	st	Z, r24
    3392:	0c c0       	rjmp	.+24     	; 0x33ac <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3394:	cf 5f       	subi	r28, 0xFF	; 255
    3396:	f8 01       	movw	r30, r16
    3398:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    339a:	81 e0       	ldi	r24, 0x01	; 1
    339c:	07 c0       	rjmp	.+14     	; 0x33ac <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    339e:	80 e0       	ldi	r24, 0x00	; 0
    33a0:	05 c0       	rjmp	.+10     	; 0x33ac <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    33a2:	81 e0       	ldi	r24, 0x01	; 1
    33a4:	03 c0       	rjmp	.+6      	; 0x33ac <xQueueGenericSendFromISR+0x66>
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	01 c0       	rjmp	.+2      	; 0x33ac <xQueueGenericSendFromISR+0x66>
    33aa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    33ac:	cf 91       	pop	r28
    33ae:	1f 91       	pop	r17
    33b0:	0f 91       	pop	r16
    33b2:	ff 90       	pop	r15
    33b4:	ef 90       	pop	r14
    33b6:	08 95       	ret

000033b8 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    33b8:	cf 93       	push	r28
    33ba:	df 93       	push	r29
    33bc:	fc 01       	movw	r30, r24
    33be:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    33c0:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    33c2:	93 8d       	ldd	r25, Z+27	; 0x1b
    33c4:	89 17       	cp	r24, r25
    33c6:	b8 f4       	brcc	.+46     	; 0x33f6 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    33c8:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    33ca:	8f 5f       	subi	r24, 0xFF	; 255
    33cc:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    33ce:	9f 3f       	cpi	r25, 0xFF	; 255
    33d0:	71 f4       	brne	.+28     	; 0x33ee <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    33d2:	81 89       	ldd	r24, Z+17	; 0x11
    33d4:	88 23       	and	r24, r24
    33d6:	89 f0       	breq	.+34     	; 0x33fa <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    33d8:	cf 01       	movw	r24, r30
    33da:	41 96       	adiw	r24, 0x11	; 17
    33dc:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    33e0:	88 23       	and	r24, r24
    33e2:	69 f0       	breq	.+26     	; 0x33fe <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    33e4:	20 97       	sbiw	r28, 0x00	; 0
    33e6:	69 f0       	breq	.+26     	; 0x3402 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    33e8:	81 e0       	ldi	r24, 0x01	; 1
    33ea:	88 83       	st	Y, r24
    33ec:	0b c0       	rjmp	.+22     	; 0x3404 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    33ee:	9f 5f       	subi	r25, 0xFF	; 255
    33f0:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    33f2:	81 e0       	ldi	r24, 0x01	; 1
    33f4:	07 c0       	rjmp	.+14     	; 0x3404 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    33f6:	80 e0       	ldi	r24, 0x00	; 0
    33f8:	05 c0       	rjmp	.+10     	; 0x3404 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    33fa:	81 e0       	ldi	r24, 0x01	; 1
    33fc:	03 c0       	rjmp	.+6      	; 0x3404 <xQueueGiveFromISR+0x4c>
    33fe:	81 e0       	ldi	r24, 0x01	; 1
    3400:	01 c0       	rjmp	.+2      	; 0x3404 <xQueueGiveFromISR+0x4c>
    3402:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3404:	df 91       	pop	r29
    3406:	cf 91       	pop	r28
    3408:	08 95       	ret

0000340a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    340a:	8f 92       	push	r8
    340c:	9f 92       	push	r9
    340e:	af 92       	push	r10
    3410:	bf 92       	push	r11
    3412:	df 92       	push	r13
    3414:	ef 92       	push	r14
    3416:	ff 92       	push	r15
    3418:	0f 93       	push	r16
    341a:	1f 93       	push	r17
    341c:	cf 93       	push	r28
    341e:	df 93       	push	r29
    3420:	00 d0       	rcall	.+0      	; 0x3422 <xQueueReceive+0x18>
    3422:	00 d0       	rcall	.+0      	; 0x3424 <xQueueReceive+0x1a>
    3424:	0f 92       	push	r0
    3426:	cd b7       	in	r28, 0x3d	; 61
    3428:	de b7       	in	r29, 0x3e	; 62
    342a:	7c 01       	movw	r14, r24
    342c:	4b 01       	movw	r8, r22
    342e:	5d 83       	std	Y+5, r21	; 0x05
    3430:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    3432:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3434:	dd 24       	eor	r13, r13
    3436:	d3 94       	inc	r13
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3438:	0f 2e       	mov	r0, r31
    343a:	f1 e1       	ldi	r31, 0x11	; 17
    343c:	af 2e       	mov	r10, r31
    343e:	bb 24       	eor	r11, r11
    3440:	f0 2d       	mov	r31, r0
    3442:	a8 0e       	add	r10, r24
    3444:	b9 1e       	adc	r11, r25
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3446:	0f b6       	in	r0, 0x3f	; 63
    3448:	f8 94       	cli
    344a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    344c:	f7 01       	movw	r30, r14
    344e:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3450:	11 23       	and	r17, r17
    3452:	b1 f0       	breq	.+44     	; 0x3480 <xQueueReceive+0x76>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3454:	c7 01       	movw	r24, r14
    3456:	b4 01       	movw	r22, r8
    3458:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    345c:	11 50       	subi	r17, 0x01	; 1
    345e:	f7 01       	movw	r30, r14
    3460:	12 8f       	std	Z+26, r17	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3462:	80 85       	ldd	r24, Z+8	; 0x08
    3464:	88 23       	and	r24, r24
    3466:	41 f0       	breq	.+16     	; 0x3478 <xQueueReceive+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3468:	c7 01       	movw	r24, r14
    346a:	08 96       	adiw	r24, 0x08	; 8
    346c:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    3470:	88 23       	and	r24, r24
    3472:	11 f0       	breq	.+4      	; 0x3478 <xQueueReceive+0x6e>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3474:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3478:	0f 90       	pop	r0
    347a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    347c:	81 e0       	ldi	r24, 0x01	; 1
    347e:	52 c0       	rjmp	.+164    	; 0x3524 <xQueueReceive+0x11a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3480:	8c 81       	ldd	r24, Y+4	; 0x04
    3482:	9d 81       	ldd	r25, Y+5	; 0x05
    3484:	00 97       	sbiw	r24, 0x00	; 0
    3486:	21 f4       	brne	.+8      	; 0x3490 <xQueueReceive+0x86>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3488:	0f 90       	pop	r0
    348a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    348c:	80 e0       	ldi	r24, 0x00	; 0
    348e:	4a c0       	rjmp	.+148    	; 0x3524 <xQueueReceive+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    3490:	00 23       	and	r16, r16
    3492:	29 f4       	brne	.+10     	; 0x349e <xQueueReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3494:	ce 01       	movw	r24, r28
    3496:	01 96       	adiw	r24, 0x01	; 1
    3498:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    349c:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    349e:	0f 90       	pop	r0
    34a0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    34a2:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    34a6:	0f b6       	in	r0, 0x3f	; 63
    34a8:	f8 94       	cli
    34aa:	0f 92       	push	r0
    34ac:	f7 01       	movw	r30, r14
    34ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    34b0:	8f 3f       	cpi	r24, 0xFF	; 255
    34b2:	09 f4       	brne	.+2      	; 0x34b6 <xQueueReceive+0xac>
    34b4:	15 8e       	std	Z+29, r1	; 0x1d
    34b6:	f7 01       	movw	r30, r14
    34b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    34ba:	8f 3f       	cpi	r24, 0xFF	; 255
    34bc:	09 f4       	brne	.+2      	; 0x34c0 <xQueueReceive+0xb6>
    34be:	16 8e       	std	Z+30, r1	; 0x1e
    34c0:	0f 90       	pop	r0
    34c2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    34c4:	ce 01       	movw	r24, r28
    34c6:	01 96       	adiw	r24, 0x01	; 1
    34c8:	be 01       	movw	r22, r28
    34ca:	6c 5f       	subi	r22, 0xFC	; 252
    34cc:	7f 4f       	sbci	r23, 0xFF	; 255
    34ce:	0e 94 29 25 	call	0x4a52	; 0x4a52 <xTaskCheckForTimeOut>
    34d2:	88 23       	and	r24, r24
    34d4:	d9 f4       	brne	.+54     	; 0x350c <xQueueReceive+0x102>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    34d6:	c7 01       	movw	r24, r14
    34d8:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <prvIsQueueEmpty>
    34dc:	88 23       	and	r24, r24
    34de:	81 f0       	breq	.+32     	; 0x3500 <xQueueReceive+0xf6>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    34e0:	6c 81       	ldd	r22, Y+4	; 0x04
    34e2:	7d 81       	ldd	r23, Y+5	; 0x05
    34e4:	c5 01       	movw	r24, r10
    34e6:	0e 94 60 24 	call	0x48c0	; 0x48c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    34ea:	c7 01       	movw	r24, r14
    34ec:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    34f0:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    34f4:	88 23       	and	r24, r24
    34f6:	09 f0       	breq	.+2      	; 0x34fa <xQueueReceive+0xf0>
    34f8:	a6 cf       	rjmp	.-180    	; 0x3446 <xQueueReceive+0x3c>
				{
					portYIELD_WITHIN_API();
    34fa:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    34fe:	a3 cf       	rjmp	.-186    	; 0x3446 <xQueueReceive+0x3c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    3500:	c7 01       	movw	r24, r14
    3502:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3506:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    350a:	9d cf       	rjmp	.-198    	; 0x3446 <xQueueReceive+0x3c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    350c:	c7 01       	movw	r24, r14
    350e:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3512:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3516:	c7 01       	movw	r24, r14
    3518:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <prvIsQueueEmpty>
    351c:	88 23       	and	r24, r24
    351e:	09 f4       	brne	.+2      	; 0x3522 <xQueueReceive+0x118>
    3520:	92 cf       	rjmp	.-220    	; 0x3446 <xQueueReceive+0x3c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3522:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	0f 90       	pop	r0
    352a:	0f 90       	pop	r0
    352c:	0f 90       	pop	r0
    352e:	df 91       	pop	r29
    3530:	cf 91       	pop	r28
    3532:	1f 91       	pop	r17
    3534:	0f 91       	pop	r16
    3536:	ff 90       	pop	r15
    3538:	ef 90       	pop	r14
    353a:	df 90       	pop	r13
    353c:	bf 90       	pop	r11
    353e:	af 90       	pop	r10
    3540:	9f 90       	pop	r9
    3542:	8f 90       	pop	r8
    3544:	08 95       	ret

00003546 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    3546:	cf 92       	push	r12
    3548:	df 92       	push	r13
    354a:	ef 92       	push	r14
    354c:	ff 92       	push	r15
    354e:	0f 93       	push	r16
    3550:	1f 93       	push	r17
    3552:	cf 93       	push	r28
    3554:	df 93       	push	r29
    3556:	00 d0       	rcall	.+0      	; 0x3558 <xQueueSemaphoreTake+0x12>
    3558:	00 d0       	rcall	.+0      	; 0x355a <xQueueSemaphoreTake+0x14>
    355a:	0f 92       	push	r0
    355c:	cd b7       	in	r28, 0x3d	; 61
    355e:	de b7       	in	r29, 0x3e	; 62
    3560:	8c 01       	movw	r16, r24
    3562:	7d 83       	std	Y+5, r23	; 0x05
    3564:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    3566:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3568:	ee 24       	eor	r14, r14
    356a:	e3 94       	inc	r14
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    356c:	0f 2e       	mov	r0, r31
    356e:	f1 e1       	ldi	r31, 0x11	; 17
    3570:	cf 2e       	mov	r12, r31
    3572:	dd 24       	eor	r13, r13
    3574:	f0 2d       	mov	r31, r0
    3576:	c8 0e       	add	r12, r24
    3578:	d9 1e       	adc	r13, r25
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    357a:	0f b6       	in	r0, 0x3f	; 63
    357c:	f8 94       	cli
    357e:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3580:	f8 01       	movw	r30, r16
    3582:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3584:	88 23       	and	r24, r24
    3586:	89 f0       	breq	.+34     	; 0x35aa <xQueueSemaphoreTake+0x64>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3588:	81 50       	subi	r24, 0x01	; 1
    358a:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    358c:	80 85       	ldd	r24, Z+8	; 0x08
    358e:	88 23       	and	r24, r24
    3590:	41 f0       	breq	.+16     	; 0x35a2 <xQueueSemaphoreTake+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3592:	c8 01       	movw	r24, r16
    3594:	08 96       	adiw	r24, 0x08	; 8
    3596:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    359a:	88 23       	and	r24, r24
    359c:	11 f0       	breq	.+4      	; 0x35a2 <xQueueSemaphoreTake+0x5c>
					{
						queueYIELD_IF_USING_PREEMPTION();
    359e:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    35a2:	0f 90       	pop	r0
    35a4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    35a6:	81 e0       	ldi	r24, 0x01	; 1
    35a8:	52 c0       	rjmp	.+164    	; 0x364e <xQueueSemaphoreTake+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    35aa:	8c 81       	ldd	r24, Y+4	; 0x04
    35ac:	9d 81       	ldd	r25, Y+5	; 0x05
    35ae:	00 97       	sbiw	r24, 0x00	; 0
    35b0:	21 f4       	brne	.+8      	; 0x35ba <xQueueSemaphoreTake+0x74>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    35b2:	0f 90       	pop	r0
    35b4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    35b6:	80 e0       	ldi	r24, 0x00	; 0
    35b8:	4a c0       	rjmp	.+148    	; 0x364e <xQueueSemaphoreTake+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
    35ba:	ff 20       	and	r15, r15
    35bc:	29 f4       	brne	.+10     	; 0x35c8 <xQueueSemaphoreTake+0x82>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    35be:	ce 01       	movw	r24, r28
    35c0:	01 96       	adiw	r24, 0x01	; 1
    35c2:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    35c6:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    35c8:	0f 90       	pop	r0
    35ca:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    35cc:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    35d0:	0f b6       	in	r0, 0x3f	; 63
    35d2:	f8 94       	cli
    35d4:	0f 92       	push	r0
    35d6:	f8 01       	movw	r30, r16
    35d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    35da:	8f 3f       	cpi	r24, 0xFF	; 255
    35dc:	09 f4       	brne	.+2      	; 0x35e0 <xQueueSemaphoreTake+0x9a>
    35de:	15 8e       	std	Z+29, r1	; 0x1d
    35e0:	f8 01       	movw	r30, r16
    35e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    35e4:	8f 3f       	cpi	r24, 0xFF	; 255
    35e6:	09 f4       	brne	.+2      	; 0x35ea <xQueueSemaphoreTake+0xa4>
    35e8:	16 8e       	std	Z+30, r1	; 0x1e
    35ea:	0f 90       	pop	r0
    35ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    35ee:	ce 01       	movw	r24, r28
    35f0:	01 96       	adiw	r24, 0x01	; 1
    35f2:	be 01       	movw	r22, r28
    35f4:	6c 5f       	subi	r22, 0xFC	; 252
    35f6:	7f 4f       	sbci	r23, 0xFF	; 255
    35f8:	0e 94 29 25 	call	0x4a52	; 0x4a52 <xTaskCheckForTimeOut>
    35fc:	88 23       	and	r24, r24
    35fe:	d9 f4       	brne	.+54     	; 0x3636 <xQueueSemaphoreTake+0xf0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3600:	c8 01       	movw	r24, r16
    3602:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <prvIsQueueEmpty>
    3606:	88 23       	and	r24, r24
    3608:	81 f0       	breq	.+32     	; 0x362a <xQueueSemaphoreTake+0xe4>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    360a:	6c 81       	ldd	r22, Y+4	; 0x04
    360c:	7d 81       	ldd	r23, Y+5	; 0x05
    360e:	c6 01       	movw	r24, r12
    3610:	0e 94 60 24 	call	0x48c0	; 0x48c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3614:	c8 01       	movw	r24, r16
    3616:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    361a:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    361e:	88 23       	and	r24, r24
    3620:	09 f0       	breq	.+2      	; 0x3624 <xQueueSemaphoreTake+0xde>
    3622:	ab cf       	rjmp	.-170    	; 0x357a <xQueueSemaphoreTake+0x34>
				{
					portYIELD_WITHIN_API();
    3624:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    3628:	a8 cf       	rjmp	.-176    	; 0x357a <xQueueSemaphoreTake+0x34>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    362a:	c8 01       	movw	r24, r16
    362c:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3630:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    3634:	a2 cf       	rjmp	.-188    	; 0x357a <xQueueSemaphoreTake+0x34>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3636:	c8 01       	movw	r24, r16
    3638:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    363c:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3640:	c8 01       	movw	r24, r16
    3642:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <prvIsQueueEmpty>
    3646:	88 23       	and	r24, r24
    3648:	09 f4       	brne	.+2      	; 0x364c <xQueueSemaphoreTake+0x106>
    364a:	97 cf       	rjmp	.-210    	; 0x357a <xQueueSemaphoreTake+0x34>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    364c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    364e:	0f 90       	pop	r0
    3650:	0f 90       	pop	r0
    3652:	0f 90       	pop	r0
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	df 91       	pop	r29
    365a:	cf 91       	pop	r28
    365c:	1f 91       	pop	r17
    365e:	0f 91       	pop	r16
    3660:	ff 90       	pop	r15
    3662:	ef 90       	pop	r14
    3664:	df 90       	pop	r13
    3666:	cf 90       	pop	r12
    3668:	08 95       	ret

0000366a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    366a:	af 92       	push	r10
    366c:	bf 92       	push	r11
    366e:	cf 92       	push	r12
    3670:	df 92       	push	r13
    3672:	ef 92       	push	r14
    3674:	ff 92       	push	r15
    3676:	0f 93       	push	r16
    3678:	1f 93       	push	r17
    367a:	cf 93       	push	r28
    367c:	df 93       	push	r29
    367e:	00 d0       	rcall	.+0      	; 0x3680 <xQueuePeek+0x16>
    3680:	00 d0       	rcall	.+0      	; 0x3682 <xQueuePeek+0x18>
    3682:	0f 92       	push	r0
    3684:	cd b7       	in	r28, 0x3d	; 61
    3686:	de b7       	in	r29, 0x3e	; 62
    3688:	8c 01       	movw	r16, r24
    368a:	5b 01       	movw	r10, r22
    368c:	5d 83       	std	Y+5, r21	; 0x05
    368e:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    3690:	ff 24       	eor	r15, r15
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3692:	ee 24       	eor	r14, r14
    3694:	e3 94       	inc	r14
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3696:	0f 2e       	mov	r0, r31
    3698:	f1 e1       	ldi	r31, 0x11	; 17
    369a:	cf 2e       	mov	r12, r31
    369c:	dd 24       	eor	r13, r13
    369e:	f0 2d       	mov	r31, r0
    36a0:	c8 0e       	add	r12, r24
    36a2:	d9 1e       	adc	r13, r25
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    36a4:	0f b6       	in	r0, 0x3f	; 63
    36a6:	f8 94       	cli
    36a8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    36aa:	f8 01       	movw	r30, r16
    36ac:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    36ae:	88 23       	and	r24, r24
    36b0:	c1 f0       	breq	.+48     	; 0x36e2 <xQueuePeek+0x78>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    36b2:	e6 80       	ldd	r14, Z+6	; 0x06
    36b4:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    36b6:	c8 01       	movw	r24, r16
    36b8:	b5 01       	movw	r22, r10
    36ba:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    36be:	f8 01       	movw	r30, r16
    36c0:	f7 82       	std	Z+7, r15	; 0x07
    36c2:	e6 82       	std	Z+6, r14	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    36c4:	81 89       	ldd	r24, Z+17	; 0x11
    36c6:	88 23       	and	r24, r24
    36c8:	41 f0       	breq	.+16     	; 0x36da <xQueuePeek+0x70>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    36ca:	c8 01       	movw	r24, r16
    36cc:	41 96       	adiw	r24, 0x11	; 17
    36ce:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    36d2:	88 23       	and	r24, r24
    36d4:	11 f0       	breq	.+4      	; 0x36da <xQueuePeek+0x70>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    36d6:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    36da:	0f 90       	pop	r0
    36dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    36de:	81 e0       	ldi	r24, 0x01	; 1
    36e0:	52 c0       	rjmp	.+164    	; 0x3786 <xQueuePeek+0x11c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    36e2:	8c 81       	ldd	r24, Y+4	; 0x04
    36e4:	9d 81       	ldd	r25, Y+5	; 0x05
    36e6:	00 97       	sbiw	r24, 0x00	; 0
    36e8:	21 f4       	brne	.+8      	; 0x36f2 <xQueuePeek+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    36ea:	0f 90       	pop	r0
    36ec:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    36ee:	80 e0       	ldi	r24, 0x00	; 0
    36f0:	4a c0       	rjmp	.+148    	; 0x3786 <xQueuePeek+0x11c>
				}
				else if( xEntryTimeSet == pdFALSE )
    36f2:	ff 20       	and	r15, r15
    36f4:	29 f4       	brne	.+10     	; 0x3700 <xQueuePeek+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    36f6:	ce 01       	movw	r24, r28
    36f8:	01 96       	adiw	r24, 0x01	; 1
    36fa:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    36fe:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3700:	0f 90       	pop	r0
    3702:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3704:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3708:	0f b6       	in	r0, 0x3f	; 63
    370a:	f8 94       	cli
    370c:	0f 92       	push	r0
    370e:	f8 01       	movw	r30, r16
    3710:	85 8d       	ldd	r24, Z+29	; 0x1d
    3712:	8f 3f       	cpi	r24, 0xFF	; 255
    3714:	09 f4       	brne	.+2      	; 0x3718 <xQueuePeek+0xae>
    3716:	15 8e       	std	Z+29, r1	; 0x1d
    3718:	f8 01       	movw	r30, r16
    371a:	86 8d       	ldd	r24, Z+30	; 0x1e
    371c:	8f 3f       	cpi	r24, 0xFF	; 255
    371e:	09 f4       	brne	.+2      	; 0x3722 <xQueuePeek+0xb8>
    3720:	16 8e       	std	Z+30, r1	; 0x1e
    3722:	0f 90       	pop	r0
    3724:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3726:	ce 01       	movw	r24, r28
    3728:	01 96       	adiw	r24, 0x01	; 1
    372a:	be 01       	movw	r22, r28
    372c:	6c 5f       	subi	r22, 0xFC	; 252
    372e:	7f 4f       	sbci	r23, 0xFF	; 255
    3730:	0e 94 29 25 	call	0x4a52	; 0x4a52 <xTaskCheckForTimeOut>
    3734:	88 23       	and	r24, r24
    3736:	d9 f4       	brne	.+54     	; 0x376e <xQueuePeek+0x104>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3738:	c8 01       	movw	r24, r16
    373a:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <prvIsQueueEmpty>
    373e:	88 23       	and	r24, r24
    3740:	81 f0       	breq	.+32     	; 0x3762 <xQueuePeek+0xf8>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3742:	6c 81       	ldd	r22, Y+4	; 0x04
    3744:	7d 81       	ldd	r23, Y+5	; 0x05
    3746:	c6 01       	movw	r24, r12
    3748:	0e 94 60 24 	call	0x48c0	; 0x48c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    374c:	c8 01       	movw	r24, r16
    374e:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3752:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    3756:	88 23       	and	r24, r24
    3758:	09 f0       	breq	.+2      	; 0x375c <xQueuePeek+0xf2>
    375a:	a4 cf       	rjmp	.-184    	; 0x36a4 <xQueuePeek+0x3a>
				{
					portYIELD_WITHIN_API();
    375c:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    3760:	a1 cf       	rjmp	.-190    	; 0x36a4 <xQueuePeek+0x3a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    3762:	c8 01       	movw	r24, r16
    3764:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3768:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    376c:	9b cf       	rjmp	.-202    	; 0x36a4 <xQueuePeek+0x3a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    376e:	c8 01       	movw	r24, r16
    3770:	0e 94 39 18 	call	0x3072	; 0x3072 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3774:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3778:	c8 01       	movw	r24, r16
    377a:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <prvIsQueueEmpty>
    377e:	88 23       	and	r24, r24
    3780:	09 f4       	brne	.+2      	; 0x3784 <xQueuePeek+0x11a>
    3782:	90 cf       	rjmp	.-224    	; 0x36a4 <xQueuePeek+0x3a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3784:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    3786:	0f 90       	pop	r0
    3788:	0f 90       	pop	r0
    378a:	0f 90       	pop	r0
    378c:	0f 90       	pop	r0
    378e:	0f 90       	pop	r0
    3790:	df 91       	pop	r29
    3792:	cf 91       	pop	r28
    3794:	1f 91       	pop	r17
    3796:	0f 91       	pop	r16
    3798:	ff 90       	pop	r15
    379a:	ef 90       	pop	r14
    379c:	df 90       	pop	r13
    379e:	cf 90       	pop	r12
    37a0:	bf 90       	pop	r11
    37a2:	af 90       	pop	r10
    37a4:	08 95       	ret

000037a6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    37a6:	ef 92       	push	r14
    37a8:	ff 92       	push	r15
    37aa:	0f 93       	push	r16
    37ac:	1f 93       	push	r17
    37ae:	cf 93       	push	r28
    37b0:	df 93       	push	r29
    37b2:	8c 01       	movw	r16, r24
    37b4:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    37b6:	fc 01       	movw	r30, r24
    37b8:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    37ba:	cc 23       	and	r28, r28
    37bc:	e9 f0       	breq	.+58     	; 0x37f8 <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    37be:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    37c0:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    37c4:	c1 50       	subi	r28, 0x01	; 1
    37c6:	f8 01       	movw	r30, r16
    37c8:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    37ca:	df 3f       	cpi	r29, 0xFF	; 255
    37cc:	81 f4       	brne	.+32     	; 0x37ee <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    37ce:	80 85       	ldd	r24, Z+8	; 0x08
    37d0:	88 23       	and	r24, r24
    37d2:	a1 f0       	breq	.+40     	; 0x37fc <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    37d4:	c8 01       	movw	r24, r16
    37d6:	08 96       	adiw	r24, 0x08	; 8
    37d8:	0e 94 8b 24 	call	0x4916	; 0x4916 <xTaskRemoveFromEventList>
    37dc:	88 23       	and	r24, r24
    37de:	81 f0       	breq	.+32     	; 0x3800 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    37e0:	e1 14       	cp	r14, r1
    37e2:	f1 04       	cpc	r15, r1
    37e4:	79 f0       	breq	.+30     	; 0x3804 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    37e6:	81 e0       	ldi	r24, 0x01	; 1
    37e8:	f7 01       	movw	r30, r14
    37ea:	80 83       	st	Z, r24
    37ec:	0c c0       	rjmp	.+24     	; 0x3806 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    37ee:	df 5f       	subi	r29, 0xFF	; 255
    37f0:	f8 01       	movw	r30, r16
    37f2:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    37f4:	81 e0       	ldi	r24, 0x01	; 1
    37f6:	07 c0       	rjmp	.+14     	; 0x3806 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    37f8:	80 e0       	ldi	r24, 0x00	; 0
    37fa:	05 c0       	rjmp	.+10     	; 0x3806 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    37fc:	81 e0       	ldi	r24, 0x01	; 1
    37fe:	03 c0       	rjmp	.+6      	; 0x3806 <xQueueReceiveFromISR+0x60>
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	01 c0       	rjmp	.+2      	; 0x3806 <xQueueReceiveFromISR+0x60>
    3804:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3806:	df 91       	pop	r29
    3808:	cf 91       	pop	r28
    380a:	1f 91       	pop	r17
    380c:	0f 91       	pop	r16
    380e:	ff 90       	pop	r15
    3810:	ef 90       	pop	r14
    3812:	08 95       	ret

00003814 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3814:	0f 93       	push	r16
    3816:	1f 93       	push	r17
    3818:	cf 93       	push	r28
    381a:	df 93       	push	r29
    381c:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    381e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3820:	88 23       	and	r24, r24
    3822:	49 f0       	breq	.+18     	; 0x3836 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3824:	0e 81       	ldd	r16, Y+6	; 0x06
    3826:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3828:	ce 01       	movw	r24, r28
    382a:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    382e:	1f 83       	std	Y+7, r17	; 0x07
    3830:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    3832:	81 e0       	ldi	r24, 0x01	; 1
    3834:	01 c0       	rjmp	.+2      	; 0x3838 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    3836:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3838:	df 91       	pop	r29
    383a:	cf 91       	pop	r28
    383c:	1f 91       	pop	r17
    383e:	0f 91       	pop	r16
    3840:	08 95       	ret

00003842 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3842:	0f b6       	in	r0, 0x3f	; 63
    3844:	f8 94       	cli
    3846:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3848:	fc 01       	movw	r30, r24
    384a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    384c:	0f 90       	pop	r0
    384e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3850:	08 95       	ret

00003852 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3852:	fc 01       	movw	r30, r24
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3854:	0f b6       	in	r0, 0x3f	; 63
    3856:	f8 94       	cli
    3858:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    385a:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    385c:	0f 90       	pop	r0
    385e:	0f be       	out	0x3f, r0	; 63

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3860:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3862:	89 1b       	sub	r24, r25
    3864:	08 95       	ret

00003866 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3866:	fc 01       	movw	r30, r24
    3868:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    386a:	08 95       	ret

0000386c <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    386c:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3870:	08 95       	ret

00003872 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3872:	fc 01       	movw	r30, r24
    3874:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    3876:	81 e0       	ldi	r24, 0x01	; 1
    3878:	91 11       	cpse	r25, r1
    387a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    387c:	08 95       	ret

0000387e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    387e:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3880:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    3882:	81 e0       	ldi	r24, 0x01	; 1
    3884:	93 8d       	ldd	r25, Z+27	; 0x1b
    3886:	29 13       	cpse	r18, r25
    3888:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    388a:	08 95       	ret

0000388c <prvBytesInBuffer>:
	return xCount;
}
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    388c:	fc 01       	movw	r30, r24
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    388e:	24 81       	ldd	r18, Z+4	; 0x04
    3890:	35 81       	ldd	r19, Z+5	; 0x05
    3892:	82 81       	ldd	r24, Z+2	; 0x02
    3894:	93 81       	ldd	r25, Z+3	; 0x03
    3896:	82 0f       	add	r24, r18
    3898:	93 1f       	adc	r25, r19
	xCount -= pxStreamBuffer->xTail;
    389a:	40 81       	ld	r20, Z
    389c:	51 81       	ldd	r21, Z+1	; 0x01
    389e:	84 1b       	sub	r24, r20
    38a0:	95 0b       	sbc	r25, r21
	if ( xCount >= pxStreamBuffer->xLength )
    38a2:	82 17       	cp	r24, r18
    38a4:	93 07       	cpc	r25, r19
    38a6:	10 f0       	brcs	.+4      	; 0x38ac <prvBytesInBuffer+0x20>
	{
		xCount -= pxStreamBuffer->xLength;
    38a8:	82 1b       	sub	r24, r18
    38aa:	93 0b       	sbc	r25, r19
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
}
    38ac:	08 95       	ret

000038ae <prvReadBytesFromBuffer>:
	return xCount;
}
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    38ae:	af 92       	push	r10
    38b0:	bf 92       	push	r11
    38b2:	cf 92       	push	r12
    38b4:	df 92       	push	r13
    38b6:	ef 92       	push	r14
    38b8:	ff 92       	push	r15
    38ba:	0f 93       	push	r16
    38bc:	1f 93       	push	r17
    38be:	cf 93       	push	r28
    38c0:	df 93       	push	r29
    38c2:	8c 01       	movw	r16, r24
    38c4:	6b 01       	movw	r12, r22
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    38c6:	c2 2f       	mov	r28, r18
    38c8:	d3 2f       	mov	r29, r19
    38ca:	4c 17       	cp	r20, r28
    38cc:	5d 07       	cpc	r21, r29
    38ce:	08 f4       	brcc	.+2      	; 0x38d2 <prvReadBytesFromBuffer+0x24>
    38d0:	ea 01       	movw	r28, r20

	if( xCount > ( size_t ) 0 )
    38d2:	20 97       	sbiw	r28, 0x00	; 0
    38d4:	99 f1       	breq	.+102    	; 0x393c <prvReadBytesFromBuffer+0x8e>
	{
		xNextTail = pxStreamBuffer->xTail;
    38d6:	f8 01       	movw	r30, r16
    38d8:	a0 80       	ld	r10, Z
    38da:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    38dc:	84 81       	ldd	r24, Z+4	; 0x04
    38de:	95 81       	ldd	r25, Z+5	; 0x05
    38e0:	8a 19       	sub	r24, r10
    38e2:	9b 09       	sbc	r25, r11
    38e4:	7e 01       	movw	r14, r28
    38e6:	8c 17       	cp	r24, r28
    38e8:	9d 07       	cpc	r25, r29
    38ea:	08 f4       	brcc	.+2      	; 0x38ee <prvReadBytesFromBuffer+0x40>
    38ec:	7c 01       	movw	r14, r24

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    38ee:	f8 01       	movw	r30, r16
    38f0:	64 85       	ldd	r22, Z+12	; 0x0c
    38f2:	75 85       	ldd	r23, Z+13	; 0x0d
    38f4:	6a 0d       	add	r22, r10
    38f6:	7b 1d       	adc	r23, r11
    38f8:	8c 2d       	mov	r24, r12
    38fa:	9d 2d       	mov	r25, r13
    38fc:	4e 2d       	mov	r20, r14
    38fe:	5f 2d       	mov	r21, r15
    3900:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3904:	ec 16       	cp	r14, r28
    3906:	fd 06       	cpc	r15, r29
    3908:	58 f4       	brcc	.+22     	; 0x3920 <prvReadBytesFromBuffer+0x72>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    390a:	c6 01       	movw	r24, r12
    390c:	8e 0d       	add	r24, r14
    390e:	9f 1d       	adc	r25, r15
    3910:	ae 01       	movw	r20, r28
    3912:	4e 19       	sub	r20, r14
    3914:	5f 09       	sbc	r21, r15
    3916:	f8 01       	movw	r30, r16
    3918:	64 85       	ldd	r22, Z+12	; 0x0c
    391a:	75 85       	ldd	r23, Z+13	; 0x0d
    391c:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3920:	ce 01       	movw	r24, r28
    3922:	8a 0d       	add	r24, r10
    3924:	9b 1d       	adc	r25, r11

		if( xNextTail >= pxStreamBuffer->xLength )
    3926:	f8 01       	movw	r30, r16
    3928:	24 81       	ldd	r18, Z+4	; 0x04
    392a:	35 81       	ldd	r19, Z+5	; 0x05
    392c:	82 17       	cp	r24, r18
    392e:	93 07       	cpc	r25, r19
    3930:	10 f0       	brcs	.+4      	; 0x3936 <prvReadBytesFromBuffer+0x88>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3932:	82 1b       	sub	r24, r18
    3934:	93 0b       	sbc	r25, r19
		}

		pxStreamBuffer->xTail = xNextTail;
    3936:	f8 01       	movw	r30, r16
    3938:	91 83       	std	Z+1, r25	; 0x01
    393a:	80 83       	st	Z, r24
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
}
    393c:	8c 2f       	mov	r24, r28
    393e:	9d 2f       	mov	r25, r29
    3940:	df 91       	pop	r29
    3942:	cf 91       	pop	r28
    3944:	1f 91       	pop	r17
    3946:	0f 91       	pop	r16
    3948:	ff 90       	pop	r15
    394a:	ef 90       	pop	r14
    394c:	df 90       	pop	r13
    394e:	cf 90       	pop	r12
    3950:	bf 90       	pop	r11
    3952:	af 90       	pop	r10
    3954:	08 95       	ret

00003956 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    3956:	6f 92       	push	r6
    3958:	7f 92       	push	r7
    395a:	8f 92       	push	r8
    395c:	9f 92       	push	r9
    395e:	af 92       	push	r10
    3960:	bf 92       	push	r11
    3962:	cf 92       	push	r12
    3964:	df 92       	push	r13
    3966:	ef 92       	push	r14
    3968:	ff 92       	push	r15
    396a:	0f 93       	push	r16
    396c:	1f 93       	push	r17
    396e:	cf 93       	push	r28
    3970:	df 93       	push	r29
    3972:	00 d0       	rcall	.+0      	; 0x3974 <prvReadMessageFromBuffer+0x1e>
    3974:	cd b7       	in	r28, 0x3d	; 61
    3976:	de b7       	in	r29, 0x3e	; 62
    3978:	5c 01       	movw	r10, r24
    397a:	4b 01       	movw	r8, r22
    397c:	7a 01       	movw	r14, r20
    397e:	69 01       	movw	r12, r18
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3980:	01 15       	cp	r16, r1
    3982:	11 05       	cpc	r17, r1
    3984:	a9 f0       	breq	.+42     	; 0x39b0 <prvReadMessageFromBuffer+0x5a>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3986:	fc 01       	movw	r30, r24
    3988:	60 80       	ld	r6, Z
    398a:	71 80       	ldd	r7, Z+1	; 0x01
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    398c:	be 01       	movw	r22, r28
    398e:	6f 5f       	subi	r22, 0xFF	; 255
    3990:	7f 4f       	sbci	r23, 0xFF	; 255
    3992:	a8 01       	movw	r20, r16
    3994:	0e 94 57 1c 	call	0x38ae	; 0x38ae <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3998:	49 81       	ldd	r20, Y+1	; 0x01
    399a:	5a 81       	ldd	r21, Y+2	; 0x02

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    399c:	c0 1a       	sub	r12, r16
    399e:	d1 0a       	sbc	r13, r17

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    39a0:	e4 16       	cp	r14, r20
    39a2:	f5 06       	cpc	r15, r21
    39a4:	28 f4       	brcc	.+10     	; 0x39b0 <prvReadMessageFromBuffer+0x5a>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    39a6:	f5 01       	movw	r30, r10
    39a8:	71 82       	std	Z+1, r7	; 0x01
    39aa:	60 82       	st	Z, r6
			xNextMessageLength = 0;
    39ac:	40 e0       	ldi	r20, 0x00	; 0
    39ae:	50 e0       	ldi	r21, 0x00	; 0
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    39b0:	c5 01       	movw	r24, r10
    39b2:	b4 01       	movw	r22, r8
    39b4:	96 01       	movw	r18, r12
    39b6:	0e 94 57 1c 	call	0x38ae	; 0x38ae <prvReadBytesFromBuffer>

	return xReceivedLength;
}
    39ba:	0f 90       	pop	r0
    39bc:	0f 90       	pop	r0
    39be:	df 91       	pop	r29
    39c0:	cf 91       	pop	r28
    39c2:	1f 91       	pop	r17
    39c4:	0f 91       	pop	r16
    39c6:	ff 90       	pop	r15
    39c8:	ef 90       	pop	r14
    39ca:	df 90       	pop	r13
    39cc:	cf 90       	pop	r12
    39ce:	bf 90       	pop	r11
    39d0:	af 90       	pop	r10
    39d2:	9f 90       	pop	r9
    39d4:	8f 90       	pop	r8
    39d6:	7f 90       	pop	r7
    39d8:	6f 90       	pop	r6
    39da:	08 95       	ret

000039dc <prvWriteBytesToBuffer>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    39dc:	af 92       	push	r10
    39de:	bf 92       	push	r11
    39e0:	cf 92       	push	r12
    39e2:	df 92       	push	r13
    39e4:	ef 92       	push	r14
    39e6:	ff 92       	push	r15
    39e8:	0f 93       	push	r16
    39ea:	1f 93       	push	r17
    39ec:	cf 93       	push	r28
    39ee:	df 93       	push	r29
    39f0:	ec 01       	movw	r28, r24
    39f2:	5b 01       	movw	r10, r22
    39f4:	8a 01       	movw	r16, r20
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    39f6:	ca 80       	ldd	r12, Y+2	; 0x02
    39f8:	db 80       	ldd	r13, Y+3	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    39fa:	8c 81       	ldd	r24, Y+4	; 0x04
    39fc:	9d 81       	ldd	r25, Y+5	; 0x05
    39fe:	8c 19       	sub	r24, r12
    3a00:	9d 09       	sbc	r25, r13
    3a02:	7a 01       	movw	r14, r20
    3a04:	84 17       	cp	r24, r20
    3a06:	95 07       	cpc	r25, r21
    3a08:	08 f4       	brcc	.+2      	; 0x3a0c <prvWriteBytesToBuffer+0x30>
    3a0a:	7c 01       	movw	r14, r24

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3a0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3a10:	8c 0d       	add	r24, r12
    3a12:	9d 1d       	adc	r25, r13
    3a14:	6a 2d       	mov	r22, r10
    3a16:	7b 2d       	mov	r23, r11
    3a18:	4e 2d       	mov	r20, r14
    3a1a:	5f 2d       	mov	r21, r15
    3a1c:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3a20:	e0 16       	cp	r14, r16
    3a22:	f1 06       	cpc	r15, r17
    3a24:	50 f4       	brcc	.+20     	; 0x3a3a <prvWriteBytesToBuffer+0x5e>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3a26:	a8 01       	movw	r20, r16
    3a28:	4e 19       	sub	r20, r14
    3a2a:	5f 09       	sbc	r21, r15
    3a2c:	b5 01       	movw	r22, r10
    3a2e:	6e 0d       	add	r22, r14
    3a30:	7f 1d       	adc	r23, r15
    3a32:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a34:	9d 85       	ldd	r25, Y+13	; 0x0d
    3a36:	0e 94 94 2a 	call	0x5528	; 0x5528 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3a3a:	c8 01       	movw	r24, r16
    3a3c:	8c 0d       	add	r24, r12
    3a3e:	9d 1d       	adc	r25, r13
	if( xNextHead >= pxStreamBuffer->xLength )
    3a40:	2c 81       	ldd	r18, Y+4	; 0x04
    3a42:	3d 81       	ldd	r19, Y+5	; 0x05
    3a44:	82 17       	cp	r24, r18
    3a46:	93 07       	cpc	r25, r19
    3a48:	10 f0       	brcs	.+4      	; 0x3a4e <prvWriteBytesToBuffer+0x72>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3a4a:	82 1b       	sub	r24, r18
    3a4c:	93 0b       	sbc	r25, r19
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    3a4e:	9b 83       	std	Y+3, r25	; 0x03
    3a50:	8a 83       	std	Y+2, r24	; 0x02

	return xCount;
}
    3a52:	80 2f       	mov	r24, r16
    3a54:	91 2f       	mov	r25, r17
    3a56:	df 91       	pop	r29
    3a58:	cf 91       	pop	r28
    3a5a:	1f 91       	pop	r17
    3a5c:	0f 91       	pop	r16
    3a5e:	ff 90       	pop	r15
    3a60:	ef 90       	pop	r14
    3a62:	df 90       	pop	r13
    3a64:	cf 90       	pop	r12
    3a66:	bf 90       	pop	r11
    3a68:	af 90       	pop	r10
    3a6a:	08 95       	ret

00003a6c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3a6c:	cf 92       	push	r12
    3a6e:	df 92       	push	r13
    3a70:	ef 92       	push	r14
    3a72:	ff 92       	push	r15
    3a74:	0f 93       	push	r16
    3a76:	1f 93       	push	r17
    3a78:	cf 93       	push	r28
    3a7a:	df 93       	push	r29
    3a7c:	00 d0       	rcall	.+0      	; 0x3a7e <prvWriteMessageToBuffer+0x12>
    3a7e:	cd b7       	in	r28, 0x3d	; 61
    3a80:	de b7       	in	r29, 0x3e	; 62
    3a82:	7c 01       	movw	r14, r24
    3a84:	6b 01       	movw	r12, r22
    3a86:	5a 83       	std	Y+2, r21	; 0x02
    3a88:	49 83       	std	Y+1, r20	; 0x01
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    3a8a:	21 15       	cp	r18, r1
    3a8c:	31 05       	cpc	r19, r1
    3a8e:	b9 f0       	breq	.+46     	; 0x3abe <prvWriteMessageToBuffer+0x52>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3a90:	fc 01       	movw	r30, r24
    3a92:	86 85       	ldd	r24, Z+14	; 0x0e
    3a94:	80 fd       	sbrc	r24, 0
    3a96:	07 c0       	rjmp	.+14     	; 0x3aa6 <prvWriteMessageToBuffer+0x3a>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3a98:	42 17       	cp	r20, r18
    3a9a:	53 07       	cpc	r21, r19
    3a9c:	08 f4       	brcc	.+2      	; 0x3aa0 <prvWriteMessageToBuffer+0x34>
    3a9e:	9a 01       	movw	r18, r20
    3aa0:	3a 83       	std	Y+2, r19	; 0x02
    3aa2:	29 83       	std	Y+1, r18	; 0x01
    3aa4:	1c c0       	rjmp	.+56     	; 0x3ade <prvWriteMessageToBuffer+0x72>
	}
	else if( xSpace >= xRequiredSpace )
    3aa6:	20 17       	cp	r18, r16
    3aa8:	31 07       	cpc	r19, r17
    3aaa:	60 f0       	brcs	.+24     	; 0x3ac4 <prvWriteMessageToBuffer+0x58>
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3aac:	c7 01       	movw	r24, r14
    3aae:	be 01       	movw	r22, r28
    3ab0:	6f 5f       	subi	r22, 0xFF	; 255
    3ab2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ab4:	42 e0       	ldi	r20, 0x02	; 2
    3ab6:	50 e0       	ldi	r21, 0x00	; 0
    3ab8:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <prvWriteBytesToBuffer>
    3abc:	10 c0       	rjmp	.+32     	; 0x3ade <prvWriteMessageToBuffer+0x72>
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
	}
	else
	{
		xReturn = 0;
    3abe:	80 e0       	ldi	r24, 0x00	; 0
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
    3ac2:	02 c0       	rjmp	.+4      	; 0x3ac8 <prvWriteMessageToBuffer+0x5c>
    3ac4:	80 e0       	ldi	r24, 0x00	; 0
    3ac6:	90 e0       	ldi	r25, 0x00	; 0
	}

	return xReturn;
}
    3ac8:	0f 90       	pop	r0
    3aca:	0f 90       	pop	r0
    3acc:	df 91       	pop	r29
    3ace:	cf 91       	pop	r28
    3ad0:	1f 91       	pop	r17
    3ad2:	0f 91       	pop	r16
    3ad4:	ff 90       	pop	r15
    3ad6:	ef 90       	pop	r14
    3ad8:	df 90       	pop	r13
    3ada:	cf 90       	pop	r12
    3adc:	08 95       	ret
	}

	if( xShouldWrite != pdFALSE )
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3ade:	49 81       	ldd	r20, Y+1	; 0x01
    3ae0:	5a 81       	ldd	r21, Y+2	; 0x02
    3ae2:	c7 01       	movw	r24, r14
    3ae4:	b6 01       	movw	r22, r12
    3ae6:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <prvWriteBytesToBuffer>
    3aea:	ee cf       	rjmp	.-36     	; 0x3ac8 <prvWriteMessageToBuffer+0x5c>

00003aec <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3aec:	0f 93       	push	r16
    3aee:	fc 01       	movw	r30, r24
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3af0:	8f e0       	ldi	r24, 0x0F	; 15
    3af2:	df 01       	movw	r26, r30
    3af4:	1d 92       	st	X+, r1
    3af6:	8a 95       	dec	r24
    3af8:	e9 f7       	brne	.-6      	; 0x3af4 <prvInitialiseNewStreamBuffer+0x8>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3afa:	75 87       	std	Z+13, r23	; 0x0d
    3afc:	64 87       	std	Z+12, r22	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3afe:	55 83       	std	Z+5, r21	; 0x05
    3b00:	44 83       	std	Z+4, r20	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3b02:	37 83       	std	Z+7, r19	; 0x07
    3b04:	26 83       	std	Z+6, r18	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3b06:	06 87       	std	Z+14, r16	; 0x0e
}
    3b08:	0f 91       	pop	r16
    3b0a:	08 95       	ret

00003b0c <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    3b0c:	df 92       	push	r13
    3b0e:	ef 92       	push	r14
    3b10:	ff 92       	push	r15
    3b12:	0f 93       	push	r16
    3b14:	1f 93       	push	r17
    3b16:	cf 93       	push	r28
    3b18:	df 93       	push	r29
    3b1a:	8c 01       	movw	r16, r24
    3b1c:	7b 01       	movw	r14, r22
    3b1e:	d4 2e       	mov	r13, r20
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3b20:	61 15       	cp	r22, r1
    3b22:	71 05       	cpc	r23, r1
    3b24:	19 f4       	brne	.+6      	; 0x3b2c <xStreamBufferGenericCreate+0x20>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3b26:	ee 24       	eor	r14, r14
    3b28:	ff 24       	eor	r15, r15
    3b2a:	e3 94       	inc	r14
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    3b2c:	c8 01       	movw	r24, r16
    3b2e:	40 96       	adiw	r24, 0x10	; 16
    3b30:	0e 94 78 15 	call	0x2af0	; 0x2af0 <pvPortMalloc>
    3b34:	ec 01       	movw	r28, r24

		if( pucAllocatedMemory != NULL )
    3b36:	00 97       	sbiw	r24, 0x00	; 0
    3b38:	69 f0       	breq	.+26     	; 0x3b54 <xStreamBufferGenericCreate+0x48>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3b3a:	bc 01       	movw	r22, r24
    3b3c:	61 5f       	subi	r22, 0xF1	; 241
    3b3e:	7f 4f       	sbci	r23, 0xFF	; 255
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3b40:	a8 01       	movw	r20, r16
    3b42:	4f 5f       	subi	r20, 0xFF	; 255
    3b44:	5f 4f       	sbci	r21, 0xFF	; 255
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3b46:	01 e0       	ldi	r16, 0x01	; 1
    3b48:	d0 12       	cpse	r13, r16
    3b4a:	00 e0       	ldi	r16, 0x00	; 0
		xBufferSizeBytes++;
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */

		if( pucAllocatedMemory != NULL )
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3b4c:	ce 01       	movw	r24, r28
    3b4e:	97 01       	movw	r18, r14
    3b50:	0e 94 76 1d 	call	0x3aec	; 0x3aec <prvInitialiseNewStreamBuffer>
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
	}
    3b54:	8c 2f       	mov	r24, r28
    3b56:	9d 2f       	mov	r25, r29
    3b58:	df 91       	pop	r29
    3b5a:	cf 91       	pop	r28
    3b5c:	1f 91       	pop	r17
    3b5e:	0f 91       	pop	r16
    3b60:	ff 90       	pop	r15
    3b62:	ef 90       	pop	r14
    3b64:	df 90       	pop	r13
    3b66:	08 95       	ret

00003b68 <vStreamBufferDelete>:

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    3b68:	fc 01       	movw	r30, r24
    3b6a:	26 85       	ldd	r18, Z+14	; 0x0e
    3b6c:	21 fd       	sbrc	r18, 1
    3b6e:	03 c0       	rjmp	.+6      	; 0x3b76 <vStreamBufferDelete+0xe>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    3b70:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <vPortFree>
    3b74:	08 95       	ret
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3b76:	2f e0       	ldi	r18, 0x0F	; 15
    3b78:	fc 01       	movw	r30, r24
    3b7a:	11 92       	st	Z+, r1
    3b7c:	2a 95       	dec	r18
    3b7e:	e9 f7       	brne	.-6      	; 0x3b7a <vStreamBufferDelete+0x12>
    3b80:	08 95       	ret

00003b82 <xStreamBufferReset>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3b82:	0f 93       	push	r16
    3b84:	fc 01       	movw	r30, r24
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3b86:	0f b6       	in	r0, 0x3f	; 63
    3b88:	f8 94       	cli
    3b8a:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3b8c:	80 85       	ldd	r24, Z+8	; 0x08
    3b8e:	91 85       	ldd	r25, Z+9	; 0x09
    3b90:	00 97       	sbiw	r24, 0x00	; 0
    3b92:	81 f4       	brne	.+32     	; 0x3bb4 <xStreamBufferReset+0x32>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3b94:	82 85       	ldd	r24, Z+10	; 0x0a
    3b96:	93 85       	ldd	r25, Z+11	; 0x0b
    3b98:	00 97       	sbiw	r24, 0x00	; 0
    3b9a:	71 f4       	brne	.+28     	; 0x3bb8 <xStreamBufferReset+0x36>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3b9c:	64 85       	ldd	r22, Z+12	; 0x0c
    3b9e:	75 85       	ldd	r23, Z+13	; 0x0d
    3ba0:	44 81       	ldd	r20, Z+4	; 0x04
    3ba2:	55 81       	ldd	r21, Z+5	; 0x05
    3ba4:	26 81       	ldd	r18, Z+6	; 0x06
    3ba6:	37 81       	ldd	r19, Z+7	; 0x07
    3ba8:	cf 01       	movw	r24, r30
    3baa:	06 85       	ldd	r16, Z+14	; 0x0e
    3bac:	0e 94 76 1d 	call	0x3aec	; 0x3aec <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3bb0:	81 e0       	ldi	r24, 0x01	; 1
    3bb2:	03 c0       	rjmp	.+6      	; 0x3bba <xStreamBufferReset+0x38>
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
BaseType_t xReturn = pdFAIL;
    3bb4:	80 e0       	ldi	r24, 0x00	; 0
    3bb6:	01 c0       	rjmp	.+2      	; 0x3bba <xStreamBufferReset+0x38>
    3bb8:	80 e0       	ldi	r24, 0x00	; 0

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3bba:	0f 90       	pop	r0
    3bbc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3bbe:	0f 91       	pop	r16
    3bc0:	08 95       	ret

00003bc2 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    3bc2:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3bc4:	61 15       	cp	r22, r1
    3bc6:	71 05       	cpc	r23, r1
    3bc8:	11 f4       	brne	.+4      	; 0x3bce <xStreamBufferSetTriggerLevel+0xc>
	{
		xTriggerLevel = ( size_t ) 1;
    3bca:	61 e0       	ldi	r22, 0x01	; 1
    3bcc:	70 e0       	ldi	r23, 0x00	; 0
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    3bce:	84 81       	ldd	r24, Z+4	; 0x04
    3bd0:	95 81       	ldd	r25, Z+5	; 0x05
    3bd2:	86 17       	cp	r24, r22
    3bd4:	97 07       	cpc	r25, r23
    3bd6:	20 f0       	brcs	.+8      	; 0x3be0 <xStreamBufferSetTriggerLevel+0x1e>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3bd8:	77 83       	std	Z+7, r23	; 0x07
    3bda:	66 83       	std	Z+6, r22	; 0x06
		xReturn = pdPASS;
    3bdc:	81 e0       	ldi	r24, 0x01	; 1
    3bde:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    3be0:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    3be2:	08 95       	ret

00003be4 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3be4:	fc 01       	movw	r30, r24
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3be6:	24 81       	ldd	r18, Z+4	; 0x04
    3be8:	35 81       	ldd	r19, Z+5	; 0x05
    3bea:	40 81       	ld	r20, Z
    3bec:	51 81       	ldd	r21, Z+1	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3bee:	62 81       	ldd	r22, Z+2	; 0x02
    3bf0:	73 81       	ldd	r23, Z+3	; 0x03
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3bf2:	c9 01       	movw	r24, r18
    3bf4:	84 0f       	add	r24, r20
    3bf6:	95 1f       	adc	r25, r21
	xSpace -= pxStreamBuffer->xHead;
    3bf8:	01 97       	sbiw	r24, 0x01	; 1
	xSpace -= ( size_t ) 1;
    3bfa:	86 1b       	sub	r24, r22
    3bfc:	97 0b       	sbc	r25, r23

	if( xSpace >= pxStreamBuffer->xLength )
    3bfe:	82 17       	cp	r24, r18
    3c00:	93 07       	cpc	r25, r19
    3c02:	10 f0       	brcs	.+4      	; 0x3c08 <xStreamBufferSpacesAvailable+0x24>
	{
		xSpace -= pxStreamBuffer->xLength;
    3c04:	82 1b       	sub	r24, r18
    3c06:	93 0b       	sbc	r25, r19
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
}
    3c08:	08 95       	ret

00003c0a <xStreamBufferBytesAvailable>:
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3c0a:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
	return xReturn;
}
    3c0e:	08 95       	ret

00003c10 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3c10:	4f 92       	push	r4
    3c12:	5f 92       	push	r5
    3c14:	6f 92       	push	r6
    3c16:	7f 92       	push	r7
    3c18:	8f 92       	push	r8
    3c1a:	9f 92       	push	r9
    3c1c:	af 92       	push	r10
    3c1e:	bf 92       	push	r11
    3c20:	cf 92       	push	r12
    3c22:	df 92       	push	r13
    3c24:	ef 92       	push	r14
    3c26:	ff 92       	push	r15
    3c28:	0f 93       	push	r16
    3c2a:	1f 93       	push	r17
    3c2c:	cf 93       	push	r28
    3c2e:	df 93       	push	r29
    3c30:	00 d0       	rcall	.+0      	; 0x3c32 <xStreamBufferSend+0x22>
    3c32:	00 d0       	rcall	.+0      	; 0x3c34 <xStreamBufferSend+0x24>
    3c34:	0f 92       	push	r0
    3c36:	cd b7       	in	r28, 0x3d	; 61
    3c38:	de b7       	in	r29, 0x3e	; 62
    3c3a:	6c 01       	movw	r12, r24
    3c3c:	2b 01       	movw	r4, r22
    3c3e:	3a 01       	movw	r6, r20
    3c40:	3d 83       	std	Y+5, r19	; 0x05
    3c42:	2c 83       	std	Y+4, r18	; 0x04

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3c44:	fc 01       	movw	r30, r24
    3c46:	86 85       	ldd	r24, Z+14	; 0x0e
    3c48:	80 ff       	sbrs	r24, 0
    3c4a:	07 c0       	rjmp	.+14     	; 0x3c5a <xStreamBufferSend+0x4a>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3c4c:	88 24       	eor	r8, r8
    3c4e:	99 24       	eor	r9, r9
    3c50:	68 94       	set
    3c52:	81 f8       	bld	r8, 1
    3c54:	84 0e       	add	r8, r20
    3c56:	95 1e       	adc	r9, r21
    3c58:	01 c0       	rjmp	.+2      	; 0x3c5c <xStreamBufferSend+0x4c>
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn, xSpace = 0;
size_t xRequiredSpace = xDataLengthBytes;
    3c5a:	4a 01       	movw	r8, r20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3c5c:	8c 81       	ldd	r24, Y+4	; 0x04
    3c5e:	9d 81       	ldd	r25, Y+5	; 0x05
    3c60:	00 97       	sbiw	r24, 0x00	; 0
    3c62:	b9 f1       	breq	.+110    	; 0x3cd2 <xStreamBufferSend+0xc2>
	{
		vTaskSetTimeOutState( &xTimeOut );
    3c64:	ce 01       	movw	r24, r28
    3c66:	01 96       	adiw	r24, 0x01	; 1
    3c68:	0e 94 0e 25 	call	0x4a1c	; 0x4a1c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3c6c:	0f b6       	in	r0, 0x3f	; 63
    3c6e:	f8 94       	cli
    3c70:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3c72:	c6 01       	movw	r24, r12
    3c74:	0e 94 f2 1d 	call	0x3be4	; 0x3be4 <xStreamBufferSpacesAvailable>
    3c78:	5c 01       	movw	r10, r24

				if( xSpace < xRequiredSpace )
    3c7a:	88 15       	cp	r24, r8
    3c7c:	99 05       	cpc	r25, r9
    3c7e:	28 f5       	brcc	.+74     	; 0x3cca <xStreamBufferSend+0xba>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3c80:	80 e0       	ldi	r24, 0x00	; 0
    3c82:	90 e0       	ldi	r25, 0x00	; 0
    3c84:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3c88:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <xTaskGetCurrentTaskHandle>
    3c8c:	f6 01       	movw	r30, r12
    3c8e:	93 87       	std	Z+11, r25	; 0x0b
    3c90:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3c92:	0f 90       	pop	r0
    3c94:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3c96:	ec 80       	ldd	r14, Y+4	; 0x04
    3c98:	fd 80       	ldd	r15, Y+5	; 0x05
    3c9a:	60 e0       	ldi	r22, 0x00	; 0
    3c9c:	70 e0       	ldi	r23, 0x00	; 0
    3c9e:	cb 01       	movw	r24, r22
    3ca0:	20 e0       	ldi	r18, 0x00	; 0
    3ca2:	30 e0       	ldi	r19, 0x00	; 0
    3ca4:	a9 01       	movw	r20, r18
    3ca6:	00 e0       	ldi	r16, 0x00	; 0
    3ca8:	10 e0       	ldi	r17, 0x00	; 0
    3caa:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3cae:	f6 01       	movw	r30, r12
    3cb0:	13 86       	std	Z+11, r1	; 0x0b
    3cb2:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3cb4:	ce 01       	movw	r24, r28
    3cb6:	01 96       	adiw	r24, 0x01	; 1
    3cb8:	be 01       	movw	r22, r28
    3cba:	6c 5f       	subi	r22, 0xFC	; 252
    3cbc:	7f 4f       	sbci	r23, 0xFF	; 255
    3cbe:	0e 94 29 25 	call	0x4a52	; 0x4a52 <xTaskCheckForTimeOut>
    3cc2:	88 23       	and	r24, r24
    3cc4:	99 f2       	breq	.-90     	; 0x3c6c <xStreamBufferSend+0x5c>
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3cc6:	c5 01       	movw	r24, r10
    3cc8:	02 c0       	rjmp	.+4      	; 0x3cce <xStreamBufferSend+0xbe>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3cca:	0f 90       	pop	r0
    3ccc:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3cce:	00 97       	sbiw	r24, 0x00	; 0
    3cd0:	21 f4       	brne	.+8      	; 0x3cda <xStreamBufferSend+0xca>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3cd2:	c6 01       	movw	r24, r12
    3cd4:	0e 94 f2 1d 	call	0x3be4	; 0x3be4 <xStreamBufferSpacesAvailable>
    3cd8:	5c 01       	movw	r10, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3cda:	c6 01       	movw	r24, r12
    3cdc:	b2 01       	movw	r22, r4
    3cde:	a3 01       	movw	r20, r6
    3ce0:	95 01       	movw	r18, r10
    3ce2:	84 01       	movw	r16, r8
    3ce4:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <prvWriteMessageToBuffer>
    3ce8:	7c 01       	movw	r14, r24

	if( xReturn > ( size_t ) 0 )
    3cea:	00 97       	sbiw	r24, 0x00	; 0
    3cec:	f9 f0       	breq	.+62     	; 0x3d2c <xStreamBufferSend+0x11c>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3cee:	c6 01       	movw	r24, r12
    3cf0:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3cf4:	f6 01       	movw	r30, r12
    3cf6:	26 81       	ldd	r18, Z+6	; 0x06
    3cf8:	37 81       	ldd	r19, Z+7	; 0x07
    3cfa:	82 17       	cp	r24, r18
    3cfc:	93 07       	cpc	r25, r19
    3cfe:	b0 f0       	brcs	.+44     	; 0x3d2c <xStreamBufferSend+0x11c>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3d00:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
    3d04:	f6 01       	movw	r30, r12
    3d06:	80 85       	ldd	r24, Z+8	; 0x08
    3d08:	91 85       	ldd	r25, Z+9	; 0x09
    3d0a:	00 97       	sbiw	r24, 0x00	; 0
    3d0c:	69 f0       	breq	.+26     	; 0x3d28 <xStreamBufferSend+0x118>
    3d0e:	80 85       	ldd	r24, Z+8	; 0x08
    3d10:	91 85       	ldd	r25, Z+9	; 0x09
    3d12:	40 e0       	ldi	r20, 0x00	; 0
    3d14:	50 e0       	ldi	r21, 0x00	; 0
    3d16:	ba 01       	movw	r22, r20
    3d18:	20 e0       	ldi	r18, 0x00	; 0
    3d1a:	00 e0       	ldi	r16, 0x00	; 0
    3d1c:	10 e0       	ldi	r17, 0x00	; 0
    3d1e:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <xTaskGenericNotify>
    3d22:	f6 01       	movw	r30, r12
    3d24:	11 86       	std	Z+9, r1	; 0x09
    3d26:	10 86       	std	Z+8, r1	; 0x08
    3d28:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
}
    3d2c:	8e 2d       	mov	r24, r14
    3d2e:	9f 2d       	mov	r25, r15
    3d30:	0f 90       	pop	r0
    3d32:	0f 90       	pop	r0
    3d34:	0f 90       	pop	r0
    3d36:	0f 90       	pop	r0
    3d38:	0f 90       	pop	r0
    3d3a:	df 91       	pop	r29
    3d3c:	cf 91       	pop	r28
    3d3e:	1f 91       	pop	r17
    3d40:	0f 91       	pop	r16
    3d42:	ff 90       	pop	r15
    3d44:	ef 90       	pop	r14
    3d46:	df 90       	pop	r13
    3d48:	cf 90       	pop	r12
    3d4a:	bf 90       	pop	r11
    3d4c:	af 90       	pop	r10
    3d4e:	9f 90       	pop	r9
    3d50:	8f 90       	pop	r8
    3d52:	7f 90       	pop	r7
    3d54:	6f 90       	pop	r6
    3d56:	5f 90       	pop	r5
    3d58:	4f 90       	pop	r4
    3d5a:	08 95       	ret

00003d5c <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3d5c:	af 92       	push	r10
    3d5e:	bf 92       	push	r11
    3d60:	cf 92       	push	r12
    3d62:	df 92       	push	r13
    3d64:	ef 92       	push	r14
    3d66:	ff 92       	push	r15
    3d68:	0f 93       	push	r16
    3d6a:	1f 93       	push	r17
    3d6c:	cf 93       	push	r28
    3d6e:	df 93       	push	r29
    3d70:	ec 01       	movw	r28, r24
    3d72:	6b 01       	movw	r12, r22
    3d74:	7a 01       	movw	r14, r20
    3d76:	59 01       	movw	r10, r18

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3d78:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d7a:	80 ff       	sbrs	r24, 0
    3d7c:	04 c0       	rjmp	.+8      	; 0x3d86 <xStreamBufferSendFromISR+0x2a>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3d7e:	8a 01       	movw	r16, r20
    3d80:	0e 5f       	subi	r16, 0xFE	; 254
    3d82:	1f 4f       	sbci	r17, 0xFF	; 255
    3d84:	01 c0       	rjmp	.+2      	; 0x3d88 <xStreamBufferSendFromISR+0x2c>
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3d86:	8a 01       	movw	r16, r20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3d88:	ce 01       	movw	r24, r28
    3d8a:	0e 94 f2 1d 	call	0x3be4	; 0x3be4 <xStreamBufferSpacesAvailable>
    3d8e:	9c 01       	movw	r18, r24
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3d90:	ce 01       	movw	r24, r28
    3d92:	b6 01       	movw	r22, r12
    3d94:	a7 01       	movw	r20, r14
    3d96:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <prvWriteMessageToBuffer>
    3d9a:	6c 01       	movw	r12, r24

	if( xReturn > ( size_t ) 0 )
    3d9c:	00 97       	sbiw	r24, 0x00	; 0
    3d9e:	c9 f0       	breq	.+50     	; 0x3dd2 <xStreamBufferSendFromISR+0x76>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3da0:	ce 01       	movw	r24, r28
    3da2:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3da6:	2e 81       	ldd	r18, Y+6	; 0x06
    3da8:	3f 81       	ldd	r19, Y+7	; 0x07
    3daa:	82 17       	cp	r24, r18
    3dac:	93 07       	cpc	r25, r19
    3dae:	88 f0       	brcs	.+34     	; 0x3dd2 <xStreamBufferSendFromISR+0x76>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3db0:	88 85       	ldd	r24, Y+8	; 0x08
    3db2:	99 85       	ldd	r25, Y+9	; 0x09
    3db4:	00 97       	sbiw	r24, 0x00	; 0
    3db6:	69 f0       	breq	.+26     	; 0x3dd2 <xStreamBufferSendFromISR+0x76>
    3db8:	88 85       	ldd	r24, Y+8	; 0x08
    3dba:	99 85       	ldd	r25, Y+9	; 0x09
    3dbc:	40 e0       	ldi	r20, 0x00	; 0
    3dbe:	50 e0       	ldi	r21, 0x00	; 0
    3dc0:	ba 01       	movw	r22, r20
    3dc2:	20 e0       	ldi	r18, 0x00	; 0
    3dc4:	00 e0       	ldi	r16, 0x00	; 0
    3dc6:	10 e0       	ldi	r17, 0x00	; 0
    3dc8:	75 01       	movw	r14, r10
    3dca:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <xTaskGenericNotifyFromISR>
    3dce:	19 86       	std	Y+9, r1	; 0x09
    3dd0:	18 86       	std	Y+8, r1	; 0x08
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
}
    3dd2:	8c 2d       	mov	r24, r12
    3dd4:	9d 2d       	mov	r25, r13
    3dd6:	df 91       	pop	r29
    3dd8:	cf 91       	pop	r28
    3dda:	1f 91       	pop	r17
    3ddc:	0f 91       	pop	r16
    3dde:	ff 90       	pop	r15
    3de0:	ef 90       	pop	r14
    3de2:	df 90       	pop	r13
    3de4:	cf 90       	pop	r12
    3de6:	bf 90       	pop	r11
    3de8:	af 90       	pop	r10
    3dea:	08 95       	ret

00003dec <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3dec:	6f 92       	push	r6
    3dee:	7f 92       	push	r7
    3df0:	8f 92       	push	r8
    3df2:	9f 92       	push	r9
    3df4:	af 92       	push	r10
    3df6:	bf 92       	push	r11
    3df8:	cf 92       	push	r12
    3dfa:	df 92       	push	r13
    3dfc:	ef 92       	push	r14
    3dfe:	ff 92       	push	r15
    3e00:	0f 93       	push	r16
    3e02:	1f 93       	push	r17
    3e04:	cf 93       	push	r28
    3e06:	df 93       	push	r29
    3e08:	5c 01       	movw	r10, r24
    3e0a:	4b 01       	movw	r8, r22
    3e0c:	3a 01       	movw	r6, r20
    3e0e:	79 01       	movw	r14, r18
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e10:	fc 01       	movw	r30, r24
    3e12:	86 85       	ldd	r24, Z+14	; 0x0e
    3e14:	80 ff       	sbrs	r24, 0
    3e16:	05 c0       	rjmp	.+10     	; 0x3e22 <xStreamBufferReceive+0x36>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3e18:	cc 24       	eor	r12, r12
    3e1a:	dd 24       	eor	r13, r13
    3e1c:	68 94       	set
    3e1e:	c1 f8       	bld	r12, 1
    3e20:	02 c0       	rjmp	.+4      	; 0x3e26 <xStreamBufferReceive+0x3a>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3e22:	cc 24       	eor	r12, r12
    3e24:	dd 24       	eor	r13, r13
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3e26:	e1 14       	cp	r14, r1
    3e28:	f1 04       	cpc	r15, r1
    3e2a:	51 f1       	breq	.+84     	; 0x3e80 <xStreamBufferReceive+0x94>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3e2c:	0f b6       	in	r0, 0x3f	; 63
    3e2e:	f8 94       	cli
    3e30:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3e32:	c5 01       	movw	r24, r10
    3e34:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3e38:	ec 01       	movw	r28, r24
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3e3a:	c8 16       	cp	r12, r24
    3e3c:	d9 06       	cpc	r13, r25
    3e3e:	48 f0       	brcs	.+18     	; 0x3e52 <xStreamBufferReceive+0x66>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3e40:	80 e0       	ldi	r24, 0x00	; 0
    3e42:	90 e0       	ldi	r25, 0x00	; 0
    3e44:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3e48:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <xTaskGetCurrentTaskHandle>
    3e4c:	f5 01       	movw	r30, r10
    3e4e:	91 87       	std	Z+9, r25	; 0x09
    3e50:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3e52:	0f 90       	pop	r0
    3e54:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3e56:	cc 16       	cp	r12, r28
    3e58:	dd 06       	cpc	r13, r29
    3e5a:	c8 f0       	brcs	.+50     	; 0x3e8e <xStreamBufferReceive+0xa2>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3e5c:	60 e0       	ldi	r22, 0x00	; 0
    3e5e:	70 e0       	ldi	r23, 0x00	; 0
    3e60:	cb 01       	movw	r24, r22
    3e62:	20 e0       	ldi	r18, 0x00	; 0
    3e64:	30 e0       	ldi	r19, 0x00	; 0
    3e66:	a9 01       	movw	r20, r18
    3e68:	00 e0       	ldi	r16, 0x00	; 0
    3e6a:	10 e0       	ldi	r17, 0x00	; 0
    3e6c:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3e70:	f5 01       	movw	r30, r10
    3e72:	11 86       	std	Z+9, r1	; 0x09
    3e74:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3e76:	c5 01       	movw	r24, r10
    3e78:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3e7c:	ec 01       	movw	r28, r24
    3e7e:	04 c0       	rjmp	.+8      	; 0x3e88 <xStreamBufferReceive+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3e80:	c5 01       	movw	r24, r10
    3e82:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3e86:	ec 01       	movw	r28, r24
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3e88:	cc 16       	cp	r12, r28
    3e8a:	dd 06       	cpc	r13, r29
    3e8c:	08 f5       	brcc	.+66     	; 0x3ed0 <xStreamBufferReceive+0xe4>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3e8e:	c5 01       	movw	r24, r10
    3e90:	b4 01       	movw	r22, r8
    3e92:	a3 01       	movw	r20, r6
    3e94:	9e 01       	movw	r18, r28
    3e96:	86 01       	movw	r16, r12
    3e98:	0e 94 ab 1c 	call	0x3956	; 0x3956 <prvReadMessageFromBuffer>
    3e9c:	ec 01       	movw	r28, r24

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3e9e:	00 97       	sbiw	r24, 0x00	; 0
    3ea0:	c9 f0       	breq	.+50     	; 0x3ed4 <xStreamBufferReceive+0xe8>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3ea2:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
    3ea6:	f5 01       	movw	r30, r10
    3ea8:	82 85       	ldd	r24, Z+10	; 0x0a
    3eaa:	93 85       	ldd	r25, Z+11	; 0x0b
    3eac:	00 97       	sbiw	r24, 0x00	; 0
    3eae:	69 f0       	breq	.+26     	; 0x3eca <xStreamBufferReceive+0xde>
    3eb0:	82 85       	ldd	r24, Z+10	; 0x0a
    3eb2:	93 85       	ldd	r25, Z+11	; 0x0b
    3eb4:	40 e0       	ldi	r20, 0x00	; 0
    3eb6:	50 e0       	ldi	r21, 0x00	; 0
    3eb8:	ba 01       	movw	r22, r20
    3eba:	20 e0       	ldi	r18, 0x00	; 0
    3ebc:	00 e0       	ldi	r16, 0x00	; 0
    3ebe:	10 e0       	ldi	r17, 0x00	; 0
    3ec0:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <xTaskGenericNotify>
    3ec4:	f5 01       	movw	r30, r10
    3ec6:	13 86       	std	Z+11, r1	; 0x0b
    3ec8:	12 86       	std	Z+10, r1	; 0x0a
    3eca:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
    3ece:	02 c0       	rjmp	.+4      	; 0x3ed4 <xStreamBufferReceive+0xe8>
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3ed0:	c0 e0       	ldi	r28, 0x00	; 0
    3ed2:	d0 e0       	ldi	r29, 0x00	; 0
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
}
    3ed4:	8c 2f       	mov	r24, r28
    3ed6:	9d 2f       	mov	r25, r29
    3ed8:	df 91       	pop	r29
    3eda:	cf 91       	pop	r28
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	df 90       	pop	r13
    3ee6:	cf 90       	pop	r12
    3ee8:	bf 90       	pop	r11
    3eea:	af 90       	pop	r10
    3eec:	9f 90       	pop	r9
    3eee:	8f 90       	pop	r8
    3ef0:	7f 90       	pop	r7
    3ef2:	6f 90       	pop	r6
    3ef4:	08 95       	ret

00003ef6 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3ef6:	ef 92       	push	r14
    3ef8:	ff 92       	push	r15
    3efa:	0f 93       	push	r16
    3efc:	1f 93       	push	r17
    3efe:	cf 93       	push	r28
    3f00:	df 93       	push	r29
    3f02:	00 d0       	rcall	.+0      	; 0x3f04 <xStreamBufferNextMessageLengthBytes+0xe>
    3f04:	cd b7       	in	r28, 0x3d	; 61
    3f06:	de b7       	in	r29, 0x3e	; 62
    3f08:	8c 01       	movw	r16, r24
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3f0a:	fc 01       	movw	r30, r24
    3f0c:	86 85       	ldd	r24, Z+14	; 0x0e
    3f0e:	80 ff       	sbrs	r24, 0
    3f10:	18 c0       	rjmp	.+48     	; 0x3f42 <xStreamBufferNextMessageLengthBytes+0x4c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3f12:	c8 01       	movw	r24, r16
    3f14:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3f18:	9c 01       	movw	r18, r24
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3f1a:	83 30       	cpi	r24, 0x03	; 3
    3f1c:	91 05       	cpc	r25, r1
    3f1e:	a0 f0       	brcs	.+40     	; 0x3f48 <xStreamBufferNextMessageLengthBytes+0x52>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3f20:	f8 01       	movw	r30, r16
    3f22:	e0 80       	ld	r14, Z
    3f24:	f1 80       	ldd	r15, Z+1	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    3f26:	c8 01       	movw	r24, r16
    3f28:	be 01       	movw	r22, r28
    3f2a:	6f 5f       	subi	r22, 0xFF	; 255
    3f2c:	7f 4f       	sbci	r23, 0xFF	; 255
    3f2e:	42 e0       	ldi	r20, 0x02	; 2
    3f30:	50 e0       	ldi	r21, 0x00	; 0
    3f32:	0e 94 57 1c 	call	0x38ae	; 0x38ae <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3f36:	89 81       	ldd	r24, Y+1	; 0x01
    3f38:	9a 81       	ldd	r25, Y+2	; 0x02
			pxStreamBuffer->xTail = xOriginalTail;
    3f3a:	f8 01       	movw	r30, r16
    3f3c:	f1 82       	std	Z+1, r15	; 0x01
    3f3e:	e0 82       	st	Z, r14
    3f40:	05 c0       	rjmp	.+10     	; 0x3f4c <xStreamBufferNextMessageLengthBytes+0x56>
			xReturn = 0;
		}
	}
	else
	{
		xReturn = 0;
    3f42:	80 e0       	ldi	r24, 0x00	; 0
    3f44:	90 e0       	ldi	r25, 0x00	; 0
    3f46:	02 c0       	rjmp	.+4      	; 0x3f4c <xStreamBufferNextMessageLengthBytes+0x56>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    3f48:	80 e0       	ldi	r24, 0x00	; 0
    3f4a:	90 e0       	ldi	r25, 0x00	; 0
	{
		xReturn = 0;
	}

	return xReturn;
}
    3f4c:	0f 90       	pop	r0
    3f4e:	0f 90       	pop	r0
    3f50:	df 91       	pop	r29
    3f52:	cf 91       	pop	r28
    3f54:	1f 91       	pop	r17
    3f56:	0f 91       	pop	r16
    3f58:	ff 90       	pop	r15
    3f5a:	ef 90       	pop	r14
    3f5c:	08 95       	ret

00003f5e <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    3f5e:	af 92       	push	r10
    3f60:	bf 92       	push	r11
    3f62:	cf 92       	push	r12
    3f64:	df 92       	push	r13
    3f66:	ef 92       	push	r14
    3f68:	ff 92       	push	r15
    3f6a:	0f 93       	push	r16
    3f6c:	1f 93       	push	r17
    3f6e:	cf 93       	push	r28
    3f70:	df 93       	push	r29
    3f72:	6c 01       	movw	r12, r24
    3f74:	eb 01       	movw	r28, r22
    3f76:	7a 01       	movw	r14, r20
    3f78:	59 01       	movw	r10, r18
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3f7a:	fc 01       	movw	r30, r24
    3f7c:	86 85       	ldd	r24, Z+14	; 0x0e
    3f7e:	80 ff       	sbrs	r24, 0
    3f80:	03 c0       	rjmp	.+6      	; 0x3f88 <xStreamBufferReceiveFromISR+0x2a>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3f82:	02 e0       	ldi	r16, 0x02	; 2
    3f84:	10 e0       	ldi	r17, 0x00	; 0
    3f86:	02 c0       	rjmp	.+4      	; 0x3f8c <xStreamBufferReceiveFromISR+0x2e>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3f88:	00 e0       	ldi	r16, 0x00	; 0
    3f8a:	10 e0       	ldi	r17, 0x00	; 0
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3f8c:	c6 01       	movw	r24, r12
    3f8e:	0e 94 46 1c 	call	0x388c	; 0x388c <prvBytesInBuffer>
    3f92:	9c 01       	movw	r18, r24
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3f94:	08 17       	cp	r16, r24
    3f96:	19 07       	cpc	r17, r25
    3f98:	e0 f4       	brcc	.+56     	; 0x3fd2 <xStreamBufferReceiveFromISR+0x74>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3f9a:	c6 01       	movw	r24, r12
    3f9c:	be 01       	movw	r22, r28
    3f9e:	a7 01       	movw	r20, r14
    3fa0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <prvReadMessageFromBuffer>
    3fa4:	ec 01       	movw	r28, r24

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3fa6:	00 97       	sbiw	r24, 0x00	; 0
    3fa8:	b1 f0       	breq	.+44     	; 0x3fd6 <xStreamBufferReceiveFromISR+0x78>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3faa:	f6 01       	movw	r30, r12
    3fac:	82 85       	ldd	r24, Z+10	; 0x0a
    3fae:	93 85       	ldd	r25, Z+11	; 0x0b
    3fb0:	00 97       	sbiw	r24, 0x00	; 0
    3fb2:	89 f0       	breq	.+34     	; 0x3fd6 <xStreamBufferReceiveFromISR+0x78>
    3fb4:	82 85       	ldd	r24, Z+10	; 0x0a
    3fb6:	93 85       	ldd	r25, Z+11	; 0x0b
    3fb8:	40 e0       	ldi	r20, 0x00	; 0
    3fba:	50 e0       	ldi	r21, 0x00	; 0
    3fbc:	ba 01       	movw	r22, r20
    3fbe:	20 e0       	ldi	r18, 0x00	; 0
    3fc0:	00 e0       	ldi	r16, 0x00	; 0
    3fc2:	10 e0       	ldi	r17, 0x00	; 0
    3fc4:	75 01       	movw	r14, r10
    3fc6:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <xTaskGenericNotifyFromISR>
    3fca:	f6 01       	movw	r30, r12
    3fcc:	13 86       	std	Z+11, r1	; 0x0b
    3fce:	12 86       	std	Z+10, r1	; 0x0a
    3fd0:	02 c0       	rjmp	.+4      	; 0x3fd6 <xStreamBufferReceiveFromISR+0x78>
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3fd2:	c0 e0       	ldi	r28, 0x00	; 0
    3fd4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
}
    3fd6:	8c 2f       	mov	r24, r28
    3fd8:	9d 2f       	mov	r25, r29
    3fda:	df 91       	pop	r29
    3fdc:	cf 91       	pop	r28
    3fde:	1f 91       	pop	r17
    3fe0:	0f 91       	pop	r16
    3fe2:	ff 90       	pop	r15
    3fe4:	ef 90       	pop	r14
    3fe6:	df 90       	pop	r13
    3fe8:	cf 90       	pop	r12
    3fea:	bf 90       	pop	r11
    3fec:	af 90       	pop	r10
    3fee:	08 95       	ret

00003ff0 <xStreamBufferIsEmpty>:
	return xReceivedLength;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3ff0:	fc 01       	movw	r30, r24
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3ff2:	40 81       	ld	r20, Z
    3ff4:	51 81       	ldd	r21, Z+1	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    3ff6:	22 81       	ldd	r18, Z+2	; 0x02
    3ff8:	33 81       	ldd	r19, Z+3	; 0x03
	{
		xReturn = pdTRUE;
    3ffa:	81 e0       	ldi	r24, 0x01	; 1
    3ffc:	42 17       	cp	r20, r18
    3ffe:	53 07       	cpc	r21, r19
    4000:	09 f0       	breq	.+2      	; 0x4004 <xStreamBufferIsEmpty+0x14>
    4002:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    4004:	08 95       	ret

00004006 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    4006:	cf 93       	push	r28
    4008:	df 93       	push	r29

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    400a:	fc 01       	movw	r30, r24
    400c:	26 85       	ldd	r18, Z+14	; 0x0e
    400e:	20 ff       	sbrs	r18, 0
    4010:	03 c0       	rjmp	.+6      	; 0x4018 <xStreamBufferIsFull+0x12>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4012:	c2 e0       	ldi	r28, 0x02	; 2
    4014:	d0 e0       	ldi	r29, 0x00	; 0
    4016:	02 c0       	rjmp	.+4      	; 0x401c <xStreamBufferIsFull+0x16>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4018:	c0 e0       	ldi	r28, 0x00	; 0
    401a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    401c:	0e 94 f2 1d 	call	0x3be4	; 0x3be4 <xStreamBufferSpacesAvailable>
	{
		xReturn = pdTRUE;
    4020:	21 e0       	ldi	r18, 0x01	; 1
    4022:	c8 17       	cp	r28, r24
    4024:	d9 07       	cpc	r29, r25
    4026:	08 f4       	brcc	.+2      	; 0x402a <xStreamBufferIsFull+0x24>
    4028:	20 e0       	ldi	r18, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    402a:	82 2f       	mov	r24, r18
    402c:	df 91       	pop	r29
    402e:	cf 91       	pop	r28
    4030:	08 95       	ret

00004032 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4032:	ef 92       	push	r14
    4034:	ff 92       	push	r15
    4036:	0f 93       	push	r16
    4038:	1f 93       	push	r17
    403a:	cf 93       	push	r28
    403c:	df 93       	push	r29
    403e:	ec 01       	movw	r28, r24
    4040:	7b 01       	movw	r14, r22

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4042:	88 85       	ldd	r24, Y+8	; 0x08
    4044:	99 85       	ldd	r25, Y+9	; 0x09
    4046:	00 97       	sbiw	r24, 0x00	; 0
    4048:	71 f0       	breq	.+28     	; 0x4066 <xStreamBufferSendCompletedFromISR+0x34>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    404a:	88 85       	ldd	r24, Y+8	; 0x08
    404c:	99 85       	ldd	r25, Y+9	; 0x09
    404e:	40 e0       	ldi	r20, 0x00	; 0
    4050:	50 e0       	ldi	r21, 0x00	; 0
    4052:	ba 01       	movw	r22, r20
    4054:	20 e0       	ldi	r18, 0x00	; 0
    4056:	00 e0       	ldi	r16, 0x00	; 0
    4058:	10 e0       	ldi	r17, 0x00	; 0
    405a:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    405e:	19 86       	std	Y+9, r1	; 0x09
    4060:	18 86       	std	Y+8, r1	; 0x08
			xReturn = pdTRUE;
    4062:	81 e0       	ldi	r24, 0x01	; 1
    4064:	01 c0       	rjmp	.+2      	; 0x4068 <xStreamBufferSendCompletedFromISR+0x36>
		}
		else
		{
			xReturn = pdFALSE;
    4066:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    4068:	df 91       	pop	r29
    406a:	cf 91       	pop	r28
    406c:	1f 91       	pop	r17
    406e:	0f 91       	pop	r16
    4070:	ff 90       	pop	r15
    4072:	ef 90       	pop	r14
    4074:	08 95       	ret

00004076 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4076:	ef 92       	push	r14
    4078:	ff 92       	push	r15
    407a:	0f 93       	push	r16
    407c:	1f 93       	push	r17
    407e:	cf 93       	push	r28
    4080:	df 93       	push	r29
    4082:	ec 01       	movw	r28, r24
    4084:	7b 01       	movw	r14, r22

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    4086:	8a 85       	ldd	r24, Y+10	; 0x0a
    4088:	9b 85       	ldd	r25, Y+11	; 0x0b
    408a:	00 97       	sbiw	r24, 0x00	; 0
    408c:	71 f0       	breq	.+28     	; 0x40aa <xStreamBufferReceiveCompletedFromISR+0x34>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    408e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4090:	9b 85       	ldd	r25, Y+11	; 0x0b
    4092:	40 e0       	ldi	r20, 0x00	; 0
    4094:	50 e0       	ldi	r21, 0x00	; 0
    4096:	ba 01       	movw	r22, r20
    4098:	20 e0       	ldi	r18, 0x00	; 0
    409a:	00 e0       	ldi	r16, 0x00	; 0
    409c:	10 e0       	ldi	r17, 0x00	; 0
    409e:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    40a2:	1b 86       	std	Y+11, r1	; 0x0b
    40a4:	1a 86       	std	Y+10, r1	; 0x0a
			xReturn = pdTRUE;
    40a6:	81 e0       	ldi	r24, 0x01	; 1
    40a8:	01 c0       	rjmp	.+2      	; 0x40ac <xStreamBufferReceiveCompletedFromISR+0x36>
		}
		else
		{
			xReturn = pdFALSE;
    40aa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    40ac:	df 91       	pop	r29
    40ae:	cf 91       	pop	r28
    40b0:	1f 91       	pop	r17
    40b2:	0f 91       	pop	r16
    40b4:	ff 90       	pop	r15
    40b6:	ef 90       	pop	r14
    40b8:	08 95       	ret

000040ba <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    40ba:	e0 91 27 05 	lds	r30, 0x0527
    40be:	f0 91 28 05 	lds	r31, 0x0528
    40c2:	80 81       	ld	r24, Z
    40c4:	88 23       	and	r24, r24
    40c6:	39 f4       	brne	.+14     	; 0x40d6 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    40c8:	8f ef       	ldi	r24, 0xFF	; 255
    40ca:	9f ef       	ldi	r25, 0xFF	; 255
    40cc:	90 93 1b 05 	sts	0x051B, r25
    40d0:	80 93 1a 05 	sts	0x051A, r24
    40d4:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    40d6:	e0 91 27 05 	lds	r30, 0x0527
    40da:	f0 91 28 05 	lds	r31, 0x0528
    40de:	05 80       	ldd	r0, Z+5	; 0x05
    40e0:	f6 81       	ldd	r31, Z+6	; 0x06
    40e2:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    40e4:	06 80       	ldd	r0, Z+6	; 0x06
    40e6:	f7 81       	ldd	r31, Z+7	; 0x07
    40e8:	e0 2d       	mov	r30, r0
    40ea:	82 81       	ldd	r24, Z+2	; 0x02
    40ec:	93 81       	ldd	r25, Z+3	; 0x03
    40ee:	90 93 1b 05 	sts	0x051B, r25
    40f2:	80 93 1a 05 	sts	0x051A, r24
    40f6:	08 95       	ret

000040f8 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    40f8:	0f 93       	push	r16
    40fa:	1f 93       	push	r17
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4102:	00 91 21 05 	lds	r16, 0x0521
    4106:	10 91 22 05 	lds	r17, 0x0522
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    410a:	80 91 17 05 	lds	r24, 0x0517
    410e:	90 91 18 05 	lds	r25, 0x0518
    4112:	02 96       	adiw	r24, 0x02	; 2
    4114:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    4118:	c0 0f       	add	r28, r16
    411a:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    411c:	e0 91 17 05 	lds	r30, 0x0517
    4120:	f0 91 18 05 	lds	r31, 0x0518
    4124:	d3 83       	std	Z+3, r29	; 0x03
    4126:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    4128:	c0 17       	cp	r28, r16
    412a:	d1 07       	cpc	r29, r17
    412c:	68 f4       	brcc	.+26     	; 0x4148 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    412e:	80 91 25 05 	lds	r24, 0x0525
    4132:	90 91 26 05 	lds	r25, 0x0526
    4136:	60 91 17 05 	lds	r22, 0x0517
    413a:	70 91 18 05 	lds	r23, 0x0518
    413e:	6e 5f       	subi	r22, 0xFE	; 254
    4140:	7f 4f       	sbci	r23, 0xFF	; 255
    4142:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vListInsert>
    4146:	17 c0       	rjmp	.+46     	; 0x4176 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4148:	80 91 27 05 	lds	r24, 0x0527
    414c:	90 91 28 05 	lds	r25, 0x0528
    4150:	60 91 17 05 	lds	r22, 0x0517
    4154:	70 91 18 05 	lds	r23, 0x0518
    4158:	6e 5f       	subi	r22, 0xFE	; 254
    415a:	7f 4f       	sbci	r23, 0xFF	; 255
    415c:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    4160:	80 91 1a 05 	lds	r24, 0x051A
    4164:	90 91 1b 05 	lds	r25, 0x051B
    4168:	c8 17       	cp	r28, r24
    416a:	d9 07       	cpc	r29, r25
    416c:	20 f4       	brcc	.+8      	; 0x4176 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    416e:	d0 93 1b 05 	sts	0x051B, r29
    4172:	c0 93 1a 05 	sts	0x051A, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4176:	df 91       	pop	r29
    4178:	cf 91       	pop	r28
    417a:	1f 91       	pop	r17
    417c:	0f 91       	pop	r16
    417e:	08 95       	ret

00004180 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4180:	cf 93       	push	r28
    4182:	df 93       	push	r29
    4184:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4186:	8f 89       	ldd	r24, Y+23	; 0x17
    4188:	98 8d       	ldd	r25, Y+24	; 0x18
    418a:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <vPortFree>
			vPortFree( pxTCB );
    418e:	ce 01       	movw	r24, r28
    4190:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4194:	df 91       	pop	r29
    4196:	cf 91       	pop	r28
    4198:	08 95       	ret

0000419a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    419a:	1c c0       	rjmp	.+56     	; 0x41d4 <prvIdleTask+0x3a>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    419c:	0f b6       	in	r0, 0x3f	; 63
    419e:	f8 94       	cli
    41a0:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    41a2:	e0 91 6e 05 	lds	r30, 0x056E
    41a6:	f0 91 6f 05 	lds	r31, 0x056F
    41aa:	c6 81       	ldd	r28, Z+6	; 0x06
    41ac:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    41ae:	ce 01       	movw	r24, r28
    41b0:	02 96       	adiw	r24, 0x02	; 2
    41b2:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
				--uxCurrentNumberOfTasks;
    41b6:	80 91 23 05 	lds	r24, 0x0523
    41ba:	81 50       	subi	r24, 0x01	; 1
    41bc:	80 93 23 05 	sts	0x0523, r24
				--uxDeletedTasksWaitingCleanUp;
    41c0:	80 91 24 05 	lds	r24, 0x0524
    41c4:	81 50       	subi	r24, 0x01	; 1
    41c6:	80 93 24 05 	sts	0x0524, r24
			}
			taskEXIT_CRITICAL();
    41ca:	0f 90       	pop	r0
    41cc:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    41ce:	ce 01       	movw	r24, r28
    41d0:	0e 94 c0 20 	call	0x4180	; 0x4180 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    41d4:	80 91 24 05 	lds	r24, 0x0524
    41d8:	88 23       	and	r24, r24
    41da:	01 f7       	brne	.-64     	; 0x419c <prvIdleTask+0x2>
    41dc:	fb cf       	rjmp	.-10     	; 0x41d4 <prvIdleTask+0x3a>

000041de <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    41de:	2f 92       	push	r2
    41e0:	3f 92       	push	r3
    41e2:	4f 92       	push	r4
    41e4:	5f 92       	push	r5
    41e6:	6f 92       	push	r6
    41e8:	7f 92       	push	r7
    41ea:	8f 92       	push	r8
    41ec:	9f 92       	push	r9
    41ee:	af 92       	push	r10
    41f0:	bf 92       	push	r11
    41f2:	df 92       	push	r13
    41f4:	ef 92       	push	r14
    41f6:	ff 92       	push	r15
    41f8:	0f 93       	push	r16
    41fa:	1f 93       	push	r17
    41fc:	cf 93       	push	r28
    41fe:	df 93       	push	r29
    4200:	3c 01       	movw	r6, r24
    4202:	5b 01       	movw	r10, r22
    4204:	ea 01       	movw	r28, r20
    4206:	29 01       	movw	r4, r18
    4208:	d0 2e       	mov	r13, r16
    420a:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    420c:	ca 01       	movw	r24, r20
    420e:	0e 94 78 15 	call	0x2af0	; 0x2af0 <pvPortMalloc>
    4212:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    4214:	00 97       	sbiw	r24, 0x00	; 0
    4216:	09 f4       	brne	.+2      	; 0x421a <xTaskCreate+0x3c>
    4218:	ec c0       	rjmp	.+472    	; 0x43f2 <xTaskCreate+0x214>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    421a:	86 e2       	ldi	r24, 0x26	; 38
    421c:	90 e0       	ldi	r25, 0x00	; 0
    421e:	0e 94 78 15 	call	0x2af0	; 0x2af0 <pvPortMalloc>
    4222:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    4224:	00 97       	sbiw	r24, 0x00	; 0
    4226:	59 f0       	breq	.+22     	; 0x423e <xTaskCreate+0x60>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4228:	fc 01       	movw	r30, r24
    422a:	f0 8e       	std	Z+24, r15	; 0x18
    422c:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    422e:	21 97       	sbiw	r28, 0x01	; 1
    4230:	17 01       	movw	r2, r14
    4232:	2c 0e       	add	r2, r28
    4234:	3d 1e       	adc	r3, r29
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4236:	a1 14       	cp	r10, r1
    4238:	b1 04       	cpc	r11, r1
    423a:	31 f4       	brne	.+12     	; 0x4248 <xTaskCreate+0x6a>
    423c:	1e c0       	rjmp	.+60     	; 0x427a <xTaskCreate+0x9c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    423e:	c7 01       	movw	r24, r14
    4240:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4244:	8f ef       	ldi	r24, 0xFF	; 255
    4246:	da c0       	rjmp	.+436    	; 0x43fc <xTaskCreate+0x21e>
	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4248:	f5 01       	movw	r30, r10
    424a:	80 81       	ld	r24, Z
    424c:	f8 01       	movw	r30, r16
    424e:	81 8f       	std	Z+25, r24	; 0x19

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4250:	f5 01       	movw	r30, r10
    4252:	80 81       	ld	r24, Z
    4254:	88 23       	and	r24, r24
    4256:	71 f0       	breq	.+28     	; 0x4274 <xTaskCreate+0x96>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    4258:	e8 01       	movw	r28, r16
    425a:	6a 96       	adiw	r28, 0x1a	; 26
    425c:	d5 01       	movw	r26, r10
    425e:	11 96       	adiw	r26, 0x01	; 1
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4260:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    4262:	fd 01       	movw	r30, r26
	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4264:	9d 91       	ld	r25, X+
    4266:	99 93       	st	Y+, r25

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4268:	90 81       	ld	r25, Z
    426a:	99 23       	and	r25, r25
    426c:	19 f0       	breq	.+6      	; 0x4274 <xTaskCreate+0x96>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    426e:	8f 5f       	subi	r24, 0xFF	; 255
    4270:	88 30       	cpi	r24, 0x08	; 8
    4272:	b9 f7       	brne	.-18     	; 0x4262 <xTaskCreate+0x84>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4274:	f8 01       	movw	r30, r16
    4276:	10 a2       	lds	r17, 0x90
    4278:	02 c0       	rjmp	.+4      	; 0x427e <xTaskCreate+0xa0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    427a:	fc 01       	movw	r30, r24
    427c:	11 8e       	std	Z+25, r1	; 0x19
    427e:	cd 2d       	mov	r28, r13
    4280:	c4 30       	cpi	r28, 0x04	; 4
    4282:	08 f0       	brcs	.+2      	; 0x4286 <xTaskCreate+0xa8>
    4284:	c3 e0       	ldi	r28, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4286:	f8 01       	movw	r30, r16
    4288:	c6 8b       	std	Z+22, r28	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    428a:	ee 24       	eor	r14, r14
    428c:	ff 24       	eor	r15, r15
    428e:	68 94       	set
    4290:	e1 f8       	bld	r14, 1
    4292:	e0 0e       	add	r14, r16
    4294:	f1 1e       	adc	r15, r17
    4296:	c7 01       	movw	r24, r14
    4298:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    429c:	c8 01       	movw	r24, r16
    429e:	0c 96       	adiw	r24, 0x0c	; 12
    42a0:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    42a4:	f8 01       	movw	r30, r16
    42a6:	11 87       	std	Z+9, r17	; 0x09
    42a8:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    42aa:	84 e0       	ldi	r24, 0x04	; 4
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	8c 1b       	sub	r24, r28
    42b0:	91 09       	sbc	r25, r1
    42b2:	95 87       	std	Z+13, r25	; 0x0d
    42b4:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    42b6:	13 8b       	std	Z+19, r17	; 0x13
    42b8:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    42ba:	11 a2       	lds	r17, 0x91
    42bc:	12 a2       	lds	r17, 0x92
    42be:	13 a2       	lds	r17, 0x93
    42c0:	14 a2       	lds	r17, 0x94
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    42c2:	15 a2       	lds	r17, 0x95
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    42c4:	c1 01       	movw	r24, r2
    42c6:	b3 01       	movw	r22, r6
    42c8:	a2 01       	movw	r20, r4
    42ca:	0e 94 49 16 	call	0x2c92	; 0x2c92 <pxPortInitialiseStack>
    42ce:	f8 01       	movw	r30, r16
    42d0:	91 83       	std	Z+1, r25	; 0x01
    42d2:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    42d4:	81 14       	cp	r8, r1
    42d6:	91 04       	cpc	r9, r1
    42d8:	19 f0       	breq	.+6      	; 0x42e0 <xTaskCreate+0x102>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    42da:	f4 01       	movw	r30, r8
    42dc:	11 83       	std	Z+1, r17	; 0x01
    42de:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    42e0:	0f b6       	in	r0, 0x3f	; 63
    42e2:	f8 94       	cli
    42e4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    42e6:	80 91 23 05 	lds	r24, 0x0523
    42ea:	8f 5f       	subi	r24, 0xFF	; 255
    42ec:	80 93 23 05 	sts	0x0523, r24
		if( pxCurrentTCB == NULL )
    42f0:	80 91 17 05 	lds	r24, 0x0517
    42f4:	90 91 18 05 	lds	r25, 0x0518
    42f8:	00 97       	sbiw	r24, 0x00	; 0
    42fa:	d9 f5       	brne	.+118    	; 0x4372 <xTaskCreate+0x194>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    42fc:	10 93 18 05 	sts	0x0518, r17
    4300:	00 93 17 05 	sts	0x0517, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4304:	80 91 23 05 	lds	r24, 0x0523
    4308:	81 30       	cpi	r24, 0x01	; 1
    430a:	09 f0       	breq	.+2      	; 0x430e <xTaskCreate+0x130>
    430c:	43 c0       	rjmp	.+134    	; 0x4394 <xTaskCreate+0x1b6>
    430e:	c0 e0       	ldi	r28, 0x00	; 0
    4310:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4312:	ce 01       	movw	r24, r28
    4314:	88 0f       	add	r24, r24
    4316:	99 1f       	adc	r25, r25
    4318:	88 0f       	add	r24, r24
    431a:	99 1f       	adc	r25, r25
    431c:	88 0f       	add	r24, r24
    431e:	99 1f       	adc	r25, r25
    4320:	8c 0f       	add	r24, r28
    4322:	9d 1f       	adc	r25, r29
    4324:	86 5d       	subi	r24, 0xD6	; 214
    4326:	9a 4f       	sbci	r25, 0xFA	; 250
    4328:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
    432c:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    432e:	c4 30       	cpi	r28, 0x04	; 4
    4330:	d1 05       	cpc	r29, r1
    4332:	79 f7       	brne	.-34     	; 0x4312 <xTaskCreate+0x134>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4334:	ce e4       	ldi	r28, 0x4E	; 78
    4336:	d5 e0       	ldi	r29, 0x05	; 5
    4338:	ce 01       	movw	r24, r28
    433a:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    433e:	0f 2e       	mov	r0, r31
    4340:	f7 e5       	ldi	r31, 0x57	; 87
    4342:	af 2e       	mov	r10, r31
    4344:	f5 e0       	ldi	r31, 0x05	; 5
    4346:	bf 2e       	mov	r11, r31
    4348:	f0 2d       	mov	r31, r0
    434a:	c5 01       	movw	r24, r10
    434c:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4350:	80 e6       	ldi	r24, 0x60	; 96
    4352:	95 e0       	ldi	r25, 0x05	; 5
    4354:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4358:	89 e6       	ldi	r24, 0x69	; 105
    435a:	95 e0       	ldi	r25, 0x05	; 5
    435c:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4360:	d0 93 28 05 	sts	0x0528, r29
    4364:	c0 93 27 05 	sts	0x0527, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4368:	b0 92 26 05 	sts	0x0526, r11
    436c:	a0 92 25 05 	sts	0x0525, r10
    4370:	11 c0       	rjmp	.+34     	; 0x4394 <xTaskCreate+0x1b6>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4372:	80 91 1f 05 	lds	r24, 0x051F
    4376:	88 23       	and	r24, r24
    4378:	69 f4       	brne	.+26     	; 0x4394 <xTaskCreate+0x1b6>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    437a:	e0 91 17 05 	lds	r30, 0x0517
    437e:	f0 91 18 05 	lds	r31, 0x0518
    4382:	96 89       	ldd	r25, Z+22	; 0x16
    4384:	f8 01       	movw	r30, r16
    4386:	86 89       	ldd	r24, Z+22	; 0x16
    4388:	89 17       	cp	r24, r25
    438a:	20 f0       	brcs	.+8      	; 0x4394 <xTaskCreate+0x1b6>
				{
					pxCurrentTCB = pxNewTCB;
    438c:	10 93 18 05 	sts	0x0518, r17
    4390:	00 93 17 05 	sts	0x0517, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4394:	80 91 29 05 	lds	r24, 0x0529
    4398:	8f 5f       	subi	r24, 0xFF	; 255
    439a:	80 93 29 05 	sts	0x0529, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    439e:	f8 01       	movw	r30, r16
    43a0:	86 89       	ldd	r24, Z+22	; 0x16
    43a2:	90 91 20 05 	lds	r25, 0x0520
    43a6:	98 17       	cp	r25, r24
    43a8:	10 f4       	brcc	.+4      	; 0x43ae <xTaskCreate+0x1d0>
    43aa:	80 93 20 05 	sts	0x0520, r24
    43ae:	90 e0       	ldi	r25, 0x00	; 0
    43b0:	9c 01       	movw	r18, r24
    43b2:	22 0f       	add	r18, r18
    43b4:	33 1f       	adc	r19, r19
    43b6:	22 0f       	add	r18, r18
    43b8:	33 1f       	adc	r19, r19
    43ba:	22 0f       	add	r18, r18
    43bc:	33 1f       	adc	r19, r19
    43be:	82 0f       	add	r24, r18
    43c0:	93 1f       	adc	r25, r19
    43c2:	86 5d       	subi	r24, 0xD6	; 214
    43c4:	9a 4f       	sbci	r25, 0xFA	; 250
    43c6:	b7 01       	movw	r22, r14
    43c8:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    43cc:	0f 90       	pop	r0
    43ce:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    43d0:	80 91 1f 05 	lds	r24, 0x051F
    43d4:	88 23       	and	r24, r24
    43d6:	79 f0       	breq	.+30     	; 0x43f6 <xTaskCreate+0x218>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    43d8:	e0 91 17 05 	lds	r30, 0x0517
    43dc:	f0 91 18 05 	lds	r31, 0x0518
    43e0:	96 89       	ldd	r25, Z+22	; 0x16
    43e2:	f8 01       	movw	r30, r16
    43e4:	86 89       	ldd	r24, Z+22	; 0x16
    43e6:	98 17       	cp	r25, r24
    43e8:	40 f4       	brcc	.+16     	; 0x43fa <xTaskCreate+0x21c>
		{
			taskYIELD_IF_USING_PREEMPTION();
    43ea:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    43ee:	81 e0       	ldi	r24, 0x01	; 1
    43f0:	05 c0       	rjmp	.+10     	; 0x43fc <xTaskCreate+0x21e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    43f2:	8f ef       	ldi	r24, 0xFF	; 255
    43f4:	03 c0       	rjmp	.+6      	; 0x43fc <xTaskCreate+0x21e>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    43f6:	81 e0       	ldi	r24, 0x01	; 1
    43f8:	01 c0       	rjmp	.+2      	; 0x43fc <xTaskCreate+0x21e>
    43fa:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    43fc:	df 91       	pop	r29
    43fe:	cf 91       	pop	r28
    4400:	1f 91       	pop	r17
    4402:	0f 91       	pop	r16
    4404:	ff 90       	pop	r15
    4406:	ef 90       	pop	r14
    4408:	df 90       	pop	r13
    440a:	bf 90       	pop	r11
    440c:	af 90       	pop	r10
    440e:	9f 90       	pop	r9
    4410:	8f 90       	pop	r8
    4412:	7f 90       	pop	r7
    4414:	6f 90       	pop	r6
    4416:	5f 90       	pop	r5
    4418:	4f 90       	pop	r4
    441a:	3f 90       	pop	r3
    441c:	2f 90       	pop	r2
    441e:	08 95       	ret

00004420 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4420:	0f 93       	push	r16
    4422:	1f 93       	push	r17
    4424:	cf 93       	push	r28
    4426:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4428:	0f b6       	in	r0, 0x3f	; 63
    442a:	f8 94       	cli
    442c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    442e:	00 97       	sbiw	r24, 0x00	; 0
    4430:	29 f4       	brne	.+10     	; 0x443c <vTaskDelete+0x1c>
    4432:	c0 91 17 05 	lds	r28, 0x0517
    4436:	d0 91 18 05 	lds	r29, 0x0518
    443a:	01 c0       	rjmp	.+2      	; 0x443e <vTaskDelete+0x1e>
    443c:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    443e:	8e 01       	movw	r16, r28
    4440:	0e 5f       	subi	r16, 0xFE	; 254
    4442:	1f 4f       	sbci	r17, 0xFF	; 255
    4444:	c8 01       	movw	r24, r16
    4446:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    444a:	8c 89       	ldd	r24, Y+20	; 0x14
    444c:	9d 89       	ldd	r25, Y+21	; 0x15
    444e:	00 97       	sbiw	r24, 0x00	; 0
    4450:	21 f0       	breq	.+8      	; 0x445a <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4452:	ce 01       	movw	r24, r28
    4454:	0c 96       	adiw	r24, 0x0c	; 12
    4456:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    445a:	80 91 29 05 	lds	r24, 0x0529
    445e:	8f 5f       	subi	r24, 0xFF	; 255
    4460:	80 93 29 05 	sts	0x0529, r24

			if( pxTCB == pxCurrentTCB )
    4464:	80 91 17 05 	lds	r24, 0x0517
    4468:	90 91 18 05 	lds	r25, 0x0518
    446c:	c8 17       	cp	r28, r24
    446e:	d9 07       	cpc	r29, r25
    4470:	59 f4       	brne	.+22     	; 0x4488 <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4472:	89 e6       	ldi	r24, 0x69	; 105
    4474:	95 e0       	ldi	r25, 0x05	; 5
    4476:	b8 01       	movw	r22, r16
    4478:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    447c:	80 91 24 05 	lds	r24, 0x0524
    4480:	8f 5f       	subi	r24, 0xFF	; 255
    4482:	80 93 24 05 	sts	0x0524, r24
    4486:	0a c0       	rjmp	.+20     	; 0x449c <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4488:	80 91 23 05 	lds	r24, 0x0523
    448c:	81 50       	subi	r24, 0x01	; 1
    448e:	80 93 23 05 	sts	0x0523, r24
				prvDeleteTCB( pxTCB );
    4492:	ce 01       	movw	r24, r28
    4494:	0e 94 c0 20 	call	0x4180	; 0x4180 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4498:	0e 94 5d 20 	call	0x40ba	; 0x40ba <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    449c:	0f 90       	pop	r0
    449e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    44a0:	80 91 1f 05 	lds	r24, 0x051F
    44a4:	88 23       	and	r24, r24
    44a6:	49 f0       	breq	.+18     	; 0x44ba <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    44a8:	80 91 17 05 	lds	r24, 0x0517
    44ac:	90 91 18 05 	lds	r25, 0x0518
    44b0:	c8 17       	cp	r28, r24
    44b2:	d9 07       	cpc	r29, r25
    44b4:	11 f4       	brne	.+4      	; 0x44ba <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    44b6:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    44ba:	df 91       	pop	r29
    44bc:	cf 91       	pop	r28
    44be:	1f 91       	pop	r17
    44c0:	0f 91       	pop	r16
    44c2:	08 95       	ret

000044c4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    44c4:	ef 92       	push	r14
    44c6:	ff 92       	push	r15
    44c8:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    44ca:	8d ec       	ldi	r24, 0xCD	; 205
    44cc:	90 e2       	ldi	r25, 0x20	; 32
    44ce:	66 ee       	ldi	r22, 0xE6	; 230
    44d0:	70 e0       	ldi	r23, 0x00	; 0
    44d2:	45 e5       	ldi	r20, 0x55	; 85
    44d4:	50 e0       	ldi	r21, 0x00	; 0
    44d6:	20 e0       	ldi	r18, 0x00	; 0
    44d8:	30 e0       	ldi	r19, 0x00	; 0
    44da:	00 e0       	ldi	r16, 0x00	; 0
    44dc:	0f 2e       	mov	r0, r31
    44de:	f2 e7       	ldi	r31, 0x72	; 114
    44e0:	ef 2e       	mov	r14, r31
    44e2:	f5 e0       	ldi	r31, 0x05	; 5
    44e4:	ff 2e       	mov	r15, r31
    44e6:	f0 2d       	mov	r31, r0
    44e8:	0e 94 ef 20 	call	0x41de	; 0x41de <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    44ec:	81 30       	cpi	r24, 0x01	; 1
    44ee:	81 f4       	brne	.+32     	; 0x4510 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    44f0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    44f2:	8f ef       	ldi	r24, 0xFF	; 255
    44f4:	9f ef       	ldi	r25, 0xFF	; 255
    44f6:	90 93 1b 05 	sts	0x051B, r25
    44fa:	80 93 1a 05 	sts	0x051A, r24
		xSchedulerRunning = pdTRUE;
    44fe:	81 e0       	ldi	r24, 0x01	; 1
    4500:	80 93 1f 05 	sts	0x051F, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4504:	10 92 22 05 	sts	0x0522, r1
    4508:	10 92 21 05 	sts	0x0521, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    450c:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4510:	0f 91       	pop	r16
    4512:	ff 90       	pop	r15
    4514:	ef 90       	pop	r14
    4516:	08 95       	ret

00004518 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4518:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    451a:	10 92 1f 05 	sts	0x051F, r1
	vPortEndScheduler();
    451e:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <vPortEndScheduler>
}
    4522:	08 95       	ret

00004524 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4524:	80 91 19 05 	lds	r24, 0x0519
    4528:	8f 5f       	subi	r24, 0xFF	; 255
    452a:	80 93 19 05 	sts	0x0519, r24
}
    452e:	08 95       	ret

00004530 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4530:	0f b6       	in	r0, 0x3f	; 63
    4532:	f8 94       	cli
    4534:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4536:	80 91 21 05 	lds	r24, 0x0521
    453a:	90 91 22 05 	lds	r25, 0x0522
	}
	portTICK_TYPE_EXIT_CRITICAL();
    453e:	0f 90       	pop	r0
    4540:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    4542:	08 95       	ret

00004544 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    4544:	80 91 21 05 	lds	r24, 0x0521
    4548:	90 91 22 05 	lds	r25, 0x0522
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    454c:	08 95       	ret

0000454e <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    454e:	80 91 23 05 	lds	r24, 0x0523
}
    4552:	08 95       	ret

00004554 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4554:	00 97       	sbiw	r24, 0x00	; 0
    4556:	21 f4       	brne	.+8      	; 0x4560 <pcTaskGetName+0xc>
    4558:	80 91 17 05 	lds	r24, 0x0517
    455c:	90 91 18 05 	lds	r25, 0x0518
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4560:	49 96       	adiw	r24, 0x19	; 25
}
    4562:	08 95       	ret

00004564 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4564:	cf 92       	push	r12
    4566:	df 92       	push	r13
    4568:	ef 92       	push	r14
    456a:	ff 92       	push	r15
    456c:	0f 93       	push	r16
    456e:	1f 93       	push	r17
    4570:	cf 93       	push	r28
    4572:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4574:	80 91 19 05 	lds	r24, 0x0519
    4578:	88 23       	and	r24, r24
    457a:	09 f0       	breq	.+2      	; 0x457e <xTaskIncrementTick+0x1a>
    457c:	98 c0       	rjmp	.+304    	; 0x46ae <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    457e:	c0 90 21 05 	lds	r12, 0x0521
    4582:	d0 90 22 05 	lds	r13, 0x0522
    4586:	08 94       	sec
    4588:	c1 1c       	adc	r12, r1
    458a:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    458c:	d0 92 22 05 	sts	0x0522, r13
    4590:	c0 92 21 05 	sts	0x0521, r12

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4594:	c1 14       	cp	r12, r1
    4596:	d1 04       	cpc	r13, r1
    4598:	b9 f4       	brne	.+46     	; 0x45c8 <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    459a:	80 91 27 05 	lds	r24, 0x0527
    459e:	90 91 28 05 	lds	r25, 0x0528
    45a2:	20 91 25 05 	lds	r18, 0x0525
    45a6:	30 91 26 05 	lds	r19, 0x0526
    45aa:	30 93 28 05 	sts	0x0528, r19
    45ae:	20 93 27 05 	sts	0x0527, r18
    45b2:	90 93 26 05 	sts	0x0526, r25
    45b6:	80 93 25 05 	sts	0x0525, r24
    45ba:	80 91 1c 05 	lds	r24, 0x051C
    45be:	8f 5f       	subi	r24, 0xFF	; 255
    45c0:	80 93 1c 05 	sts	0x051C, r24
    45c4:	0e 94 5d 20 	call	0x40ba	; 0x40ba <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    45c8:	80 91 1a 05 	lds	r24, 0x051A
    45cc:	90 91 1b 05 	lds	r25, 0x051B
    45d0:	c8 16       	cp	r12, r24
    45d2:	d9 06       	cpc	r13, r25
    45d4:	20 f4       	brcc	.+8      	; 0x45de <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    45d6:	ff 24       	eor	r15, r15
    45d8:	54 c0       	rjmp	.+168    	; 0x4682 <xTaskIncrementTick+0x11e>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    45da:	fe 2c       	mov	r15, r14
    45dc:	03 c0       	rjmp	.+6      	; 0x45e4 <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    45de:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    45e0:	ee 24       	eor	r14, r14
    45e2:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    45e4:	e0 91 27 05 	lds	r30, 0x0527
    45e8:	f0 91 28 05 	lds	r31, 0x0528
    45ec:	80 81       	ld	r24, Z
    45ee:	88 23       	and	r24, r24
    45f0:	39 f4       	brne	.+14     	; 0x4600 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    45f2:	8f ef       	ldi	r24, 0xFF	; 255
    45f4:	9f ef       	ldi	r25, 0xFF	; 255
    45f6:	90 93 1b 05 	sts	0x051B, r25
    45fa:	80 93 1a 05 	sts	0x051A, r24
					break;
    45fe:	41 c0       	rjmp	.+130    	; 0x4682 <xTaskIncrementTick+0x11e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4600:	e0 91 27 05 	lds	r30, 0x0527
    4604:	f0 91 28 05 	lds	r31, 0x0528
    4608:	05 80       	ldd	r0, Z+5	; 0x05
    460a:	f6 81       	ldd	r31, Z+6	; 0x06
    460c:	e0 2d       	mov	r30, r0
    460e:	c6 81       	ldd	r28, Z+6	; 0x06
    4610:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4612:	8a 81       	ldd	r24, Y+2	; 0x02
    4614:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    4616:	c8 16       	cp	r12, r24
    4618:	d9 06       	cpc	r13, r25
    461a:	28 f4       	brcc	.+10     	; 0x4626 <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    461c:	90 93 1b 05 	sts	0x051B, r25
    4620:	80 93 1a 05 	sts	0x051A, r24
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    4624:	2e c0       	rjmp	.+92     	; 0x4682 <xTaskIncrementTick+0x11e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4626:	8e 01       	movw	r16, r28
    4628:	0e 5f       	subi	r16, 0xFE	; 254
    462a:	1f 4f       	sbci	r17, 0xFF	; 255
    462c:	c8 01       	movw	r24, r16
    462e:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4632:	8c 89       	ldd	r24, Y+20	; 0x14
    4634:	9d 89       	ldd	r25, Y+21	; 0x15
    4636:	00 97       	sbiw	r24, 0x00	; 0
    4638:	21 f0       	breq	.+8      	; 0x4642 <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    463a:	ce 01       	movw	r24, r28
    463c:	0c 96       	adiw	r24, 0x0c	; 12
    463e:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4642:	8e 89       	ldd	r24, Y+22	; 0x16
    4644:	90 91 20 05 	lds	r25, 0x0520
    4648:	98 17       	cp	r25, r24
    464a:	10 f4       	brcc	.+4      	; 0x4650 <xTaskIncrementTick+0xec>
    464c:	80 93 20 05 	sts	0x0520, r24
    4650:	90 e0       	ldi	r25, 0x00	; 0
    4652:	9c 01       	movw	r18, r24
    4654:	22 0f       	add	r18, r18
    4656:	33 1f       	adc	r19, r19
    4658:	22 0f       	add	r18, r18
    465a:	33 1f       	adc	r19, r19
    465c:	22 0f       	add	r18, r18
    465e:	33 1f       	adc	r19, r19
    4660:	82 0f       	add	r24, r18
    4662:	93 1f       	adc	r25, r19
    4664:	86 5d       	subi	r24, 0xD6	; 214
    4666:	9a 4f       	sbci	r25, 0xFA	; 250
    4668:	b8 01       	movw	r22, r16
    466a:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    466e:	e0 91 17 05 	lds	r30, 0x0517
    4672:	f0 91 18 05 	lds	r31, 0x0518
    4676:	9e 89       	ldd	r25, Y+22	; 0x16
    4678:	86 89       	ldd	r24, Z+22	; 0x16
    467a:	98 17       	cp	r25, r24
    467c:	08 f0       	brcs	.+2      	; 0x4680 <xTaskIncrementTick+0x11c>
    467e:	ad cf       	rjmp	.-166    	; 0x45da <xTaskIncrementTick+0x76>
    4680:	b1 cf       	rjmp	.-158    	; 0x45e4 <xTaskIncrementTick+0x80>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4682:	e0 91 17 05 	lds	r30, 0x0517
    4686:	f0 91 18 05 	lds	r31, 0x0518
    468a:	86 89       	ldd	r24, Z+22	; 0x16
    468c:	90 e0       	ldi	r25, 0x00	; 0
    468e:	fc 01       	movw	r30, r24
    4690:	ee 0f       	add	r30, r30
    4692:	ff 1f       	adc	r31, r31
    4694:	ee 0f       	add	r30, r30
    4696:	ff 1f       	adc	r31, r31
    4698:	ee 0f       	add	r30, r30
    469a:	ff 1f       	adc	r31, r31
    469c:	8e 0f       	add	r24, r30
    469e:	9f 1f       	adc	r25, r31
    46a0:	fc 01       	movw	r30, r24
    46a2:	e6 5d       	subi	r30, 0xD6	; 214
    46a4:	fa 4f       	sbci	r31, 0xFA	; 250
    46a6:	80 81       	ld	r24, Z
    46a8:	82 30       	cpi	r24, 0x02	; 2
    46aa:	40 f4       	brcc	.+16     	; 0x46bc <xTaskIncrementTick+0x158>
    46ac:	09 c0       	rjmp	.+18     	; 0x46c0 <xTaskIncrementTick+0x15c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    46ae:	80 91 1e 05 	lds	r24, 0x051E
    46b2:	8f 5f       	subi	r24, 0xFF	; 255
    46b4:	80 93 1e 05 	sts	0x051E, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    46b8:	ff 24       	eor	r15, r15
    46ba:	02 c0       	rjmp	.+4      	; 0x46c0 <xTaskIncrementTick+0x15c>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    46bc:	ff 24       	eor	r15, r15
    46be:	f3 94       	inc	r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    46c0:	80 91 1d 05 	lds	r24, 0x051D
    46c4:	88 23       	and	r24, r24
    46c6:	11 f0       	breq	.+4      	; 0x46cc <xTaskIncrementTick+0x168>
		{
			xSwitchRequired = pdTRUE;
    46c8:	ff 24       	eor	r15, r15
    46ca:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    46cc:	8f 2d       	mov	r24, r15
    46ce:	df 91       	pop	r29
    46d0:	cf 91       	pop	r28
    46d2:	1f 91       	pop	r17
    46d4:	0f 91       	pop	r16
    46d6:	ff 90       	pop	r15
    46d8:	ef 90       	pop	r14
    46da:	df 90       	pop	r13
    46dc:	cf 90       	pop	r12
    46de:	08 95       	ret

000046e0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    46e0:	df 92       	push	r13
    46e2:	ef 92       	push	r14
    46e4:	ff 92       	push	r15
    46e6:	0f 93       	push	r16
    46e8:	1f 93       	push	r17
    46ea:	cf 93       	push	r28
    46ec:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    46ee:	0f b6       	in	r0, 0x3f	; 63
    46f0:	f8 94       	cli
    46f2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    46f4:	80 91 19 05 	lds	r24, 0x0519
    46f8:	81 50       	subi	r24, 0x01	; 1
    46fa:	80 93 19 05 	sts	0x0519, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    46fe:	80 91 19 05 	lds	r24, 0x0519
    4702:	88 23       	and	r24, r24
    4704:	09 f0       	breq	.+2      	; 0x4708 <xTaskResumeAll+0x28>
    4706:	5f c0       	rjmp	.+190    	; 0x47c6 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4708:	80 91 23 05 	lds	r24, 0x0523
    470c:	88 23       	and	r24, r24
    470e:	91 f5       	brne	.+100    	; 0x4774 <xTaskResumeAll+0x94>
    4710:	5d c0       	rjmp	.+186    	; 0x47cc <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4712:	e0 91 65 05 	lds	r30, 0x0565
    4716:	f0 91 66 05 	lds	r31, 0x0566
    471a:	c6 81       	ldd	r28, Z+6	; 0x06
    471c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    471e:	ce 01       	movw	r24, r28
    4720:	0c 96       	adiw	r24, 0x0c	; 12
    4722:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4726:	8e 01       	movw	r16, r28
    4728:	0e 5f       	subi	r16, 0xFE	; 254
    472a:	1f 4f       	sbci	r17, 0xFF	; 255
    472c:	c8 01       	movw	r24, r16
    472e:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4732:	8e 89       	ldd	r24, Y+22	; 0x16
    4734:	90 91 20 05 	lds	r25, 0x0520
    4738:	98 17       	cp	r25, r24
    473a:	10 f4       	brcc	.+4      	; 0x4740 <xTaskResumeAll+0x60>
    473c:	80 93 20 05 	sts	0x0520, r24
    4740:	90 e0       	ldi	r25, 0x00	; 0
    4742:	9c 01       	movw	r18, r24
    4744:	22 0f       	add	r18, r18
    4746:	33 1f       	adc	r19, r19
    4748:	22 0f       	add	r18, r18
    474a:	33 1f       	adc	r19, r19
    474c:	22 0f       	add	r18, r18
    474e:	33 1f       	adc	r19, r19
    4750:	82 0f       	add	r24, r18
    4752:	93 1f       	adc	r25, r19
    4754:	86 5d       	subi	r24, 0xD6	; 214
    4756:	9a 4f       	sbci	r25, 0xFA	; 250
    4758:	b8 01       	movw	r22, r16
    475a:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    475e:	e0 91 17 05 	lds	r30, 0x0517
    4762:	f0 91 18 05 	lds	r31, 0x0518
    4766:	9e 89       	ldd	r25, Y+22	; 0x16
    4768:	86 89       	ldd	r24, Z+22	; 0x16
    476a:	98 17       	cp	r25, r24
    476c:	68 f0       	brcs	.+26     	; 0x4788 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    476e:	d0 92 1d 05 	sts	0x051D, r13
    4772:	0a c0       	rjmp	.+20     	; 0x4788 <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4774:	c0 e0       	ldi	r28, 0x00	; 0
    4776:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4778:	0f 2e       	mov	r0, r31
    477a:	f0 e6       	ldi	r31, 0x60	; 96
    477c:	ef 2e       	mov	r14, r31
    477e:	f5 e0       	ldi	r31, 0x05	; 5
    4780:	ff 2e       	mov	r15, r31
    4782:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    4784:	dd 24       	eor	r13, r13
    4786:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4788:	f7 01       	movw	r30, r14
    478a:	80 81       	ld	r24, Z
    478c:	88 23       	and	r24, r24
    478e:	09 f6       	brne	.-126    	; 0x4712 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4790:	20 97       	sbiw	r28, 0x00	; 0
    4792:	11 f0       	breq	.+4      	; 0x4798 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4794:	0e 94 5d 20 	call	0x40ba	; 0x40ba <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4798:	c0 91 1e 05 	lds	r28, 0x051E

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    479c:	cc 23       	and	r28, r28
    479e:	59 f0       	breq	.+22     	; 0x47b6 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    47a0:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    47a2:	0e 94 b2 22 	call	0x4564	; 0x4564 <xTaskIncrementTick>
    47a6:	88 23       	and	r24, r24
    47a8:	11 f0       	breq	.+4      	; 0x47ae <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    47aa:	00 93 1d 05 	sts	0x051D, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    47ae:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    47b0:	c1 f7       	brne	.-16     	; 0x47a2 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    47b2:	10 92 1e 05 	sts	0x051E, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    47b6:	80 91 1d 05 	lds	r24, 0x051D
    47ba:	88 23       	and	r24, r24
    47bc:	31 f0       	breq	.+12     	; 0x47ca <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    47be:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    47c2:	81 e0       	ldi	r24, 0x01	; 1
    47c4:	03 c0       	rjmp	.+6      	; 0x47cc <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    47c6:	80 e0       	ldi	r24, 0x00	; 0
    47c8:	01 c0       	rjmp	.+2      	; 0x47cc <xTaskResumeAll+0xec>
    47ca:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    47cc:	0f 90       	pop	r0
    47ce:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    47d0:	df 91       	pop	r29
    47d2:	cf 91       	pop	r28
    47d4:	1f 91       	pop	r17
    47d6:	0f 91       	pop	r16
    47d8:	ff 90       	pop	r15
    47da:	ef 90       	pop	r14
    47dc:	df 90       	pop	r13
    47de:	08 95       	ret

000047e0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    47e0:	cf 93       	push	r28
    47e2:	df 93       	push	r29
    47e4:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    47e6:	00 97       	sbiw	r24, 0x00	; 0
    47e8:	51 f0       	breq	.+20     	; 0x47fe <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    47ea:	0e 94 92 22 	call	0x4524	; 0x4524 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    47ee:	ce 01       	movw	r24, r28
    47f0:	60 e0       	ldi	r22, 0x00	; 0
    47f2:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    47f6:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    47fa:	88 23       	and	r24, r24
    47fc:	11 f4       	brne	.+4      	; 0x4802 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    47fe:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4802:	df 91       	pop	r29
    4804:	cf 91       	pop	r28
    4806:	08 95       	ret

00004808 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4808:	80 91 19 05 	lds	r24, 0x0519
    480c:	88 23       	and	r24, r24
    480e:	21 f0       	breq	.+8      	; 0x4818 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4810:	81 e0       	ldi	r24, 0x01	; 1
    4812:	80 93 1d 05 	sts	0x051D, r24
    4816:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    4818:	10 92 1d 05 	sts	0x051D, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    481c:	20 91 20 05 	lds	r18, 0x0520
    4820:	82 2f       	mov	r24, r18
    4822:	90 e0       	ldi	r25, 0x00	; 0
    4824:	fc 01       	movw	r30, r24
    4826:	ee 0f       	add	r30, r30
    4828:	ff 1f       	adc	r31, r31
    482a:	ee 0f       	add	r30, r30
    482c:	ff 1f       	adc	r31, r31
    482e:	ee 0f       	add	r30, r30
    4830:	ff 1f       	adc	r31, r31
    4832:	e8 0f       	add	r30, r24
    4834:	f9 1f       	adc	r31, r25
    4836:	e6 5d       	subi	r30, 0xD6	; 214
    4838:	fa 4f       	sbci	r31, 0xFA	; 250
    483a:	30 81       	ld	r19, Z
    483c:	33 23       	and	r19, r19
    483e:	89 f4       	brne	.+34     	; 0x4862 <vTaskSwitchContext+0x5a>
    4840:	21 50       	subi	r18, 0x01	; 1
    4842:	82 2f       	mov	r24, r18
    4844:	90 e0       	ldi	r25, 0x00	; 0
    4846:	fc 01       	movw	r30, r24
    4848:	ee 0f       	add	r30, r30
    484a:	ff 1f       	adc	r31, r31
    484c:	ee 0f       	add	r30, r30
    484e:	ff 1f       	adc	r31, r31
    4850:	ee 0f       	add	r30, r30
    4852:	ff 1f       	adc	r31, r31
    4854:	e8 0f       	add	r30, r24
    4856:	f9 1f       	adc	r31, r25
    4858:	e6 5d       	subi	r30, 0xD6	; 214
    485a:	fa 4f       	sbci	r31, 0xFA	; 250
    485c:	30 81       	ld	r19, Z
    485e:	33 23       	and	r19, r19
    4860:	79 f3       	breq	.-34     	; 0x4840 <vTaskSwitchContext+0x38>
    4862:	dc 01       	movw	r26, r24
    4864:	aa 0f       	add	r26, r26
    4866:	bb 1f       	adc	r27, r27
    4868:	aa 0f       	add	r26, r26
    486a:	bb 1f       	adc	r27, r27
    486c:	aa 0f       	add	r26, r26
    486e:	bb 1f       	adc	r27, r27
    4870:	8a 0f       	add	r24, r26
    4872:	9b 1f       	adc	r25, r27
    4874:	dc 01       	movw	r26, r24
    4876:	a6 5d       	subi	r26, 0xD6	; 214
    4878:	ba 4f       	sbci	r27, 0xFA	; 250
    487a:	11 96       	adiw	r26, 0x01	; 1
    487c:	ed 91       	ld	r30, X+
    487e:	fc 91       	ld	r31, X
    4880:	12 97       	sbiw	r26, 0x02	; 2
    4882:	02 80       	ldd	r0, Z+2	; 0x02
    4884:	f3 81       	ldd	r31, Z+3	; 0x03
    4886:	e0 2d       	mov	r30, r0
    4888:	12 96       	adiw	r26, 0x02	; 2
    488a:	fc 93       	st	X, r31
    488c:	ee 93       	st	-X, r30
    488e:	11 97       	sbiw	r26, 0x01	; 1
    4890:	cd 01       	movw	r24, r26
    4892:	03 96       	adiw	r24, 0x03	; 3
    4894:	e8 17       	cp	r30, r24
    4896:	f9 07       	cpc	r31, r25
    4898:	31 f4       	brne	.+12     	; 0x48a6 <vTaskSwitchContext+0x9e>
    489a:	82 81       	ldd	r24, Z+2	; 0x02
    489c:	93 81       	ldd	r25, Z+3	; 0x03
    489e:	12 96       	adiw	r26, 0x02	; 2
    48a0:	9c 93       	st	X, r25
    48a2:	8e 93       	st	-X, r24
    48a4:	11 97       	sbiw	r26, 0x01	; 1
    48a6:	11 96       	adiw	r26, 0x01	; 1
    48a8:	ed 91       	ld	r30, X+
    48aa:	fc 91       	ld	r31, X
    48ac:	12 97       	sbiw	r26, 0x02	; 2
    48ae:	86 81       	ldd	r24, Z+6	; 0x06
    48b0:	97 81       	ldd	r25, Z+7	; 0x07
    48b2:	90 93 18 05 	sts	0x0518, r25
    48b6:	80 93 17 05 	sts	0x0517, r24
    48ba:	20 93 20 05 	sts	0x0520, r18
    48be:	08 95       	ret

000048c0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    48c0:	cf 93       	push	r28
    48c2:	df 93       	push	r29
    48c4:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    48c6:	60 91 17 05 	lds	r22, 0x0517
    48ca:	70 91 18 05 	lds	r23, 0x0518
    48ce:	64 5f       	subi	r22, 0xF4	; 244
    48d0:	7f 4f       	sbci	r23, 0xFF	; 255
    48d2:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    48d6:	ce 01       	movw	r24, r28
    48d8:	61 e0       	ldi	r22, 0x01	; 1
    48da:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <prvAddCurrentTaskToDelayedList>
}
    48de:	df 91       	pop	r29
    48e0:	cf 91       	pop	r28
    48e2:	08 95       	ret

000048e4 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    48e4:	cf 93       	push	r28
    48e6:	df 93       	push	r29
    48e8:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    48ea:	e0 91 17 05 	lds	r30, 0x0517
    48ee:	f0 91 18 05 	lds	r31, 0x0518
    48f2:	70 68       	ori	r23, 0x80	; 128
    48f4:	75 87       	std	Z+13, r23	; 0x0d
    48f6:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    48f8:	60 91 17 05 	lds	r22, 0x0517
    48fc:	70 91 18 05 	lds	r23, 0x0518
    4900:	64 5f       	subi	r22, 0xF4	; 244
    4902:	7f 4f       	sbci	r23, 0xFF	; 255
    4904:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4908:	ce 01       	movw	r24, r28
    490a:	61 e0       	ldi	r22, 0x01	; 1
    490c:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <prvAddCurrentTaskToDelayedList>
}
    4910:	df 91       	pop	r29
    4912:	cf 91       	pop	r28
    4914:	08 95       	ret

00004916 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4916:	0f 93       	push	r16
    4918:	1f 93       	push	r17
    491a:	cf 93       	push	r28
    491c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    491e:	dc 01       	movw	r26, r24
    4920:	15 96       	adiw	r26, 0x05	; 5
    4922:	ed 91       	ld	r30, X+
    4924:	fc 91       	ld	r31, X
    4926:	16 97       	sbiw	r26, 0x06	; 6
    4928:	06 81       	ldd	r16, Z+6	; 0x06
    492a:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    492c:	e8 01       	movw	r28, r16
    492e:	2c 96       	adiw	r28, 0x0c	; 12
    4930:	ce 01       	movw	r24, r28
    4932:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4936:	80 91 19 05 	lds	r24, 0x0519
    493a:	88 23       	and	r24, r24
    493c:	e9 f4       	brne	.+58     	; 0x4978 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    493e:	e8 01       	movw	r28, r16
    4940:	22 96       	adiw	r28, 0x02	; 2
    4942:	ce 01       	movw	r24, r28
    4944:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4948:	f8 01       	movw	r30, r16
    494a:	86 89       	ldd	r24, Z+22	; 0x16
    494c:	90 91 20 05 	lds	r25, 0x0520
    4950:	98 17       	cp	r25, r24
    4952:	10 f4       	brcc	.+4      	; 0x4958 <xTaskRemoveFromEventList+0x42>
    4954:	80 93 20 05 	sts	0x0520, r24
    4958:	90 e0       	ldi	r25, 0x00	; 0
    495a:	9c 01       	movw	r18, r24
    495c:	22 0f       	add	r18, r18
    495e:	33 1f       	adc	r19, r19
    4960:	22 0f       	add	r18, r18
    4962:	33 1f       	adc	r19, r19
    4964:	22 0f       	add	r18, r18
    4966:	33 1f       	adc	r19, r19
    4968:	82 0f       	add	r24, r18
    496a:	93 1f       	adc	r25, r19
    496c:	86 5d       	subi	r24, 0xD6	; 214
    496e:	9a 4f       	sbci	r25, 0xFA	; 250
    4970:	be 01       	movw	r22, r28
    4972:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
    4976:	05 c0       	rjmp	.+10     	; 0x4982 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4978:	80 e6       	ldi	r24, 0x60	; 96
    497a:	95 e0       	ldi	r25, 0x05	; 5
    497c:	be 01       	movw	r22, r28
    497e:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4982:	e0 91 17 05 	lds	r30, 0x0517
    4986:	f0 91 18 05 	lds	r31, 0x0518
    498a:	d8 01       	movw	r26, r16
    498c:	56 96       	adiw	r26, 0x16	; 22
    498e:	9c 91       	ld	r25, X
    4990:	56 97       	sbiw	r26, 0x16	; 22
    4992:	86 89       	ldd	r24, Z+22	; 0x16
    4994:	89 17       	cp	r24, r25
    4996:	20 f4       	brcc	.+8      	; 0x49a0 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4998:	81 e0       	ldi	r24, 0x01	; 1
    499a:	80 93 1d 05 	sts	0x051D, r24
    499e:	01 c0       	rjmp	.+2      	; 0x49a2 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    49a0:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    49a2:	df 91       	pop	r29
    49a4:	cf 91       	pop	r28
    49a6:	1f 91       	pop	r17
    49a8:	0f 91       	pop	r16
    49aa:	08 95       	ret

000049ac <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    49ac:	0f 93       	push	r16
    49ae:	1f 93       	push	r17
    49b0:	cf 93       	push	r28
    49b2:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    49b4:	70 68       	ori	r23, 0x80	; 128
    49b6:	fc 01       	movw	r30, r24
    49b8:	71 83       	std	Z+1, r23	; 0x01
    49ba:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49bc:	c6 81       	ldd	r28, Z+6	; 0x06
    49be:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    49c0:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    49c4:	8e 01       	movw	r16, r28
    49c6:	0e 5f       	subi	r16, 0xFE	; 254
    49c8:	1f 4f       	sbci	r17, 0xFF	; 255
    49ca:	c8 01       	movw	r24, r16
    49cc:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    49d0:	8e 89       	ldd	r24, Y+22	; 0x16
    49d2:	90 91 20 05 	lds	r25, 0x0520
    49d6:	98 17       	cp	r25, r24
    49d8:	10 f4       	brcc	.+4      	; 0x49de <vTaskRemoveFromUnorderedEventList+0x32>
    49da:	80 93 20 05 	sts	0x0520, r24
    49de:	90 e0       	ldi	r25, 0x00	; 0
    49e0:	9c 01       	movw	r18, r24
    49e2:	22 0f       	add	r18, r18
    49e4:	33 1f       	adc	r19, r19
    49e6:	22 0f       	add	r18, r18
    49e8:	33 1f       	adc	r19, r19
    49ea:	22 0f       	add	r18, r18
    49ec:	33 1f       	adc	r19, r19
    49ee:	82 0f       	add	r24, r18
    49f0:	93 1f       	adc	r25, r19
    49f2:	86 5d       	subi	r24, 0xD6	; 214
    49f4:	9a 4f       	sbci	r25, 0xFA	; 250
    49f6:	b8 01       	movw	r22, r16
    49f8:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    49fc:	e0 91 17 05 	lds	r30, 0x0517
    4a00:	f0 91 18 05 	lds	r31, 0x0518
    4a04:	9e 89       	ldd	r25, Y+22	; 0x16
    4a06:	86 89       	ldd	r24, Z+22	; 0x16
    4a08:	89 17       	cp	r24, r25
    4a0a:	18 f4       	brcc	.+6      	; 0x4a12 <vTaskRemoveFromUnorderedEventList+0x66>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4a0c:	81 e0       	ldi	r24, 0x01	; 1
    4a0e:	80 93 1d 05 	sts	0x051D, r24
	}
}
    4a12:	df 91       	pop	r29
    4a14:	cf 91       	pop	r28
    4a16:	1f 91       	pop	r17
    4a18:	0f 91       	pop	r16
    4a1a:	08 95       	ret

00004a1c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4a1c:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4a1e:	0f b6       	in	r0, 0x3f	; 63
    4a20:	f8 94       	cli
    4a22:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4a24:	80 91 1c 05 	lds	r24, 0x051C
    4a28:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4a2a:	80 91 21 05 	lds	r24, 0x0521
    4a2e:	90 91 22 05 	lds	r25, 0x0522
    4a32:	92 83       	std	Z+2, r25	; 0x02
    4a34:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4a36:	0f 90       	pop	r0
    4a38:	0f be       	out	0x3f, r0	; 63
}
    4a3a:	08 95       	ret

00004a3c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4a3c:	fc 01       	movw	r30, r24
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4a3e:	80 91 1c 05 	lds	r24, 0x051C
    4a42:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4a44:	80 91 21 05 	lds	r24, 0x0521
    4a48:	90 91 22 05 	lds	r25, 0x0522
    4a4c:	92 83       	std	Z+2, r25	; 0x02
    4a4e:	81 83       	std	Z+1, r24	; 0x01
}
    4a50:	08 95       	ret

00004a52 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4a52:	fc 01       	movw	r30, r24
    4a54:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4a56:	0f b6       	in	r0, 0x3f	; 63
    4a58:	f8 94       	cli
    4a5a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4a5c:	20 91 21 05 	lds	r18, 0x0521
    4a60:	30 91 22 05 	lds	r19, 0x0522
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4a64:	81 81       	ldd	r24, Z+1	; 0x01
    4a66:	92 81       	ldd	r25, Z+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4a68:	40 91 1c 05 	lds	r20, 0x051C
    4a6c:	50 81       	ld	r21, Z
    4a6e:	54 17       	cp	r21, r20
    4a70:	19 f0       	breq	.+6      	; 0x4a78 <xTaskCheckForTimeOut+0x26>
    4a72:	28 17       	cp	r18, r24
    4a74:	39 07       	cpc	r19, r25
    4a76:	b0 f4       	brcc	.+44     	; 0x4aa4 <xTaskCheckForTimeOut+0x52>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4a78:	28 1b       	sub	r18, r24
    4a7a:	39 0b       	sbc	r19, r25
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4a7c:	8d 91       	ld	r24, X+
    4a7e:	9c 91       	ld	r25, X
    4a80:	11 97       	sbiw	r26, 0x01	; 1
    4a82:	28 17       	cp	r18, r24
    4a84:	39 07       	cpc	r19, r25
    4a86:	48 f4       	brcc	.+18     	; 0x4a9a <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4a88:	82 1b       	sub	r24, r18
    4a8a:	93 0b       	sbc	r25, r19
    4a8c:	8d 93       	st	X+, r24
    4a8e:	9c 93       	st	X, r25
			vTaskInternalSetTimeOutState( pxTimeOut );
    4a90:	cf 01       	movw	r24, r30
    4a92:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4a96:	80 e0       	ldi	r24, 0x00	; 0
    4a98:	06 c0       	rjmp	.+12     	; 0x4aa6 <xTaskCheckForTimeOut+0x54>
		}
		else
		{
			*pxTicksToWait = 0;
    4a9a:	11 96       	adiw	r26, 0x01	; 1
    4a9c:	1c 92       	st	X, r1
    4a9e:	1e 92       	st	-X, r1
			xReturn = pdTRUE;
    4aa0:	81 e0       	ldi	r24, 0x01	; 1
    4aa2:	01 c0       	rjmp	.+2      	; 0x4aa6 <xTaskCheckForTimeOut+0x54>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4aa4:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    4aa6:	0f 90       	pop	r0
    4aa8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    4aaa:	08 95       	ret

00004aac <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    4aac:	81 e0       	ldi	r24, 0x01	; 1
    4aae:	80 93 1d 05 	sts	0x051D, r24
}
    4ab2:	08 95       	ret

00004ab4 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4ab4:	80 91 17 05 	lds	r24, 0x0517
    4ab8:	90 91 18 05 	lds	r25, 0x0518

		return xReturn;
	}
    4abc:	08 95       	ret

00004abe <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4abe:	e0 91 17 05 	lds	r30, 0x0517
    4ac2:	f0 91 18 05 	lds	r31, 0x0518
    4ac6:	84 85       	ldd	r24, Z+12	; 0x0c
    4ac8:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4aca:	e0 91 17 05 	lds	r30, 0x0517
    4ace:	f0 91 18 05 	lds	r31, 0x0518
    4ad2:	a0 91 17 05 	lds	r26, 0x0517
    4ad6:	b0 91 18 05 	lds	r27, 0x0518
    4ada:	56 96       	adiw	r26, 0x16	; 22
    4adc:	4c 91       	ld	r20, X
    4ade:	56 97       	sbiw	r26, 0x16	; 22
    4ae0:	24 e0       	ldi	r18, 0x04	; 4
    4ae2:	30 e0       	ldi	r19, 0x00	; 0
    4ae4:	24 1b       	sub	r18, r20
    4ae6:	31 09       	sbc	r19, r1
    4ae8:	35 87       	std	Z+13, r19	; 0x0d
    4aea:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    4aec:	08 95       	ret

00004aee <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4aee:	0f 93       	push	r16
    4af0:	1f 93       	push	r17
    4af2:	cf 93       	push	r28
    4af4:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4af6:	0f b6       	in	r0, 0x3f	; 63
    4af8:	f8 94       	cli
    4afa:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4afc:	e0 91 17 05 	lds	r30, 0x0517
    4b00:	f0 91 18 05 	lds	r31, 0x0518
    4b04:	81 a1       	lds	r24, 0x41
    4b06:	92 a1       	lds	r25, 0x42
    4b08:	a3 a1       	lds	r26, 0x43
    4b0a:	b4 a1       	lds	r27, 0x44
    4b0c:	00 97       	sbiw	r24, 0x00	; 0
    4b0e:	a1 05       	cpc	r26, r1
    4b10:	b1 05       	cpc	r27, r1
    4b12:	79 f4       	brne	.+30     	; 0x4b32 <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4b14:	e0 91 17 05 	lds	r30, 0x0517
    4b18:	f0 91 18 05 	lds	r31, 0x0518
    4b1c:	81 e0       	ldi	r24, 0x01	; 1
    4b1e:	85 a3       	lds	r24, 0x55

				if( xTicksToWait > ( TickType_t ) 0 )
    4b20:	61 15       	cp	r22, r1
    4b22:	71 05       	cpc	r23, r1
    4b24:	31 f0       	breq	.+12     	; 0x4b32 <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b26:	cb 01       	movw	r24, r22
    4b28:	61 e0       	ldi	r22, 0x01	; 1
    4b2a:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4b2e:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4b32:	0f 90       	pop	r0
    4b34:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4b36:	0f b6       	in	r0, 0x3f	; 63
    4b38:	f8 94       	cli
    4b3a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4b3c:	e0 91 17 05 	lds	r30, 0x0517
    4b40:	f0 91 18 05 	lds	r31, 0x0518
    4b44:	01 a1       	lds	r16, 0x41
    4b46:	12 a1       	lds	r17, 0x42
    4b48:	23 a1       	lds	r18, 0x43
    4b4a:	34 a1       	lds	r19, 0x44

			if( ulReturn != 0UL )
    4b4c:	01 15       	cp	r16, r1
    4b4e:	11 05       	cpc	r17, r1
    4b50:	21 05       	cpc	r18, r1
    4b52:	31 05       	cpc	r19, r1
    4b54:	c1 f0       	breq	.+48     	; 0x4b86 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    4b56:	cc 23       	and	r28, r28
    4b58:	49 f0       	breq	.+18     	; 0x4b6c <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4b5a:	e0 91 17 05 	lds	r30, 0x0517
    4b5e:	f0 91 18 05 	lds	r31, 0x0518
    4b62:	11 a2       	lds	r17, 0x91
    4b64:	12 a2       	lds	r17, 0x92
    4b66:	13 a2       	lds	r17, 0x93
    4b68:	14 a2       	lds	r17, 0x94
    4b6a:	0d c0       	rjmp	.+26     	; 0x4b86 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4b6c:	e0 91 17 05 	lds	r30, 0x0517
    4b70:	f0 91 18 05 	lds	r31, 0x0518
    4b74:	d9 01       	movw	r26, r18
    4b76:	c8 01       	movw	r24, r16
    4b78:	01 97       	sbiw	r24, 0x01	; 1
    4b7a:	a1 09       	sbc	r26, r1
    4b7c:	b1 09       	sbc	r27, r1
    4b7e:	81 a3       	lds	r24, 0x51
    4b80:	92 a3       	lds	r25, 0x52
    4b82:	a3 a3       	lds	r26, 0x53
    4b84:	b4 a3       	lds	r27, 0x54
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4b86:	e0 91 17 05 	lds	r30, 0x0517
    4b8a:	f0 91 18 05 	lds	r31, 0x0518
    4b8e:	15 a2       	lds	r17, 0x95
		}
		taskEXIT_CRITICAL();
    4b90:	0f 90       	pop	r0
    4b92:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    4b94:	60 2f       	mov	r22, r16
    4b96:	71 2f       	mov	r23, r17
    4b98:	82 2f       	mov	r24, r18
    4b9a:	93 2f       	mov	r25, r19
    4b9c:	cf 91       	pop	r28
    4b9e:	1f 91       	pop	r17
    4ba0:	0f 91       	pop	r16
    4ba2:	08 95       	ret

00004ba4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4ba4:	8f 92       	push	r8
    4ba6:	9f 92       	push	r9
    4ba8:	af 92       	push	r10
    4baa:	bf 92       	push	r11
    4bac:	ef 92       	push	r14
    4bae:	ff 92       	push	r15
    4bb0:	0f 93       	push	r16
    4bb2:	1f 93       	push	r17
    4bb4:	dc 01       	movw	r26, r24
    4bb6:	cb 01       	movw	r24, r22
    4bb8:	49 01       	movw	r8, r18
    4bba:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4bbc:	0f b6       	in	r0, 0x3f	; 63
    4bbe:	f8 94       	cli
    4bc0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4bc2:	e0 91 17 05 	lds	r30, 0x0517
    4bc6:	f0 91 18 05 	lds	r31, 0x0518
    4bca:	25 a1       	lds	r18, 0x45
    4bcc:	22 30       	cpi	r18, 0x02	; 2
    4bce:	19 f1       	breq	.+70     	; 0x4c16 <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4bd0:	e0 91 17 05 	lds	r30, 0x0517
    4bd4:	f0 91 18 05 	lds	r31, 0x0518
    4bd8:	41 a1       	lds	r20, 0x41
    4bda:	52 a1       	lds	r21, 0x42
    4bdc:	63 a1       	lds	r22, 0x43
    4bde:	74 a1       	lds	r23, 0x44
    4be0:	80 95       	com	r24
    4be2:	90 95       	com	r25
    4be4:	a0 95       	com	r26
    4be6:	b0 95       	com	r27
    4be8:	84 23       	and	r24, r20
    4bea:	95 23       	and	r25, r21
    4bec:	a6 23       	and	r26, r22
    4bee:	b7 23       	and	r27, r23
    4bf0:	81 a3       	lds	r24, 0x51
    4bf2:	92 a3       	lds	r25, 0x52
    4bf4:	a3 a3       	lds	r26, 0x53
    4bf6:	b4 a3       	lds	r27, 0x54

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4bf8:	e0 91 17 05 	lds	r30, 0x0517
    4bfc:	f0 91 18 05 	lds	r31, 0x0518
    4c00:	81 e0       	ldi	r24, 0x01	; 1
    4c02:	85 a3       	lds	r24, 0x55

				if( xTicksToWait > ( TickType_t ) 0 )
    4c04:	e1 14       	cp	r14, r1
    4c06:	f1 04       	cpc	r15, r1
    4c08:	31 f0       	breq	.+12     	; 0x4c16 <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4c0a:	c7 01       	movw	r24, r14
    4c0c:	61 e0       	ldi	r22, 0x01	; 1
    4c0e:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4c12:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4c16:	0f 90       	pop	r0
    4c18:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4c1a:	0f b6       	in	r0, 0x3f	; 63
    4c1c:	f8 94       	cli
    4c1e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4c20:	01 15       	cp	r16, r1
    4c22:	11 05       	cpc	r17, r1
    4c24:	69 f0       	breq	.+26     	; 0x4c40 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4c26:	e0 91 17 05 	lds	r30, 0x0517
    4c2a:	f0 91 18 05 	lds	r31, 0x0518
    4c2e:	81 a1       	lds	r24, 0x41
    4c30:	92 a1       	lds	r25, 0x42
    4c32:	a3 a1       	lds	r26, 0x43
    4c34:	b4 a1       	lds	r27, 0x44
    4c36:	f8 01       	movw	r30, r16
    4c38:	80 83       	st	Z, r24
    4c3a:	91 83       	std	Z+1, r25	; 0x01
    4c3c:	a2 83       	std	Z+2, r26	; 0x02
    4c3e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4c40:	e0 91 17 05 	lds	r30, 0x0517
    4c44:	f0 91 18 05 	lds	r31, 0x0518
    4c48:	85 a1       	lds	r24, 0x45
    4c4a:	82 30       	cpi	r24, 0x02	; 2
    4c4c:	b1 f4       	brne	.+44     	; 0x4c7a <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4c4e:	e0 91 17 05 	lds	r30, 0x0517
    4c52:	f0 91 18 05 	lds	r31, 0x0518
    4c56:	81 a1       	lds	r24, 0x41
    4c58:	92 a1       	lds	r25, 0x42
    4c5a:	a3 a1       	lds	r26, 0x43
    4c5c:	b4 a1       	lds	r27, 0x44
    4c5e:	80 94       	com	r8
    4c60:	90 94       	com	r9
    4c62:	a0 94       	com	r10
    4c64:	b0 94       	com	r11
    4c66:	88 22       	and	r8, r24
    4c68:	99 22       	and	r9, r25
    4c6a:	aa 22       	and	r10, r26
    4c6c:	bb 22       	and	r11, r27
    4c6e:	81 a2       	lds	r24, 0x91
    4c70:	92 a2       	lds	r25, 0x92
    4c72:	a3 a2       	lds	r26, 0x93
    4c74:	b4 a2       	lds	r27, 0x94
				xReturn = pdTRUE;
    4c76:	81 e0       	ldi	r24, 0x01	; 1
    4c78:	01 c0       	rjmp	.+2      	; 0x4c7c <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4c7a:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4c7c:	e0 91 17 05 	lds	r30, 0x0517
    4c80:	f0 91 18 05 	lds	r31, 0x0518
    4c84:	15 a2       	lds	r17, 0x95
		}
		taskEXIT_CRITICAL();
    4c86:	0f 90       	pop	r0
    4c88:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4c8a:	1f 91       	pop	r17
    4c8c:	0f 91       	pop	r16
    4c8e:	ff 90       	pop	r15
    4c90:	ef 90       	pop	r14
    4c92:	bf 90       	pop	r11
    4c94:	af 90       	pop	r10
    4c96:	9f 90       	pop	r9
    4c98:	8f 90       	pop	r8
    4c9a:	08 95       	ret

00004c9c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4c9c:	0f 93       	push	r16
    4c9e:	1f 93       	push	r17
    4ca0:	cf 93       	push	r28
    4ca2:	df 93       	push	r29
    4ca4:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    4ca6:	0f b6       	in	r0, 0x3f	; 63
    4ca8:	f8 94       	cli
    4caa:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4cac:	01 15       	cp	r16, r1
    4cae:	11 05       	cpc	r17, r1
    4cb0:	49 f0       	breq	.+18     	; 0x4cc4 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4cb2:	89 a1       	lds	r24, 0x49
    4cb4:	9a a1       	lds	r25, 0x4a
    4cb6:	ab a1       	lds	r26, 0x4b
    4cb8:	bc a1       	lds	r27, 0x4c
    4cba:	f8 01       	movw	r30, r16
    4cbc:	80 83       	st	Z, r24
    4cbe:	91 83       	std	Z+1, r25	; 0x01
    4cc0:	a2 83       	std	Z+2, r26	; 0x02
    4cc2:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4cc4:	3d a1       	lds	r19, 0x4d

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4cc6:	82 e0       	ldi	r24, 0x02	; 2
    4cc8:	8d a3       	lds	r24, 0x5d

			switch( eAction )
    4cca:	22 30       	cpi	r18, 0x02	; 2
    4ccc:	b9 f0       	breq	.+46     	; 0x4cfc <xTaskGenericNotify+0x60>
    4cce:	23 30       	cpi	r18, 0x03	; 3
    4cd0:	18 f4       	brcc	.+6      	; 0x4cd8 <xTaskGenericNotify+0x3c>
    4cd2:	21 30       	cpi	r18, 0x01	; 1
    4cd4:	51 f5       	brne	.+84     	; 0x4d2a <xTaskGenericNotify+0x8e>
    4cd6:	05 c0       	rjmp	.+10     	; 0x4ce2 <xTaskGenericNotify+0x46>
    4cd8:	23 30       	cpi	r18, 0x03	; 3
    4cda:	e1 f0       	breq	.+56     	; 0x4d14 <xTaskGenericNotify+0x78>
    4cdc:	24 30       	cpi	r18, 0x04	; 4
    4cde:	29 f5       	brne	.+74     	; 0x4d2a <xTaskGenericNotify+0x8e>
    4ce0:	1e c0       	rjmp	.+60     	; 0x4d1e <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4ce2:	89 a1       	lds	r24, 0x49
    4ce4:	9a a1       	lds	r25, 0x4a
    4ce6:	ab a1       	lds	r26, 0x4b
    4ce8:	bc a1       	lds	r27, 0x4c
    4cea:	48 2b       	or	r20, r24
    4cec:	59 2b       	or	r21, r25
    4cee:	6a 2b       	or	r22, r26
    4cf0:	7b 2b       	or	r23, r27
    4cf2:	49 a3       	lds	r20, 0x59
    4cf4:	5a a3       	lds	r21, 0x5a
    4cf6:	6b a3       	lds	r22, 0x5b
    4cf8:	7c a3       	lds	r23, 0x5c
					break;
    4cfa:	17 c0       	rjmp	.+46     	; 0x4d2a <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4cfc:	89 a1       	lds	r24, 0x49
    4cfe:	9a a1       	lds	r25, 0x4a
    4d00:	ab a1       	lds	r26, 0x4b
    4d02:	bc a1       	lds	r27, 0x4c
    4d04:	01 96       	adiw	r24, 0x01	; 1
    4d06:	a1 1d       	adc	r26, r1
    4d08:	b1 1d       	adc	r27, r1
    4d0a:	89 a3       	lds	r24, 0x59
    4d0c:	9a a3       	lds	r25, 0x5a
    4d0e:	ab a3       	lds	r26, 0x5b
    4d10:	bc a3       	lds	r27, 0x5c
					break;
    4d12:	0b c0       	rjmp	.+22     	; 0x4d2a <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4d14:	49 a3       	lds	r20, 0x59
    4d16:	5a a3       	lds	r21, 0x5a
    4d18:	6b a3       	lds	r22, 0x5b
    4d1a:	7c a3       	lds	r23, 0x5c
					break;
    4d1c:	06 c0       	rjmp	.+12     	; 0x4d2a <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4d1e:	32 30       	cpi	r19, 0x02	; 2
    4d20:	71 f1       	breq	.+92     	; 0x4d7e <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4d22:	49 a3       	lds	r20, 0x59
    4d24:	5a a3       	lds	r21, 0x5a
    4d26:	6b a3       	lds	r22, 0x5b
    4d28:	7c a3       	lds	r23, 0x5c

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4d2a:	31 30       	cpi	r19, 0x01	; 1
    4d2c:	51 f5       	brne	.+84     	; 0x4d82 <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d2e:	8e 01       	movw	r16, r28
    4d30:	0e 5f       	subi	r16, 0xFE	; 254
    4d32:	1f 4f       	sbci	r17, 0xFF	; 255
    4d34:	c8 01       	movw	r24, r16
    4d36:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4d3a:	8e 89       	ldd	r24, Y+22	; 0x16
    4d3c:	90 91 20 05 	lds	r25, 0x0520
    4d40:	98 17       	cp	r25, r24
    4d42:	10 f4       	brcc	.+4      	; 0x4d48 <xTaskGenericNotify+0xac>
    4d44:	80 93 20 05 	sts	0x0520, r24
    4d48:	90 e0       	ldi	r25, 0x00	; 0
    4d4a:	9c 01       	movw	r18, r24
    4d4c:	22 0f       	add	r18, r18
    4d4e:	33 1f       	adc	r19, r19
    4d50:	22 0f       	add	r18, r18
    4d52:	33 1f       	adc	r19, r19
    4d54:	22 0f       	add	r18, r18
    4d56:	33 1f       	adc	r19, r19
    4d58:	82 0f       	add	r24, r18
    4d5a:	93 1f       	adc	r25, r19
    4d5c:	86 5d       	subi	r24, 0xD6	; 214
    4d5e:	9a 4f       	sbci	r25, 0xFA	; 250
    4d60:	b8 01       	movw	r22, r16
    4d62:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4d66:	e0 91 17 05 	lds	r30, 0x0517
    4d6a:	f0 91 18 05 	lds	r31, 0x0518
    4d6e:	9e 89       	ldd	r25, Y+22	; 0x16
    4d70:	86 89       	ldd	r24, Z+22	; 0x16
    4d72:	89 17       	cp	r24, r25
    4d74:	40 f4       	brcc	.+16     	; 0x4d86 <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4d76:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vPortYield>
    4d7a:	81 e0       	ldi	r24, 0x01	; 1
    4d7c:	05 c0       	rjmp	.+10     	; 0x4d88 <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4d7e:	80 e0       	ldi	r24, 0x00	; 0
    4d80:	03 c0       	rjmp	.+6      	; 0x4d88 <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4d82:	81 e0       	ldi	r24, 0x01	; 1
    4d84:	01 c0       	rjmp	.+2      	; 0x4d88 <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4d86:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4d88:	0f 90       	pop	r0
    4d8a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4d8c:	df 91       	pop	r29
    4d8e:	cf 91       	pop	r28
    4d90:	1f 91       	pop	r17
    4d92:	0f 91       	pop	r16
    4d94:	08 95       	ret

00004d96 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4d96:	ef 92       	push	r14
    4d98:	ff 92       	push	r15
    4d9a:	0f 93       	push	r16
    4d9c:	1f 93       	push	r17
    4d9e:	cf 93       	push	r28
    4da0:	df 93       	push	r29
    4da2:	ec 01       	movw	r28, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    4da4:	01 15       	cp	r16, r1
    4da6:	11 05       	cpc	r17, r1
    4da8:	49 f0       	breq	.+18     	; 0x4dbc <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4daa:	89 a1       	lds	r24, 0x49
    4dac:	9a a1       	lds	r25, 0x4a
    4dae:	ab a1       	lds	r26, 0x4b
    4db0:	bc a1       	lds	r27, 0x4c
    4db2:	f8 01       	movw	r30, r16
    4db4:	80 83       	st	Z, r24
    4db6:	91 83       	std	Z+1, r25	; 0x01
    4db8:	a2 83       	std	Z+2, r26	; 0x02
    4dba:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4dbc:	3d a1       	lds	r19, 0x4d
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4dbe:	82 e0       	ldi	r24, 0x02	; 2
    4dc0:	8d a3       	lds	r24, 0x5d

			switch( eAction )
    4dc2:	22 30       	cpi	r18, 0x02	; 2
    4dc4:	b9 f0       	breq	.+46     	; 0x4df4 <xTaskGenericNotifyFromISR+0x5e>
    4dc6:	23 30       	cpi	r18, 0x03	; 3
    4dc8:	18 f4       	brcc	.+6      	; 0x4dd0 <xTaskGenericNotifyFromISR+0x3a>
    4dca:	21 30       	cpi	r18, 0x01	; 1
    4dcc:	59 f5       	brne	.+86     	; 0x4e24 <xTaskGenericNotifyFromISR+0x8e>
    4dce:	05 c0       	rjmp	.+10     	; 0x4dda <xTaskGenericNotifyFromISR+0x44>
    4dd0:	23 30       	cpi	r18, 0x03	; 3
    4dd2:	e1 f0       	breq	.+56     	; 0x4e0c <xTaskGenericNotifyFromISR+0x76>
    4dd4:	24 30       	cpi	r18, 0x04	; 4
    4dd6:	31 f5       	brne	.+76     	; 0x4e24 <xTaskGenericNotifyFromISR+0x8e>
    4dd8:	1e c0       	rjmp	.+60     	; 0x4e16 <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4dda:	89 a1       	lds	r24, 0x49
    4ddc:	9a a1       	lds	r25, 0x4a
    4dde:	ab a1       	lds	r26, 0x4b
    4de0:	bc a1       	lds	r27, 0x4c
    4de2:	84 2b       	or	r24, r20
    4de4:	95 2b       	or	r25, r21
    4de6:	a6 2b       	or	r26, r22
    4de8:	b7 2b       	or	r27, r23
    4dea:	89 a3       	lds	r24, 0x59
    4dec:	9a a3       	lds	r25, 0x5a
    4dee:	ab a3       	lds	r26, 0x5b
    4df0:	bc a3       	lds	r27, 0x5c
					break;
    4df2:	18 c0       	rjmp	.+48     	; 0x4e24 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4df4:	89 a1       	lds	r24, 0x49
    4df6:	9a a1       	lds	r25, 0x4a
    4df8:	ab a1       	lds	r26, 0x4b
    4dfa:	bc a1       	lds	r27, 0x4c
    4dfc:	01 96       	adiw	r24, 0x01	; 1
    4dfe:	a1 1d       	adc	r26, r1
    4e00:	b1 1d       	adc	r27, r1
    4e02:	89 a3       	lds	r24, 0x59
    4e04:	9a a3       	lds	r25, 0x5a
    4e06:	ab a3       	lds	r26, 0x5b
    4e08:	bc a3       	lds	r27, 0x5c
					break;
    4e0a:	0c c0       	rjmp	.+24     	; 0x4e24 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4e0c:	49 a3       	lds	r20, 0x59
    4e0e:	5a a3       	lds	r21, 0x5a
    4e10:	6b a3       	lds	r22, 0x5b
    4e12:	7c a3       	lds	r23, 0x5c
					break;
    4e14:	07 c0       	rjmp	.+14     	; 0x4e24 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4e16:	32 30       	cpi	r19, 0x02	; 2
    4e18:	09 f4       	brne	.+2      	; 0x4e1c <xTaskGenericNotifyFromISR+0x86>
    4e1a:	40 c0       	rjmp	.+128    	; 0x4e9c <xTaskGenericNotifyFromISR+0x106>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4e1c:	49 a3       	lds	r20, 0x59
    4e1e:	5a a3       	lds	r21, 0x5a
    4e20:	6b a3       	lds	r22, 0x5b
    4e22:	7c a3       	lds	r23, 0x5c

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4e24:	31 30       	cpi	r19, 0x01	; 1
    4e26:	e1 f5       	brne	.+120    	; 0x4ea0 <xTaskGenericNotifyFromISR+0x10a>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e28:	80 91 19 05 	lds	r24, 0x0519
    4e2c:	88 23       	and	r24, r24
    4e2e:	e9 f4       	brne	.+58     	; 0x4e6a <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4e30:	8e 01       	movw	r16, r28
    4e32:	0e 5f       	subi	r16, 0xFE	; 254
    4e34:	1f 4f       	sbci	r17, 0xFF	; 255
    4e36:	c8 01       	movw	r24, r16
    4e38:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4e3c:	8e 89       	ldd	r24, Y+22	; 0x16
    4e3e:	90 91 20 05 	lds	r25, 0x0520
    4e42:	98 17       	cp	r25, r24
    4e44:	10 f4       	brcc	.+4      	; 0x4e4a <xTaskGenericNotifyFromISR+0xb4>
    4e46:	80 93 20 05 	sts	0x0520, r24
    4e4a:	90 e0       	ldi	r25, 0x00	; 0
    4e4c:	9c 01       	movw	r18, r24
    4e4e:	22 0f       	add	r18, r18
    4e50:	33 1f       	adc	r19, r19
    4e52:	22 0f       	add	r18, r18
    4e54:	33 1f       	adc	r19, r19
    4e56:	22 0f       	add	r18, r18
    4e58:	33 1f       	adc	r19, r19
    4e5a:	82 0f       	add	r24, r18
    4e5c:	93 1f       	adc	r25, r19
    4e5e:	86 5d       	subi	r24, 0xD6	; 214
    4e60:	9a 4f       	sbci	r25, 0xFA	; 250
    4e62:	b8 01       	movw	r22, r16
    4e64:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
    4e68:	07 c0       	rjmp	.+14     	; 0x4e78 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4e6a:	be 01       	movw	r22, r28
    4e6c:	64 5f       	subi	r22, 0xF4	; 244
    4e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    4e70:	80 e6       	ldi	r24, 0x60	; 96
    4e72:	95 e0       	ldi	r25, 0x05	; 5
    4e74:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e78:	e0 91 17 05 	lds	r30, 0x0517
    4e7c:	f0 91 18 05 	lds	r31, 0x0518
    4e80:	9e 89       	ldd	r25, Y+22	; 0x16
    4e82:	86 89       	ldd	r24, Z+22	; 0x16
    4e84:	89 17       	cp	r24, r25
    4e86:	70 f4       	brcc	.+28     	; 0x4ea4 <xTaskGenericNotifyFromISR+0x10e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4e88:	e1 14       	cp	r14, r1
    4e8a:	f1 04       	cpc	r15, r1
    4e8c:	19 f0       	breq	.+6      	; 0x4e94 <xTaskGenericNotifyFromISR+0xfe>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4e8e:	81 e0       	ldi	r24, 0x01	; 1
    4e90:	f7 01       	movw	r30, r14
    4e92:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4e94:	81 e0       	ldi	r24, 0x01	; 1
    4e96:	80 93 1d 05 	sts	0x051D, r24
    4e9a:	05 c0       	rjmp	.+10     	; 0x4ea6 <xTaskGenericNotifyFromISR+0x110>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4e9c:	80 e0       	ldi	r24, 0x00	; 0
    4e9e:	03 c0       	rjmp	.+6      	; 0x4ea6 <xTaskGenericNotifyFromISR+0x110>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4ea0:	81 e0       	ldi	r24, 0x01	; 1
    4ea2:	01 c0       	rjmp	.+2      	; 0x4ea6 <xTaskGenericNotifyFromISR+0x110>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ea4:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    4ea6:	df 91       	pop	r29
    4ea8:	cf 91       	pop	r28
    4eaa:	1f 91       	pop	r17
    4eac:	0f 91       	pop	r16
    4eae:	ff 90       	pop	r15
    4eb0:	ef 90       	pop	r14
    4eb2:	08 95       	ret

00004eb4 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4eb4:	ef 92       	push	r14
    4eb6:	ff 92       	push	r15
    4eb8:	0f 93       	push	r16
    4eba:	1f 93       	push	r17
    4ebc:	cf 93       	push	r28
    4ebe:	df 93       	push	r29
    4ec0:	ec 01       	movw	r28, r24
    4ec2:	8b 01       	movw	r16, r22

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4ec4:	2d a1       	lds	r18, 0x4d
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4ec6:	82 e0       	ldi	r24, 0x02	; 2
    4ec8:	8d a3       	lds	r24, 0x5d

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4eca:	89 a1       	lds	r24, 0x49
    4ecc:	9a a1       	lds	r25, 0x4a
    4ece:	ab a1       	lds	r26, 0x4b
    4ed0:	bc a1       	lds	r27, 0x4c
    4ed2:	01 96       	adiw	r24, 0x01	; 1
    4ed4:	a1 1d       	adc	r26, r1
    4ed6:	b1 1d       	adc	r27, r1
    4ed8:	89 a3       	lds	r24, 0x59
    4eda:	9a a3       	lds	r25, 0x5a
    4edc:	ab a3       	lds	r26, 0x5b
    4ede:	bc a3       	lds	r27, 0x5c

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4ee0:	21 30       	cpi	r18, 0x01	; 1
    4ee2:	e1 f5       	brne	.+120    	; 0x4f5c <vTaskNotifyGiveFromISR+0xa8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ee4:	80 91 19 05 	lds	r24, 0x0519
    4ee8:	88 23       	and	r24, r24
    4eea:	01 f5       	brne	.+64     	; 0x4f2c <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4eec:	ee 24       	eor	r14, r14
    4eee:	ff 24       	eor	r15, r15
    4ef0:	68 94       	set
    4ef2:	e1 f8       	bld	r14, 1
    4ef4:	ec 0e       	add	r14, r28
    4ef6:	fd 1e       	adc	r15, r29
    4ef8:	c7 01       	movw	r24, r14
    4efa:	0e 94 20 16 	call	0x2c40	; 0x2c40 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4efe:	8e 89       	ldd	r24, Y+22	; 0x16
    4f00:	90 91 20 05 	lds	r25, 0x0520
    4f04:	98 17       	cp	r25, r24
    4f06:	10 f4       	brcc	.+4      	; 0x4f0c <vTaskNotifyGiveFromISR+0x58>
    4f08:	80 93 20 05 	sts	0x0520, r24
    4f0c:	90 e0       	ldi	r25, 0x00	; 0
    4f0e:	9c 01       	movw	r18, r24
    4f10:	22 0f       	add	r18, r18
    4f12:	33 1f       	adc	r19, r19
    4f14:	22 0f       	add	r18, r18
    4f16:	33 1f       	adc	r19, r19
    4f18:	22 0f       	add	r18, r18
    4f1a:	33 1f       	adc	r19, r19
    4f1c:	82 0f       	add	r24, r18
    4f1e:	93 1f       	adc	r25, r19
    4f20:	86 5d       	subi	r24, 0xD6	; 214
    4f22:	9a 4f       	sbci	r25, 0xFA	; 250
    4f24:	b7 01       	movw	r22, r14
    4f26:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
    4f2a:	07 c0       	rjmp	.+14     	; 0x4f3a <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4f2c:	be 01       	movw	r22, r28
    4f2e:	64 5f       	subi	r22, 0xF4	; 244
    4f30:	7f 4f       	sbci	r23, 0xFF	; 255
    4f32:	80 e6       	ldi	r24, 0x60	; 96
    4f34:	95 e0       	ldi	r25, 0x05	; 5
    4f36:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f3a:	e0 91 17 05 	lds	r30, 0x0517
    4f3e:	f0 91 18 05 	lds	r31, 0x0518
    4f42:	9e 89       	ldd	r25, Y+22	; 0x16
    4f44:	86 89       	ldd	r24, Z+22	; 0x16
    4f46:	89 17       	cp	r24, r25
    4f48:	48 f4       	brcc	.+18     	; 0x4f5c <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4f4a:	01 15       	cp	r16, r1
    4f4c:	11 05       	cpc	r17, r1
    4f4e:	19 f0       	breq	.+6      	; 0x4f56 <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4f50:	81 e0       	ldi	r24, 0x01	; 1
    4f52:	f8 01       	movw	r30, r16
    4f54:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4f56:	81 e0       	ldi	r24, 0x01	; 1
    4f58:	80 93 1d 05 	sts	0x051D, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4f5c:	df 91       	pop	r29
    4f5e:	cf 91       	pop	r28
    4f60:	1f 91       	pop	r17
    4f62:	0f 91       	pop	r16
    4f64:	ff 90       	pop	r15
    4f66:	ef 90       	pop	r14
    4f68:	08 95       	ret

00004f6a <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4f6a:	00 97       	sbiw	r24, 0x00	; 0
    4f6c:	29 f4       	brne	.+10     	; 0x4f78 <xTaskNotifyStateClear+0xe>
    4f6e:	e0 91 17 05 	lds	r30, 0x0517
    4f72:	f0 91 18 05 	lds	r31, 0x0518
    4f76:	01 c0       	rjmp	.+2      	; 0x4f7a <xTaskNotifyStateClear+0x10>
    4f78:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    4f7a:	0f b6       	in	r0, 0x3f	; 63
    4f7c:	f8 94       	cli
    4f7e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4f80:	85 a1       	lds	r24, 0x45
    4f82:	82 30       	cpi	r24, 0x02	; 2
    4f84:	19 f4       	brne	.+6      	; 0x4f8c <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4f86:	15 a2       	lds	r17, 0x95
				xReturn = pdPASS;
    4f88:	81 e0       	ldi	r24, 0x01	; 1
    4f8a:	01 c0       	rjmp	.+2      	; 0x4f8e <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    4f8c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    4f8e:	0f 90       	pop	r0
    4f90:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4f92:	08 95       	ret

00004f94 <SOS_Init>:
//static uint8_t u8_is_Started=0;
uint8_t Start_status[Buffer_Size];


ERROR_STATUS SOS_Init (const TMU_ConfigType * ConfigPtr )
{uint8_t u8_channel_ID=ConfigPtr->u8_Timer_channel;
    4f94:	0f 93       	push	r16
    4f96:	1f 93       	push	r17
    4f98:	cf 93       	push	r28
    4f9a:	df 93       	push	r29
    4f9c:	ec 01       	movw	r28, r24
    4f9e:	09 81       	ldd	r16, Y+1	; 0x01
uint8_t ret=E_OK;
/*************************************************************************/
/*			Intializ the required timer identified by the user			 */
/************************************************************************/
u8_Is_Intialized++;
    4fa0:	80 91 76 05 	lds	r24, 0x0576
    4fa4:	8f 5f       	subi	r24, 0xFF	; 255
    4fa6:	80 93 76 05 	sts	0x0576, r24

if(ConfigPtr==NULL){ret=TMU_MODULE+NULL_PTR;}
    4faa:	20 97       	sbiw	r28, 0x00	; 0
    4fac:	11 f0       	breq	.+4      	; 0x4fb2 <SOS_Init+0x1e>
uint8_t Start_status[Buffer_Size];


ERROR_STATUS SOS_Init (const TMU_ConfigType * ConfigPtr )
{uint8_t u8_channel_ID=ConfigPtr->u8_Timer_channel;
uint8_t ret=E_OK;
    4fae:	10 e0       	ldi	r17, 0x00	; 0
    4fb0:	01 c0       	rjmp	.+2      	; 0x4fb4 <SOS_Init+0x20>
/*************************************************************************/
/*			Intializ the required timer identified by the user			 */
/************************************************************************/
u8_Is_Intialized++;

if(ConfigPtr==NULL){ret=TMU_MODULE+NULL_PTR;}
    4fb2:	1a e2       	ldi	r17, 0x2A	; 42
switch(u8_channel_ID)
    4fb4:	00 23       	and	r16, r16
    4fb6:	19 f0       	breq	.+6      	; 0x4fbe <SOS_Init+0x2a>
    4fb8:	02 30       	cpi	r16, 0x02	; 2
    4fba:	79 f4       	brne	.+30     	; 0x4fda <SOS_Init+0x46>
    4fbc:	07 c0       	rjmp	.+14     	; 0x4fcc <SOS_Init+0x38>
{
	case TIMER_CH0:
			G_interrupt_Enable();
    4fbe:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
			Timer_Init(&Timer_Configuration0);
    4fc2:	8a ed       	ldi	r24, 0xDA	; 218
    4fc4:	90 e0       	ldi	r25, 0x00	; 0
    4fc6:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Timer_Init>
				break;
    4fca:	08 c0       	rjmp	.+16     	; 0x4fdc <SOS_Init+0x48>
	case TIMER_CH2:
		G_interrupt_Enable();
    4fcc:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
		Timer_Init(&Timer_Configuration2);
    4fd0:	80 ee       	ldi	r24, 0xE0	; 224
    4fd2:	90 e0       	ldi	r25, 0x00	; 0
    4fd4:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Timer_Init>
			break;
    4fd8:	01 c0       	rjmp	.+2      	; 0x4fdc <SOS_Init+0x48>
	default:
			ret+=E_NOK;
    4fda:	1f 5f       	subi	r17, 0xFF	; 255

/*************************************************************************/
/*Intializ the required timer identified by the user using required prescaler  */
/************************************************************************/

switch(ConfigPtr->u8_resolution)
    4fdc:	88 81       	ld	r24, Y
    4fde:	81 30       	cpi	r24, 0x01	; 1
    4fe0:	99 f4       	brne	.+38     	; 0x5008 <SOS_Init+0x74>
{
	case TIMER_RESOLUTION_1_MS:
	{
		switch(u8_channel_ID)
    4fe2:	00 23       	and	r16, r16
    4fe4:	19 f0       	breq	.+6      	; 0x4fec <SOS_Init+0x58>
    4fe6:	02 30       	cpi	r16, 0x02	; 2
    4fe8:	69 f4       	brne	.+26     	; 0x5004 <SOS_Init+0x70>
    4fea:	06 c0       	rjmp	.+12     	; 0x4ff8 <SOS_Init+0x64>
		{
			case TIMER_CH0 :
		Timer_Start(TIMER_CH0,250);
    4fec:	80 e0       	ldi	r24, 0x00	; 0
    4fee:	6a ef       	ldi	r22, 0xFA	; 250
    4ff0:	70 e0       	ldi	r23, 0x00	; 0
    4ff2:	0e 94 94 10 	call	0x2128	; 0x2128 <Timer_Start>
					//TCNT0=5;
					break;
    4ff6:	09 c0       	rjmp	.+18     	; 0x500a <SOS_Init+0x76>
			case TIMER_CH2 :
				Timer_Start(TIMER_CH2,14);
    4ff8:	82 e0       	ldi	r24, 0x02	; 2
    4ffa:	6e e0       	ldi	r22, 0x0E	; 14
    4ffc:	70 e0       	ldi	r23, 0x00	; 0
    4ffe:	0e 94 94 10 	call	0x2128	; 0x2128 <Timer_Start>
					break;
    5002:	03 c0       	rjmp	.+6      	; 0x500a <SOS_Init+0x76>
			default:
				ret+=E_NOK;
    5004:	1f 5f       	subi	r17, 0xFF	; 255
					break;
    5006:	01 c0       	rjmp	.+2      	; 0x500a <SOS_Init+0x76>
	}	
	
	
	
	default:
	ret+=E_NOK;
    5008:	1f 5f       	subi	r17, 0xFF	; 255

/****************************************************************************/
/*      Deal with Errors  to be returned									*/
/***************************************************************************/
return ret;
}
    500a:	81 2f       	mov	r24, r17
    500c:	df 91       	pop	r29
    500e:	cf 91       	pop	r28
    5010:	1f 91       	pop	r17
    5012:	0f 91       	pop	r16
    5014:	08 95       	ret

00005016 <TMU_DeInit>:
	uint8_t ret=E_OK;
	/************************************************************************************************/
	/*1    	De_intialize the timer																	*/
	/*2		make sure this function is not called unless timer was intialized before by  TMU_INIT	*/
	/************************************************************************************************/
if (u8_Is_Intialized==1)
    5016:	80 91 76 05 	lds	r24, 0x0576
    501a:	81 30       	cpi	r24, 0x01	; 1
    501c:	41 f4       	brne	.+16     	; 0x502e <TMU_DeInit+0x18>
{/*Make the timer without a clk*/
	Timer_Init(&Timer_Deinit_Configuration0);
    501e:	84 ed       	ldi	r24, 0xD4	; 212
    5020:	90 e0       	ldi	r25, 0x00	; 0
    5022:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Timer_Init>

	u8_Is_Intialized=0;
    5026:	10 92 76 05 	sts	0x0576, r1



ERROR_STATUS TMU_DeInit( void )
{
	uint8_t ret=E_OK;
    502a:	80 e0       	ldi	r24, 0x00	; 0
    502c:	08 95       	ret
{/*Make the timer without a clk*/
	Timer_Init(&Timer_Deinit_Configuration0);

	u8_Is_Intialized=0;
	
}else if(u8_Is_Intialized>1){ret+=MULTIPLE_INIT;}
    502e:	82 30       	cpi	r24, 0x02	; 2
    5030:	10 f0       	brcs	.+4      	; 0x5036 <TMU_DeInit+0x20>
    5032:	86 e0       	ldi	r24, 0x06	; 6
    5034:	08 95       	ret
	else{
	ret=E_NOK;
    5036:	81 e0       	ldi	r24, 0x01	; 1
	}

	
return ret;	
}
    5038:	08 95       	ret

0000503a <SOS_Create_Task>:
	/*
	this enables interrupt and start the timer with the required configurations
	and provide the request to request buffer (ptr_to_func,delay) Dispatcher with the call back function needed(consumer)
	and make sure this function must not be excuted unless Init happened and De_init not happened
  	*/
	if(u8_Is_Intialized == 1)
    503a:	50 91 76 05 	lds	r21, 0x0576
    503e:	51 30       	cpi	r21, 0x01	; 1
    5040:	99 f4       	brne	.+38     	; 0x5068 <SOS_Create_Task+0x2e>
	{
		
		
		(Buffer_Array[u8_function_index]).Fuction_consumer=Function_Consumer;
    5042:	e4 2f       	mov	r30, r20
    5044:	f0 e0       	ldi	r31, 0x00	; 0
    5046:	ee 0f       	add	r30, r30
    5048:	ff 1f       	adc	r31, r31
    504a:	ee 0f       	add	r30, r30
    504c:	ff 1f       	adc	r31, r31
    504e:	ee 0f       	add	r30, r30
    5050:	ff 1f       	adc	r31, r31
    5052:	e1 54       	subi	r30, 0x41	; 65
    5054:	fa 4f       	sbci	r31, 0xFA	; 250
    5056:	91 83       	std	Z+1, r25	; 0x01
    5058:	80 83       	st	Z, r24
		(Buffer_Array[u8_function_index]).preodic=u8_Preodicity;
    505a:	65 83       	std	Z+5, r22	; 0x05
		(Buffer_Array[u8_function_index]).u16_time_delay=u16_Time_delay;
    505c:	34 83       	std	Z+4, r19	; 0x04
    505e:	23 83       	std	Z+3, r18	; 0x03
		(Buffer_Array[u8_function_index]).u8_flag_is_stopped=1;
    5060:	81 e0       	ldi	r24, 0x01	; 1
    5062:	82 83       	std	Z+2, r24	; 0x02
	
return ret;	
}

ERROR_STATUS SOS_Create_Task(ptr_to_Fun Function_Consumer,uint8_t  u8_Preodicity,uint8_t u8_function_index,uint16_t u16_Time_delay)
{uint8_t ret=E_OK;
    5064:	80 e0       	ldi	r24, 0x00	; 0
    5066:	08 95       	ret
		(Buffer_Array[u8_function_index]).u16_time_delay=u16_Time_delay;
		(Buffer_Array[u8_function_index]).u8_flag_is_stopped=1;
		
		
	}
	else if(u8_Is_Intialized>1){ret+=MULTIPLE_INIT;}else{
    5068:	52 30       	cpi	r21, 0x02	; 2
    506a:	10 f0       	brcs	.+4      	; 0x5070 <SOS_Create_Task+0x36>
    506c:	86 e0       	ldi	r24, 0x06	; 6
    506e:	08 95       	ret
		ret+=NOT_INIT;
    5070:	84 e0       	ldi	r24, 0x04	; 4
	}

	return ret;
}
    5072:	08 95       	ret

00005074 <SOS_Run>:

ERROR_STATUS SOS_Run(void)
{	uint8_t ret=E_OK;
    5074:	cf 93       	push	r28
    5076:	df 93       	push	r29
	uint16_t u16_Time_needed=0;
	ptr_to_Fun Excuted;
	*//***********************************************************************/
	/*					LOOP upon Buffer Request						*/
	/*********************************************************************/
if (u8Excution_to_be_done==1)
    5078:	80 91 74 05 	lds	r24, 0x0574
    507c:	81 30       	cpi	r24, 0x01	; 1
    507e:	09 f0       	breq	.+2      	; 0x5082 <SOS_Run+0xe>
    5080:	65 c0       	rjmp	.+202    	; 0x514c <SOS_Run+0xd8>
{	u8Excution_to_be_done=0;
    5082:	10 92 74 05 	sts	0x0574, r1

		for (u8_FUN_index=0;u8_FUN_index<Buffer_Size;u8_FUN_index++)
    5086:	10 92 75 05 	sts	0x0575, r1
    508a:	20 e0       	ldi	r18, 0x00	; 0
	status_flag =(Buffer_Array[u8_FUN_index]).u8_flag_is_stopped;
	preodic_status_flag=(Buffer_Array[u8_FUN_index]).preodic;
*/
/****************************************************************/
/* check if the event is stopped ... do nothing*/
		if((Buffer_Array[u8_FUN_index]).u8_flag_is_stopped==0){ret=E_OK;}
    508c:	cf eb       	ldi	r28, 0xBF	; 191
    508e:	d5 e0       	ldi	r29, 0x05	; 5
    5090:	30 e0       	ldi	r19, 0x00	; 0
    5092:	f9 01       	movw	r30, r18
    5094:	ee 0f       	add	r30, r30
    5096:	ff 1f       	adc	r31, r31
    5098:	ee 0f       	add	r30, r30
    509a:	ff 1f       	adc	r31, r31
    509c:	ee 0f       	add	r30, r30
    509e:	ff 1f       	adc	r31, r31
    50a0:	ec 0f       	add	r30, r28
    50a2:	fd 1f       	adc	r31, r29
    50a4:	82 81       	ldd	r24, Z+2	; 0x02
    50a6:	88 23       	and	r24, r24
    50a8:	09 f4       	brne	.+2      	; 0x50ac <SOS_Run+0x38>
    50aa:	48 c0       	rjmp	.+144    	; 0x513c <SOS_Run+0xc8>
	/*if the timer started .. and condition met excute the consumer*/
	/***************************************************************/
		
	/********************************************/
	/*Count up when flag is set**/
	((Buffer_Array[u8_FUN_index]).u16_Counter)++;
    50ac:	f9 01       	movw	r30, r18
    50ae:	ee 0f       	add	r30, r30
    50b0:	ff 1f       	adc	r31, r31
    50b2:	ee 0f       	add	r30, r30
    50b4:	ff 1f       	adc	r31, r31
    50b6:	ee 0f       	add	r30, r30
    50b8:	ff 1f       	adc	r31, r31
    50ba:	ec 0f       	add	r30, r28
    50bc:	fd 1f       	adc	r31, r29
    50be:	86 81       	ldd	r24, Z+6	; 0x06
    50c0:	97 81       	ldd	r25, Z+7	; 0x07
    50c2:	ac 01       	movw	r20, r24
    50c4:	4f 5f       	subi	r20, 0xFF	; 255
    50c6:	5f 4f       	sbci	r21, 0xFF	; 255
    50c8:	57 83       	std	Z+7, r21	; 0x07
    50ca:	46 83       	std	Z+6, r20	; 0x06
	/*make the flag down*/
							
			
/*	u16Excution_to_be_done=100;  ISR*/
	if(((Buffer_Array[u8_FUN_index]).u16_time_delay) == ((Buffer_Array[u8_FUN_index]).u16_Counter) )
    50cc:	83 81       	ldd	r24, Z+3	; 0x03
    50ce:	94 81       	ldd	r25, Z+4	; 0x04
    50d0:	48 17       	cp	r20, r24
    50d2:	59 07       	cpc	r21, r25
    50d4:	d1 f4       	brne	.+52     	; 0x510a <SOS_Run+0x96>
	{
		((Buffer_Array[u8_FUN_index]).Fuction_consumer)();
    50d6:	f9 01       	movw	r30, r18
    50d8:	ee 0f       	add	r30, r30
    50da:	ff 1f       	adc	r31, r31
    50dc:	ee 0f       	add	r30, r30
    50de:	ff 1f       	adc	r31, r31
    50e0:	ee 0f       	add	r30, r30
    50e2:	ff 1f       	adc	r31, r31
    50e4:	ec 0f       	add	r30, r28
    50e6:	fd 1f       	adc	r31, r29
    50e8:	01 90       	ld	r0, Z+
    50ea:	f0 81       	ld	r31, Z
    50ec:	e0 2d       	mov	r30, r0
    50ee:	09 95       	icall
	/******************************************/
	/*Make it zero so that it will work the next time at the required time (to stop it of ovf)*/
		(Buffer_Array[u8_FUN_index]).u16_Counter=0;
    50f0:	e0 91 75 05 	lds	r30, 0x0575
    50f4:	f0 e0       	ldi	r31, 0x00	; 0
    50f6:	ee 0f       	add	r30, r30
    50f8:	ff 1f       	adc	r31, r31
    50fa:	ee 0f       	add	r30, r30
    50fc:	ff 1f       	adc	r31, r31
    50fe:	ee 0f       	add	r30, r30
    5100:	ff 1f       	adc	r31, r31
    5102:	ec 0f       	add	r30, r28
    5104:	fd 1f       	adc	r31, r29
    5106:	17 82       	std	Z+7, r1	; 0x07
    5108:	16 82       	std	Z+6, r1	; 0x06
		
	/*********************************************************/
	/* if not preodic increment the index after excuteing	*/
	/*********************************************************/

	if((Buffer_Array[u8_FUN_index]).preodic==0)
    510a:	80 91 75 05 	lds	r24, 0x0575
    510e:	90 e0       	ldi	r25, 0x00	; 0
    5110:	fc 01       	movw	r30, r24
    5112:	ee 0f       	add	r30, r30
    5114:	ff 1f       	adc	r31, r31
    5116:	ee 0f       	add	r30, r30
    5118:	ff 1f       	adc	r31, r31
    511a:	ee 0f       	add	r30, r30
    511c:	ff 1f       	adc	r31, r31
    511e:	ec 0f       	add	r30, r28
    5120:	fd 1f       	adc	r31, r29
    5122:	25 81       	ldd	r18, Z+5	; 0x05
    5124:	22 23       	and	r18, r18
    5126:	51 f4       	brne	.+20     	; 0x513c <SOS_Run+0xc8>
	{
		/*to make it see the next event in the next time
		Also Status_flag =1 so that this function will be stopped
		*/
		(Buffer_Array[u8_FUN_index]).u8_flag_is_stopped=0;	
    5128:	fc 01       	movw	r30, r24
    512a:	ee 0f       	add	r30, r30
    512c:	ff 1f       	adc	r31, r31
    512e:	ee 0f       	add	r30, r30
    5130:	ff 1f       	adc	r31, r31
    5132:	ee 0f       	add	r30, r30
    5134:	ff 1f       	adc	r31, r31
    5136:	ec 0f       	add	r30, r28
    5138:	fd 1f       	adc	r31, r29
    513a:	12 82       	std	Z+2, r1	; 0x02
	/*					LOOP upon Buffer Request						*/
	/*********************************************************************/
if (u8Excution_to_be_done==1)
{	u8Excution_to_be_done=0;

		for (u8_FUN_index=0;u8_FUN_index<Buffer_Size;u8_FUN_index++)
    513c:	20 91 75 05 	lds	r18, 0x0575
    5140:	2f 5f       	subi	r18, 0xFF	; 255
    5142:	20 93 75 05 	sts	0x0575, r18
    5146:	27 30       	cpi	r18, 0x07	; 7
    5148:	08 f4       	brcc	.+2      	; 0x514c <SOS_Run+0xd8>
    514a:	a2 cf       	rjmp	.-188    	; 0x5090 <SOS_Run+0x1c>

		}		
	}
}	
return ret;
}
    514c:	80 e0       	ldi	r24, 0x00	; 0
    514e:	df 91       	pop	r29
    5150:	cf 91       	pop	r28
    5152:	08 95       	ret

00005154 <TMU_Stop_Timer>:
{

	/***************************************************/
	/*     Set the stop flag							*/
	/***************************************************/
	(Buffer_Array[u8_function_index]).u8_flag_is_stopped=0;
    5154:	e8 2f       	mov	r30, r24
    5156:	f0 e0       	ldi	r31, 0x00	; 0
    5158:	ee 0f       	add	r30, r30
    515a:	ff 1f       	adc	r31, r31
    515c:	ee 0f       	add	r30, r30
    515e:	ff 1f       	adc	r31, r31
    5160:	ee 0f       	add	r30, r30
    5162:	ff 1f       	adc	r31, r31
    5164:	e1 54       	subi	r30, 0x41	; 65
    5166:	fa 4f       	sbci	r31, 0xFA	; 250
    5168:	12 82       	std	Z+2, r1	; 0x02
}
    516a:	08 95       	ret

0000516c <timer_interrupt>:



void timer_interrupt(void)
{
	u8Excution_to_be_done =1;	
    516c:	81 e0       	ldi	r24, 0x01	; 1
    516e:	80 93 74 05 	sts	0x0574, r24
    5172:	08 95       	ret

00005174 <__divsf3>:
    5174:	0c d0       	rcall	.+24     	; 0x518e <__divsf3x>
    5176:	e6 c0       	rjmp	.+460    	; 0x5344 <__fp_round>
    5178:	de d0       	rcall	.+444    	; 0x5336 <__fp_pscB>
    517a:	40 f0       	brcs	.+16     	; 0x518c <__divsf3+0x18>
    517c:	d5 d0       	rcall	.+426    	; 0x5328 <__fp_pscA>
    517e:	30 f0       	brcs	.+12     	; 0x518c <__divsf3+0x18>
    5180:	21 f4       	brne	.+8      	; 0x518a <__divsf3+0x16>
    5182:	5f 3f       	cpi	r21, 0xFF	; 255
    5184:	19 f0       	breq	.+6      	; 0x518c <__divsf3+0x18>
    5186:	c7 c0       	rjmp	.+398    	; 0x5316 <__fp_inf>
    5188:	51 11       	cpse	r21, r1
    518a:	10 c1       	rjmp	.+544    	; 0x53ac <__fp_szero>
    518c:	ca c0       	rjmp	.+404    	; 0x5322 <__fp_nan>

0000518e <__divsf3x>:
    518e:	eb d0       	rcall	.+470    	; 0x5366 <__fp_split3>
    5190:	98 f3       	brcs	.-26     	; 0x5178 <__divsf3+0x4>

00005192 <__divsf3_pse>:
    5192:	99 23       	and	r25, r25
    5194:	c9 f3       	breq	.-14     	; 0x5188 <__divsf3+0x14>
    5196:	55 23       	and	r21, r21
    5198:	b1 f3       	breq	.-20     	; 0x5186 <__divsf3+0x12>
    519a:	95 1b       	sub	r25, r21
    519c:	55 0b       	sbc	r21, r21
    519e:	bb 27       	eor	r27, r27
    51a0:	aa 27       	eor	r26, r26
    51a2:	62 17       	cp	r22, r18
    51a4:	73 07       	cpc	r23, r19
    51a6:	84 07       	cpc	r24, r20
    51a8:	38 f0       	brcs	.+14     	; 0x51b8 <__divsf3_pse+0x26>
    51aa:	9f 5f       	subi	r25, 0xFF	; 255
    51ac:	5f 4f       	sbci	r21, 0xFF	; 255
    51ae:	22 0f       	add	r18, r18
    51b0:	33 1f       	adc	r19, r19
    51b2:	44 1f       	adc	r20, r20
    51b4:	aa 1f       	adc	r26, r26
    51b6:	a9 f3       	breq	.-22     	; 0x51a2 <__divsf3_pse+0x10>
    51b8:	33 d0       	rcall	.+102    	; 0x5220 <__divsf3_pse+0x8e>
    51ba:	0e 2e       	mov	r0, r30
    51bc:	3a f0       	brmi	.+14     	; 0x51cc <__divsf3_pse+0x3a>
    51be:	e0 e8       	ldi	r30, 0x80	; 128
    51c0:	30 d0       	rcall	.+96     	; 0x5222 <__divsf3_pse+0x90>
    51c2:	91 50       	subi	r25, 0x01	; 1
    51c4:	50 40       	sbci	r21, 0x00	; 0
    51c6:	e6 95       	lsr	r30
    51c8:	00 1c       	adc	r0, r0
    51ca:	ca f7       	brpl	.-14     	; 0x51be <__divsf3_pse+0x2c>
    51cc:	29 d0       	rcall	.+82     	; 0x5220 <__divsf3_pse+0x8e>
    51ce:	fe 2f       	mov	r31, r30
    51d0:	27 d0       	rcall	.+78     	; 0x5220 <__divsf3_pse+0x8e>
    51d2:	66 0f       	add	r22, r22
    51d4:	77 1f       	adc	r23, r23
    51d6:	88 1f       	adc	r24, r24
    51d8:	bb 1f       	adc	r27, r27
    51da:	26 17       	cp	r18, r22
    51dc:	37 07       	cpc	r19, r23
    51de:	48 07       	cpc	r20, r24
    51e0:	ab 07       	cpc	r26, r27
    51e2:	b0 e8       	ldi	r27, 0x80	; 128
    51e4:	09 f0       	breq	.+2      	; 0x51e8 <__divsf3_pse+0x56>
    51e6:	bb 0b       	sbc	r27, r27
    51e8:	80 2d       	mov	r24, r0
    51ea:	bf 01       	movw	r22, r30
    51ec:	ff 27       	eor	r31, r31
    51ee:	93 58       	subi	r25, 0x83	; 131
    51f0:	5f 4f       	sbci	r21, 0xFF	; 255
    51f2:	2a f0       	brmi	.+10     	; 0x51fe <__divsf3_pse+0x6c>
    51f4:	9e 3f       	cpi	r25, 0xFE	; 254
    51f6:	51 05       	cpc	r21, r1
    51f8:	68 f0       	brcs	.+26     	; 0x5214 <__divsf3_pse+0x82>
    51fa:	8d c0       	rjmp	.+282    	; 0x5316 <__fp_inf>
    51fc:	d7 c0       	rjmp	.+430    	; 0x53ac <__fp_szero>
    51fe:	5f 3f       	cpi	r21, 0xFF	; 255
    5200:	ec f3       	brlt	.-6      	; 0x51fc <__divsf3_pse+0x6a>
    5202:	98 3e       	cpi	r25, 0xE8	; 232
    5204:	dc f3       	brlt	.-10     	; 0x51fc <__divsf3_pse+0x6a>
    5206:	86 95       	lsr	r24
    5208:	77 95       	ror	r23
    520a:	67 95       	ror	r22
    520c:	b7 95       	ror	r27
    520e:	f7 95       	ror	r31
    5210:	9f 5f       	subi	r25, 0xFF	; 255
    5212:	c9 f7       	brne	.-14     	; 0x5206 <__divsf3_pse+0x74>
    5214:	88 0f       	add	r24, r24
    5216:	91 1d       	adc	r25, r1
    5218:	96 95       	lsr	r25
    521a:	87 95       	ror	r24
    521c:	97 f9       	bld	r25, 7
    521e:	08 95       	ret
    5220:	e1 e0       	ldi	r30, 0x01	; 1
    5222:	66 0f       	add	r22, r22
    5224:	77 1f       	adc	r23, r23
    5226:	88 1f       	adc	r24, r24
    5228:	bb 1f       	adc	r27, r27
    522a:	62 17       	cp	r22, r18
    522c:	73 07       	cpc	r23, r19
    522e:	84 07       	cpc	r24, r20
    5230:	ba 07       	cpc	r27, r26
    5232:	20 f0       	brcs	.+8      	; 0x523c <__divsf3_pse+0xaa>
    5234:	62 1b       	sub	r22, r18
    5236:	73 0b       	sbc	r23, r19
    5238:	84 0b       	sbc	r24, r20
    523a:	ba 0b       	sbc	r27, r26
    523c:	ee 1f       	adc	r30, r30
    523e:	88 f7       	brcc	.-30     	; 0x5222 <__divsf3_pse+0x90>
    5240:	e0 95       	com	r30
    5242:	08 95       	ret

00005244 <__fixunssfsi>:
    5244:	98 d0       	rcall	.+304    	; 0x5376 <__fp_splitA>
    5246:	88 f0       	brcs	.+34     	; 0x526a <__fixunssfsi+0x26>
    5248:	9f 57       	subi	r25, 0x7F	; 127
    524a:	90 f0       	brcs	.+36     	; 0x5270 <__fixunssfsi+0x2c>
    524c:	b9 2f       	mov	r27, r25
    524e:	99 27       	eor	r25, r25
    5250:	b7 51       	subi	r27, 0x17	; 23
    5252:	a0 f0       	brcs	.+40     	; 0x527c <__fixunssfsi+0x38>
    5254:	d1 f0       	breq	.+52     	; 0x528a <__fixunssfsi+0x46>
    5256:	66 0f       	add	r22, r22
    5258:	77 1f       	adc	r23, r23
    525a:	88 1f       	adc	r24, r24
    525c:	99 1f       	adc	r25, r25
    525e:	1a f0       	brmi	.+6      	; 0x5266 <__fixunssfsi+0x22>
    5260:	ba 95       	dec	r27
    5262:	c9 f7       	brne	.-14     	; 0x5256 <__fixunssfsi+0x12>
    5264:	12 c0       	rjmp	.+36     	; 0x528a <__fixunssfsi+0x46>
    5266:	b1 30       	cpi	r27, 0x01	; 1
    5268:	81 f0       	breq	.+32     	; 0x528a <__fixunssfsi+0x46>
    526a:	9f d0       	rcall	.+318    	; 0x53aa <__fp_zero>
    526c:	b1 e0       	ldi	r27, 0x01	; 1
    526e:	08 95       	ret
    5270:	9c c0       	rjmp	.+312    	; 0x53aa <__fp_zero>
    5272:	67 2f       	mov	r22, r23
    5274:	78 2f       	mov	r23, r24
    5276:	88 27       	eor	r24, r24
    5278:	b8 5f       	subi	r27, 0xF8	; 248
    527a:	39 f0       	breq	.+14     	; 0x528a <__fixunssfsi+0x46>
    527c:	b9 3f       	cpi	r27, 0xF9	; 249
    527e:	cc f3       	brlt	.-14     	; 0x5272 <__fixunssfsi+0x2e>
    5280:	86 95       	lsr	r24
    5282:	77 95       	ror	r23
    5284:	67 95       	ror	r22
    5286:	b3 95       	inc	r27
    5288:	d9 f7       	brne	.-10     	; 0x5280 <__fixunssfsi+0x3c>
    528a:	3e f4       	brtc	.+14     	; 0x529a <__fixunssfsi+0x56>
    528c:	90 95       	com	r25
    528e:	80 95       	com	r24
    5290:	70 95       	com	r23
    5292:	61 95       	neg	r22
    5294:	7f 4f       	sbci	r23, 0xFF	; 255
    5296:	8f 4f       	sbci	r24, 0xFF	; 255
    5298:	9f 4f       	sbci	r25, 0xFF	; 255
    529a:	08 95       	ret

0000529c <__floatunsisf>:
    529c:	e8 94       	clt
    529e:	09 c0       	rjmp	.+18     	; 0x52b2 <__floatsisf+0x12>

000052a0 <__floatsisf>:
    52a0:	97 fb       	bst	r25, 7
    52a2:	3e f4       	brtc	.+14     	; 0x52b2 <__floatsisf+0x12>
    52a4:	90 95       	com	r25
    52a6:	80 95       	com	r24
    52a8:	70 95       	com	r23
    52aa:	61 95       	neg	r22
    52ac:	7f 4f       	sbci	r23, 0xFF	; 255
    52ae:	8f 4f       	sbci	r24, 0xFF	; 255
    52b0:	9f 4f       	sbci	r25, 0xFF	; 255
    52b2:	99 23       	and	r25, r25
    52b4:	a9 f0       	breq	.+42     	; 0x52e0 <__floatsisf+0x40>
    52b6:	f9 2f       	mov	r31, r25
    52b8:	96 e9       	ldi	r25, 0x96	; 150
    52ba:	bb 27       	eor	r27, r27
    52bc:	93 95       	inc	r25
    52be:	f6 95       	lsr	r31
    52c0:	87 95       	ror	r24
    52c2:	77 95       	ror	r23
    52c4:	67 95       	ror	r22
    52c6:	b7 95       	ror	r27
    52c8:	f1 11       	cpse	r31, r1
    52ca:	f8 cf       	rjmp	.-16     	; 0x52bc <__floatsisf+0x1c>
    52cc:	fa f4       	brpl	.+62     	; 0x530c <__floatsisf+0x6c>
    52ce:	bb 0f       	add	r27, r27
    52d0:	11 f4       	brne	.+4      	; 0x52d6 <__floatsisf+0x36>
    52d2:	60 ff       	sbrs	r22, 0
    52d4:	1b c0       	rjmp	.+54     	; 0x530c <__floatsisf+0x6c>
    52d6:	6f 5f       	subi	r22, 0xFF	; 255
    52d8:	7f 4f       	sbci	r23, 0xFF	; 255
    52da:	8f 4f       	sbci	r24, 0xFF	; 255
    52dc:	9f 4f       	sbci	r25, 0xFF	; 255
    52de:	16 c0       	rjmp	.+44     	; 0x530c <__floatsisf+0x6c>
    52e0:	88 23       	and	r24, r24
    52e2:	11 f0       	breq	.+4      	; 0x52e8 <__floatsisf+0x48>
    52e4:	96 e9       	ldi	r25, 0x96	; 150
    52e6:	11 c0       	rjmp	.+34     	; 0x530a <__floatsisf+0x6a>
    52e8:	77 23       	and	r23, r23
    52ea:	21 f0       	breq	.+8      	; 0x52f4 <__floatsisf+0x54>
    52ec:	9e e8       	ldi	r25, 0x8E	; 142
    52ee:	87 2f       	mov	r24, r23
    52f0:	76 2f       	mov	r23, r22
    52f2:	05 c0       	rjmp	.+10     	; 0x52fe <__floatsisf+0x5e>
    52f4:	66 23       	and	r22, r22
    52f6:	71 f0       	breq	.+28     	; 0x5314 <__floatsisf+0x74>
    52f8:	96 e8       	ldi	r25, 0x86	; 134
    52fa:	86 2f       	mov	r24, r22
    52fc:	70 e0       	ldi	r23, 0x00	; 0
    52fe:	60 e0       	ldi	r22, 0x00	; 0
    5300:	2a f0       	brmi	.+10     	; 0x530c <__floatsisf+0x6c>
    5302:	9a 95       	dec	r25
    5304:	66 0f       	add	r22, r22
    5306:	77 1f       	adc	r23, r23
    5308:	88 1f       	adc	r24, r24
    530a:	da f7       	brpl	.-10     	; 0x5302 <__floatsisf+0x62>
    530c:	88 0f       	add	r24, r24
    530e:	96 95       	lsr	r25
    5310:	87 95       	ror	r24
    5312:	97 f9       	bld	r25, 7
    5314:	08 95       	ret

00005316 <__fp_inf>:
    5316:	97 f9       	bld	r25, 7
    5318:	9f 67       	ori	r25, 0x7F	; 127
    531a:	80 e8       	ldi	r24, 0x80	; 128
    531c:	70 e0       	ldi	r23, 0x00	; 0
    531e:	60 e0       	ldi	r22, 0x00	; 0
    5320:	08 95       	ret

00005322 <__fp_nan>:
    5322:	9f ef       	ldi	r25, 0xFF	; 255
    5324:	80 ec       	ldi	r24, 0xC0	; 192
    5326:	08 95       	ret

00005328 <__fp_pscA>:
    5328:	00 24       	eor	r0, r0
    532a:	0a 94       	dec	r0
    532c:	16 16       	cp	r1, r22
    532e:	17 06       	cpc	r1, r23
    5330:	18 06       	cpc	r1, r24
    5332:	09 06       	cpc	r0, r25
    5334:	08 95       	ret

00005336 <__fp_pscB>:
    5336:	00 24       	eor	r0, r0
    5338:	0a 94       	dec	r0
    533a:	12 16       	cp	r1, r18
    533c:	13 06       	cpc	r1, r19
    533e:	14 06       	cpc	r1, r20
    5340:	05 06       	cpc	r0, r21
    5342:	08 95       	ret

00005344 <__fp_round>:
    5344:	09 2e       	mov	r0, r25
    5346:	03 94       	inc	r0
    5348:	00 0c       	add	r0, r0
    534a:	11 f4       	brne	.+4      	; 0x5350 <__fp_round+0xc>
    534c:	88 23       	and	r24, r24
    534e:	52 f0       	brmi	.+20     	; 0x5364 <__fp_round+0x20>
    5350:	bb 0f       	add	r27, r27
    5352:	40 f4       	brcc	.+16     	; 0x5364 <__fp_round+0x20>
    5354:	bf 2b       	or	r27, r31
    5356:	11 f4       	brne	.+4      	; 0x535c <__fp_round+0x18>
    5358:	60 ff       	sbrs	r22, 0
    535a:	04 c0       	rjmp	.+8      	; 0x5364 <__fp_round+0x20>
    535c:	6f 5f       	subi	r22, 0xFF	; 255
    535e:	7f 4f       	sbci	r23, 0xFF	; 255
    5360:	8f 4f       	sbci	r24, 0xFF	; 255
    5362:	9f 4f       	sbci	r25, 0xFF	; 255
    5364:	08 95       	ret

00005366 <__fp_split3>:
    5366:	57 fd       	sbrc	r21, 7
    5368:	90 58       	subi	r25, 0x80	; 128
    536a:	44 0f       	add	r20, r20
    536c:	55 1f       	adc	r21, r21
    536e:	59 f0       	breq	.+22     	; 0x5386 <__fp_splitA+0x10>
    5370:	5f 3f       	cpi	r21, 0xFF	; 255
    5372:	71 f0       	breq	.+28     	; 0x5390 <__fp_splitA+0x1a>
    5374:	47 95       	ror	r20

00005376 <__fp_splitA>:
    5376:	88 0f       	add	r24, r24
    5378:	97 fb       	bst	r25, 7
    537a:	99 1f       	adc	r25, r25
    537c:	61 f0       	breq	.+24     	; 0x5396 <__fp_splitA+0x20>
    537e:	9f 3f       	cpi	r25, 0xFF	; 255
    5380:	79 f0       	breq	.+30     	; 0x53a0 <__fp_splitA+0x2a>
    5382:	87 95       	ror	r24
    5384:	08 95       	ret
    5386:	12 16       	cp	r1, r18
    5388:	13 06       	cpc	r1, r19
    538a:	14 06       	cpc	r1, r20
    538c:	55 1f       	adc	r21, r21
    538e:	f2 cf       	rjmp	.-28     	; 0x5374 <__fp_split3+0xe>
    5390:	46 95       	lsr	r20
    5392:	f1 df       	rcall	.-30     	; 0x5376 <__fp_splitA>
    5394:	08 c0       	rjmp	.+16     	; 0x53a6 <__fp_splitA+0x30>
    5396:	16 16       	cp	r1, r22
    5398:	17 06       	cpc	r1, r23
    539a:	18 06       	cpc	r1, r24
    539c:	99 1f       	adc	r25, r25
    539e:	f1 cf       	rjmp	.-30     	; 0x5382 <__fp_splitA+0xc>
    53a0:	86 95       	lsr	r24
    53a2:	71 05       	cpc	r23, r1
    53a4:	61 05       	cpc	r22, r1
    53a6:	08 94       	sec
    53a8:	08 95       	ret

000053aa <__fp_zero>:
    53aa:	e8 94       	clt

000053ac <__fp_szero>:
    53ac:	bb 27       	eor	r27, r27
    53ae:	66 27       	eor	r22, r22
    53b0:	77 27       	eor	r23, r23
    53b2:	cb 01       	movw	r24, r22
    53b4:	97 f9       	bld	r25, 7
    53b6:	08 95       	ret

000053b8 <__mulsf3>:
    53b8:	0b d0       	rcall	.+22     	; 0x53d0 <__mulsf3x>
    53ba:	c4 cf       	rjmp	.-120    	; 0x5344 <__fp_round>
    53bc:	b5 df       	rcall	.-150    	; 0x5328 <__fp_pscA>
    53be:	28 f0       	brcs	.+10     	; 0x53ca <__mulsf3+0x12>
    53c0:	ba df       	rcall	.-140    	; 0x5336 <__fp_pscB>
    53c2:	18 f0       	brcs	.+6      	; 0x53ca <__mulsf3+0x12>
    53c4:	95 23       	and	r25, r21
    53c6:	09 f0       	breq	.+2      	; 0x53ca <__mulsf3+0x12>
    53c8:	a6 cf       	rjmp	.-180    	; 0x5316 <__fp_inf>
    53ca:	ab cf       	rjmp	.-170    	; 0x5322 <__fp_nan>
    53cc:	11 24       	eor	r1, r1
    53ce:	ee cf       	rjmp	.-36     	; 0x53ac <__fp_szero>

000053d0 <__mulsf3x>:
    53d0:	ca df       	rcall	.-108    	; 0x5366 <__fp_split3>
    53d2:	a0 f3       	brcs	.-24     	; 0x53bc <__mulsf3+0x4>

000053d4 <__mulsf3_pse>:
    53d4:	95 9f       	mul	r25, r21
    53d6:	d1 f3       	breq	.-12     	; 0x53cc <__mulsf3+0x14>
    53d8:	95 0f       	add	r25, r21
    53da:	50 e0       	ldi	r21, 0x00	; 0
    53dc:	55 1f       	adc	r21, r21
    53de:	62 9f       	mul	r22, r18
    53e0:	f0 01       	movw	r30, r0
    53e2:	72 9f       	mul	r23, r18
    53e4:	bb 27       	eor	r27, r27
    53e6:	f0 0d       	add	r31, r0
    53e8:	b1 1d       	adc	r27, r1
    53ea:	63 9f       	mul	r22, r19
    53ec:	aa 27       	eor	r26, r26
    53ee:	f0 0d       	add	r31, r0
    53f0:	b1 1d       	adc	r27, r1
    53f2:	aa 1f       	adc	r26, r26
    53f4:	64 9f       	mul	r22, r20
    53f6:	66 27       	eor	r22, r22
    53f8:	b0 0d       	add	r27, r0
    53fa:	a1 1d       	adc	r26, r1
    53fc:	66 1f       	adc	r22, r22
    53fe:	82 9f       	mul	r24, r18
    5400:	22 27       	eor	r18, r18
    5402:	b0 0d       	add	r27, r0
    5404:	a1 1d       	adc	r26, r1
    5406:	62 1f       	adc	r22, r18
    5408:	73 9f       	mul	r23, r19
    540a:	b0 0d       	add	r27, r0
    540c:	a1 1d       	adc	r26, r1
    540e:	62 1f       	adc	r22, r18
    5410:	83 9f       	mul	r24, r19
    5412:	a0 0d       	add	r26, r0
    5414:	61 1d       	adc	r22, r1
    5416:	22 1f       	adc	r18, r18
    5418:	74 9f       	mul	r23, r20
    541a:	33 27       	eor	r19, r19
    541c:	a0 0d       	add	r26, r0
    541e:	61 1d       	adc	r22, r1
    5420:	23 1f       	adc	r18, r19
    5422:	84 9f       	mul	r24, r20
    5424:	60 0d       	add	r22, r0
    5426:	21 1d       	adc	r18, r1
    5428:	82 2f       	mov	r24, r18
    542a:	76 2f       	mov	r23, r22
    542c:	6a 2f       	mov	r22, r26
    542e:	11 24       	eor	r1, r1
    5430:	9f 57       	subi	r25, 0x7F	; 127
    5432:	50 40       	sbci	r21, 0x00	; 0
    5434:	8a f0       	brmi	.+34     	; 0x5458 <__mulsf3_pse+0x84>
    5436:	e1 f0       	breq	.+56     	; 0x5470 <__mulsf3_pse+0x9c>
    5438:	88 23       	and	r24, r24
    543a:	4a f0       	brmi	.+18     	; 0x544e <__mulsf3_pse+0x7a>
    543c:	ee 0f       	add	r30, r30
    543e:	ff 1f       	adc	r31, r31
    5440:	bb 1f       	adc	r27, r27
    5442:	66 1f       	adc	r22, r22
    5444:	77 1f       	adc	r23, r23
    5446:	88 1f       	adc	r24, r24
    5448:	91 50       	subi	r25, 0x01	; 1
    544a:	50 40       	sbci	r21, 0x00	; 0
    544c:	a9 f7       	brne	.-22     	; 0x5438 <__mulsf3_pse+0x64>
    544e:	9e 3f       	cpi	r25, 0xFE	; 254
    5450:	51 05       	cpc	r21, r1
    5452:	70 f0       	brcs	.+28     	; 0x5470 <__mulsf3_pse+0x9c>
    5454:	60 cf       	rjmp	.-320    	; 0x5316 <__fp_inf>
    5456:	aa cf       	rjmp	.-172    	; 0x53ac <__fp_szero>
    5458:	5f 3f       	cpi	r21, 0xFF	; 255
    545a:	ec f3       	brlt	.-6      	; 0x5456 <__mulsf3_pse+0x82>
    545c:	98 3e       	cpi	r25, 0xE8	; 232
    545e:	dc f3       	brlt	.-10     	; 0x5456 <__mulsf3_pse+0x82>
    5460:	86 95       	lsr	r24
    5462:	77 95       	ror	r23
    5464:	67 95       	ror	r22
    5466:	b7 95       	ror	r27
    5468:	f7 95       	ror	r31
    546a:	e7 95       	ror	r30
    546c:	9f 5f       	subi	r25, 0xFF	; 255
    546e:	c1 f7       	brne	.-16     	; 0x5460 <__mulsf3_pse+0x8c>
    5470:	fe 2b       	or	r31, r30
    5472:	88 0f       	add	r24, r24
    5474:	91 1d       	adc	r25, r1
    5476:	96 95       	lsr	r25
    5478:	87 95       	ror	r24
    547a:	97 f9       	bld	r25, 7
    547c:	08 95       	ret

0000547e <__mulsi3>:
    547e:	62 9f       	mul	r22, r18
    5480:	d0 01       	movw	r26, r0
    5482:	73 9f       	mul	r23, r19
    5484:	f0 01       	movw	r30, r0
    5486:	82 9f       	mul	r24, r18
    5488:	e0 0d       	add	r30, r0
    548a:	f1 1d       	adc	r31, r1
    548c:	64 9f       	mul	r22, r20
    548e:	e0 0d       	add	r30, r0
    5490:	f1 1d       	adc	r31, r1
    5492:	92 9f       	mul	r25, r18
    5494:	f0 0d       	add	r31, r0
    5496:	83 9f       	mul	r24, r19
    5498:	f0 0d       	add	r31, r0
    549a:	74 9f       	mul	r23, r20
    549c:	f0 0d       	add	r31, r0
    549e:	65 9f       	mul	r22, r21
    54a0:	f0 0d       	add	r31, r0
    54a2:	99 27       	eor	r25, r25
    54a4:	72 9f       	mul	r23, r18
    54a6:	b0 0d       	add	r27, r0
    54a8:	e1 1d       	adc	r30, r1
    54aa:	f9 1f       	adc	r31, r25
    54ac:	63 9f       	mul	r22, r19
    54ae:	b0 0d       	add	r27, r0
    54b0:	e1 1d       	adc	r30, r1
    54b2:	f9 1f       	adc	r31, r25
    54b4:	bd 01       	movw	r22, r26
    54b6:	cf 01       	movw	r24, r30
    54b8:	11 24       	eor	r1, r1
    54ba:	08 95       	ret

000054bc <__udivmodhi4>:
    54bc:	aa 1b       	sub	r26, r26
    54be:	bb 1b       	sub	r27, r27
    54c0:	51 e1       	ldi	r21, 0x11	; 17
    54c2:	07 c0       	rjmp	.+14     	; 0x54d2 <__udivmodhi4_ep>

000054c4 <__udivmodhi4_loop>:
    54c4:	aa 1f       	adc	r26, r26
    54c6:	bb 1f       	adc	r27, r27
    54c8:	a6 17       	cp	r26, r22
    54ca:	b7 07       	cpc	r27, r23
    54cc:	10 f0       	brcs	.+4      	; 0x54d2 <__udivmodhi4_ep>
    54ce:	a6 1b       	sub	r26, r22
    54d0:	b7 0b       	sbc	r27, r23

000054d2 <__udivmodhi4_ep>:
    54d2:	88 1f       	adc	r24, r24
    54d4:	99 1f       	adc	r25, r25
    54d6:	5a 95       	dec	r21
    54d8:	a9 f7       	brne	.-22     	; 0x54c4 <__udivmodhi4_loop>
    54da:	80 95       	com	r24
    54dc:	90 95       	com	r25
    54de:	bc 01       	movw	r22, r24
    54e0:	cd 01       	movw	r24, r26
    54e2:	08 95       	ret

000054e4 <__udivmodsi4>:
    54e4:	a1 e2       	ldi	r26, 0x21	; 33
    54e6:	1a 2e       	mov	r1, r26
    54e8:	aa 1b       	sub	r26, r26
    54ea:	bb 1b       	sub	r27, r27
    54ec:	fd 01       	movw	r30, r26
    54ee:	0d c0       	rjmp	.+26     	; 0x550a <__udivmodsi4_ep>

000054f0 <__udivmodsi4_loop>:
    54f0:	aa 1f       	adc	r26, r26
    54f2:	bb 1f       	adc	r27, r27
    54f4:	ee 1f       	adc	r30, r30
    54f6:	ff 1f       	adc	r31, r31
    54f8:	a2 17       	cp	r26, r18
    54fa:	b3 07       	cpc	r27, r19
    54fc:	e4 07       	cpc	r30, r20
    54fe:	f5 07       	cpc	r31, r21
    5500:	20 f0       	brcs	.+8      	; 0x550a <__udivmodsi4_ep>
    5502:	a2 1b       	sub	r26, r18
    5504:	b3 0b       	sbc	r27, r19
    5506:	e4 0b       	sbc	r30, r20
    5508:	f5 0b       	sbc	r31, r21

0000550a <__udivmodsi4_ep>:
    550a:	66 1f       	adc	r22, r22
    550c:	77 1f       	adc	r23, r23
    550e:	88 1f       	adc	r24, r24
    5510:	99 1f       	adc	r25, r25
    5512:	1a 94       	dec	r1
    5514:	69 f7       	brne	.-38     	; 0x54f0 <__udivmodsi4_loop>
    5516:	60 95       	com	r22
    5518:	70 95       	com	r23
    551a:	80 95       	com	r24
    551c:	90 95       	com	r25
    551e:	9b 01       	movw	r18, r22
    5520:	ac 01       	movw	r20, r24
    5522:	bd 01       	movw	r22, r26
    5524:	cf 01       	movw	r24, r30
    5526:	08 95       	ret

00005528 <memcpy>:
    5528:	fb 01       	movw	r30, r22
    552a:	dc 01       	movw	r26, r24
    552c:	02 c0       	rjmp	.+4      	; 0x5532 <memcpy+0xa>
    552e:	01 90       	ld	r0, Z+
    5530:	0d 92       	st	X+, r0
    5532:	41 50       	subi	r20, 0x01	; 1
    5534:	50 40       	sbci	r21, 0x00	; 0
    5536:	d8 f7       	brcc	.-10     	; 0x552e <memcpy+0x6>
    5538:	08 95       	ret

0000553a <_exit>:
    553a:	f8 94       	cli

0000553c <__stop_program>:
    553c:	ff cf       	rjmp	.-2      	; 0x553c <__stop_program>
