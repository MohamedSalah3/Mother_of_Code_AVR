
Mother_of_Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000055d4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008e  00800060  000055d4  00005668  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000517  008000ee  008000ee  000056f6  2**0
                  ALLOC
  3 .stab         00001c50  00000000  00000000  000056f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000005e5  00000000  00000000  00007348  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  00007930  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000761e  00000000  00000000  00007d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021fd  00000000  00000000  0000f36e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002f97  00000000  00000000  0001156b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e04  00000000  00000000  00014504  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000029f0  00000000  00000000  00016308  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007e26  00000000  00000000  00018cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  00020b1e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 63 07 	jmp	0xec6	; 0xec6 <__vector_1>
       8:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <__vector_2>
       c:	0c 94 b1 07 	jmp	0xf62	; 0xf62 <__vector_3>
      10:	0c 94 d8 07 	jmp	0xfb0	; 0xfb0 <__vector_4>
      14:	0c 94 ff 07 	jmp	0xffe	; 0xffe <__vector_5>
      18:	0c 94 26 08 	jmp	0x104c	; 0x104c <__vector_6>
      1c:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__vector_7>
      20:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <__vector_8>
      24:	0c 94 9b 08 	jmp	0x1136	; 0x1136 <__vector_9>
      28:	0c 94 c2 08 	jmp	0x1184	; 0x1184 <__vector_10>
      2c:	0c 94 e9 08 	jmp	0x11d2	; 0x11d2 <__vector_11>
      30:	0c 94 10 09 	jmp	0x1220	; 0x1220 <__vector_12>
      34:	0c 94 37 09 	jmp	0x126e	; 0x126e <__vector_13>
      38:	0c 94 5e 09 	jmp	0x12bc	; 0x12bc <__vector_14>
      3c:	0c 94 85 09 	jmp	0x130a	; 0x130a <__vector_15>
      40:	0c 94 ac 09 	jmp	0x1358	; 0x1358 <__vector_16>
      44:	0c 94 d3 09 	jmp	0x13a6	; 0x13a6 <__vector_17>
      48:	0c 94 fa 09 	jmp	0x13f4	; 0x13f4 <__vector_18>
      4c:	0c 94 21 0a 	jmp	0x1442	; 0x1442 <__vector_19>
      50:	0c 94 48 0a 	jmp	0x1490	; 0x1490 <__vector_20>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ed       	ldi	r30, 0xD4	; 212
      68:	f5 e5       	ldi	r31, 0x55	; 85
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 3e       	cpi	r26, 0xEE	; 238
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ae ee       	ldi	r26, 0xEE	; 238
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 30       	cpi	r26, 0x05	; 5
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 15 14 	call	0x282a	; 0x282a <main>
      8a:	0c 94 e8 2a 	jmp	0x55d0	; 0x55d0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Car_SM_Init>:
//extern uint16_t Distance;
static uint16_t Distance;
ERROR_STATUS Car_SM_Init(void)
{
uint8_t ret=E_OK;
Steering_Init();
      92:	0e 94 48 02 	call	0x490	; 0x490 <Steering_Init>
Us_Init();
      96:	0e 94 fd 06 	call	0xdfa	; 0xdfa <Us_Init>
return ret;
}
      9a:	80 e0       	ldi	r24, 0x00	; 0
      9c:	08 95       	ret

0000009e <Car_SM_Update>:


ERROR_STATUS Car_SM_Update(void)
{uint8_t ret=E_OK;
Us_Trigger();
      9e:	0e 94 06 07 	call	0xe0c	; 0xe0c <Us_Trigger>
Us_GetDistance(&Distance);
      a2:	8e ee       	ldi	r24, 0xEE	; 238
      a4:	90 e0       	ldi	r25, 0x00	; 0
      a6:	0e 94 1c 07 	call	0xe38	; 0xe38 <Us_GetDistance>

if(Distance <= 30)
      aa:	80 91 ee 00 	lds	r24, 0x00EE
      ae:	90 91 ef 00 	lds	r25, 0x00EF
      b2:	8f 31       	cpi	r24, 0x1F	; 31
      b4:	91 05       	cpc	r25, r1
      b6:	28 f4       	brcc	.+10     	; 0xc2 <Car_SM_Update+0x24>
{
	
	Steering_SteerCar(CAR_RIGHT,50);
      b8:	83 e0       	ldi	r24, 0x03	; 3
      ba:	62 e3       	ldi	r22, 0x32	; 50
      bc:	0e 94 4c 02 	call	0x498	; 0x498 <Steering_SteerCar>
      c0:	04 c0       	rjmp	.+8      	; 0xca <Car_SM_Update+0x2c>
}else
{
	Steering_SteerCar(CAR_FORWARD,50);
      c2:	81 e0       	ldi	r24, 0x01	; 1
      c4:	62 e3       	ldi	r22, 0x32	; 50
      c6:	0e 94 4c 02 	call	0x498	; 0x498 <Steering_SteerCar>
}

return ret;
}	
      ca:	80 e0       	ldi	r24, 0x00	; 0
      cc:	08 95       	ret

000000ce <init_fun_plastic>:


void init_fun_plastic(void)
{
/*initialization of magnetic sensor*/
DIO_init(&Dio_D_magnetic);
      ce:	89 e6       	ldi	r24, 0x69	; 105
      d0:	90 e0       	ldi	r25, 0x00	; 0
      d2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*initialization of on off switch*/
DIO_init(&Dio_B_On_Off);
      d6:	86 e6       	ldi	r24, 0x66	; 102
      d8:	90 e0       	ldi	r25, 0x00	; 0
      da:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*initialization of the alarm output*/
DIO_init(&Dio_D_ALARM);
      de:	83 e6       	ldi	r24, 0x63	; 99
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*initialization of the motor output*/
DIO_init(&Dio_B_MOTOR);
      e6:	80 e6       	ldi	r24, 0x60	; 96
      e8:	90 e0       	ldi	r25, 0x00	; 0
      ea:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
/*SW1
 EX_interrupt_enable0();
*/


}
      ee:	08 95       	ret

000000f0 <on_switch_int>:
void on_switch_int(void)
{



}
      f0:	08 95       	ret

000000f2 <off_switch_int>:
void off_switch_int(void)
{
/*Motor_stop*/


}
      f2:	08 95       	ret

000000f4 <sw_int>:


void sw_int(void)
{
 
if(READBIT(MCUCSR,6))
      f4:	84 b7       	in	r24, 0x34	; 52
      f6:	82 95       	swap	r24
      f8:	86 95       	lsr	r24
      fa:	86 95       	lsr	r24
      fc:	83 70       	andi	r24, 0x03	; 3
      fe:	80 ff       	sbrs	r24, 0
     100:	09 c0       	rjmp	.+18     	; 0x114 <sw_int+0x20>
{	/**if rising edge*/
	/*Motor_start*/
	DIO_Write(GPIOB,BIT5,HIGH);
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	60 e2       	ldi	r22, 0x20	; 32
     106:	4f ef       	ldi	r20, 0xFF	; 255
     108:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	CLEAR_BIT(MCUCSR,6);
     10c:	84 b7       	in	r24, 0x34	; 52
     10e:	8f 7b       	andi	r24, 0xBF	; 191
     110:	84 bf       	out	0x34, r24	; 52
     112:	08 95       	ret
}
else{
/*if fallen edge*/
DIO_Write(GPIOB,BIT5,HIGH);
     114:	81 e0       	ldi	r24, 0x01	; 1
     116:	60 e2       	ldi	r22, 0x20	; 32
     118:	4f ef       	ldi	r20, 0xFF	; 255
     11a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/*Motor_stop*/
/*********************************/
SET_BIT(MCUCSR,6);		/*Make it Rising*/
     11e:	84 b7       	in	r24, 0x34	; 52
     120:	80 64       	ori	r24, 0x40	; 64
     122:	84 bf       	out	0x34, r24	; 52
     124:	08 95       	ret

00000126 <Display_Task>:
	u8_Init_finished=0;

	
	}
*/
		LCD_goto_xy(0,0);
     126:	80 e0       	ldi	r24, 0x00	; 0
     128:	60 e0       	ldi	r22, 0x00	; 0
     12a:	0e 94 67 03 	call	0x6ce	; 0x6ce <LCD_goto_xy>
		LCD_send_char('x');
     12e:	88 e7       	ldi	r24, 0x78	; 120
     130:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <LCD_send_char>



}
     134:	08 95       	ret

00000136 <Push_Task>:
		u8_Counter1=0;
	}
	

	*/
DIO_Toggle(GPIOD,BIT4);
     136:	83 e0       	ldi	r24, 0x03	; 3
     138:	60 e1       	ldi	r22, 0x10	; 16
     13a:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
}
     13e:	08 95       	ret

00000140 <Push_Task1>:
void Push_Task1(void)
{
u8_flag_push = pushButtonGetStatus(BTN_0);
     140:	80 e0       	ldi	r24, 0x00	; 0
     142:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <pushButtonGetStatus>
     146:	80 93 f1 00 	sts	0x00F1, r24
if (u8_flag_push)
     14a:	88 23       	and	r24, r24
     14c:	19 f0       	breq	.+6      	; 0x154 <Push_Task1+0x14>
{
	u8_State_Machine=BUTTON_PRESSED;
     14e:	87 e0       	ldi	r24, 0x07	; 7
     150:	80 93 f2 00 	sts	0x00F2, r24
     154:	08 95       	ret

00000156 <Push_Task2>:
}
}
void Push_Task2(void){
	DIO_Toggle(GPIOD,BIT2);
     156:	83 e0       	ldi	r24, 0x03	; 3
     158:	64 e0       	ldi	r22, 0x04	; 4
     15a:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
}
     15e:	08 95       	ret

00000160 <Read_Time_Task>:

void Read_Time_Task(void)
{
	static uint8_t st_u16_indix=0;
	adc_read();
     160:	0e 94 3d 0b 	call	0x167a	; 0x167a <adc_read>
//u16_ADC_readings_Channel[st_u16_indix]
if (st_u16_indix <3)
     164:	80 91 f3 00 	lds	r24, 0x00F3
     168:	83 30       	cpi	r24, 0x03	; 3
     16a:	20 f4       	brcc	.+8      	; 0x174 <Read_Time_Task+0x14>
{st_u16_indix++;}
     16c:	8f 5f       	subi	r24, 0xFF	; 255
     16e:	80 93 f3 00 	sts	0x00F3, r24
     172:	02 c0       	rjmp	.+4      	; 0x178 <Read_Time_Task+0x18>
else{st_u16_indix=0;}
     174:	10 92 f3 00 	sts	0x00F3, r1
Timing_arr[st_u16_indix]=(u16_ADC_readings_Channel[st_u16_indix])*3  ;
     178:	80 91 f3 00 	lds	r24, 0x00F3
     17c:	90 e0       	ldi	r25, 0x00	; 0
     17e:	88 0f       	add	r24, r24
     180:	99 1f       	adc	r25, r25
     182:	fc 01       	movw	r30, r24
     184:	e4 59       	subi	r30, 0x94	; 148
     186:	ff 4f       	sbci	r31, 0xFF	; 255
     188:	83 56       	subi	r24, 0x63	; 99
     18a:	9a 4f       	sbci	r25, 0xFA	; 250
     18c:	dc 01       	movw	r26, r24
     18e:	8d 91       	ld	r24, X+
     190:	9c 91       	ld	r25, X
     192:	11 97       	sbiw	r26, 0x01	; 1
     194:	9c 01       	movw	r18, r24
     196:	22 0f       	add	r18, r18
     198:	33 1f       	adc	r19, r19
     19a:	82 0f       	add	r24, r18
     19c:	93 1f       	adc	r25, r19
     19e:	91 83       	std	Z+1, r25	; 0x01
     1a0:	80 83       	st	Z, r24


}
     1a2:	08 95       	ret

000001a4 <relay2>:
}

void relay2(void)
{
	/*************************************************************************************/
	counting_arr[2] += 1;
     1a4:	80 91 f8 00 	lds	r24, 0x00F8
     1a8:	90 91 f9 00 	lds	r25, 0x00F9
     1ac:	01 96       	adiw	r24, 0x01	; 1
     1ae:	90 93 f9 00 	sts	0x00F9, r25
     1b2:	80 93 f8 00 	sts	0x00F8, r24
	/*************************************************************************************/
	/*************************************************************************************/
	if (counting_arr[2]==Timing_arr[2])
     1b6:	20 91 70 00 	lds	r18, 0x0070
     1ba:	30 91 71 00 	lds	r19, 0x0071
     1be:	82 17       	cp	r24, r18
     1c0:	93 07       	cpc	r25, r19
     1c2:	51 f4       	brne	.+20     	; 0x1d8 <relay2+0x34>
	{DIO_Toggle(GPIOD,BIT4);
     1c4:	83 e0       	ldi	r24, 0x03	; 3
     1c6:	60 e1       	ldi	r22, 0x10	; 16
     1c8:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
		counting_arr[2]=0;
     1cc:	10 92 f9 00 	sts	0x00F9, r1
     1d0:	10 92 f8 00 	sts	0x00F8, r1
		relay0();
     1d4:	0e 94 08 01 	call	0x210	; 0x210 <relay0>
     1d8:	08 95       	ret

000001da <relay1>:
}

void relay1(void)
{
	/*************************************************************************************/
	counting_arr[1] += 1;
     1da:	80 91 f6 00 	lds	r24, 0x00F6
     1de:	90 91 f7 00 	lds	r25, 0x00F7
     1e2:	01 96       	adiw	r24, 0x01	; 1
     1e4:	90 93 f7 00 	sts	0x00F7, r25
     1e8:	80 93 f6 00 	sts	0x00F6, r24
	/*************************************************************************************/
	/*************************************************************************************/
	if (counting_arr[1]==Timing_arr[1])
     1ec:	20 91 6e 00 	lds	r18, 0x006E
     1f0:	30 91 6f 00 	lds	r19, 0x006F
     1f4:	82 17       	cp	r24, r18
     1f6:	93 07       	cpc	r25, r19
     1f8:	51 f4       	brne	.+20     	; 0x20e <relay1+0x34>
	{DIO_Toggle(GPIOD,BIT2);
     1fa:	83 e0       	ldi	r24, 0x03	; 3
     1fc:	64 e0       	ldi	r22, 0x04	; 4
     1fe:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
		counting_arr[1]=0;
     202:	10 92 f7 00 	sts	0x00F7, r1
     206:	10 92 f6 00 	sts	0x00F6, r1
		relay2();
     20a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <relay2>
     20e:	08 95       	ret

00000210 <relay0>:
}

void relay0(void)
{
/*************************************************************************************/
counting_arr[0] += 1;
     210:	80 91 f4 00 	lds	r24, 0x00F4
     214:	90 91 f5 00 	lds	r25, 0x00F5
     218:	01 96       	adiw	r24, 0x01	; 1
     21a:	90 93 f5 00 	sts	0x00F5, r25
     21e:	80 93 f4 00 	sts	0x00F4, r24
/*************************************************************************************/
/*************************************************************************************/
if (counting_arr[0]==Timing_arr[0])
     222:	20 91 6c 00 	lds	r18, 0x006C
     226:	30 91 6d 00 	lds	r19, 0x006D
     22a:	82 17       	cp	r24, r18
     22c:	93 07       	cpc	r25, r19
     22e:	51 f4       	brne	.+20     	; 0x244 <relay0+0x34>
{
	DIO_Toggle(GPIOD,BIT2);
     230:	83 e0       	ldi	r24, 0x03	; 3
     232:	64 e0       	ldi	r22, 0x04	; 4
     234:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
	counting_arr[0]=0;
     238:	10 92 f5 00 	sts	0x00F5, r1
     23c:	10 92 f4 00 	sts	0x00F4, r1
	relay1();
     240:	0e 94 ed 00 	call	0x1da	; 0x1da <relay1>
     244:	08 95       	ret

00000246 <update_timing>:
SOS_Create_Task(Push_Task1,1,4,20);
SOS_Create_Task(Push_Task2,1,5,30);
*/

/*************************************************************************************/
if (u8_State_Machine == BUTTON_PRESSED || u8_State_Machine == RELAY0_COUNTING)
     246:	80 91 f2 00 	lds	r24, 0x00F2
     24a:	87 30       	cpi	r24, 0x07	; 7
     24c:	11 f0       	breq	.+4      	; 0x252 <update_timing+0xc>
     24e:	81 30       	cpi	r24, 0x01	; 1
     250:	91 f4       	brne	.+36     	; 0x276 <update_timing+0x30>
{
	DIO_Write(GPIOD,BIT2,HIGH);
     252:	83 e0       	ldi	r24, 0x03	; 3
     254:	64 e0       	ldi	r22, 0x04	; 4
     256:	4f ef       	ldi	r20, 0xFF	; 255
     258:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	counting_arr[0] += 1;
     25c:	80 91 f4 00 	lds	r24, 0x00F4
     260:	90 91 f5 00 	lds	r25, 0x00F5
     264:	01 96       	adiw	r24, 0x01	; 1
     266:	90 93 f5 00 	sts	0x00F5, r25
     26a:	80 93 f4 00 	sts	0x00F4, r24
	
	u8_State_Machine=RELAY0_COUNTING;
     26e:	81 e0       	ldi	r24, 0x01	; 1
     270:	80 93 f2 00 	sts	0x00F2, r24
     274:	22 c0       	rjmp	.+68     	; 0x2ba <update_timing+0x74>
}
	    
/*************************************************************************************/
   if (u8_State_Machine==RELAY0_ACTION_DONE)// || u8_State_Machine == RELAY1_COUNTING)
     276:	84 30       	cpi	r24, 0x04	; 4
     278:	71 f4       	brne	.+28     	; 0x296 <update_timing+0x50>
   {
	DIO_Write(GPIOD,BIT3,HIGH);   
     27a:	83 e0       	ldi	r24, 0x03	; 3
     27c:	68 e0       	ldi	r22, 0x08	; 8
     27e:	4f ef       	ldi	r20, 0xFF	; 255
     280:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	    counting_arr[1] += 1;
     284:	80 91 f6 00 	lds	r24, 0x00F6
     288:	90 91 f7 00 	lds	r25, 0x00F7
     28c:	01 96       	adiw	r24, 0x01	; 1
     28e:	90 93 f7 00 	sts	0x00F7, r25
     292:	80 93 f6 00 	sts	0x00F6, r24
	//	u8_State_Machine=RELAY1_COUNTING;
   }
   
/*************************************************************************************/
if (u8_State_Machine == RELAY1_ACTION_DONE )//|| u8_State_Machine == RELAY2_COUNTING)
     296:	80 91 f2 00 	lds	r24, 0x00F2
     29a:	85 30       	cpi	r24, 0x05	; 5
     29c:	71 f4       	brne	.+28     	; 0x2ba <update_timing+0x74>
{
	DIO_Write(GPIOD,BIT4,HIGH);
     29e:	83 e0       	ldi	r24, 0x03	; 3
     2a0:	60 e1       	ldi	r22, 0x10	; 16
     2a2:	4f ef       	ldi	r20, 0xFF	; 255
     2a4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     counting_arr[2] += 1;
     2a8:	80 91 f8 00 	lds	r24, 0x00F8
     2ac:	90 91 f9 00 	lds	r25, 0x00F9
     2b0:	01 96       	adiw	r24, 0x01	; 1
     2b2:	90 93 f9 00 	sts	0x00F9, r25
     2b6:	80 93 f8 00 	sts	0x00F8, r24
//	 u8_State_Machine=RELAY2_COUNTING;
}

	
/*************************************************************************************/
if (counting_arr[0]==Timing_arr[0])
     2ba:	20 91 f4 00 	lds	r18, 0x00F4
     2be:	30 91 f5 00 	lds	r19, 0x00F5
     2c2:	80 91 6c 00 	lds	r24, 0x006C
     2c6:	90 91 6d 00 	lds	r25, 0x006D
     2ca:	28 17       	cp	r18, r24
     2cc:	39 07       	cpc	r19, r25
     2ce:	c9 f5       	brne	.+114    	; 0x342 <update_timing+0xfc>
{
	DIO_Write(GPIOD,BIT2,LOW);
     2d0:	83 e0       	ldi	r24, 0x03	; 3
     2d2:	64 e0       	ldi	r22, 0x04	; 4
     2d4:	40 e0       	ldi	r20, 0x00	; 0
     2d6:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	UartTransmitPooling('A');
     2da:	81 e4       	ldi	r24, 0x41	; 65
     2dc:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     2e0:	84 e4       	ldi	r24, 0x44	; 68
     2e2:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     2e6:	83 e4       	ldi	r24, 0x43	; 67
     2e8:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('0');
     2ec:	80 e3       	ldi	r24, 0x30	; 48
     2ee:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     2f2:	8d e3       	ldi	r24, 0x3D	; 61
     2f4:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(Timing_arr[0]);
     2f8:	80 91 6c 00 	lds	r24, 0x006C
     2fc:	90 91 6d 00 	lds	r25, 0x006D
     300:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('A');
     304:	81 e4       	ldi	r24, 0x41	; 65
     306:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     30a:	84 e4       	ldi	r24, 0x44	; 68
     30c:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     310:	83 e4       	ldi	r24, 0x43	; 67
     312:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('0');
     316:	80 e3       	ldi	r24, 0x30	; 48
     318:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     31c:	8d e3       	ldi	r24, 0x3D	; 61
     31e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[0]);
     322:	80 91 f4 00 	lds	r24, 0x00F4
     326:	90 91 f5 00 	lds	r25, 0x00F5
     32a:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('\n');
     32e:	8a e0       	ldi	r24, 0x0A	; 10
     330:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
counting_arr[0]=0;
     334:	10 92 f5 00 	sts	0x00F5, r1
     338:	10 92 f4 00 	sts	0x00F4, r1
u8_State_Machine=RELAY0_ACTION_DONE;
     33c:	84 e0       	ldi	r24, 0x04	; 4
     33e:	80 93 f2 00 	sts	0x00F2, r24
}
/**************************************************************************************/
if (counting_arr[1]==Timing_arr[1] && u8_State_Machine==RELAY0_ACTION_DONE)
     342:	20 91 f6 00 	lds	r18, 0x00F6
     346:	30 91 f7 00 	lds	r19, 0x00F7
     34a:	80 91 6e 00 	lds	r24, 0x006E
     34e:	90 91 6f 00 	lds	r25, 0x006F
     352:	28 17       	cp	r18, r24
     354:	39 07       	cpc	r19, r25
     356:	09 f0       	breq	.+2      	; 0x35a <update_timing+0x114>
     358:	45 c0       	rjmp	.+138    	; 0x3e4 <update_timing+0x19e>
     35a:	80 91 f2 00 	lds	r24, 0x00F2
     35e:	84 30       	cpi	r24, 0x04	; 4
     360:	09 f0       	breq	.+2      	; 0x364 <update_timing+0x11e>
     362:	40 c0       	rjmp	.+128    	; 0x3e4 <update_timing+0x19e>
{
	DIO_Write(GPIOD,BIT2,LOW);
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	64 e0       	ldi	r22, 0x04	; 4
     368:	40 e0       	ldi	r20, 0x00	; 0
     36a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
DIO_Toggle(GPIOD,BIT3);
     36e:	83 e0       	ldi	r24, 0x03	; 3
     370:	68 e0       	ldi	r22, 0x08	; 8
     372:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
UartTransmitPooling(' ');
     376:	80 e2       	ldi	r24, 0x20	; 32
     378:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('A');
     37c:	81 e4       	ldi	r24, 0x41	; 65
     37e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     382:	84 e4       	ldi	r24, 0x44	; 68
     384:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     388:	83 e4       	ldi	r24, 0x43	; 67
     38a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('1');
     38e:	81 e3       	ldi	r24, 0x31	; 49
     390:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     394:	8d e3       	ldi	r24, 0x3D	; 61
     396:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(Timing_arr[1]);
     39a:	80 91 6e 00 	lds	r24, 0x006E
     39e:	90 91 6f 00 	lds	r25, 0x006F
     3a2:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('A');
     3a6:	81 e4       	ldi	r24, 0x41	; 65
     3a8:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     3ac:	84 e4       	ldi	r24, 0x44	; 68
     3ae:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     3b2:	83 e4       	ldi	r24, 0x43	; 67
     3b4:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('1');
     3b8:	81 e3       	ldi	r24, 0x31	; 49
     3ba:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     3be:	8d e3       	ldi	r24, 0x3D	; 61
     3c0:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[1]);
     3c4:	80 91 f6 00 	lds	r24, 0x00F6
     3c8:	90 91 f7 00 	lds	r25, 0x00F7
     3cc:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('\n');
     3d0:	8a e0       	ldi	r24, 0x0A	; 10
     3d2:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
counting_arr[1]=0;
     3d6:	10 92 f7 00 	sts	0x00F7, r1
     3da:	10 92 f6 00 	sts	0x00F6, r1
u8_State_Machine=RELAY1_ACTION_DONE;
     3de:	85 e0       	ldi	r24, 0x05	; 5
     3e0:	80 93 f2 00 	sts	0x00F2, r24
}
/**************************************************************************************/
if (counting_arr[2]==Timing_arr[2]&& u8_State_Machine==RELAY1_ACTION_DONE)
     3e4:	20 91 f8 00 	lds	r18, 0x00F8
     3e8:	30 91 f9 00 	lds	r19, 0x00F9
     3ec:	80 91 70 00 	lds	r24, 0x0070
     3f0:	90 91 71 00 	lds	r25, 0x0071
     3f4:	28 17       	cp	r18, r24
     3f6:	39 07       	cpc	r19, r25
     3f8:	09 f0       	breq	.+2      	; 0x3fc <update_timing+0x1b6>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <update_timing+0x23a>
     3fc:	80 91 f2 00 	lds	r24, 0x00F2
     400:	85 30       	cpi	r24, 0x05	; 5
     402:	f1 f5       	brne	.+124    	; 0x480 <update_timing+0x23a>
{
	DIO_Write(GPIOD,BIT3,LOW);
     404:	83 e0       	ldi	r24, 0x03	; 3
     406:	68 e0       	ldi	r22, 0x08	; 8
     408:	40 e0       	ldi	r20, 0x00	; 0
     40a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
DIO_Toggle(GPIOD,BIT4);
     40e:	83 e0       	ldi	r24, 0x03	; 3
     410:	60 e1       	ldi	r22, 0x10	; 16
     412:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>

	UartTransmitPooling(' ');
     416:	80 e2       	ldi	r24, 0x20	; 32
     418:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('A');
     41c:	81 e4       	ldi	r24, 0x41	; 65
     41e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     422:	84 e4       	ldi	r24, 0x44	; 68
     424:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     428:	83 e4       	ldi	r24, 0x43	; 67
     42a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('2');
     42e:	82 e3       	ldi	r24, 0x32	; 50
     430:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     434:	8d e3       	ldi	r24, 0x3D	; 61
     436:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(Timing_arr[2]);
     43a:	80 91 70 00 	lds	r24, 0x0070
     43e:	90 91 71 00 	lds	r25, 0x0071
     442:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('A');
     446:	81 e4       	ldi	r24, 0x41	; 65
     448:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('D');
     44c:	84 e4       	ldi	r24, 0x44	; 68
     44e:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('C');
     452:	83 e4       	ldi	r24, 0x43	; 67
     454:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('2');
     458:	82 e3       	ldi	r24, 0x32	; 50
     45a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	UartTransmitPooling('=');
     45e:	8d e3       	ldi	r24, 0x3D	; 61
     460:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(counting_arr[2]);
     464:	80 91 f8 00 	lds	r24, 0x00F8
     468:	90 91 f9 00 	lds	r25, 0x00F9
     46c:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('\n');
     470:	8a e0       	ldi	r24, 0x0A	; 10
     472:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	counting_arr[2]=0;
     476:	10 92 f9 00 	sts	0x00F9, r1
     47a:	10 92 f8 00 	sts	0x00F8, r1
     47e:	04 c0       	rjmp	.+8      	; 0x488 <update_timing+0x242>
u8_State_Machine=RELAY2_ACTION_DONE;
}
if (u8_State_Machine == RELAY2_ACTION_DONE)
     480:	80 91 f2 00 	lds	r24, 0x00F2
     484:	86 30       	cpi	r24, 0x06	; 6
     486:	11 f4       	brne	.+4      	; 0x48c <update_timing+0x246>
{
	u8_State_Machine=NO_ACTION;
     488:	10 92 f2 00 	sts	0x00F2, r1
     48c:	08 95       	ret

0000048e <uart_send_sos>:
{
	
	
	
	
}
     48e:	08 95       	ret

00000490 <Steering_Init>:


ERROR_STATUS Steering_Init(void)
{
	uint8_t ret=0;
	ret=Motor_Init(MOTOR_1|MOTOR_2);
     490:	83 e0       	ldi	r24, 0x03	; 3
     492:	0e 94 94 05 	call	0xb28	; 0xb28 <Motor_Init>
	return ret;
}
     496:	08 95       	ret

00000498 <Steering_SteerCar>:


ERROR_STATUS Steering_SteerCar(uint8_t Steering_CarCmd, uint8_t speed)
{
     498:	cf 93       	push	r28
     49a:	c6 2f       	mov	r28, r22
	uint8_t ret=0;
		switch(Steering_CarCmd)
     49c:	82 30       	cpi	r24, 0x02	; 2
     49e:	a1 f0       	breq	.+40     	; 0x4c8 <Steering_SteerCar+0x30>
     4a0:	83 30       	cpi	r24, 0x03	; 3
     4a2:	20 f4       	brcc	.+8      	; 0x4ac <Steering_SteerCar+0x14>
     4a4:	81 30       	cpi	r24, 0x01	; 1
     4a6:	09 f0       	breq	.+2      	; 0x4aa <Steering_SteerCar+0x12>
     4a8:	42 c0       	rjmp	.+132    	; 0x52e <Steering_SteerCar+0x96>
     4aa:	05 c0       	rjmp	.+10     	; 0x4b6 <Steering_SteerCar+0x1e>
     4ac:	83 30       	cpi	r24, 0x03	; 3
     4ae:	51 f1       	breq	.+84     	; 0x504 <Steering_SteerCar+0x6c>
     4b0:	84 30       	cpi	r24, 0x04	; 4
     4b2:	e9 f5       	brne	.+122    	; 0x52e <Steering_SteerCar+0x96>
     4b4:	12 c0       	rjmp	.+36     	; 0x4da <Steering_SteerCar+0x42>
	{
		case CAR_FORWARD:
			ret= Motor_Direction(MOTOR_1|MOTOR_2, CAR_FORWARD);
     4b6:	83 e0       	ldi	r24, 0x03	; 3
     4b8:	61 e0       	ldi	r22, 0x01	; 1
     4ba:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     4be:	83 e0       	ldi	r24, 0x03	; 3
     4c0:	6c 2f       	mov	r22, r28
     4c2:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>
			break;
     4c6:	34 c0       	rjmp	.+104    	; 0x530 <Steering_SteerCar+0x98>
			case CAR_BACKWARD:
			ret= Motor_Direction(MOTOR_1|MOTOR_2,CAR_BACKWARD);
     4c8:	83 e0       	ldi	r24, 0x03	; 3
     4ca:	62 e0       	ldi	r22, 0x02	; 2
     4cc:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     4d0:	83 e0       	ldi	r24, 0x03	; 3
     4d2:	6c 2f       	mov	r22, r28
     4d4:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>
			break;
     4d8:	2b c0       	rjmp	.+86     	; 0x530 <Steering_SteerCar+0x98>
			case CAR_LEFT:
			ret= Motor_Direction(MOTOR_1, CAR_FORWARD);
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	61 e0       	ldi	r22, 0x01	; 1
     4de:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_BACKWARD);
     4e2:	82 e0       	ldi	r24, 0x02	; 2
     4e4:	62 e0       	ldi	r22, 0x02	; 2
     4e6:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     4ea:	83 e0       	ldi	r24, 0x03	; 3
     4ec:	6c 2f       	mov	r22, r28
     4ee:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>

/*************************************************************/
			ret= Motor_Direction(MOTOR_1, CAR_STOP);
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	60 e0       	ldi	r22, 0x00	; 0
     4f6:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_STOP);
     4fa:	82 e0       	ldi	r24, 0x02	; 2
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			break;
     502:	16 c0       	rjmp	.+44     	; 0x530 <Steering_SteerCar+0x98>
			case CAR_RIGHT:
			ret= Motor_Direction(MOTOR_1, CAR_BACKWARD);
     504:	81 e0       	ldi	r24, 0x01	; 1
     506:	62 e0       	ldi	r22, 0x02	; 2
     508:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_FORWARD);
     50c:	82 e0       	ldi	r24, 0x02	; 2
     50e:	61 e0       	ldi	r22, 0x01	; 1
     510:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret=Motor_Start(MOTOR_1|MOTOR_2,speed);
     514:	83 e0       	ldi	r24, 0x03	; 3
     516:	6c 2f       	mov	r22, r28
     518:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <Motor_Start>
		/*	timer2Start();
			timer2DelayMs(100);
*//***********************************************************/
			ret= Motor_Direction(MOTOR_1, CAR_STOP);
     51c:	81 e0       	ldi	r24, 0x01	; 1
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			ret= Motor_Direction(MOTOR_2, CAR_STOP);
     524:	82 e0       	ldi	r24, 0x02	; 2
     526:	60 e0       	ldi	r22, 0x00	; 0
     528:	0e 94 c3 05 	call	0xb86	; 0xb86 <Motor_Direction>
			break;
     52c:	01 c0       	rjmp	.+2      	; 0x530 <Steering_SteerCar+0x98>
}


ERROR_STATUS Steering_SteerCar(uint8_t Steering_CarCmd, uint8_t speed)
{
	uint8_t ret=0;
     52e:	80 e0       	ldi	r24, 0x00	; 0
			break;
	}
	
	
return ret;
     530:	cf 91       	pop	r28
     532:	08 95       	ret

00000534 <LCD_EN_pulse>:
 #include <stdlib.h>
extern uint8_t u8_Init_finished;
 static uint8_t U8_index=0;
 void LCD_EN_pulse(void)
 {
	 DIO_Write(LCD_EN_PORT, LCD_EN_PIN, HIGH);
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	68 e0       	ldi	r22, 0x08	; 8
     538:	4f ef       	ldi	r20, 0xFF	; 255
     53a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/***********************************************************/
	 SwDelay_us(10);
     53e:	6a e0       	ldi	r22, 0x0A	; 10
     540:	70 e0       	ldi	r23, 0x00	; 0
     542:	80 e0       	ldi	r24, 0x00	; 0
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	0e 94 f2 06 	call	0xde4	; 0xde4 <SwDelay_us>
	 DIO_Write(LCD_EN_PORT, LCD_EN_PIN, LOW);
     54a:	81 e0       	ldi	r24, 0x01	; 1
     54c:	68 e0       	ldi	r22, 0x08	; 8
     54e:	40 e0       	ldi	r20, 0x00	; 0
     550:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/*************************************************************/	 
	 SwDelay_us(10);
     554:	6a e0       	ldi	r22, 0x0A	; 10
     556:	70 e0       	ldi	r23, 0x00	; 0
     558:	80 e0       	ldi	r24, 0x00	; 0
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 f2 06 	call	0xde4	; 0xde4 <SwDelay_us>
 }
     560:	08 95       	ret

00000562 <LCD_config_pins>:

 void LCD_config_pins(void){

	 /* set LCD pins as outputs */
	DIO_init(&Dio_configurationB);
     562:	84 ec       	ldi	r24, 0xC4	; 196
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
}
     56a:	08 95       	ret

0000056c <LCD_send_nibble>:

 void LCD_send_nibble(uint8_t data){
     56c:	cf 93       	push	r28
	 uint8_t mask = 1;
	 data >>= 4;
     56e:	c8 2f       	mov	r28, r24
     570:	c2 95       	swap	r28
     572:	cf 70       	andi	r28, 0x0F	; 15
	 if(data & mask)
     574:	c0 ff       	sbrs	r28, 0
     576:	06 c0       	rjmp	.+12     	; 0x584 <LCD_send_nibble+0x18>
	 DIO_Write(LCD_D4_PORT, LCD_D4_PIN, HIGH);
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	60 e1       	ldi	r22, 0x10	; 16
     57c:	4f ef       	ldi	r20, 0xFF	; 255
     57e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     582:	05 c0       	rjmp	.+10     	; 0x58e <LCD_send_nibble+0x22>
	 else
	 DIO_Write(LCD_D4_PORT, LCD_D4_PIN, LOW);
     584:	81 e0       	ldi	r24, 0x01	; 1
     586:	60 e1       	ldi	r22, 0x10	; 16
     588:	40 e0       	ldi	r20, 0x00	; 0
     58a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     58e:	c1 ff       	sbrs	r28, 1
     590:	06 c0       	rjmp	.+12     	; 0x59e <LCD_send_nibble+0x32>
	 DIO_Write(LCD_D5_PORT, LCD_D5_PIN, HIGH);
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	60 e2       	ldi	r22, 0x20	; 32
     596:	4f ef       	ldi	r20, 0xFF	; 255
     598:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     59c:	05 c0       	rjmp	.+10     	; 0x5a8 <LCD_send_nibble+0x3c>
	 else
	 DIO_Write(LCD_D5_PORT, LCD_D5_PIN, LOW);
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	60 e2       	ldi	r22, 0x20	; 32
     5a2:	40 e0       	ldi	r20, 0x00	; 0
     5a4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     5a8:	c2 ff       	sbrs	r28, 2
     5aa:	06 c0       	rjmp	.+12     	; 0x5b8 <LCD_send_nibble+0x4c>
	 DIO_Write(LCD_D6_PORT, LCD_D6_PIN, HIGH);
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	60 e4       	ldi	r22, 0x40	; 64
     5b0:	4f ef       	ldi	r20, 0xFF	; 255
     5b2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     5b6:	05 c0       	rjmp	.+10     	; 0x5c2 <LCD_send_nibble+0x56>
	 else
	 DIO_Write(LCD_D6_PORT, LCD_D6_PIN, LOW);
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	60 e4       	ldi	r22, 0x40	; 64
     5bc:	40 e0       	ldi	r20, 0x00	; 0
     5be:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 mask *= 2;
	 if(data & mask)
     5c2:	c8 70       	andi	r28, 0x08	; 8
     5c4:	31 f0       	breq	.+12     	; 0x5d2 <LCD_send_nibble+0x66>
	 DIO_Write(LCD_D7_PORT, LCD_D7_PIN, HIGH);
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	60 e8       	ldi	r22, 0x80	; 128
     5ca:	4f ef       	ldi	r20, 0xFF	; 255
     5cc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
     5d0:	05 c0       	rjmp	.+10     	; 0x5dc <LCD_send_nibble+0x70>
	 else
	 DIO_Write(LCD_D7_PORT, LCD_D7_PIN, LOW);
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	60 e8       	ldi	r22, 0x80	; 128
     5d6:	40 e0       	ldi	r20, 0x00	; 0
     5d8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
 }
     5dc:	cf 91       	pop	r28
     5de:	08 95       	ret

000005e0 <LCD_send_char>:
/***************************************************************************/
 void LCD_send_char(char data)		//Sends Char to LCD
 {
     5e0:	cf 93       	push	r28
     5e2:	c8 2f       	mov	r28, r24
	 DIO_Write(LCD_RS_PORT, LCD_RS_PIN, HIGH);
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	62 e0       	ldi	r22, 0x02	; 2
     5e8:	4f ef       	ldi	r20, 0xFF	; 255
     5ea:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	 LCD_send_nibble(data); // Higher nibble first
     5ee:	8c 2f       	mov	r24, r28
     5f0:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     5f4:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>

	 LCD_send_nibble(data<<4);
     5f8:	8c 2f       	mov	r24, r28
     5fa:	82 95       	swap	r24
     5fc:	80 7f       	andi	r24, 0xF0	; 240
     5fe:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     602:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>
 }
     606:	cf 91       	pop	r28
     608:	08 95       	ret

0000060a <LCD_send_command>:
 /**************************************************************************/
 void LCD_send_command(uint8_t data)	//Sends Command to LCD
 {
     60a:	cf 93       	push	r28
     60c:	c8 2f       	mov	r28, r24
	 DIO_Write(LCD_RS_PORT, LCD_RS_PIN, LOW);
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	62 e0       	ldi	r22, 0x02	; 2
     612:	40 e0       	ldi	r20, 0x00	; 0
     614:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
	 LCD_send_nibble(data); // Higher nibble first
     618:	8c 2f       	mov	r24, r28
     61a:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     61e:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>

	 LCD_send_nibble(data<<4);
     622:	8c 2f       	mov	r24, r28
     624:	82 95       	swap	r24
     626:	80 7f       	andi	r24, 0xF0	; 240
     628:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	 LCD_EN_pulse();
     62c:	0e 94 9a 02 	call	0x534	; 0x534 <LCD_EN_pulse>
	 SwDelay_ms(1);
     630:	61 e0       	ldi	r22, 0x01	; 1
     632:	70 e0       	ldi	r23, 0x00	; 0
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	90 e0       	ldi	r25, 0x00	; 0
     638:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <SwDelay_ms>
 }
     63c:	cf 91       	pop	r28
     63e:	08 95       	ret

00000640 <LCD_init>:
	/*
	uint8_t commands[9]={0x33,0x32,Four_bit,Cursor_on,Lcd_clear,Increment_cursor,Cursor_off,0};
	 LCD_config_pins();
	 */
	/*******************************************************************/
	 SwDelay_ms(20);
     640:	64 e1       	ldi	r22, 0x14	; 20
     642:	70 e0       	ldi	r23, 0x00	; 0
     644:	80 e0       	ldi	r24, 0x00	; 0
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <SwDelay_ms>
	LCD_send_nibble(0x00);
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_send_nibble>
	
		DIO_Write(LCD_RS_PORT, LCD_RS_PIN, LOW);
     652:	81 e0       	ldi	r24, 0x01	; 1
     654:	62 e0       	ldi	r22, 0x02	; 2
     656:	40 e0       	ldi	r20, 0x00	; 0
     658:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(LCD_RW_PORT, LCD_RW_PIN, LOW);
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	64 e0       	ldi	r22, 0x04	; 4
     660:	40 e0       	ldi	r20, 0x00	; 0
     662:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(LCD_EN_PORT, LCD_EN_PIN, LOW);
     666:	81 e0       	ldi	r24, 0x01	; 1
     668:	68 e0       	ldi	r22, 0x08	; 8
     66a:	40 e0       	ldi	r20, 0x00	; 0
     66c:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

	 LCD_send_command(Four_bit); // 4-bit
     670:	88 e2       	ldi	r24, 0x28	; 40
     672:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(0x38);
     676:	88 e3       	ldi	r24, 0x38	; 56
     678:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(0x32);
     67c:	82 e3       	ldi	r24, 0x32	; 50
     67e:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 
	 LCD_send_command(Cursor_on);
     682:	8e e0       	ldi	r24, 0x0E	; 14
     684:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(Lcd_clear);
     688:	81 e0       	ldi	r24, 0x01	; 1
     68a:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 
	SwDelay_ms(10);
     68e:	6a e0       	ldi	r22, 0x0A	; 10
     690:	70 e0       	ldi	r23, 0x00	; 0
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <SwDelay_ms>
	 LCD_send_command(Increment_cursor);
     69a:	86 e0       	ldi	r24, 0x06	; 6
     69c:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
	 LCD_send_command(Cursor_off); // Cursor off
     6a0:	8c e0       	ldi	r24, 0x0C	; 12
     6a2:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
}else
{
	u8_Init_finished=1;
}
 */
}
     6a6:	08 95       	ret

000006a8 <LCD_clear>:
 void LCD_clear(void)				//Clears LCD
 {
	 LCD_send_command(Lcd_clear);
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>
 }
     6ae:	08 95       	ret

000006b0 <LCD_send_string>:

 void LCD_send_string(char* data)	//Outputs string to LCD
 {
     6b0:	cf 93       	push	r28
     6b2:	df 93       	push	r29
     6b4:	ec 01       	movw	r28, r24
	while(*data)
     6b6:	88 81       	ld	r24, Y
     6b8:	88 23       	and	r24, r24
     6ba:	31 f0       	breq	.+12     	; 0x6c8 <LCD_send_string+0x18>
 void LCD_clear(void)				//Clears LCD
 {
	 LCD_send_command(Lcd_clear);
 }

 void LCD_send_string(char* data)	//Outputs string to LCD
     6bc:	21 96       	adiw	r28, 0x01	; 1
 {
	while(*data)
	 {
		 LCD_send_char(*data++);
     6be:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <LCD_send_char>
	 LCD_send_command(Lcd_clear);
 }

 void LCD_send_string(char* data)	//Outputs string to LCD
 {
	while(*data)
     6c2:	89 91       	ld	r24, Y+
     6c4:	88 23       	and	r24, r24
     6c6:	d9 f7       	brne	.-10     	; 0x6be <LCD_send_string+0xe>
	 {
		 LCD_send_char(*data++);
	 }
	 
 }
     6c8:	df 91       	pop	r29
     6ca:	cf 91       	pop	r28
     6cc:	08 95       	ret

000006ce <LCD_goto_xy>:

 void LCD_goto_xy(uint8_t x, uint8_t y)	//Cursor to X Y position
 {
	 uint8_t DDRAMAddr;
	 // remap lines into proper order
	 switch(y)
     6ce:	62 30       	cpi	r22, 0x02	; 2
     6d0:	31 f0       	breq	.+12     	; 0x6de <LCD_goto_xy+0x10>
     6d2:	63 30       	cpi	r22, 0x03	; 3
     6d4:	31 f0       	breq	.+12     	; 0x6e2 <LCD_goto_xy+0x14>
     6d6:	61 30       	cpi	r22, 0x01	; 1
     6d8:	29 f4       	brne	.+10     	; 0x6e4 <LCD_goto_xy+0x16>
	 {
		 case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
		 case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
     6da:	80 5c       	subi	r24, 0xC0	; 192
     6dc:	03 c0       	rjmp	.+6      	; 0x6e4 <LCD_goto_xy+0x16>
		 case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
     6de:	8c 5e       	subi	r24, 0xEC	; 236
     6e0:	01 c0       	rjmp	.+2      	; 0x6e4 <LCD_goto_xy+0x16>
		 case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
     6e2:	8c 5a       	subi	r24, 0xAC	; 172
		 default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	 }
	 // set data address
	 LCD_send_command(1<<LCD_DDRAM | DDRAMAddr);
     6e4:	80 68       	ori	r24, 0x80	; 128
     6e6:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_send_command>

 }
     6ea:	08 95       	ret

000006ec <reverse>:
	 char t = *x; *x = *y; *y = t;
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
 {
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
	 while (i < j)
     6f4:	40 17       	cp	r20, r16
     6f6:	51 07       	cpc	r21, r17
     6f8:	62 07       	cpc	r22, r18
     6fa:	73 07       	cpc	r23, r19
     6fc:	c0 f4       	brcc	.+48     	; 0x72e <reverse+0x42>
 inline void swap(char *x, char *y) {
	 char t = *x; *x = *y; *y = t;
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
     6fe:	d8 01       	movw	r26, r16
     700:	11 96       	adiw	r26, 0x01	; 1
     702:	a8 0f       	add	r26, r24
     704:	b9 1f       	adc	r27, r25
     706:	fc 01       	movw	r30, r24
     708:	e4 0f       	add	r30, r20
     70a:	f5 1f       	adc	r31, r21
 {
	 while (i < j)
	 swap(&buffer[i++], &buffer[j--]);
     70c:	4f 5f       	subi	r20, 0xFF	; 255
     70e:	5f 4f       	sbci	r21, 0xFF	; 255
     710:	6f 4f       	sbci	r22, 0xFF	; 255
     712:	7f 4f       	sbci	r23, 0xFF	; 255
     714:	01 50       	subi	r16, 0x01	; 1
     716:	10 40       	sbci	r17, 0x00	; 0
     718:	20 40       	sbci	r18, 0x00	; 0
     71a:	30 40       	sbci	r19, 0x00	; 0

 /*---Modification----------------------------------------------------------------------------------------------*/

 // inline function to swap two numbers
 inline void swap(char *x, char *y) {
	 char t = *x; *x = *y; *y = t;
     71c:	c0 81       	ld	r28, Z
     71e:	de 91       	ld	r29, -X
     720:	d1 93       	st	Z+, r29
     722:	cc 93       	st	X, r28
 }

 // function to reverse buffer[i..j]
 char* reverse(char *buffer, uint32_t i, uint32_t j)
 {
	 while (i < j)
     724:	40 17       	cp	r20, r16
     726:	51 07       	cpc	r21, r17
     728:	62 07       	cpc	r22, r18
     72a:	73 07       	cpc	r23, r19
     72c:	78 f3       	brcs	.-34     	; 0x70c <reverse+0x20>
	 swap(&buffer[i++], &buffer[j--]);

	 return buffer;
 }
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	1f 91       	pop	r17
     734:	0f 91       	pop	r16
     736:	08 95       	ret

00000738 <itoa_>:

 // Iterative function to implement itoa() function in C
 char* itoa_(uint32_t value, char* buffer, uint32_t base)
 {
     738:	4f 92       	push	r4
     73a:	5f 92       	push	r5
     73c:	6f 92       	push	r6
     73e:	7f 92       	push	r7
     740:	8f 92       	push	r8
     742:	9f 92       	push	r9
     744:	af 92       	push	r10
     746:	bf 92       	push	r11
     748:	cf 92       	push	r12
     74a:	df 92       	push	r13
     74c:	ef 92       	push	r14
     74e:	ff 92       	push	r15
     750:	0f 93       	push	r16
     752:	1f 93       	push	r17
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	6b 01       	movw	r12, r22
     75a:	7c 01       	movw	r14, r24
     75c:	2a 01       	movw	r4, r20
     75e:	48 01       	movw	r8, r16
     760:	59 01       	movw	r10, r18
	 // invalid input
	 if (base < 2 || base > 32)
     762:	d9 01       	movw	r26, r18
     764:	c8 01       	movw	r24, r16
     766:	02 97       	sbiw	r24, 0x02	; 2
     768:	a1 09       	sbc	r26, r1
     76a:	b1 09       	sbc	r27, r1
     76c:	8f 31       	cpi	r24, 0x1F	; 31
     76e:	91 05       	cpc	r25, r1
     770:	a1 05       	cpc	r26, r1
     772:	b1 05       	cpc	r27, r1
     774:	08 f0       	brcs	.+2      	; 0x778 <itoa_+0x40>
     776:	49 c0       	rjmp	.+146    	; 0x80a <itoa_+0xd2>
	 return buffer;

	 // consider absolute value of number
	 int n = abs(value);
     778:	96 01       	movw	r18, r12
     77a:	dd 20       	and	r13, r13
     77c:	1c f4       	brge	.+6      	; 0x784 <itoa_+0x4c>
     77e:	30 95       	com	r19
     780:	21 95       	neg	r18
     782:	3f 4f       	sbci	r19, 0xFF	; 255

	 int i = 0;
	 while (n)
     784:	21 15       	cp	r18, r1
     786:	31 05       	cpc	r19, r1
     788:	39 f1       	breq	.+78     	; 0x7d8 <itoa_+0xa0>
     78a:	e2 01       	movw	r28, r4
     78c:	01 e0       	ldi	r16, 0x01	; 1
     78e:	10 e0       	ldi	r17, 0x00	; 0
	 {
		 int r = n % base;
     790:	69 01       	movw	r12, r18
     792:	ee 24       	eor	r14, r14
     794:	d7 fc       	sbrc	r13, 7
     796:	e0 94       	com	r14
     798:	fe 2c       	mov	r15, r14
     79a:	c7 01       	movw	r24, r14
     79c:	b6 01       	movw	r22, r12
     79e:	a5 01       	movw	r20, r10
     7a0:	94 01       	movw	r18, r8
     7a2:	0e 94 bd 2a 	call	0x557a	; 0x557a <__udivmodsi4>

		 if (r >= 10)
     7a6:	6a 30       	cpi	r22, 0x0A	; 10
     7a8:	71 05       	cpc	r23, r1
     7aa:	24 f0       	brlt	.+8      	; 0x7b4 <itoa_+0x7c>
		 buffer[i++] = 65 + (r - 10);
     7ac:	69 5c       	subi	r22, 0xC9	; 201
     7ae:	68 83       	st	Y, r22
     7b0:	38 01       	movw	r6, r16
     7b2:	03 c0       	rjmp	.+6      	; 0x7ba <itoa_+0x82>
		 else
		 buffer[i++] = 48 + r;
     7b4:	60 5d       	subi	r22, 0xD0	; 208
     7b6:	68 83       	st	Y, r22
     7b8:	38 01       	movw	r6, r16

		 n = n / base;
     7ba:	c7 01       	movw	r24, r14
     7bc:	b6 01       	movw	r22, r12
     7be:	a5 01       	movw	r20, r10
     7c0:	94 01       	movw	r18, r8
     7c2:	0e 94 bd 2a 	call	0x557a	; 0x557a <__udivmodsi4>
     7c6:	0f 5f       	subi	r16, 0xFF	; 255
     7c8:	1f 4f       	sbci	r17, 0xFF	; 255
     7ca:	21 96       	adiw	r28, 0x01	; 1

	 // consider absolute value of number
	 int n = abs(value);

	 int i = 0;
	 while (n)
     7cc:	21 15       	cp	r18, r1
     7ce:	31 05       	cpc	r19, r1
     7d0:	f9 f6       	brne	.-66     	; 0x790 <itoa_+0x58>

		 n = n / base;
	 }

	 // if number is 0
	 if (i == 0)
     7d2:	61 14       	cp	r6, r1
     7d4:	71 04       	cpc	r7, r1
     7d6:	31 f4       	brne	.+12     	; 0x7e4 <itoa_+0xac>
	 buffer[i++] = '0';
     7d8:	80 e3       	ldi	r24, 0x30	; 48
     7da:	f2 01       	movw	r30, r4
     7dc:	80 83       	st	Z, r24
     7de:	66 24       	eor	r6, r6
     7e0:	77 24       	eor	r7, r7
     7e2:	63 94       	inc	r6
	 // is preceded with a minus sign (-)
	 // With any other base, value is always considered unsigned
	 if (value < 0 && base == 10)
	 buffer[i++] = '-';

	 buffer[i] = '\0'; // null terminate string
     7e4:	f2 01       	movw	r30, r4
     7e6:	e6 0d       	add	r30, r6
     7e8:	f7 1d       	adc	r31, r7
     7ea:	10 82       	st	Z, r1

	 // reverse the string and return it
	 return reverse(buffer, 0, i - 1);
     7ec:	08 94       	sec
     7ee:	61 08       	sbc	r6, r1
     7f0:	71 08       	sbc	r7, r1
     7f2:	83 01       	movw	r16, r6
     7f4:	22 27       	eor	r18, r18
     7f6:	17 fd       	sbrc	r17, 7
     7f8:	20 95       	com	r18
     7fa:	32 2f       	mov	r19, r18
     7fc:	c2 01       	movw	r24, r4
     7fe:	40 e0       	ldi	r20, 0x00	; 0
     800:	50 e0       	ldi	r21, 0x00	; 0
     802:	ba 01       	movw	r22, r20
     804:	0e 94 76 03 	call	0x6ec	; 0x6ec <reverse>
     808:	2c 01       	movw	r4, r24
 }
     80a:	84 2d       	mov	r24, r4
     80c:	95 2d       	mov	r25, r5
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	1f 91       	pop	r17
     814:	0f 91       	pop	r16
     816:	ff 90       	pop	r15
     818:	ef 90       	pop	r14
     81a:	df 90       	pop	r13
     81c:	cf 90       	pop	r12
     81e:	bf 90       	pop	r11
     820:	af 90       	pop	r10
     822:	9f 90       	pop	r9
     824:	8f 90       	pop	r8
     826:	7f 90       	pop	r7
     828:	6f 90       	pop	r6
     82a:	5f 90       	pop	r5
     82c:	4f 90       	pop	r4
     82e:	08 95       	ret

00000830 <gpioPortDirection>:
 * @param value: set the port value and takes the following values
 * 				- 0x00 -> Low
 * 				- 0xff -> High
 */

switch (u8_port)	
     830:	81 30       	cpi	r24, 0x01	; 1
     832:	49 f0       	breq	.+18     	; 0x846 <gpioPortDirection+0x16>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	28 f0       	brcs	.+10     	; 0x842 <gpioPortDirection+0x12>
     838:	82 30       	cpi	r24, 0x02	; 2
     83a:	39 f0       	breq	.+14     	; 0x84a <gpioPortDirection+0x1a>
     83c:	83 30       	cpi	r24, 0x03	; 3
     83e:	41 f4       	brne	.+16     	; 0x850 <gpioPortDirection+0x20>
     840:	06 c0       	rjmp	.+12     	; 0x84e <gpioPortDirection+0x1e>
{	case GPIOA:
	PORTA_DIR = u8_direction;
     842:	6a bb       	out	0x1a, r22	; 26
	break;
     844:	08 95       	ret
	case GPIOB:
	PORTB_DIR = u8_direction;
     846:	67 bb       	out	0x17, r22	; 23
	break;
     848:	08 95       	ret
	case GPIOC:
	PORTC_DIR = u8_direction;
     84a:	64 bb       	out	0x14, r22	; 20
	break;
     84c:	08 95       	ret
	case GPIOD:
	PORTD_DIR = u8_direction;
     84e:	61 bb       	out	0x11, r22	; 17
     850:	08 95       	ret

00000852 <gpioPortWrite>:
}

void gpioPortWrite(uint8_t u8_port, uint8_t u8_value)
{
	
switch (u8_port)	
     852:	81 30       	cpi	r24, 0x01	; 1
     854:	49 f0       	breq	.+18     	; 0x868 <__stack+0x9>
     856:	81 30       	cpi	r24, 0x01	; 1
     858:	28 f0       	brcs	.+10     	; 0x864 <__stack+0x5>
     85a:	82 30       	cpi	r24, 0x02	; 2
     85c:	39 f0       	breq	.+14     	; 0x86c <__stack+0xd>
     85e:	83 30       	cpi	r24, 0x03	; 3
     860:	41 f4       	brne	.+16     	; 0x872 <__stack+0x13>
     862:	06 c0       	rjmp	.+12     	; 0x870 <__stack+0x11>
{	case GPIOA:
	PORTA_DATA = u8_value;
     864:	6b bb       	out	0x1b, r22	; 27
	break;
     866:	08 95       	ret
	case GPIOB:
	PORTB_DATA = u8_value;
     868:	68 bb       	out	0x18, r22	; 24
	break;
     86a:	08 95       	ret
	case GPIOC:
	PORTC_DATA = u8_value;
     86c:	65 bb       	out	0x15, r22	; 21
	break;
     86e:	08 95       	ret
	case GPIOD:
	PORTD_DATA = u8_value;
     870:	62 bb       	out	0x12, r22	; 18
     872:	08 95       	ret

00000874 <gpioPortToggle>:
	
}
void gpioPortToggle(uint8_t u8_port)
{
	
switch (u8_port)	
     874:	81 30       	cpi	r24, 0x01	; 1
     876:	59 f0       	breq	.+22     	; 0x88e <gpioPortToggle+0x1a>
     878:	81 30       	cpi	r24, 0x01	; 1
     87a:	28 f0       	brcs	.+10     	; 0x886 <gpioPortToggle+0x12>
     87c:	82 30       	cpi	r24, 0x02	; 2
     87e:	59 f0       	breq	.+22     	; 0x896 <gpioPortToggle+0x22>
     880:	83 30       	cpi	r24, 0x03	; 3
     882:	81 f4       	brne	.+32     	; 0x8a4 <gpioPortToggle+0x30>
     884:	0c c0       	rjmp	.+24     	; 0x89e <gpioPortToggle+0x2a>
{	case GPIOA:
	PORTA_DATA ^= HIGH;
     886:	8b b3       	in	r24, 0x1b	; 27
     888:	80 95       	com	r24
     88a:	8b bb       	out	0x1b, r24	; 27
	break;
     88c:	08 95       	ret
	case GPIOB:
	PORTB_DATA ^= HIGH;
     88e:	88 b3       	in	r24, 0x18	; 24
     890:	80 95       	com	r24
     892:	88 bb       	out	0x18, r24	; 24
	break;
     894:	08 95       	ret
	case GPIOC:
	PORTC_DATA ^= HIGH;
     896:	85 b3       	in	r24, 0x15	; 21
     898:	80 95       	com	r24
     89a:	85 bb       	out	0x15, r24	; 21
	break;
     89c:	08 95       	ret
	case GPIOD:
	PORTD_DATA ^= HIGH;
     89e:	82 b3       	in	r24, 0x12	; 18
     8a0:	80 95       	com	r24
     8a2:	82 bb       	out	0x12, r24	; 18
     8a4:	08 95       	ret

000008a6 <gpioPortRead>:

uint8_t gpioPortRead(uint8_t u8_port)
{
	uint8_t U8_ret_Port_data=0;
	
switch (u8_port)	
     8a6:	81 30       	cpi	r24, 0x01	; 1
     8a8:	49 f0       	breq	.+18     	; 0x8bc <gpioPortRead+0x16>
     8aa:	81 30       	cpi	r24, 0x01	; 1
     8ac:	28 f0       	brcs	.+10     	; 0x8b8 <gpioPortRead+0x12>
     8ae:	82 30       	cpi	r24, 0x02	; 2
     8b0:	39 f0       	breq	.+14     	; 0x8c0 <gpioPortRead+0x1a>
     8b2:	83 30       	cpi	r24, 0x03	; 3
     8b4:	49 f4       	brne	.+18     	; 0x8c8 <gpioPortRead+0x22>
     8b6:	06 c0       	rjmp	.+12     	; 0x8c4 <gpioPortRead+0x1e>
{	case GPIOA:
	U8_ret_Port_data=PORTA_DATA & HIGH;
     8b8:	8b b3       	in	r24, 0x1b	; 27
	break;
     8ba:	08 95       	ret
	case GPIOB:
	U8_ret_Port_data=PORTB_DATA & HIGH;
     8bc:	88 b3       	in	r24, 0x18	; 24
	break;
     8be:	08 95       	ret
	case GPIOC:
	U8_ret_Port_data=PORTC_DATA & HIGH;
     8c0:	85 b3       	in	r24, 0x15	; 21
	break;
     8c2:	08 95       	ret
	case GPIOD:
	U8_ret_Port_data=PORTD_DATA & HIGH;
     8c4:	82 b3       	in	r24, 0x12	; 18
	break;
     8c6:	08 95       	ret
	
}

uint8_t gpioPortRead(uint8_t u8_port)
{
	uint8_t U8_ret_Port_data=0;
     8c8:	80 e0       	ldi	r24, 0x00	; 0
	break;
	
}

return 	U8_ret_Port_data;
}
     8ca:	08 95       	ret

000008cc <gpioPinDirection>:
 * 				- 0x00 -> Input
 * 				- 0xff -> Output
 */
void gpioPinDirection(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_direction)
{
switch(u8_direction){
     8cc:	44 23       	and	r20, r20
     8ce:	19 f0       	breq	.+6      	; 0x8d6 <gpioPinDirection+0xa>
     8d0:	4f 3f       	cpi	r20, 0xFF	; 255
     8d2:	d1 f5       	brne	.+116    	; 0x948 <gpioPinDirection+0x7c>
     8d4:	21 c0       	rjmp	.+66     	; 0x918 <gpioPinDirection+0x4c>
case INPUT:
{
switch (u8_port)	
     8d6:	81 30       	cpi	r24, 0x01	; 1
     8d8:	69 f0       	breq	.+26     	; 0x8f4 <gpioPinDirection+0x28>
     8da:	81 30       	cpi	r24, 0x01	; 1
     8dc:	28 f0       	brcs	.+10     	; 0x8e8 <gpioPinDirection+0x1c>
     8de:	82 30       	cpi	r24, 0x02	; 2
     8e0:	79 f0       	breq	.+30     	; 0x900 <gpioPinDirection+0x34>
     8e2:	83 30       	cpi	r24, 0x03	; 3
     8e4:	c9 f4       	brne	.+50     	; 0x918 <gpioPinDirection+0x4c>
     8e6:	12 c0       	rjmp	.+36     	; 0x90c <gpioPinDirection+0x40>
{	case GPIOA:
	PORTA_DIR &=(~u8_pins);   // 0b01111111
     8e8:	8a b3       	in	r24, 0x1a	; 26
     8ea:	96 2f       	mov	r25, r22
     8ec:	90 95       	com	r25
     8ee:	89 23       	and	r24, r25
     8f0:	8a bb       	out	0x1a, r24	; 26
     8f2:	1b c0       	rjmp	.+54     	; 0x92a <gpioPinDirection+0x5e>
	break;
	case GPIOB:
	PORTB_DIR &=(~u8_pins);
     8f4:	87 b3       	in	r24, 0x17	; 23
     8f6:	96 2f       	mov	r25, r22
     8f8:	90 95       	com	r25
     8fa:	89 23       	and	r24, r25
     8fc:	87 bb       	out	0x17, r24	; 23
     8fe:	19 c0       	rjmp	.+50     	; 0x932 <gpioPinDirection+0x66>
	break;
	case GPIOC:
	PORTC_DIR &=(~u8_pins);
     900:	84 b3       	in	r24, 0x14	; 20
     902:	96 2f       	mov	r25, r22
     904:	90 95       	com	r25
     906:	89 23       	and	r24, r25
     908:	84 bb       	out	0x14, r24	; 20
     90a:	17 c0       	rjmp	.+46     	; 0x93a <gpioPinDirection+0x6e>
	break;
	case GPIOD:
	PORTD_DIR &=(~u8_pins);
     90c:	81 b3       	in	r24, 0x11	; 17
     90e:	96 2f       	mov	r25, r22
     910:	90 95       	com	r25
     912:	89 23       	and	r24, r25
     914:	81 bb       	out	0x11, r24	; 17
     916:	15 c0       	rjmp	.+42     	; 0x942 <gpioPinDirection+0x76>
	break;
	
}
}
case OUTPUT:{
switch (u8_port)	
     918:	81 30       	cpi	r24, 0x01	; 1
     91a:	59 f0       	breq	.+22     	; 0x932 <gpioPinDirection+0x66>
     91c:	81 30       	cpi	r24, 0x01	; 1
     91e:	28 f0       	brcs	.+10     	; 0x92a <gpioPinDirection+0x5e>
     920:	82 30       	cpi	r24, 0x02	; 2
     922:	59 f0       	breq	.+22     	; 0x93a <gpioPinDirection+0x6e>
     924:	83 30       	cpi	r24, 0x03	; 3
     926:	81 f4       	brne	.+32     	; 0x948 <gpioPinDirection+0x7c>
     928:	0c c0       	rjmp	.+24     	; 0x942 <gpioPinDirection+0x76>
{	case GPIOA:
	PORTA_DIR |=(u8_pins);
     92a:	8a b3       	in	r24, 0x1a	; 26
     92c:	68 2b       	or	r22, r24
     92e:	6a bb       	out	0x1a, r22	; 26
	break;
     930:	08 95       	ret
	case GPIOB:
	PORTB_DIR |=(u8_pins);
     932:	87 b3       	in	r24, 0x17	; 23
     934:	68 2b       	or	r22, r24
     936:	67 bb       	out	0x17, r22	; 23
	break;
     938:	08 95       	ret
	case GPIOC:
	PORTC_DIR |=(u8_pins);
     93a:	84 b3       	in	r24, 0x14	; 20
     93c:	68 2b       	or	r22, r24
     93e:	64 bb       	out	0x14, r22	; 20
	break;
     940:	08 95       	ret
	case GPIOD:
	PORTD_DIR |=(u8_pins);
     942:	81 b3       	in	r24, 0x11	; 17
     944:	68 2b       	or	r22, r24
     946:	61 bb       	out	0x11, r22	; 17
     948:	08 95       	ret

0000094a <gpioPinWrite>:
	
	
}

void gpioPinWrite(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_value)
{switch(u8_value){
     94a:	44 23       	and	r20, r20
     94c:	19 f0       	breq	.+6      	; 0x954 <gpioPinWrite+0xa>
     94e:	4f 3f       	cpi	r20, 0xFF	; 255
     950:	b1 f5       	brne	.+108    	; 0x9be <gpioPinWrite+0x74>
     952:	1d c0       	rjmp	.+58     	; 0x98e <gpioPinWrite+0x44>
case LOW:
{
switch (u8_port)	
     954:	81 30       	cpi	r24, 0x01	; 1
     956:	61 f0       	breq	.+24     	; 0x970 <gpioPinWrite+0x26>
     958:	81 30       	cpi	r24, 0x01	; 1
     95a:	28 f0       	brcs	.+10     	; 0x966 <gpioPinWrite+0x1c>
     95c:	82 30       	cpi	r24, 0x02	; 2
     95e:	69 f0       	breq	.+26     	; 0x97a <gpioPinWrite+0x30>
     960:	83 30       	cpi	r24, 0x03	; 3
     962:	69 f5       	brne	.+90     	; 0x9be <gpioPinWrite+0x74>
     964:	0f c0       	rjmp	.+30     	; 0x984 <gpioPinWrite+0x3a>
{	case GPIOA:
	PORTA_DATA &= ~(u8_pins);   // 0b01111111
     966:	8b b3       	in	r24, 0x1b	; 27
     968:	60 95       	com	r22
     96a:	68 23       	and	r22, r24
     96c:	6b bb       	out	0x1b, r22	; 27
	break;
     96e:	08 95       	ret
	case GPIOB:
	PORTB_DATA &= ~(u8_pins);
     970:	88 b3       	in	r24, 0x18	; 24
     972:	60 95       	com	r22
     974:	68 23       	and	r22, r24
     976:	68 bb       	out	0x18, r22	; 24
	break;
     978:	08 95       	ret
	case GPIOC:
	PORTC_DATA &= ~(u8_pins);
     97a:	85 b3       	in	r24, 0x15	; 21
     97c:	60 95       	com	r22
     97e:	68 23       	and	r22, r24
     980:	65 bb       	out	0x15, r22	; 21
	break;
     982:	08 95       	ret
	case GPIOD:
	PORTD_DATA &= ~(u8_pins);
     984:	82 b3       	in	r24, 0x12	; 18
     986:	60 95       	com	r22
     988:	68 23       	and	r22, r24
     98a:	62 bb       	out	0x12, r22	; 18
	break;
     98c:	08 95       	ret
	
}
break;
}
case HIGH:{
switch (u8_port)	
     98e:	81 30       	cpi	r24, 0x01	; 1
     990:	59 f0       	breq	.+22     	; 0x9a8 <gpioPinWrite+0x5e>
     992:	81 30       	cpi	r24, 0x01	; 1
     994:	28 f0       	brcs	.+10     	; 0x9a0 <gpioPinWrite+0x56>
     996:	82 30       	cpi	r24, 0x02	; 2
     998:	59 f0       	breq	.+22     	; 0x9b0 <gpioPinWrite+0x66>
     99a:	83 30       	cpi	r24, 0x03	; 3
     99c:	81 f4       	brne	.+32     	; 0x9be <gpioPinWrite+0x74>
     99e:	0c c0       	rjmp	.+24     	; 0x9b8 <gpioPinWrite+0x6e>
{	case GPIOA:
	PORTA_DATA |=(u8_pins);
     9a0:	8b b3       	in	r24, 0x1b	; 27
     9a2:	68 2b       	or	r22, r24
     9a4:	6b bb       	out	0x1b, r22	; 27
	break;
     9a6:	08 95       	ret
	case GPIOB:
	PORTB_DATA |=(u8_pins);
     9a8:	88 b3       	in	r24, 0x18	; 24
     9aa:	68 2b       	or	r22, r24
     9ac:	68 bb       	out	0x18, r22	; 24
	break;
     9ae:	08 95       	ret
	case GPIOC:
	PORTC_DATA |=(u8_pins);
     9b0:	85 b3       	in	r24, 0x15	; 21
     9b2:	68 2b       	or	r22, r24
     9b4:	65 bb       	out	0x15, r22	; 21
	break;
     9b6:	08 95       	ret
	case GPIOD:
	PORTD_DATA |=(u8_pins);
     9b8:	82 b3       	in	r24, 0x12	; 18
     9ba:	68 2b       	or	r22, r24
     9bc:	62 bb       	out	0x12, r22	; 18
     9be:	08 95       	ret

000009c0 <gpioPinToggle>:
}

}
void gpioPinToggle(uint8_t u8_port, uint8_t u8_pins)
{
switch (u8_port)	
     9c0:	81 30       	cpi	r24, 0x01	; 1
     9c2:	59 f0       	breq	.+22     	; 0x9da <gpioPinToggle+0x1a>
     9c4:	81 30       	cpi	r24, 0x01	; 1
     9c6:	28 f0       	brcs	.+10     	; 0x9d2 <gpioPinToggle+0x12>
     9c8:	82 30       	cpi	r24, 0x02	; 2
     9ca:	59 f0       	breq	.+22     	; 0x9e2 <gpioPinToggle+0x22>
     9cc:	83 30       	cpi	r24, 0x03	; 3
     9ce:	81 f4       	brne	.+32     	; 0x9f0 <gpioPinToggle+0x30>
     9d0:	0c c0       	rjmp	.+24     	; 0x9ea <gpioPinToggle+0x2a>
{	case GPIOA:
	PORTA_DATA ^=(u8_pins);
     9d2:	8b b3       	in	r24, 0x1b	; 27
     9d4:	68 27       	eor	r22, r24
     9d6:	6b bb       	out	0x1b, r22	; 27
	break;
     9d8:	08 95       	ret
	case GPIOB:
	PORTB_DATA ^=(u8_pins);
     9da:	88 b3       	in	r24, 0x18	; 24
     9dc:	68 27       	eor	r22, r24
     9de:	68 bb       	out	0x18, r22	; 24
	break;
     9e0:	08 95       	ret
	case GPIOC:
	PORTC_DATA ^=(u8_pins);
     9e2:	85 b3       	in	r24, 0x15	; 21
     9e4:	68 27       	eor	r22, r24
     9e6:	65 bb       	out	0x15, r22	; 21
	break;
     9e8:	08 95       	ret
	case GPIOD:
	PORTD_DATA ^=(u8_pins);
     9ea:	82 b3       	in	r24, 0x12	; 18
     9ec:	68 27       	eor	r22, r24
     9ee:	62 bb       	out	0x12, r22	; 18
     9f0:	08 95       	ret

000009f2 <gpioPinRead>:
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
{
	uint8_t U8_ret_BIT_data = 0;
switch (u8_port)	
     9f2:	81 30       	cpi	r24, 0x01	; 1
     9f4:	51 f0       	breq	.+20     	; 0xa0a <gpioPinRead+0x18>
     9f6:	81 30       	cpi	r24, 0x01	; 1
     9f8:	28 f0       	brcs	.+10     	; 0xa04 <gpioPinRead+0x12>
     9fa:	82 30       	cpi	r24, 0x02	; 2
     9fc:	49 f0       	breq	.+18     	; 0xa10 <gpioPinRead+0x1e>
     9fe:	83 30       	cpi	r24, 0x03	; 3
     a00:	69 f4       	brne	.+26     	; 0xa1c <gpioPinRead+0x2a>
     a02:	09 c0       	rjmp	.+18     	; 0xa16 <gpioPinRead+0x24>
{	case GPIOA:
	U8_ret_BIT_data=(PORTA_PIN & u8_pin);
     a04:	89 b3       	in	r24, 0x19	; 25
     a06:	68 23       	and	r22, r24
	break;
     a08:	0a c0       	rjmp	.+20     	; 0xa1e <gpioPinRead+0x2c>
	case GPIOB:
	U8_ret_BIT_data=(PORTB_PIN & u8_pin);
     a0a:	86 b3       	in	r24, 0x16	; 22
     a0c:	68 23       	and	r22, r24
	break;
     a0e:	07 c0       	rjmp	.+14     	; 0xa1e <gpioPinRead+0x2c>
	case GPIOC:
	U8_ret_BIT_data=(PORTC_PIN & u8_pin);
     a10:	83 b3       	in	r24, 0x13	; 19
     a12:	68 23       	and	r22, r24
	break;
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <gpioPinRead+0x2c>
	case GPIOD:
	U8_ret_BIT_data=(PORTD_PIN & u8_pin);
     a16:	80 b3       	in	r24, 0x10	; 16
     a18:	68 23       	and	r22, r24
	break;
     a1a:	01 c0       	rjmp	.+2      	; 0xa1e <gpioPinRead+0x2c>
	
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
{
	uint8_t U8_ret_BIT_data = 0;
     a1c:	60 e0       	ldi	r22, 0x00	; 0
}
	
	
	
}
uint8_t gpioPinRead(uint8_t u8_port, uint8_t u8_pin)
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	66 23       	and	r22, r22
     a22:	09 f4       	brne	.+2      	; 0xa26 <gpioPinRead+0x34>
     a24:	80 e0       	ldi	r24, 0x00	; 0
if(U8_ret_BIT_data > 0)
{
	U8_ret_BIT_data = 1;
}
return U8_ret_BIT_data;
     a26:	08 95       	ret

00000a28 <Led_Init>:
	LED_3

*/
void Led_Init(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     a28:	81 30       	cpi	r24, 0x01	; 1
     a2a:	69 f0       	breq	.+26     	; 0xa46 <Led_Init+0x1e>
     a2c:	81 30       	cpi	r24, 0x01	; 1
     a2e:	28 f0       	brcs	.+10     	; 0xa3a <Led_Init+0x12>
     a30:	82 30       	cpi	r24, 0x02	; 2
     a32:	79 f0       	breq	.+30     	; 0xa52 <Led_Init+0x2a>
     a34:	83 30       	cpi	r24, 0x03	; 3
     a36:	c1 f4       	brne	.+48     	; 0xa68 <Led_Init+0x40>
     a38:	12 c0       	rjmp	.+36     	; 0xa5e <Led_Init+0x36>
{
case LED_0:
gpioPinDirection(LED_0_GPIO,LED_0_BIT,HIGH);
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	60 e1       	ldi	r22, 0x10	; 16
     a3e:	4f ef       	ldi	r20, 0xFF	; 255
     a40:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
break;
     a44:	08 95       	ret

case LED_1:
gpioPinDirection(LED_1_GPIO,LED_1_BIT,HIGH);
     a46:	81 e0       	ldi	r24, 0x01	; 1
     a48:	60 e2       	ldi	r22, 0x20	; 32
     a4a:	4f ef       	ldi	r20, 0xFF	; 255
     a4c:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
break;
     a50:	08 95       	ret

case LED_2:
gpioPinDirection(LED_2_GPIO,LED_2_BIT,HIGH);
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	60 e4       	ldi	r22, 0x40	; 64
     a56:	4f ef       	ldi	r20, 0xFF	; 255
     a58:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
break;
     a5c:	08 95       	ret

case LED_3:
gpioPinDirection(LED_3_GPIO,LED_3_BIT,HIGH);
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	60 e8       	ldi	r22, 0x80	; 128
     a62:	4f ef       	ldi	r20, 0xFF	; 255
     a64:	0e 94 66 04 	call	0x8cc	; 0x8cc <gpioPinDirection>
     a68:	08 95       	ret

00000a6a <Led_On>:
}


void Led_On(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     a6a:	81 30       	cpi	r24, 0x01	; 1
     a6c:	69 f0       	breq	.+26     	; 0xa88 <Led_On+0x1e>
     a6e:	81 30       	cpi	r24, 0x01	; 1
     a70:	28 f0       	brcs	.+10     	; 0xa7c <Led_On+0x12>
     a72:	82 30       	cpi	r24, 0x02	; 2
     a74:	79 f0       	breq	.+30     	; 0xa94 <Led_On+0x2a>
     a76:	83 30       	cpi	r24, 0x03	; 3
     a78:	c1 f4       	brne	.+48     	; 0xaaa <Led_On+0x40>
     a7a:	12 c0       	rjmp	.+36     	; 0xaa0 <Led_On+0x36>
{
case LED_0:
gpioPinWrite(LED_0_GPIO,LED_0_BIT,HIGH);
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	60 e1       	ldi	r22, 0x10	; 16
     a80:	4f ef       	ldi	r20, 0xFF	; 255
     a82:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     a86:	08 95       	ret

case LED_1:
gpioPinWrite(LED_1_GPIO,LED_1_BIT,HIGH);
     a88:	81 e0       	ldi	r24, 0x01	; 1
     a8a:	60 e2       	ldi	r22, 0x20	; 32
     a8c:	4f ef       	ldi	r20, 0xFF	; 255
     a8e:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     a92:	08 95       	ret

case LED_2:
gpioPinWrite(LED_2_GPIO,LED_2_BIT,HIGH);
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	60 e4       	ldi	r22, 0x40	; 64
     a98:	4f ef       	ldi	r20, 0xFF	; 255
     a9a:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     a9e:	08 95       	ret

case LED_3:
gpioPinWrite(LED_3_GPIO,LED_3_BIT,HIGH);
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	60 e8       	ldi	r22, 0x80	; 128
     aa4:	4f ef       	ldi	r20, 0xFF	; 255
     aa6:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
     aaa:	08 95       	ret

00000aac <Led_Off>:
}

void Led_Off(En_LedNumber_t en_led_id)
{

switch(en_led_id)
     aac:	81 30       	cpi	r24, 0x01	; 1
     aae:	69 f0       	breq	.+26     	; 0xaca <Led_Off+0x1e>
     ab0:	81 30       	cpi	r24, 0x01	; 1
     ab2:	28 f0       	brcs	.+10     	; 0xabe <Led_Off+0x12>
     ab4:	82 30       	cpi	r24, 0x02	; 2
     ab6:	79 f0       	breq	.+30     	; 0xad6 <Led_Off+0x2a>
     ab8:	83 30       	cpi	r24, 0x03	; 3
     aba:	c1 f4       	brne	.+48     	; 0xaec <Led_Off+0x40>
     abc:	12 c0       	rjmp	.+36     	; 0xae2 <Led_Off+0x36>
{
case LED_0:
gpioPinWrite(LED_0_GPIO,LED_0_BIT,LOW);
     abe:	81 e0       	ldi	r24, 0x01	; 1
     ac0:	60 e1       	ldi	r22, 0x10	; 16
     ac2:	40 e0       	ldi	r20, 0x00	; 0
     ac4:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     ac8:	08 95       	ret

case LED_1:
gpioPinWrite(LED_1_GPIO,LED_1_BIT,LOW);
     aca:	81 e0       	ldi	r24, 0x01	; 1
     acc:	60 e2       	ldi	r22, 0x20	; 32
     ace:	40 e0       	ldi	r20, 0x00	; 0
     ad0:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     ad4:	08 95       	ret

case LED_2:
gpioPinWrite(LED_2_GPIO,LED_2_BIT,LOW);
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	60 e4       	ldi	r22, 0x40	; 64
     ada:	40 e0       	ldi	r20, 0x00	; 0
     adc:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
break;
     ae0:	08 95       	ret

case LED_3:
gpioPinWrite(LED_3_GPIO,LED_3_BIT,LOW);
     ae2:	81 e0       	ldi	r24, 0x01	; 1
     ae4:	60 e8       	ldi	r22, 0x80	; 128
     ae6:	40 e0       	ldi	r20, 0x00	; 0
     ae8:	0e 94 a5 04 	call	0x94a	; 0x94a <gpioPinWrite>
     aec:	08 95       	ret

00000aee <Led_Toggle>:


}
void Led_Toggle(En_LedNumber_t en_led_id)
{
switch(en_led_id)
     aee:	81 30       	cpi	r24, 0x01	; 1
     af0:	61 f0       	breq	.+24     	; 0xb0a <Led_Toggle+0x1c>
     af2:	81 30       	cpi	r24, 0x01	; 1
     af4:	28 f0       	brcs	.+10     	; 0xb00 <Led_Toggle+0x12>
     af6:	82 30       	cpi	r24, 0x02	; 2
     af8:	69 f0       	breq	.+26     	; 0xb14 <Led_Toggle+0x26>
     afa:	83 30       	cpi	r24, 0x03	; 3
     afc:	a1 f4       	brne	.+40     	; 0xb26 <Led_Toggle+0x38>
     afe:	0f c0       	rjmp	.+30     	; 0xb1e <Led_Toggle+0x30>
{
case LED_0:
gpioPinToggle(LED_0_GPIO,LED_0_BIT);
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	60 e1       	ldi	r22, 0x10	; 16
     b04:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
break;
     b08:	08 95       	ret

case LED_1:
gpioPinToggle(LED_1_GPIO,LED_1_BIT);
     b0a:	81 e0       	ldi	r24, 0x01	; 1
     b0c:	60 e2       	ldi	r22, 0x20	; 32
     b0e:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
break;
     b12:	08 95       	ret

case LED_2:
gpioPinToggle(LED_2_GPIO,LED_2_BIT);
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	60 e4       	ldi	r22, 0x40	; 64
     b18:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
break;
     b1c:	08 95       	ret

case LED_3:
gpioPinToggle(LED_3_GPIO,LED_3_BIT);
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	60 e8       	ldi	r22, 0x80	; 128
     b22:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <gpioPinToggle>
     b26:	08 95       	ret

00000b28 <Motor_Init>:
#include "motor.h"
static uint8_t gsv_is_Started=0;
static uint8_t gsv_is_intialized=0;
ERROR_STATUS Motor_Init(uint8_t Motor_Number)
{uint8_t Ret=0;
    switch(Motor_Number)
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	79 f0       	breq	.+30     	; 0xb4a <Motor_Init+0x22>
     b2c:	83 30       	cpi	r24, 0x03	; 3
     b2e:	c9 f0       	breq	.+50     	; 0xb62 <Motor_Init+0x3a>
     b30:	81 30       	cpi	r24, 0x01	; 1
     b32:	39 f5       	brne	.+78     	; 0xb82 <Motor_Init+0x5a>
    {
        case MOTOR_1:
        /*Enable PWM Bit...output*/
        /*IN1*/
        /*IN2*/
			gsv_is_intialized=MOTOR_1;
     b34:	80 93 fa 00 	sts	0x00FA, r24
			Ret=Pwm_Init(&PWM_Configuration_1A);
     b38:	82 ed       	ldi	r24, 0xD2	; 210
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
			Ret=DIO_init(&Motorone);
     b40:	88 e7       	ldi	r24, 0x78	; 120
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>

			  break;
     b48:	08 95       	ret

          case MOTOR_2:
				gsv_is_intialized=MOTOR_2;
     b4a:	82 e0       	ldi	r24, 0x02	; 2
     b4c:	80 93 fa 00 	sts	0x00FA, r24
				Ret=Pwm_Init(&PWM_Configuration_1B);
     b50:	80 ed       	ldi	r24, 0xD0	; 208
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
				Ret=DIO_init(&Motortwo);
     b58:	85 e7       	ldi	r24, 0x75	; 117
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
				break;
     b60:	08 95       	ret
				/*IN1*/
				/*IN2*/
				/*ENABLE PWM BIT FOR MOTOR 2*/
				/*IN3*/
				/*IN4*/
				gsv_is_intialized=ALL_MOTOR;
     b62:	83 e0       	ldi	r24, 0x03	; 3
     b64:	80 93 fa 00 	sts	0x00FA, r24
			Ret=Pwm_Init(&PWM_Configuration_1A);
     b68:	82 ed       	ldi	r24, 0xD2	; 210
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
			Ret=Pwm_Init(&PWM_Configuration_1B);
     b70:	80 ed       	ldi	r24, 0xD0	; 208
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <Pwm_Init>
			Ret=DIO_init(&ALL_Motor);
     b78:	82 e7       	ldi	r24, 0x72	; 114
     b7a:	90 e0       	ldi	r25, 0x00	; 0
     b7c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
				break;
     b80:	08 95       	ret
			   }
      default:
      Ret=E_NOK;
     b82:	81 e0       	ldi	r24, 0x01	; 1
      break;
    }
return Ret;
}
     b84:	08 95       	ret

00000b86 <Motor_Direction>:

ERROR_STATUS Motor_Direction(uint8_t Motor_Number, uint8_t Motor_Direction)
{uint8_t Ret=0;

  switch(Motor_Number)
     b86:	82 30       	cpi	r24, 0x02	; 2
     b88:	79 f1       	breq	.+94     	; 0xbe8 <Motor_Direction+0x62>
     b8a:	83 30       	cpi	r24, 0x03	; 3
     b8c:	09 f4       	brne	.+2      	; 0xb90 <Motor_Direction+0xa>
     b8e:	55 c0       	rjmp	.+170    	; 0xc3a <Motor_Direction+0xb4>
     b90:	81 30       	cpi	r24, 0x01	; 1
     b92:	09 f0       	breq	.+2      	; 0xb96 <Motor_Direction+0x10>
     b94:	99 c0       	rjmp	.+306    	; 0xcc8 <Motor_Direction+0x142>
  {
  	case MOTOR_1:{
  	switch(Motor_Direction)
     b96:	61 30       	cpi	r22, 0x01	; 1
     b98:	31 f0       	breq	.+12     	; 0xba6 <Motor_Direction+0x20>
     b9a:	61 30       	cpi	r22, 0x01	; 1
     b9c:	d0 f0       	brcs	.+52     	; 0xbd2 <Motor_Direction+0x4c>
     b9e:	62 30       	cpi	r22, 0x02	; 2
     ba0:	09 f0       	breq	.+2      	; 0xba4 <Motor_Direction+0x1e>
     ba2:	94 c0       	rjmp	.+296    	; 0xccc <Motor_Direction+0x146>
     ba4:	0b c0       	rjmp	.+22     	; 0xbbc <Motor_Direction+0x36>
  	{
  		case MOTOR_FORWARD:
  		{
  			Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,HIGH);
     ba6:	83 e0       	ldi	r24, 0x03	; 3
     ba8:	64 e0       	ldi	r22, 0x04	; 4
     baa:	4f ef       	ldi	r20, 0xFF	; 255
     bac:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write (MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     bb0:	83 e0       	ldi	r24, 0x03	; 3
     bb2:	68 e0       	ldi	r22, 0x08	; 8
     bb4:	40 e0       	ldi	r20, 0x00	; 0
     bb6:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  			break;
     bba:	08 95       	ret
  		}
  		case MOTOR_BACKWARD:
  		{
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,HIGH);
     bbc:	83 e0       	ldi	r24, 0x03	; 3
     bbe:	68 e0       	ldi	r22, 0x08	; 8
     bc0:	4f ef       	ldi	r20, 0xFF	; 255
     bc2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
        Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     bc6:	83 e0       	ldi	r24, 0x03	; 3
     bc8:	64 e0       	ldi	r22, 0x04	; 4
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  			break;
     bd0:	08 95       	ret
  		}
  		case MOTOR_STOP:{Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     bd2:	83 e0       	ldi	r24, 0x03	; 3
     bd4:	64 e0       	ldi	r22, 0x04	; 4
     bd6:	40 e0       	ldi	r20, 0x00	; 0
     bd8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     bdc:	83 e0       	ldi	r24, 0x03	; 3
     bde:	68 e0       	ldi	r22, 0x08	; 8
     be0:	40 e0       	ldi	r20, 0x00	; 0
     be2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		break;}
     be6:	08 95       	ret
  	}
  		break;
  	}
  	case MOTOR_2:
  	{
  		switch(Motor_Direction)
     be8:	61 30       	cpi	r22, 0x01	; 1
     bea:	31 f0       	breq	.+12     	; 0xbf8 <Motor_Direction+0x72>
     bec:	61 30       	cpi	r22, 0x01	; 1
     bee:	d0 f0       	brcs	.+52     	; 0xc24 <Motor_Direction+0x9e>
     bf0:	62 30       	cpi	r22, 0x02	; 2
     bf2:	09 f0       	breq	.+2      	; 0xbf6 <Motor_Direction+0x70>
     bf4:	6d c0       	rjmp	.+218    	; 0xcd0 <Motor_Direction+0x14a>
     bf6:	0b c0       	rjmp	.+22     	; 0xc0e <Motor_Direction+0x88>
  		{
  			case MOTOR_FORWARD:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,HIGH);
     bf8:	83 e0       	ldi	r24, 0x03	; 3
     bfa:	60 e8       	ldi	r22, 0x80	; 128
     bfc:	4f ef       	ldi	r20, 0xFF	; 255
     bfe:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
          Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     c02:	83 e0       	ldi	r24, 0x03	; 3
     c04:	60 e4       	ldi	r22, 0x40	; 64
     c06:	40 e0       	ldi	r20, 0x00	; 0
     c08:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  				break;
     c0c:	08 95       	ret
  			}
  			case MOTOR_BACKWARD:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,HIGH);
     c0e:	83 e0       	ldi	r24, 0x03	; 3
     c10:	60 e4       	ldi	r22, 0x40	; 64
     c12:	4f ef       	ldi	r20, 0xFF	; 255
     c14:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     c18:	83 e0       	ldi	r24, 0x03	; 3
     c1a:	60 e8       	ldi	r22, 0x80	; 128
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  				break;
     c22:	08 95       	ret
  			}
  			case MOTOR_STOP:
  			{
  				Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     c24:	83 e0       	ldi	r24, 0x03	; 3
     c26:	60 e4       	ldi	r22, 0x40	; 64
     c28:	40 e0       	ldi	r20, 0x00	; 0
     c2a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  				Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     c2e:	83 e0       	ldi	r24, 0x03	; 3
     c30:	60 e8       	ldi	r22, 0x80	; 128
     c32:	40 e0       	ldi	r20, 0x00	; 0
     c34:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  				break;
     c38:	08 95       	ret

  		break;
  	}
  	case ALL_MOTOR:
  	{
  switch(Motor_Direction)
     c3a:	61 30       	cpi	r22, 0x01	; 1
     c3c:	31 f0       	breq	.+12     	; 0xc4a <Motor_Direction+0xc4>
     c3e:	61 30       	cpi	r22, 0x01	; 1
     c40:	70 f1       	brcs	.+92     	; 0xc9e <Motor_Direction+0x118>
     c42:	62 30       	cpi	r22, 0x02	; 2
     c44:	09 f0       	breq	.+2      	; 0xc48 <Motor_Direction+0xc2>
     c46:	46 c0       	rjmp	.+140    	; 0xcd4 <Motor_Direction+0x14e>
     c48:	15 c0       	rjmp	.+42     	; 0xc74 <Motor_Direction+0xee>
  {
  	case MOTOR_FORWARD:
  	{
  		Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,HIGH);
     c4a:	83 e0       	ldi	r24, 0x03	; 3
     c4c:	64 e0       	ldi	r22, 0x04	; 4
     c4e:	4f ef       	ldi	r20, 0xFF	; 255
     c50:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     c54:	83 e0       	ldi	r24, 0x03	; 3
     c56:	68 e0       	ldi	r22, 0x08	; 8
     c58:	40 e0       	ldi	r20, 0x00	; 0
     c5a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  	Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     c5e:	83 e0       	ldi	r24, 0x03	; 3
     c60:	60 e4       	ldi	r22, 0x40	; 64
     c62:	40 e0       	ldi	r20, 0x00	; 0
     c64:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,HIGH);
     c68:	83 e0       	ldi	r24, 0x03	; 3
     c6a:	60 e8       	ldi	r22, 0x80	; 128
     c6c:	4f ef       	ldi	r20, 0xFF	; 255
     c6e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  		break;
     c72:	08 95       	ret
  	}
  	case MOTOR_BACKWARD:
  	{

  		Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     c74:	83 e0       	ldi	r24, 0x03	; 3
     c76:	64 e0       	ldi	r22, 0x04	; 4
     c78:	40 e0       	ldi	r20, 0x00	; 0
     c7a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
      Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,HIGH);
     c7e:	83 e0       	ldi	r24, 0x03	; 3
     c80:	68 e0       	ldi	r22, 0x08	; 8
     c82:	4f ef       	ldi	r20, 0xFF	; 255
     c84:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,HIGH);
     c88:	83 e0       	ldi	r24, 0x03	; 3
     c8a:	60 e4       	ldi	r22, 0x40	; 64
     c8c:	4f ef       	ldi	r20, 0xFF	; 255
     c8e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  		Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     c92:	83 e0       	ldi	r24, 0x03	; 3
     c94:	60 e8       	ldi	r22, 0x80	; 128
     c96:	40 e0       	ldi	r20, 0x00	; 0
     c98:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  		break;	}
     c9c:	08 95       	ret
  	case MOTOR_STOP:
  	{
  			Ret=DIO_Write(MOTOR_OUT_1A_GPIO,MOTOR_OUT_1A_BIT,LOW);
     c9e:	83 e0       	ldi	r24, 0x03	; 3
     ca0:	64 e0       	ldi	r22, 0x04	; 4
     ca2:	40 e0       	ldi	r20, 0x00	; 0
     ca4:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2A_GPIO,MOTOR_OUT_2A_BIT,LOW);
     ca8:	83 e0       	ldi	r24, 0x03	; 3
     caa:	60 e4       	ldi	r22, 0x40	; 64
     cac:	40 e0       	ldi	r20, 0x00	; 0
     cae:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  			Ret=DIO_Write(MOTOR_OUT_1B_GPIO,MOTOR_OUT_1B_BIT,LOW);
     cb2:	83 e0       	ldi	r24, 0x03	; 3
     cb4:	68 e0       	ldi	r22, 0x08	; 8
     cb6:	40 e0       	ldi	r20, 0x00	; 0
     cb8:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);
     cbc:	83 e0       	ldi	r24, 0x03	; 3
     cbe:	60 e8       	ldi	r22, 0x80	; 128
     cc0:	40 e0       	ldi	r20, 0x00	; 0
     cc2:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>

  		break;
     cc6:	08 95       	ret
    }
return Ret;
}

ERROR_STATUS Motor_Direction(uint8_t Motor_Number, uint8_t Motor_Direction)
{uint8_t Ret=0;
     cc8:	80 e0       	ldi	r24, 0x00	; 0
     cca:	08 95       	ret
     ccc:	80 e0       	ldi	r24, 0x00	; 0
     cce:	08 95       	ret
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	08 95       	ret
  			Ret=DIO_Write(MOTOR_OUT_2B_GPIO,MOTOR_OUT_2B_BIT,LOW);

  		break;
  	}
    default:
    Ret=E_NOK;
     cd4:	81 e0       	ldi	r24, 0x01	; 1



    }
return Ret;
}
     cd6:	08 95       	ret

00000cd8 <Motor_Start>:


ERROR_STATUS Motor_Start(uint8_t Motor_Number, uint8_t Mot_Speed)
{
  uint8_t Ret=0;
switch (Motor_Number) {
     cd8:	82 30       	cpi	r24, 0x02	; 2
     cda:	69 f0       	breq	.+26     	; 0xcf6 <Motor_Start+0x1e>
     cdc:	83 30       	cpi	r24, 0x03	; 3
     cde:	a9 f0       	breq	.+42     	; 0xd0a <Motor_Start+0x32>
     ce0:	81 30       	cpi	r24, 0x01	; 1
     ce2:	f1 f4       	brne	.+60     	; 0xd20 <Motor_Start+0x48>
  case MOTOR_1:
  {gsv_is_Started=MOTOR_1;
     ce4:	80 93 fb 00 	sts	0x00FB, r24
    Ret=Pwm_Start(PWM_CH1A,Mot_Speed,30);
     ce8:	2e e1       	ldi	r18, 0x1E	; 30
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	40 e0       	ldi	r20, 0x00	; 0
     cee:	50 e0       	ldi	r21, 0x00	; 0
     cf0:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
    break;
     cf4:	08 95       	ret
  }
  case MOTOR_2:
  {
    gsv_is_Started=MOTOR_2;
     cf6:	82 e0       	ldi	r24, 0x02	; 2
     cf8:	80 93 fb 00 	sts	0x00FB, r24
    Ret=Pwm_Start(PWM_CH1B,Mot_Speed,30);
     cfc:	2e e1       	ldi	r18, 0x1E	; 30
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	40 e0       	ldi	r20, 0x00	; 0
     d02:	50 e0       	ldi	r21, 0x00	; 0
     d04:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
    break;
     d08:	08 95       	ret
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    gsv_is_Started=MOTOR_1 | MOTOR_2;
     d0a:	83 e0       	ldi	r24, 0x03	; 3
     d0c:	80 93 fb 00 	sts	0x00FB, r24
    Ret=Pwm_Start(PWM_CH1B,Mot_Speed,30);
     d10:	82 e0       	ldi	r24, 0x02	; 2
     d12:	2e e1       	ldi	r18, 0x1E	; 30
     d14:	30 e0       	ldi	r19, 0x00	; 0
     d16:	40 e0       	ldi	r20, 0x00	; 0
     d18:	50 e0       	ldi	r21, 0x00	; 0
     d1a:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
    break;
     d1e:	08 95       	ret
  }
  default:
  Ret=E_NOK;
     d20:	81 e0       	ldi	r24, 0x01	; 1
  break;
}


return Ret;
}
     d22:	08 95       	ret

00000d24 <Motor_SpeedUpdate>:
ERROR_STATUS Motor_SpeedUpdate(uint8_t Motor_Number, uint8_t Speed)
{
  uint8_t Ret=0;

switch (Motor_Number) {
     d24:	82 30       	cpi	r24, 0x02	; 2
     d26:	79 f0       	breq	.+30     	; 0xd46 <Motor_SpeedUpdate+0x22>
     d28:	83 30       	cpi	r24, 0x03	; 3
     d2a:	c1 f0       	breq	.+48     	; 0xd5c <Motor_SpeedUpdate+0x38>
     d2c:	81 30       	cpi	r24, 0x01	; 1
     d2e:	11 f5       	brne	.+68     	; 0xd74 <Motor_SpeedUpdate+0x50>
  case MOTOR_1:
  { if(gsv_is_intialized == Motor_Number)
     d30:	80 91 fa 00 	lds	r24, 0x00FA
     d34:	81 30       	cpi	r24, 0x01	; 1
     d36:	01 f5       	brne	.+64     	; 0xd78 <Motor_SpeedUpdate+0x54>
    Ret=Pwm_Start(PWM_CH1A,Speed,30);
     d38:	2e e1       	ldi	r18, 0x1E	; 30
     d3a:	30 e0       	ldi	r19, 0x00	; 0
     d3c:	40 e0       	ldi	r20, 0x00	; 0
     d3e:	50 e0       	ldi	r21, 0x00	; 0
     d40:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
     d44:	08 95       	ret
    else{Ret=E_NOK;}
    break;
  }
  case MOTOR_2:
  {
    if(gsv_is_intialized == Motor_Number)
     d46:	80 91 fa 00 	lds	r24, 0x00FA
     d4a:	82 30       	cpi	r24, 0x02	; 2
     d4c:	b9 f4       	brne	.+46     	; 0xd7c <Motor_SpeedUpdate+0x58>
      Ret=Pwm_Start(PWM_CH1B,Speed,30);
     d4e:	2e e1       	ldi	r18, 0x1E	; 30
     d50:	30 e0       	ldi	r19, 0x00	; 0
     d52:	40 e0       	ldi	r20, 0x00	; 0
     d54:	50 e0       	ldi	r21, 0x00	; 0
     d56:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
     d5a:	08 95       	ret
      else{Ret=E_NOK;}
    break;
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    if(gsv_is_intialized == Motor_Number)
     d5c:	80 91 fa 00 	lds	r24, 0x00FA
     d60:	83 30       	cpi	r24, 0x03	; 3
     d62:	71 f4       	brne	.+28     	; 0xd80 <Motor_SpeedUpdate+0x5c>
        Ret=Pwm_Start(PWM_CH1B,Speed,30);
     d64:	82 e0       	ldi	r24, 0x02	; 2
     d66:	2e e1       	ldi	r18, 0x1E	; 30
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	40 e0       	ldi	r20, 0x00	; 0
     d6c:	50 e0       	ldi	r21, 0x00	; 0
     d6e:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
     d72:	08 95       	ret
        else{Ret=E_NOK;}
    break;
  }
  default:
  Ret=E_NOK;
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	08 95       	ret

switch (Motor_Number) {
  case MOTOR_1:
  { if(gsv_is_intialized == Motor_Number)
    Ret=Pwm_Start(PWM_CH1A,Speed,30);
    else{Ret=E_NOK;}
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	08 95       	ret
  }
  case MOTOR_2:
  {
    if(gsv_is_intialized == Motor_Number)
      Ret=Pwm_Start(PWM_CH1B,Speed,30);
      else{Ret=E_NOK;}
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	08 95       	ret
  }
  case ( MOTOR_1 | MOTOR_2 ) :
  {
    if(gsv_is_intialized == Motor_Number)
        Ret=Pwm_Start(PWM_CH1B,Speed,30);
        else{Ret=E_NOK;}
     d80:	81 e0       	ldi	r24, 0x01	; 1
  Ret=E_NOK;
  break;
}

return Ret;
}
     d82:	08 95       	ret

00000d84 <Motor_Stop>:

ERROR_STATUS Motor_Stop(uint8_t Motor_Number)
{
	uint8_t Ret=0;
	switch(Motor_Number)
     d84:	81 30       	cpi	r24, 0x01	; 1
     d86:	19 f0       	breq	.+6      	; 0xd8e <Motor_Stop+0xa>
     d88:	82 30       	cpi	r24, 0x02	; 2
     d8a:	49 f4       	brne	.+18     	; 0xd9e <Motor_Stop+0x1a>
     d8c:	04 c0       	rjmp	.+8      	; 0xd96 <Motor_Stop+0x12>
	{
		case MOTOR_1 :
		Ret=Pwm_Stop(PWM_CH1A);
     d8e:	81 e0       	ldi	r24, 0x01	; 1
     d90:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <Pwm_Stop>
		break;
     d94:	08 95       	ret
		case MOTOR_2:
		Ret=Pwm_Stop(PWM_CH1B);
     d96:	82 e0       	ldi	r24, 0x02	; 2
     d98:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <Pwm_Stop>
		break;
     d9c:	08 95       	ret
		default:
		Ret=E_NOK;
     d9e:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}


	return Ret;
}
     da0:	08 95       	ret

00000da2 <Motor_GetStatus>:

 ERROR_STATUS Motor_GetStatus(uint8_t Motor_Number, uint8_t* Mot_status)
 {
	 if(gsv_is_intialized == Motor_Number)
     da2:	90 91 fa 00 	lds	r25, 0x00FA
     da6:	98 17       	cp	r25, r24
     da8:	21 f4       	brne	.+8      	; 0xdb2 <Motor_GetStatus+0x10>
		*Mot_status=1;
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	fb 01       	movw	r30, r22
     dae:	80 83       	st	Z, r24
     db0:	08 95       	ret
	 else
	 {
		*Mot_status=0;
     db2:	fb 01       	movw	r30, r22
     db4:	10 82       	st	Z, r1
	 }
	 
 }
     db6:	08 95       	ret

00000db8 <SwDelay_ms>:
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     db8:	dc 01       	movw	r26, r24
     dba:	cb 01       	movw	r24, r22
	uint8_t counter_256;
	uint8_t counter_21;
	while (n)
     dbc:	00 97       	sbiw	r24, 0x00	; 0
     dbe:	a1 05       	cpc	r26, r1
     dc0:	b1 05       	cpc	r27, r1
     dc2:	61 f4       	brne	.+24     	; 0xddc <SwDelay_ms+0x24>
     dc4:	08 95       	ret
     dc6:	21 50       	subi	r18, 0x01	; 1
		counter_21 = 21;
		while (counter_21)
		{
			/* every 256 branch costs 48 micro seconds */
			counter_256 = 255;
			while (counter_256)
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <SwDelay_ms+0xe>
     dca:	31 50       	subi	r19, 0x01	; 1
	uint8_t counter_21;
	while (n)
	{
		/* every 21 repetition of the 256 branches costs almost 1 milli second as: 48 micro x 21 = 1.008 milli second*/
		counter_21 = 21;
		while (counter_21)
     dcc:	11 f0       	breq	.+4      	; 0xdd2 <SwDelay_ms+0x1a>
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     dce:	24 2f       	mov	r18, r20
     dd0:	fa cf       	rjmp	.-12     	; 0xdc6 <SwDelay_ms+0xe>
			{
				counter_256--;
			}
			counter_21--;
		}
		n--;
     dd2:	01 97       	sbiw	r24, 0x01	; 1
     dd4:	a1 09       	sbc	r26, r1
     dd6:	b1 09       	sbc	r27, r1
 */
void SwDelay_ms(uint32_t n)
{
	uint8_t counter_256;
	uint8_t counter_21;
	while (n)
     dd8:	19 f4       	brne	.+6      	; 0xde0 <SwDelay_ms+0x28>
     dda:	08 95       	ret
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the milli-seconds
 */
void SwDelay_ms(uint32_t n)
{
     ddc:	55 e1       	ldi	r21, 0x15	; 21
     dde:	4f ef       	ldi	r20, 0xFF	; 255
     de0:	35 2f       	mov	r19, r21
     de2:	f5 cf       	rjmp	.-22     	; 0xdce <SwDelay_ms+0x16>

00000de4 <SwDelay_us>:
 * Description: this delay function operate in a polling manner
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32_t n)
{
     de4:	dc 01       	movw	r26, r24
     de6:	cb 01       	movw	r24, r22
	while (n)
     de8:	00 97       	sbiw	r24, 0x00	; 0
     dea:	a1 05       	cpc	r26, r1
     dec:	b1 05       	cpc	r27, r1
     dee:	21 f0       	breq	.+8      	; 0xdf8 <SwDelay_us+0x14>
	{
		n--;
     df0:	01 97       	sbiw	r24, 0x01	; 1
     df2:	a1 09       	sbc	r26, r1
     df4:	b1 09       	sbc	r27, r1
 * 				don't use it with RTOSs
 * @param n: the micro-seconds
 */
void SwDelay_us(uint32_t n)
{
	while (n)
     df6:	e1 f7       	brne	.-8      	; 0xdf0 <SwDelay_us+0xc>
     df8:	08 95       	ret

00000dfa <Us_Init>:
 *                                                                                                  *
 ***************************************************************************************************/

ERROR_STATUS Us_Init(void)
{uint8_t Ret;
Ret=DIO_init(&US_Configuration);
     dfa:	8b e7       	ldi	r24, 0x7B	; 123
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
Ret=Icu_Init(&ICU_Configuration);
     e02:	8a ec       	ldi	r24, 0xCA	; 202
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	0e 94 37 0c 	call	0x186e	; 0x186e <Icu_Init>
return Ret;
}
     e0a:	08 95       	ret

00000e0c <Us_Trigger>:
ERROR_STATUS Us_Trigger(void)
{uint8_t Ret=0;
Ret=DIO_Write(GPIOC,BIT4,HIGH);
     e0c:	82 e0       	ldi	r24, 0x02	; 2
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	60 e1       	ldi	r22, 0x10	; 16
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	4f ef       	ldi	r20, 0xFF	; 255
     e16:	50 e0       	ldi	r21, 0x00	; 0
     e18:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
/***********************************************/
Timer_Start(TIMER_CH0,10);
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	6a e0       	ldi	r22, 0x0A	; 10
     e20:	70 e0       	ldi	r23, 0x00	; 0
     e22:	0e 94 94 10 	call	0x2128	; 0x2128 <Timer_Start>
/**********************************************/
Ret=DIO_Write(GPIOC,BIT4,LOW);
     e26:	82 e0       	ldi	r24, 0x02	; 2
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	60 e1       	ldi	r22, 0x10	; 16
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	40 e0       	ldi	r20, 0x00	; 0
     e30:	50 e0       	ldi	r21, 0x00	; 0
     e32:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
return Ret;	
}
     e36:	08 95       	ret

00000e38 <Us_GetDistance>:


ERROR_STATUS Us_GetDistance(uint16_t *Distance)
{uint8_t Ret=0;
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
     e40:	00 d0       	rcall	.+0      	; 0xe42 <Us_GetDistance+0xa>
     e42:	00 d0       	rcall	.+0      	; 0xe44 <Us_GetDistance+0xc>
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	8c 01       	movw	r16, r24
	uint32_t u32l_Time;
	Ret=Icu_ReadTime(ICU_CH2,ICU_RISE_TO_FALL,&u32l_Time);
     e4a:	82 e0       	ldi	r24, 0x02	; 2
     e4c:	61 e0       	ldi	r22, 0x01	; 1
     e4e:	ae 01       	movw	r20, r28
     e50:	4f 5f       	subi	r20, 0xFF	; 255
     e52:	5f 4f       	sbci	r21, 0xFF	; 255
     e54:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <Icu_ReadTime>
	*Distance=u32l_Time;
     e58:	29 81       	ldd	r18, Y+1	; 0x01
     e5a:	3a 81       	ldd	r19, Y+2	; 0x02
     e5c:	f8 01       	movw	r30, r16
     e5e:	31 83       	std	Z+1, r19	; 0x01
     e60:	20 83       	st	Z, r18
	return Ret;
}
     e62:	0f 90       	pop	r0
     e64:	0f 90       	pop	r0
     e66:	0f 90       	pop	r0
     e68:	0f 90       	pop	r0
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	1f 91       	pop	r17
     e70:	0f 91       	pop	r16
     e72:	08 95       	ret

00000e74 <G_interrupt_Enable>:
ptr_to_Fun TWI_I2C;
ptr_to_Fun SPM_RDY;

void G_interrupt_Enable(void)
{
 SREG |=(0x80);
     e74:	8f b7       	in	r24, 0x3f	; 63
     e76:	80 68       	ori	r24, 0x80	; 128
     e78:	8f bf       	out	0x3f, r24	; 63
}
     e7a:	08 95       	ret

00000e7c <EX_interrupt_enable2>:
void EX_interrupt_enable2(void)
{
CLEAR_BIT(PORTB_DIR,2);/*Input*/
     e7c:	ba 98       	cbi	0x17, 2	; 23
SET_BIT(PORTB_DATA,2);/*Pullup*/
     e7e:	c2 9a       	sbi	0x18, 2	; 24
SET_BIT(GICR,INT2);/*EXT2*/
     e80:	8b b7       	in	r24, 0x3b	; 59
     e82:	80 62       	ori	r24, 0x20	; 32
     e84:	8b bf       	out	0x3b, r24	; 59
SET_BIT(MCUCSR,6);/*Rising*/
     e86:	84 b7       	in	r24, 0x34	; 52
     e88:	80 64       	ori	r24, 0x40	; 64
     e8a:	84 bf       	out	0x34, r24	; 52
}
     e8c:	08 95       	ret

00000e8e <EX_interrupt_enable1>:
void EX_interrupt_enable1(void)
{
	CLEAR_BIT(PORTD_DIR,3);
     e8e:	8b 98       	cbi	0x11, 3	; 17
	SET_BIT(PORTD_DATA,3);
     e90:	93 9a       	sbi	0x12, 3	; 18
	SET_BIT(GICR,INT1);
     e92:	8b b7       	in	r24, 0x3b	; 59
     e94:	80 68       	ori	r24, 0x80	; 128
     e96:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(MCUCR,2);/*Any logical change*/
     e98:	85 b7       	in	r24, 0x35	; 53
     e9a:	84 60       	ori	r24, 0x04	; 4
     e9c:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR,3);
     e9e:	85 b7       	in	r24, 0x35	; 53
     ea0:	87 7f       	andi	r24, 0xF7	; 247
     ea2:	85 bf       	out	0x35, r24	; 53
}
     ea4:	08 95       	ret

00000ea6 <EX_interrupt_enable0>:
void EX_interrupt_enable0(void)
{
	CLEAR_BIT(PORTD_DIR,2);
     ea6:	8a 98       	cbi	0x11, 2	; 17
	SET_BIT(PORTD_DATA,2);
     ea8:	92 9a       	sbi	0x12, 2	; 18
	SET_BIT(GICR,INT0);
     eaa:	8b b7       	in	r24, 0x3b	; 59
     eac:	80 64       	ori	r24, 0x40	; 64
     eae:	8b bf       	out	0x3b, r24	; 59
	SET_BIT(MCUCR,0);/*Any logical change*/
     eb0:	85 b7       	in	r24, 0x35	; 53
     eb2:	81 60       	ori	r24, 0x01	; 1
     eb4:	85 bf       	out	0x35, r24	; 53
	CLEAR_BIT(MCUCR,1);
     eb6:	85 b7       	in	r24, 0x35	; 53
     eb8:	8d 7f       	andi	r24, 0xFD	; 253
     eba:	85 bf       	out	0x35, r24	; 53
	
}
     ebc:	08 95       	ret

00000ebe <G_interrupt_Disable>:
void G_interrupt_Disable(void)
{
CLEAR_BIT(SREG,7);
     ebe:	8f b7       	in	r24, 0x3f	; 63
     ec0:	8f 77       	andi	r24, 0x7F	; 127
     ec2:	8f bf       	out	0x3f, r24	; 63
}
     ec4:	08 95       	ret

00000ec6 <__vector_1>:
void __vector_1(void) __attribute__((signal));
void __vector_1(void)
{
     ec6:	1f 92       	push	r1
     ec8:	0f 92       	push	r0
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	0f 92       	push	r0
     ece:	11 24       	eor	r1, r1
     ed0:	2f 93       	push	r18
     ed2:	3f 93       	push	r19
     ed4:	4f 93       	push	r20
     ed6:	5f 93       	push	r21
     ed8:	6f 93       	push	r22
     eda:	7f 93       	push	r23
     edc:	8f 93       	push	r24
     ede:	9f 93       	push	r25
     ee0:	af 93       	push	r26
     ee2:	bf 93       	push	r27
     ee4:	ef 93       	push	r30
     ee6:	ff 93       	push	r31
  INT0_external_interrupt();
     ee8:	e0 91 8d 05 	lds	r30, 0x058D
     eec:	f0 91 8e 05 	lds	r31, 0x058E
     ef0:	09 95       	icall
}
     ef2:	ff 91       	pop	r31
     ef4:	ef 91       	pop	r30
     ef6:	bf 91       	pop	r27
     ef8:	af 91       	pop	r26
     efa:	9f 91       	pop	r25
     efc:	8f 91       	pop	r24
     efe:	7f 91       	pop	r23
     f00:	6f 91       	pop	r22
     f02:	5f 91       	pop	r21
     f04:	4f 91       	pop	r20
     f06:	3f 91       	pop	r19
     f08:	2f 91       	pop	r18
     f0a:	0f 90       	pop	r0
     f0c:	0f be       	out	0x3f, r0	; 63
     f0e:	0f 90       	pop	r0
     f10:	1f 90       	pop	r1
     f12:	18 95       	reti

00000f14 <__vector_2>:


void __vector_2(void) __attribute__((signal));
void __vector_2(void)
{
     f14:	1f 92       	push	r1
     f16:	0f 92       	push	r0
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	0f 92       	push	r0
     f1c:	11 24       	eor	r1, r1
     f1e:	2f 93       	push	r18
     f20:	3f 93       	push	r19
     f22:	4f 93       	push	r20
     f24:	5f 93       	push	r21
     f26:	6f 93       	push	r22
     f28:	7f 93       	push	r23
     f2a:	8f 93       	push	r24
     f2c:	9f 93       	push	r25
     f2e:	af 93       	push	r26
     f30:	bf 93       	push	r27
     f32:	ef 93       	push	r30
     f34:	ff 93       	push	r31
  INT1_external_interrupt();
     f36:	e0 91 95 05 	lds	r30, 0x0595
     f3a:	f0 91 96 05 	lds	r31, 0x0596
     f3e:	09 95       	icall
}
     f40:	ff 91       	pop	r31
     f42:	ef 91       	pop	r30
     f44:	bf 91       	pop	r27
     f46:	af 91       	pop	r26
     f48:	9f 91       	pop	r25
     f4a:	8f 91       	pop	r24
     f4c:	7f 91       	pop	r23
     f4e:	6f 91       	pop	r22
     f50:	5f 91       	pop	r21
     f52:	4f 91       	pop	r20
     f54:	3f 91       	pop	r19
     f56:	2f 91       	pop	r18
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	0f 90       	pop	r0
     f5e:	1f 90       	pop	r1
     f60:	18 95       	reti

00000f62 <__vector_3>:


void __vector_3(void) __attribute__((signal));
void __vector_3(void)
{
     f62:	1f 92       	push	r1
     f64:	0f 92       	push	r0
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	0f 92       	push	r0
     f6a:	11 24       	eor	r1, r1
     f6c:	2f 93       	push	r18
     f6e:	3f 93       	push	r19
     f70:	4f 93       	push	r20
     f72:	5f 93       	push	r21
     f74:	6f 93       	push	r22
     f76:	7f 93       	push	r23
     f78:	8f 93       	push	r24
     f7a:	9f 93       	push	r25
     f7c:	af 93       	push	r26
     f7e:	bf 93       	push	r27
     f80:	ef 93       	push	r30
     f82:	ff 93       	push	r31
  INT2_external_interrupt();
     f84:	e0 91 85 05 	lds	r30, 0x0585
     f88:	f0 91 86 05 	lds	r31, 0x0586
     f8c:	09 95       	icall
}
     f8e:	ff 91       	pop	r31
     f90:	ef 91       	pop	r30
     f92:	bf 91       	pop	r27
     f94:	af 91       	pop	r26
     f96:	9f 91       	pop	r25
     f98:	8f 91       	pop	r24
     f9a:	7f 91       	pop	r23
     f9c:	6f 91       	pop	r22
     f9e:	5f 91       	pop	r21
     fa0:	4f 91       	pop	r20
     fa2:	3f 91       	pop	r19
     fa4:	2f 91       	pop	r18
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63
     faa:	0f 90       	pop	r0
     fac:	1f 90       	pop	r1
     fae:	18 95       	reti

00000fb0 <__vector_4>:


void __vector_4(void) __attribute__((signal));
void __vector_4(void)
{
     fb0:	1f 92       	push	r1
     fb2:	0f 92       	push	r0
     fb4:	0f b6       	in	r0, 0x3f	; 63
     fb6:	0f 92       	push	r0
     fb8:	11 24       	eor	r1, r1
     fba:	2f 93       	push	r18
     fbc:	3f 93       	push	r19
     fbe:	4f 93       	push	r20
     fc0:	5f 93       	push	r21
     fc2:	6f 93       	push	r22
     fc4:	7f 93       	push	r23
     fc6:	8f 93       	push	r24
     fc8:	9f 93       	push	r25
     fca:	af 93       	push	r26
     fcc:	bf 93       	push	r27
     fce:	ef 93       	push	r30
     fd0:	ff 93       	push	r31
TIMER2COMP();
     fd2:	e0 91 9b 05 	lds	r30, 0x059B
     fd6:	f0 91 9c 05 	lds	r31, 0x059C
     fda:	09 95       	icall
}
     fdc:	ff 91       	pop	r31
     fde:	ef 91       	pop	r30
     fe0:	bf 91       	pop	r27
     fe2:	af 91       	pop	r26
     fe4:	9f 91       	pop	r25
     fe6:	8f 91       	pop	r24
     fe8:	7f 91       	pop	r23
     fea:	6f 91       	pop	r22
     fec:	5f 91       	pop	r21
     fee:	4f 91       	pop	r20
     ff0:	3f 91       	pop	r19
     ff2:	2f 91       	pop	r18
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	0f 90       	pop	r0
     ffa:	1f 90       	pop	r1
     ffc:	18 95       	reti

00000ffe <__vector_5>:


void __vector_5(void) __attribute__((signal));
void __vector_5(void)
{
     ffe:	1f 92       	push	r1
    1000:	0f 92       	push	r0
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	0f 92       	push	r0
    1006:	11 24       	eor	r1, r1
    1008:	2f 93       	push	r18
    100a:	3f 93       	push	r19
    100c:	4f 93       	push	r20
    100e:	5f 93       	push	r21
    1010:	6f 93       	push	r22
    1012:	7f 93       	push	r23
    1014:	8f 93       	push	r24
    1016:	9f 93       	push	r25
    1018:	af 93       	push	r26
    101a:	bf 93       	push	r27
    101c:	ef 93       	push	r30
    101e:	ff 93       	push	r31
  TIMER2OVF();
    1020:	e0 91 7b 05 	lds	r30, 0x057B
    1024:	f0 91 7c 05 	lds	r31, 0x057C
    1028:	09 95       	icall
}
    102a:	ff 91       	pop	r31
    102c:	ef 91       	pop	r30
    102e:	bf 91       	pop	r27
    1030:	af 91       	pop	r26
    1032:	9f 91       	pop	r25
    1034:	8f 91       	pop	r24
    1036:	7f 91       	pop	r23
    1038:	6f 91       	pop	r22
    103a:	5f 91       	pop	r21
    103c:	4f 91       	pop	r20
    103e:	3f 91       	pop	r19
    1040:	2f 91       	pop	r18
    1042:	0f 90       	pop	r0
    1044:	0f be       	out	0x3f, r0	; 63
    1046:	0f 90       	pop	r0
    1048:	1f 90       	pop	r1
    104a:	18 95       	reti

0000104c <__vector_6>:

void __vector_6(void) __attribute__((signal));
void __vector_6(void)
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	11 24       	eor	r1, r1
    1056:	2f 93       	push	r18
    1058:	3f 93       	push	r19
    105a:	4f 93       	push	r20
    105c:	5f 93       	push	r21
    105e:	6f 93       	push	r22
    1060:	7f 93       	push	r23
    1062:	8f 93       	push	r24
    1064:	9f 93       	push	r25
    1066:	af 93       	push	r26
    1068:	bf 93       	push	r27
    106a:	ef 93       	push	r30
    106c:	ff 93       	push	r31
  TIMER1CAPT();
    106e:	e0 91 97 05 	lds	r30, 0x0597
    1072:	f0 91 98 05 	lds	r31, 0x0598
    1076:	09 95       	icall
}
    1078:	ff 91       	pop	r31
    107a:	ef 91       	pop	r30
    107c:	bf 91       	pop	r27
    107e:	af 91       	pop	r26
    1080:	9f 91       	pop	r25
    1082:	8f 91       	pop	r24
    1084:	7f 91       	pop	r23
    1086:	6f 91       	pop	r22
    1088:	5f 91       	pop	r21
    108a:	4f 91       	pop	r20
    108c:	3f 91       	pop	r19
    108e:	2f 91       	pop	r18
    1090:	0f 90       	pop	r0
    1092:	0f be       	out	0x3f, r0	; 63
    1094:	0f 90       	pop	r0
    1096:	1f 90       	pop	r1
    1098:	18 95       	reti

0000109a <__vector_7>:

void __vector_7(void) __attribute__((signal));
void __vector_7(void)
{
    109a:	1f 92       	push	r1
    109c:	0f 92       	push	r0
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	0f 92       	push	r0
    10a2:	11 24       	eor	r1, r1
    10a4:	2f 93       	push	r18
    10a6:	3f 93       	push	r19
    10a8:	4f 93       	push	r20
    10aa:	5f 93       	push	r21
    10ac:	6f 93       	push	r22
    10ae:	7f 93       	push	r23
    10b0:	8f 93       	push	r24
    10b2:	9f 93       	push	r25
    10b4:	af 93       	push	r26
    10b6:	bf 93       	push	r27
    10b8:	ef 93       	push	r30
    10ba:	ff 93       	push	r31
TIMER1COMPA();
    10bc:	e0 91 81 05 	lds	r30, 0x0581
    10c0:	f0 91 82 05 	lds	r31, 0x0582
    10c4:	09 95       	icall
}
    10c6:	ff 91       	pop	r31
    10c8:	ef 91       	pop	r30
    10ca:	bf 91       	pop	r27
    10cc:	af 91       	pop	r26
    10ce:	9f 91       	pop	r25
    10d0:	8f 91       	pop	r24
    10d2:	7f 91       	pop	r23
    10d4:	6f 91       	pop	r22
    10d6:	5f 91       	pop	r21
    10d8:	4f 91       	pop	r20
    10da:	3f 91       	pop	r19
    10dc:	2f 91       	pop	r18
    10de:	0f 90       	pop	r0
    10e0:	0f be       	out	0x3f, r0	; 63
    10e2:	0f 90       	pop	r0
    10e4:	1f 90       	pop	r1
    10e6:	18 95       	reti

000010e8 <__vector_8>:

void __vector_8(void) __attribute__((signal));
void __vector_8(void)
{
    10e8:	1f 92       	push	r1
    10ea:	0f 92       	push	r0
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	0f 92       	push	r0
    10f0:	11 24       	eor	r1, r1
    10f2:	2f 93       	push	r18
    10f4:	3f 93       	push	r19
    10f6:	4f 93       	push	r20
    10f8:	5f 93       	push	r21
    10fa:	6f 93       	push	r22
    10fc:	7f 93       	push	r23
    10fe:	8f 93       	push	r24
    1100:	9f 93       	push	r25
    1102:	af 93       	push	r26
    1104:	bf 93       	push	r27
    1106:	ef 93       	push	r30
    1108:	ff 93       	push	r31
  TIMER1COMPB();
    110a:	e0 91 7f 05 	lds	r30, 0x057F
    110e:	f0 91 80 05 	lds	r31, 0x0580
    1112:	09 95       	icall
}
    1114:	ff 91       	pop	r31
    1116:	ef 91       	pop	r30
    1118:	bf 91       	pop	r27
    111a:	af 91       	pop	r26
    111c:	9f 91       	pop	r25
    111e:	8f 91       	pop	r24
    1120:	7f 91       	pop	r23
    1122:	6f 91       	pop	r22
    1124:	5f 91       	pop	r21
    1126:	4f 91       	pop	r20
    1128:	3f 91       	pop	r19
    112a:	2f 91       	pop	r18
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	0f 90       	pop	r0
    1132:	1f 90       	pop	r1
    1134:	18 95       	reti

00001136 <__vector_9>:

void __vector_9(void) __attribute__((signal));
void __vector_9(void)
{
    1136:	1f 92       	push	r1
    1138:	0f 92       	push	r0
    113a:	0f b6       	in	r0, 0x3f	; 63
    113c:	0f 92       	push	r0
    113e:	11 24       	eor	r1, r1
    1140:	2f 93       	push	r18
    1142:	3f 93       	push	r19
    1144:	4f 93       	push	r20
    1146:	5f 93       	push	r21
    1148:	6f 93       	push	r22
    114a:	7f 93       	push	r23
    114c:	8f 93       	push	r24
    114e:	9f 93       	push	r25
    1150:	af 93       	push	r26
    1152:	bf 93       	push	r27
    1154:	ef 93       	push	r30
    1156:	ff 93       	push	r31
  TIMER1OVF();
    1158:	e0 91 99 05 	lds	r30, 0x0599
    115c:	f0 91 9a 05 	lds	r31, 0x059A
    1160:	09 95       	icall
}
    1162:	ff 91       	pop	r31
    1164:	ef 91       	pop	r30
    1166:	bf 91       	pop	r27
    1168:	af 91       	pop	r26
    116a:	9f 91       	pop	r25
    116c:	8f 91       	pop	r24
    116e:	7f 91       	pop	r23
    1170:	6f 91       	pop	r22
    1172:	5f 91       	pop	r21
    1174:	4f 91       	pop	r20
    1176:	3f 91       	pop	r19
    1178:	2f 91       	pop	r18
    117a:	0f 90       	pop	r0
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	0f 90       	pop	r0
    1180:	1f 90       	pop	r1
    1182:	18 95       	reti

00001184 <__vector_10>:

void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
    1184:	1f 92       	push	r1
    1186:	0f 92       	push	r0
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	0f 92       	push	r0
    118c:	11 24       	eor	r1, r1
    118e:	2f 93       	push	r18
    1190:	3f 93       	push	r19
    1192:	4f 93       	push	r20
    1194:	5f 93       	push	r21
    1196:	6f 93       	push	r22
    1198:	7f 93       	push	r23
    119a:	8f 93       	push	r24
    119c:	9f 93       	push	r25
    119e:	af 93       	push	r26
    11a0:	bf 93       	push	r27
    11a2:	ef 93       	push	r30
    11a4:	ff 93       	push	r31

  TIMER0COMP();
    11a6:	e0 91 91 05 	lds	r30, 0x0591
    11aa:	f0 91 92 05 	lds	r31, 0x0592
    11ae:	09 95       	icall
}
    11b0:	ff 91       	pop	r31
    11b2:	ef 91       	pop	r30
    11b4:	bf 91       	pop	r27
    11b6:	af 91       	pop	r26
    11b8:	9f 91       	pop	r25
    11ba:	8f 91       	pop	r24
    11bc:	7f 91       	pop	r23
    11be:	6f 91       	pop	r22
    11c0:	5f 91       	pop	r21
    11c2:	4f 91       	pop	r20
    11c4:	3f 91       	pop	r19
    11c6:	2f 91       	pop	r18
    11c8:	0f 90       	pop	r0
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	0f 90       	pop	r0
    11ce:	1f 90       	pop	r1
    11d0:	18 95       	reti

000011d2 <__vector_11>:

void __vector_11(void) __attribute__((signal));
void __vector_11(void)
{
    11d2:	1f 92       	push	r1
    11d4:	0f 92       	push	r0
    11d6:	0f b6       	in	r0, 0x3f	; 63
    11d8:	0f 92       	push	r0
    11da:	11 24       	eor	r1, r1
    11dc:	2f 93       	push	r18
    11de:	3f 93       	push	r19
    11e0:	4f 93       	push	r20
    11e2:	5f 93       	push	r21
    11e4:	6f 93       	push	r22
    11e6:	7f 93       	push	r23
    11e8:	8f 93       	push	r24
    11ea:	9f 93       	push	r25
    11ec:	af 93       	push	r26
    11ee:	bf 93       	push	r27
    11f0:	ef 93       	push	r30
    11f2:	ff 93       	push	r31

  TIMER0OVF_INT();
    11f4:	e0 91 7e 00 	lds	r30, 0x007E
    11f8:	f0 91 7f 00 	lds	r31, 0x007F
    11fc:	09 95       	icall
}
    11fe:	ff 91       	pop	r31
    1200:	ef 91       	pop	r30
    1202:	bf 91       	pop	r27
    1204:	af 91       	pop	r26
    1206:	9f 91       	pop	r25
    1208:	8f 91       	pop	r24
    120a:	7f 91       	pop	r23
    120c:	6f 91       	pop	r22
    120e:	5f 91       	pop	r21
    1210:	4f 91       	pop	r20
    1212:	3f 91       	pop	r19
    1214:	2f 91       	pop	r18
    1216:	0f 90       	pop	r0
    1218:	0f be       	out	0x3f, r0	; 63
    121a:	0f 90       	pop	r0
    121c:	1f 90       	pop	r1
    121e:	18 95       	reti

00001220 <__vector_12>:

void __vector_12(void) __attribute__((signal));
void __vector_12(void)
{
    1220:	1f 92       	push	r1
    1222:	0f 92       	push	r0
    1224:	0f b6       	in	r0, 0x3f	; 63
    1226:	0f 92       	push	r0
    1228:	11 24       	eor	r1, r1
    122a:	2f 93       	push	r18
    122c:	3f 93       	push	r19
    122e:	4f 93       	push	r20
    1230:	5f 93       	push	r21
    1232:	6f 93       	push	r22
    1234:	7f 93       	push	r23
    1236:	8f 93       	push	r24
    1238:	9f 93       	push	r25
    123a:	af 93       	push	r26
    123c:	bf 93       	push	r27
    123e:	ef 93       	push	r30
    1240:	ff 93       	push	r31
  SPI_STC();
    1242:	e0 91 83 05 	lds	r30, 0x0583
    1246:	f0 91 84 05 	lds	r31, 0x0584
    124a:	09 95       	icall
}
    124c:	ff 91       	pop	r31
    124e:	ef 91       	pop	r30
    1250:	bf 91       	pop	r27
    1252:	af 91       	pop	r26
    1254:	9f 91       	pop	r25
    1256:	8f 91       	pop	r24
    1258:	7f 91       	pop	r23
    125a:	6f 91       	pop	r22
    125c:	5f 91       	pop	r21
    125e:	4f 91       	pop	r20
    1260:	3f 91       	pop	r19
    1262:	2f 91       	pop	r18
    1264:	0f 90       	pop	r0
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	0f 90       	pop	r0
    126a:	1f 90       	pop	r1
    126c:	18 95       	reti

0000126e <__vector_13>:

void __vector_13(void) __attribute__((signal));
void __vector_13(void)
{
    126e:	1f 92       	push	r1
    1270:	0f 92       	push	r0
    1272:	0f b6       	in	r0, 0x3f	; 63
    1274:	0f 92       	push	r0
    1276:	11 24       	eor	r1, r1
    1278:	2f 93       	push	r18
    127a:	3f 93       	push	r19
    127c:	4f 93       	push	r20
    127e:	5f 93       	push	r21
    1280:	6f 93       	push	r22
    1282:	7f 93       	push	r23
    1284:	8f 93       	push	r24
    1286:	9f 93       	push	r25
    1288:	af 93       	push	r26
    128a:	bf 93       	push	r27
    128c:	ef 93       	push	r30
    128e:	ff 93       	push	r31
  USART_RXC();
    1290:	e0 91 79 05 	lds	r30, 0x0579
    1294:	f0 91 7a 05 	lds	r31, 0x057A
    1298:	09 95       	icall
}
    129a:	ff 91       	pop	r31
    129c:	ef 91       	pop	r30
    129e:	bf 91       	pop	r27
    12a0:	af 91       	pop	r26
    12a2:	9f 91       	pop	r25
    12a4:	8f 91       	pop	r24
    12a6:	7f 91       	pop	r23
    12a8:	6f 91       	pop	r22
    12aa:	5f 91       	pop	r21
    12ac:	4f 91       	pop	r20
    12ae:	3f 91       	pop	r19
    12b0:	2f 91       	pop	r18
    12b2:	0f 90       	pop	r0
    12b4:	0f be       	out	0x3f, r0	; 63
    12b6:	0f 90       	pop	r0
    12b8:	1f 90       	pop	r1
    12ba:	18 95       	reti

000012bc <__vector_14>:

void __vector_14(void) __attribute__((signal));
void __vector_14(void)
{
    12bc:	1f 92       	push	r1
    12be:	0f 92       	push	r0
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	0f 92       	push	r0
    12c4:	11 24       	eor	r1, r1
    12c6:	2f 93       	push	r18
    12c8:	3f 93       	push	r19
    12ca:	4f 93       	push	r20
    12cc:	5f 93       	push	r21
    12ce:	6f 93       	push	r22
    12d0:	7f 93       	push	r23
    12d2:	8f 93       	push	r24
    12d4:	9f 93       	push	r25
    12d6:	af 93       	push	r26
    12d8:	bf 93       	push	r27
    12da:	ef 93       	push	r30
    12dc:	ff 93       	push	r31
  USART_UDRE();
    12de:	e0 91 93 05 	lds	r30, 0x0593
    12e2:	f0 91 94 05 	lds	r31, 0x0594
    12e6:	09 95       	icall
}
    12e8:	ff 91       	pop	r31
    12ea:	ef 91       	pop	r30
    12ec:	bf 91       	pop	r27
    12ee:	af 91       	pop	r26
    12f0:	9f 91       	pop	r25
    12f2:	8f 91       	pop	r24
    12f4:	7f 91       	pop	r23
    12f6:	6f 91       	pop	r22
    12f8:	5f 91       	pop	r21
    12fa:	4f 91       	pop	r20
    12fc:	3f 91       	pop	r19
    12fe:	2f 91       	pop	r18
    1300:	0f 90       	pop	r0
    1302:	0f be       	out	0x3f, r0	; 63
    1304:	0f 90       	pop	r0
    1306:	1f 90       	pop	r1
    1308:	18 95       	reti

0000130a <__vector_15>:

void __vector_15(void) __attribute__((signal));
void __vector_15(void)
{
    130a:	1f 92       	push	r1
    130c:	0f 92       	push	r0
    130e:	0f b6       	in	r0, 0x3f	; 63
    1310:	0f 92       	push	r0
    1312:	11 24       	eor	r1, r1
    1314:	2f 93       	push	r18
    1316:	3f 93       	push	r19
    1318:	4f 93       	push	r20
    131a:	5f 93       	push	r21
    131c:	6f 93       	push	r22
    131e:	7f 93       	push	r23
    1320:	8f 93       	push	r24
    1322:	9f 93       	push	r25
    1324:	af 93       	push	r26
    1326:	bf 93       	push	r27
    1328:	ef 93       	push	r30
    132a:	ff 93       	push	r31
  USART_TXC();
    132c:	e0 91 8f 05 	lds	r30, 0x058F
    1330:	f0 91 90 05 	lds	r31, 0x0590
    1334:	09 95       	icall
}
    1336:	ff 91       	pop	r31
    1338:	ef 91       	pop	r30
    133a:	bf 91       	pop	r27
    133c:	af 91       	pop	r26
    133e:	9f 91       	pop	r25
    1340:	8f 91       	pop	r24
    1342:	7f 91       	pop	r23
    1344:	6f 91       	pop	r22
    1346:	5f 91       	pop	r21
    1348:	4f 91       	pop	r20
    134a:	3f 91       	pop	r19
    134c:	2f 91       	pop	r18
    134e:	0f 90       	pop	r0
    1350:	0f be       	out	0x3f, r0	; 63
    1352:	0f 90       	pop	r0
    1354:	1f 90       	pop	r1
    1356:	18 95       	reti

00001358 <__vector_16>:

void __vector_16(void) __attribute__((signal));
void __vector_16(void)
{
    1358:	1f 92       	push	r1
    135a:	0f 92       	push	r0
    135c:	0f b6       	in	r0, 0x3f	; 63
    135e:	0f 92       	push	r0
    1360:	11 24       	eor	r1, r1
    1362:	2f 93       	push	r18
    1364:	3f 93       	push	r19
    1366:	4f 93       	push	r20
    1368:	5f 93       	push	r21
    136a:	6f 93       	push	r22
    136c:	7f 93       	push	r23
    136e:	8f 93       	push	r24
    1370:	9f 93       	push	r25
    1372:	af 93       	push	r26
    1374:	bf 93       	push	r27
    1376:	ef 93       	push	r30
    1378:	ff 93       	push	r31
  ADC_INT();
    137a:	e0 91 89 05 	lds	r30, 0x0589
    137e:	f0 91 8a 05 	lds	r31, 0x058A
    1382:	09 95       	icall
}
    1384:	ff 91       	pop	r31
    1386:	ef 91       	pop	r30
    1388:	bf 91       	pop	r27
    138a:	af 91       	pop	r26
    138c:	9f 91       	pop	r25
    138e:	8f 91       	pop	r24
    1390:	7f 91       	pop	r23
    1392:	6f 91       	pop	r22
    1394:	5f 91       	pop	r21
    1396:	4f 91       	pop	r20
    1398:	3f 91       	pop	r19
    139a:	2f 91       	pop	r18
    139c:	0f 90       	pop	r0
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	0f 90       	pop	r0
    13a2:	1f 90       	pop	r1
    13a4:	18 95       	reti

000013a6 <__vector_17>:

void __vector_17(void) __attribute__((signal));
void __vector_17(void)
{
    13a6:	1f 92       	push	r1
    13a8:	0f 92       	push	r0
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	0f 92       	push	r0
    13ae:	11 24       	eor	r1, r1
    13b0:	2f 93       	push	r18
    13b2:	3f 93       	push	r19
    13b4:	4f 93       	push	r20
    13b6:	5f 93       	push	r21
    13b8:	6f 93       	push	r22
    13ba:	7f 93       	push	r23
    13bc:	8f 93       	push	r24
    13be:	9f 93       	push	r25
    13c0:	af 93       	push	r26
    13c2:	bf 93       	push	r27
    13c4:	ef 93       	push	r30
    13c6:	ff 93       	push	r31
  EE_RDY();
    13c8:	e0 91 8b 05 	lds	r30, 0x058B
    13cc:	f0 91 8c 05 	lds	r31, 0x058C
    13d0:	09 95       	icall
}
    13d2:	ff 91       	pop	r31
    13d4:	ef 91       	pop	r30
    13d6:	bf 91       	pop	r27
    13d8:	af 91       	pop	r26
    13da:	9f 91       	pop	r25
    13dc:	8f 91       	pop	r24
    13de:	7f 91       	pop	r23
    13e0:	6f 91       	pop	r22
    13e2:	5f 91       	pop	r21
    13e4:	4f 91       	pop	r20
    13e6:	3f 91       	pop	r19
    13e8:	2f 91       	pop	r18
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	0f 90       	pop	r0
    13f0:	1f 90       	pop	r1
    13f2:	18 95       	reti

000013f4 <__vector_18>:

void __vector_18(void) __attribute__((signal));
void __vector_18(void)
{
    13f4:	1f 92       	push	r1
    13f6:	0f 92       	push	r0
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	0f 92       	push	r0
    13fc:	11 24       	eor	r1, r1
    13fe:	2f 93       	push	r18
    1400:	3f 93       	push	r19
    1402:	4f 93       	push	r20
    1404:	5f 93       	push	r21
    1406:	6f 93       	push	r22
    1408:	7f 93       	push	r23
    140a:	8f 93       	push	r24
    140c:	9f 93       	push	r25
    140e:	af 93       	push	r26
    1410:	bf 93       	push	r27
    1412:	ef 93       	push	r30
    1414:	ff 93       	push	r31
  ANA_COMP();
    1416:	e0 91 87 05 	lds	r30, 0x0587
    141a:	f0 91 88 05 	lds	r31, 0x0588
    141e:	09 95       	icall
}
    1420:	ff 91       	pop	r31
    1422:	ef 91       	pop	r30
    1424:	bf 91       	pop	r27
    1426:	af 91       	pop	r26
    1428:	9f 91       	pop	r25
    142a:	8f 91       	pop	r24
    142c:	7f 91       	pop	r23
    142e:	6f 91       	pop	r22
    1430:	5f 91       	pop	r21
    1432:	4f 91       	pop	r20
    1434:	3f 91       	pop	r19
    1436:	2f 91       	pop	r18
    1438:	0f 90       	pop	r0
    143a:	0f be       	out	0x3f, r0	; 63
    143c:	0f 90       	pop	r0
    143e:	1f 90       	pop	r1
    1440:	18 95       	reti

00001442 <__vector_19>:

void __vector_19(void) __attribute__((signal));
void __vector_19(void)
{
    1442:	1f 92       	push	r1
    1444:	0f 92       	push	r0
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	0f 92       	push	r0
    144a:	11 24       	eor	r1, r1
    144c:	2f 93       	push	r18
    144e:	3f 93       	push	r19
    1450:	4f 93       	push	r20
    1452:	5f 93       	push	r21
    1454:	6f 93       	push	r22
    1456:	7f 93       	push	r23
    1458:	8f 93       	push	r24
    145a:	9f 93       	push	r25
    145c:	af 93       	push	r26
    145e:	bf 93       	push	r27
    1460:	ef 93       	push	r30
    1462:	ff 93       	push	r31
  TWI_I2C();
    1464:	e0 91 77 05 	lds	r30, 0x0577
    1468:	f0 91 78 05 	lds	r31, 0x0578
    146c:	09 95       	icall
}
    146e:	ff 91       	pop	r31
    1470:	ef 91       	pop	r30
    1472:	bf 91       	pop	r27
    1474:	af 91       	pop	r26
    1476:	9f 91       	pop	r25
    1478:	8f 91       	pop	r24
    147a:	7f 91       	pop	r23
    147c:	6f 91       	pop	r22
    147e:	5f 91       	pop	r21
    1480:	4f 91       	pop	r20
    1482:	3f 91       	pop	r19
    1484:	2f 91       	pop	r18
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	0f 90       	pop	r0
    148c:	1f 90       	pop	r1
    148e:	18 95       	reti

00001490 <__vector_20>:

void __vector_20(void) __attribute__((signal));
void __vector_20(void)
{
    1490:	1f 92       	push	r1
    1492:	0f 92       	push	r0
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	0f 92       	push	r0
    1498:	11 24       	eor	r1, r1
    149a:	2f 93       	push	r18
    149c:	3f 93       	push	r19
    149e:	4f 93       	push	r20
    14a0:	5f 93       	push	r21
    14a2:	6f 93       	push	r22
    14a4:	7f 93       	push	r23
    14a6:	8f 93       	push	r24
    14a8:	9f 93       	push	r25
    14aa:	af 93       	push	r26
    14ac:	bf 93       	push	r27
    14ae:	ef 93       	push	r30
    14b0:	ff 93       	push	r31
  SPM_RDY();
    14b2:	e0 91 7d 05 	lds	r30, 0x057D
    14b6:	f0 91 7e 05 	lds	r31, 0x057E
    14ba:	09 95       	icall
}
    14bc:	ff 91       	pop	r31
    14be:	ef 91       	pop	r30
    14c0:	bf 91       	pop	r27
    14c2:	af 91       	pop	r26
    14c4:	9f 91       	pop	r25
    14c6:	8f 91       	pop	r24
    14c8:	7f 91       	pop	r23
    14ca:	6f 91       	pop	r22
    14cc:	5f 91       	pop	r21
    14ce:	4f 91       	pop	r20
    14d0:	3f 91       	pop	r19
    14d2:	2f 91       	pop	r18
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	0f 90       	pop	r0
    14da:	1f 90       	pop	r1
    14dc:	18 95       	reti

000014de <ADC_read_int>:
}
void ADC_read_int(void)
{


    14de:	08 95       	ret

000014e0 <ADC_INIT>:
#include "ADC.h"
static uint8_t arr_counter_of_ptr=0;
static ptr_to_Fun ADC_R[8]={ADC_Read0,ADC_Read1,ADC_Read2,ADC_Read3,ADC_Read4,ADC_Read5,ADC_Read6,ADC_Read7};
uint16_t u16_ADC_readings_Channel[8];
ERROR_STATUS ADC_INIT(ADC_Cfg_s *ADC_info)
{
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	ec 01       	movw	r28, r24
	uint8_t ret_error=E_OK;
	
	ADMUX |= (ADC_info->u8_voltage_refrences) ;
    14e6:	97 b1       	in	r25, 0x07	; 7
    14e8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ea:	89 2b       	or	r24, r25
    14ec:	87 b9       	out	0x07, r24	; 7
	if ((ADC_info ->u8_Channel_Number) != ADC_MULTIPLE_CHANNELS)
    14ee:	88 81       	ld	r24, Y
    14f0:	8f 3f       	cpi	r24, 0xFF	; 255
    14f2:	39 f0       	breq	.+14     	; 0x1502 <ADC_INIT+0x22>
	{
		ADMUX &= 0xf0;
    14f4:	87 b1       	in	r24, 0x07	; 7
    14f6:	80 7f       	andi	r24, 0xF0	; 240
    14f8:	87 b9       	out	0x07, r24	; 7
		ADMUX |=(ADC_info ->u8_Channel_Number);
    14fa:	97 b1       	in	r25, 0x07	; 7
    14fc:	88 81       	ld	r24, Y
    14fe:	89 2b       	or	r24, r25
    1500:	87 b9       	out	0x07, r24	; 7
	}
	ADMUX |= (ADC_info->u8_ten_bit_arrangment);
    1502:	97 b1       	in	r25, 0x07	; 7
    1504:	8b 81       	ldd	r24, Y+3	; 0x03
    1506:	89 2b       	or	r24, r25
    1508:	87 b9       	out	0x07, r24	; 7
	G_interrupt_Enable();
    150a:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
	ADCSRA |= (ADC_info ->u8_polling_interrupt);
    150e:	96 b1       	in	r25, 0x06	; 6
    1510:	8c 81       	ldd	r24, Y+4	; 0x04
    1512:	89 2b       	or	r24, r25
    1514:	86 b9       	out	0x06, r24	; 6
	ADC_INT = ADC_read_int;
    1516:	8f e6       	ldi	r24, 0x6F	; 111
    1518:	9a e0       	ldi	r25, 0x0A	; 10
    151a:	90 93 8a 05 	sts	0x058A, r25
    151e:	80 93 89 05 	sts	0x0589, r24
	ADCSRA |=(ADC_info->u8_Prescaler);
    1522:	96 b1       	in	r25, 0x06	; 6
    1524:	89 81       	ldd	r24, Y+1	; 0x01
    1526:	89 2b       	or	r24, r25
    1528:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 0x80;/*ADC ENABLE*/
    152a:	37 9a       	sbi	0x06, 7	; 6
	ADCSRA |= 0x40;//start conversion
    152c:	36 9a       	sbi	0x06, 6	; 6
	return ret_error;
}
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	df 91       	pop	r29
    1532:	cf 91       	pop	r28
    1534:	08 95       	ret

00001536 <ADC_Read7>:
	u16_ADC_readings_Channel[6]  = (low_adc + (ADCH << 8));
}
void ADC_Read7(void)
{
	uint8_t low_adc=0;
ADC_INIT(&ADC_Cnfiguration7);
    1536:	80 e9       	ldi	r24, 0x90	; 144
    1538:	90 e0       	ldi	r25, 0x00	; 0
    153a:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
ADCSRA |= 0x40;
    153e:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    1540:	86 b1       	in	r24, 0x06	; 6
    1542:	84 ff       	sbrs	r24, 4
    1544:	fd cf       	rjmp	.-6      	; 0x1540 <ADC_Read7+0xa>
low_adc=ADCL;
    1546:	24 b1       	in	r18, 0x04	; 4
    1548:	35 b1       	in	r19, 0x05	; 5
u16_ADC_readings_Channel[7]  = (low_adc + (ADCH << 8));
    154a:	85 b1       	in	r24, 0x05	; 5
    154c:	96 b1       	in	r25, 0x06	; 6
    154e:	98 2f       	mov	r25, r24
    1550:	88 27       	eor	r24, r24
    1552:	82 0f       	add	r24, r18
    1554:	91 1d       	adc	r25, r1
    1556:	90 93 ac 05 	sts	0x05AC, r25
    155a:	80 93 ab 05 	sts	0x05AB, r24
}
    155e:	08 95       	ret

00001560 <ADC_Read6>:
}

void ADC_Read6(void)
{
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration6);
    1560:	85 e9       	ldi	r24, 0x95	; 149
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    1568:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    156a:	86 b1       	in	r24, 0x06	; 6
    156c:	84 ff       	sbrs	r24, 4
    156e:	fd cf       	rjmp	.-6      	; 0x156a <ADC_Read6+0xa>
	low_adc=ADCL;
    1570:	24 b1       	in	r18, 0x04	; 4
    1572:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[6]  = (low_adc + (ADCH << 8));
    1574:	85 b1       	in	r24, 0x05	; 5
    1576:	96 b1       	in	r25, 0x06	; 6
    1578:	98 2f       	mov	r25, r24
    157a:	88 27       	eor	r24, r24
    157c:	82 0f       	add	r24, r18
    157e:	91 1d       	adc	r25, r1
    1580:	90 93 aa 05 	sts	0x05AA, r25
    1584:	80 93 a9 05 	sts	0x05A9, r24
}
    1588:	08 95       	ret

0000158a <ADC_Read5>:

}
void ADC_Read5(void)
{
	uint8_t low_adc=0;
ADC_INIT(&ADC_Cnfiguration5);
    158a:	8a e9       	ldi	r24, 0x9A	; 154
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
ADCSRA |= 0x40;
    1592:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    1594:	86 b1       	in	r24, 0x06	; 6
    1596:	84 ff       	sbrs	r24, 4
    1598:	fd cf       	rjmp	.-6      	; 0x1594 <ADC_Read5+0xa>
low_adc=ADCL;
    159a:	24 b1       	in	r18, 0x04	; 4
    159c:	35 b1       	in	r19, 0x05	; 5
u16_ADC_readings_Channel[5]  = (low_adc + (ADCH << 8));
    159e:	85 b1       	in	r24, 0x05	; 5
    15a0:	96 b1       	in	r25, 0x06	; 6
    15a2:	98 2f       	mov	r25, r24
    15a4:	88 27       	eor	r24, r24
    15a6:	82 0f       	add	r24, r18
    15a8:	91 1d       	adc	r25, r1
    15aa:	90 93 a8 05 	sts	0x05A8, r25
    15ae:	80 93 a7 05 	sts	0x05A7, r24
}
    15b2:	08 95       	ret

000015b4 <ADC_Read4>:
u16_ADC_readings_Channel[3]  = (low_adc + (ADCH << 8));
}
void ADC_Read4(void)
{
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration4);
    15b4:	8f e9       	ldi	r24, 0x9F	; 159
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    15bc:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    15be:	86 b1       	in	r24, 0x06	; 6
    15c0:	84 ff       	sbrs	r24, 4
    15c2:	fd cf       	rjmp	.-6      	; 0x15be <ADC_Read4+0xa>
	low_adc=ADCL;
    15c4:	24 b1       	in	r18, 0x04	; 4
    15c6:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[4]  =(low_adc + (ADCH << 8));
    15c8:	85 b1       	in	r24, 0x05	; 5
    15ca:	96 b1       	in	r25, 0x06	; 6
    15cc:	98 2f       	mov	r25, r24
    15ce:	88 27       	eor	r24, r24
    15d0:	82 0f       	add	r24, r18
    15d2:	91 1d       	adc	r25, r1
    15d4:	90 93 a6 05 	sts	0x05A6, r25
    15d8:	80 93 a5 05 	sts	0x05A5, r24

}
    15dc:	08 95       	ret

000015de <ADC_Read3>:
	u16_ADC_readings_Channel[2]  = (low_adc + (ADCH << 8));
}
void ADC_Read3(void)
{
	uint8_t low_adc=0;
ADC_INIT(&ADC_Cnfiguration3);
    15de:	84 ea       	ldi	r24, 0xA4	; 164
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
ADCSRA |= 0x40;
    15e6:	36 9a       	sbi	0x06, 6	; 6
while (!(READBIT(ADCSRA,ADIF)));
    15e8:	86 b1       	in	r24, 0x06	; 6
    15ea:	84 ff       	sbrs	r24, 4
    15ec:	fd cf       	rjmp	.-6      	; 0x15e8 <ADC_Read3+0xa>
low_adc=ADCL;
    15ee:	24 b1       	in	r18, 0x04	; 4
    15f0:	35 b1       	in	r19, 0x05	; 5
u16_ADC_readings_Channel[3]  = (low_adc + (ADCH << 8));
    15f2:	85 b1       	in	r24, 0x05	; 5
    15f4:	96 b1       	in	r25, 0x06	; 6
    15f6:	98 2f       	mov	r25, r24
    15f8:	88 27       	eor	r24, r24
    15fa:	82 0f       	add	r24, r18
    15fc:	91 1d       	adc	r25, r1
    15fe:	90 93 a4 05 	sts	0x05A4, r25
    1602:	80 93 a3 05 	sts	0x05A3, r24
}
    1606:	08 95       	ret

00001608 <ADC_Read2>:
	low_adc=ADCL;
	u16_ADC_readings_Channel[1]  =(low_adc + (ADCH << 8));
}
void ADC_Read2(void){
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration2);
    1608:	89 ea       	ldi	r24, 0xA9	; 169
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    1610:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1612:	86 b1       	in	r24, 0x06	; 6
    1614:	84 ff       	sbrs	r24, 4
    1616:	fd cf       	rjmp	.-6      	; 0x1612 <ADC_Read2+0xa>
	u16_ADC_readings_Channel[2]  = (low_adc + (ADCH << 8));
    1618:	85 b1       	in	r24, 0x05	; 5
    161a:	96 b1       	in	r25, 0x06	; 6
    161c:	10 92 a1 05 	sts	0x05A1, r1
    1620:	80 93 a2 05 	sts	0x05A2, r24
}
    1624:	08 95       	ret

00001626 <ADC_Read1>:
	u16_ADC_readings_Channel[0]  = (low_adc + (ADCH << 8));

}
void ADC_Read1(void){
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration1);
    1626:	8e ea       	ldi	r24, 0xAE	; 174
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    162e:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    1630:	86 b1       	in	r24, 0x06	; 6
    1632:	84 ff       	sbrs	r24, 4
    1634:	fd cf       	rjmp	.-6      	; 0x1630 <ADC_Read1+0xa>
	low_adc=ADCL;
    1636:	24 b1       	in	r18, 0x04	; 4
    1638:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[1]  =(low_adc + (ADCH << 8));
    163a:	85 b1       	in	r24, 0x05	; 5
    163c:	96 b1       	in	r25, 0x06	; 6
    163e:	98 2f       	mov	r25, r24
    1640:	88 27       	eor	r24, r24
    1642:	82 0f       	add	r24, r18
    1644:	91 1d       	adc	r25, r1
    1646:	90 93 a0 05 	sts	0x05A0, r25
    164a:	80 93 9f 05 	sts	0x059F, r24
}
    164e:	08 95       	ret

00001650 <ADC_Read0>:
	return ret_error;
}
void ADC_Read0(void)
{
	uint8_t low_adc=0;
	ADC_INIT(&ADC_Cnfiguration0);
    1650:	83 eb       	ldi	r24, 0xB3	; 179
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ADC_INIT>
	ADCSRA |= 0x40;
    1658:	36 9a       	sbi	0x06, 6	; 6
	while (!(READBIT(ADCSRA,ADIF)));
    165a:	86 b1       	in	r24, 0x06	; 6
    165c:	84 ff       	sbrs	r24, 4
    165e:	fd cf       	rjmp	.-6      	; 0x165a <ADC_Read0+0xa>
	low_adc=ADCL;
    1660:	24 b1       	in	r18, 0x04	; 4
    1662:	35 b1       	in	r19, 0x05	; 5
	u16_ADC_readings_Channel[0]  = (low_adc + (ADCH << 8));
    1664:	85 b1       	in	r24, 0x05	; 5
    1666:	96 b1       	in	r25, 0x06	; 6
    1668:	98 2f       	mov	r25, r24
    166a:	88 27       	eor	r24, r24
    166c:	82 0f       	add	r24, r18
    166e:	91 1d       	adc	r25, r1
    1670:	90 93 9e 05 	sts	0x059E, r25
    1674:	80 93 9d 05 	sts	0x059D, r24

}
    1678:	08 95       	ret

0000167a <adc_read>:
while (!(READBIT(ADCSRA,ADIF)));
low_adc=ADCL;
u16_ADC_readings_Channel[7]  = (low_adc + (ADCH << 8));
}
void adc_read(void){
	if (arr_counter_of_ptr < 8)
    167a:	e0 91 fc 00 	lds	r30, 0x00FC
    167e:	e8 30       	cpi	r30, 0x08	; 8
    1680:	78 f4       	brcc	.+30     	; 0x16a0 <adc_read+0x26>
	{
		ADC_R[arr_counter_of_ptr]();
    1682:	f0 e0       	ldi	r31, 0x00	; 0
    1684:	ee 0f       	add	r30, r30
    1686:	ff 1f       	adc	r31, r31
    1688:	e0 58       	subi	r30, 0x80	; 128
    168a:	ff 4f       	sbci	r31, 0xFF	; 255
    168c:	01 90       	ld	r0, Z+
    168e:	f0 81       	ld	r31, Z
    1690:	e0 2d       	mov	r30, r0
    1692:	09 95       	icall
			arr_counter_of_ptr++;
    1694:	80 91 fc 00 	lds	r24, 0x00FC
    1698:	8f 5f       	subi	r24, 0xFF	; 255
    169a:	80 93 fc 00 	sts	0x00FC, r24
    169e:	08 95       	ret
	}else{arr_counter_of_ptr=0;}
    16a0:	10 92 fc 00 	sts	0x00FC, r1
    16a4:	08 95       	ret

000016a6 <DIO_init>:
*Description: This function can set the direction of a full port, a nibble
* 			  or even one pin.
*/

ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{	
    16a6:	fc 01       	movw	r30, r24
	uint8_t RET=0;
	if (DIO_info== NULL)
    16a8:	00 97       	sbiw	r24, 0x00	; 0
    16aa:	09 f4       	brne	.+2      	; 0x16ae <DIO_init+0x8>
    16ac:	50 c0       	rjmp	.+160    	; 0x174e <DIO_init+0xa8>
	{
		RET=NULL_PTR+DIO_MODULE;
		
	}else{
		switch(DIO_info->dir)
    16ae:	82 81       	ldd	r24, Z+2	; 0x02
    16b0:	88 23       	and	r24, r24
    16b2:	21 f0       	breq	.+8      	; 0x16bc <DIO_init+0x16>
    16b4:	8f 3f       	cpi	r24, 0xFF	; 255
    16b6:	09 f0       	breq	.+2      	; 0x16ba <DIO_init+0x14>
    16b8:	4c c0       	rjmp	.+152    	; 0x1752 <DIO_init+0xac>
    16ba:	27 c0       	rjmp	.+78     	; 0x170a <DIO_init+0x64>
			{	
		case INPUT:
		     	switch(DIO_info ->GPIO)
    16bc:	80 81       	ld	r24, Z
    16be:	81 30       	cpi	r24, 0x01	; 1
    16c0:	79 f0       	breq	.+30     	; 0x16e0 <DIO_init+0x3a>
    16c2:	81 30       	cpi	r24, 0x01	; 1
    16c4:	30 f0       	brcs	.+12     	; 0x16d2 <DIO_init+0x2c>
    16c6:	82 30       	cpi	r24, 0x02	; 2
    16c8:	91 f0       	breq	.+36     	; 0x16ee <DIO_init+0x48>
    16ca:	83 30       	cpi	r24, 0x03	; 3
    16cc:	09 f0       	breq	.+2      	; 0x16d0 <DIO_init+0x2a>
    16ce:	43 c0       	rjmp	.+134    	; 0x1756 <DIO_init+0xb0>
    16d0:	15 c0       	rjmp	.+42     	; 0x16fc <DIO_init+0x56>
		 		{
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
    16d2:	9a b3       	in	r25, 0x1a	; 26
    16d4:	81 81       	ldd	r24, Z+1	; 0x01
    16d6:	80 95       	com	r24
    16d8:	89 23       	and	r24, r25
    16da:	8a bb       	out	0x1a, r24	; 26
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    16dc:	80 e0       	ldi	r24, 0x00	; 0
		case INPUT:
		     	switch(DIO_info ->GPIO)
		 		{
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
					break;
    16de:	08 95       	ret
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
    16e0:	97 b3       	in	r25, 0x17	; 23
    16e2:	81 81       	ldd	r24, Z+1	; 0x01
    16e4:	80 95       	com	r24
    16e6:	89 23       	and	r24, r25
    16e8:	87 bb       	out	0x17, r24	; 23
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    16ea:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOA:
					PORTA_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
					break;
    16ec:	08 95       	ret
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
    16ee:	94 b3       	in	r25, 0x14	; 20
    16f0:	81 81       	ldd	r24, Z+1	; 0x01
    16f2:	80 95       	com	r24
    16f4:	89 23       	and	r24, r25
    16f6:	84 bb       	out	0x14, r24	; 20
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    16f8:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOB:
					PORTB_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
					break;
    16fa:	08 95       	ret
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
    16fc:	91 b3       	in	r25, 0x11	; 17
    16fe:	81 81       	ldd	r24, Z+1	; 0x01
    1700:	80 95       	com	r24
    1702:	89 23       	and	r24, r25
    1704:	81 bb       	out	0x11, r24	; 17
					break;
					RET=E_OK;
				}
				RET=E_OK;
    1706:	80 e0       	ldi	r24, 0x00	; 0
					case GPIOC:
					PORTC_DIR &=(~(DIO_info->pins))	;
					break;
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
    1708:	08 95       	ret
				}
				RET=E_OK;
				break;

		case OUTPUT:
			  switch(DIO_info ->GPIO)
    170a:	80 81       	ld	r24, Z
    170c:	81 30       	cpi	r24, 0x01	; 1
    170e:	69 f0       	breq	.+26     	; 0x172a <DIO_init+0x84>
    1710:	81 30       	cpi	r24, 0x01	; 1
    1712:	28 f0       	brcs	.+10     	; 0x171e <DIO_init+0x78>
    1714:	82 30       	cpi	r24, 0x02	; 2
    1716:	79 f0       	breq	.+30     	; 0x1736 <DIO_init+0x90>
    1718:	83 30       	cpi	r24, 0x03	; 3
    171a:	f9 f4       	brne	.+62     	; 0x175a <DIO_init+0xb4>
    171c:	12 c0       	rjmp	.+36     	; 0x1742 <DIO_init+0x9c>
			  {
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
    171e:	9a b3       	in	r25, 0x1a	; 26
    1720:	81 81       	ldd	r24, Z+1	; 0x01
    1722:	89 2b       	or	r24, r25
    1724:	8a bb       	out	0x1a, r24	; 26
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1726:	80 e0       	ldi	r24, 0x00	; 0
		case OUTPUT:
			  switch(DIO_info ->GPIO)
			  {
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
				  break;
    1728:	08 95       	ret
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
    172a:	97 b3       	in	r25, 0x17	; 23
    172c:	81 81       	ldd	r24, Z+1	; 0x01
    172e:	89 2b       	or	r24, r25
    1730:	87 bb       	out	0x17, r24	; 23
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    1732:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOA:
				  PORTA_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
				  break;
    1734:	08 95       	ret
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
    1736:	94 b3       	in	r25, 0x14	; 20
    1738:	81 81       	ldd	r24, Z+1	; 0x01
    173a:	89 2b       	or	r24, r25
    173c:	84 bb       	out	0x14, r24	; 20
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    173e:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOB:
				  PORTB_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
				  break;
    1740:	08 95       	ret
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
    1742:	91 b3       	in	r25, 0x11	; 17
    1744:	81 81       	ldd	r24, Z+1	; 0x01
    1746:	89 2b       	or	r24, r25
    1748:	81 bb       	out	0x11, r24	; 17
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    174a:	80 e0       	ldi	r24, 0x00	; 0
				  case GPIOC:
				  PORTC_DIR |=(DIO_info->pins)	;
				  break;
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
    174c:	08 95       	ret
ERROR_STATUS DIO_init (DIO_Cfg_s *DIO_info)
{	
	uint8_t RET=0;
	if (DIO_info== NULL)
	{
		RET=NULL_PTR+DIO_MODULE;
    174e:	86 e1       	ldi	r24, 0x16	; 22
    1750:	08 95       	ret
			  }
			  RET=E_OK;
			  break;

			default:
			RET=E_NOK;
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	08 95       	ret
					case GPIOD:
					PORTD_DIR &=(~(DIO_info->pins))	;
					break;
					RET=E_OK;
				}
				RET=E_OK;
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	08 95       	ret
				  case GPIOD:
				  PORTD_DIR |=(DIO_info->pins)	;
				  break;
				  RET=E_OK;
			  }
			  RET=E_OK;
    175a:	80 e0       	ldi	r24, 0x00	; 0
			RET=E_NOK;
	}
	
}	
return RET;
}
    175c:	08 95       	ret

0000175e <DIO_Write>:

ERROR_STATUS DIO_Write (uint8_t GPIO, uint8_t pins, uint8_t value)
{uint8_t Ret=0;
switch(value){
    175e:	44 23       	and	r20, r20
    1760:	21 f0       	breq	.+8      	; 0x176a <DIO_Write+0xc>
    1762:	4f 3f       	cpi	r20, 0xFF	; 255
    1764:	09 f0       	breq	.+2      	; 0x1768 <DIO_Write+0xa>
    1766:	3f c0       	rjmp	.+126    	; 0x17e6 <DIO_Write+0x88>
    1768:	21 c0       	rjmp	.+66     	; 0x17ac <DIO_Write+0x4e>
case LOW:
{
switch (GPIO)
    176a:	81 30       	cpi	r24, 0x01	; 1
    176c:	69 f0       	breq	.+26     	; 0x1788 <DIO_Write+0x2a>
    176e:	81 30       	cpi	r24, 0x01	; 1
    1770:	28 f0       	brcs	.+10     	; 0x177c <DIO_Write+0x1e>
    1772:	82 30       	cpi	r24, 0x02	; 2
    1774:	79 f0       	breq	.+30     	; 0x1794 <DIO_Write+0x36>
    1776:	83 30       	cpi	r24, 0x03	; 3
    1778:	c1 f5       	brne	.+112    	; 0x17ea <DIO_Write+0x8c>
    177a:	12 c0       	rjmp	.+36     	; 0x17a0 <DIO_Write+0x42>
{	case GPIOA:
	PORTA_DATA &= ~(pins);   // 0b01111111
    177c:	8b b3       	in	r24, 0x1b	; 27
    177e:	60 95       	com	r22
    1780:	68 23       	and	r22, r24
    1782:	6b bb       	out	0x1b, r22	; 27
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    1784:	80 e0       	ldi	r24, 0x00	; 0
{
switch (GPIO)
{	case GPIOA:
	PORTA_DATA &= ~(pins);   // 0b01111111
Ret=E_OK;
	break;
    1786:	08 95       	ret
	case GPIOB:
	PORTB_DATA &= ~(pins);
    1788:	88 b3       	in	r24, 0x18	; 24
    178a:	60 95       	com	r22
    178c:	68 23       	and	r22, r24
    178e:	68 bb       	out	0x18, r22	; 24
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    1790:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOB:
	PORTB_DATA &= ~(pins);
Ret=E_OK;
	break;
    1792:	08 95       	ret
	case GPIOC:
	PORTC_DATA &= ~(pins);
    1794:	85 b3       	in	r24, 0x15	; 21
    1796:	60 95       	com	r22
    1798:	68 23       	and	r22, r24
    179a:	65 bb       	out	0x15, r22	; 21
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    179c:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOC:
	PORTC_DATA &= ~(pins);
Ret=E_OK;
	break;
    179e:	08 95       	ret
	case GPIOD:
	PORTD_DATA &= ~(pins);
    17a0:	82 b3       	in	r24, 0x12	; 18
    17a2:	60 95       	com	r22
    17a4:	68 23       	and	r22, r24
    17a6:	62 bb       	out	0x12, r22	; 18
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    17a8:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOD:
	PORTD_DATA &= ~(pins);
	Ret=E_OK;
	break;
    17aa:	08 95       	ret
	}
Ret=E_OK;
break;
}
case HIGH:{
switch (GPIO)
    17ac:	81 30       	cpi	r24, 0x01	; 1
    17ae:	61 f0       	breq	.+24     	; 0x17c8 <DIO_Write+0x6a>
    17b0:	81 30       	cpi	r24, 0x01	; 1
    17b2:	28 f0       	brcs	.+10     	; 0x17be <DIO_Write+0x60>
    17b4:	82 30       	cpi	r24, 0x02	; 2
    17b6:	69 f0       	breq	.+26     	; 0x17d2 <DIO_Write+0x74>
    17b8:	83 30       	cpi	r24, 0x03	; 3
    17ba:	c9 f4       	brne	.+50     	; 0x17ee <DIO_Write+0x90>
    17bc:	0f c0       	rjmp	.+30     	; 0x17dc <DIO_Write+0x7e>
{	case GPIOA:
	PORTA_DATA |=(pins);
    17be:	8b b3       	in	r24, 0x1b	; 27
    17c0:	68 2b       	or	r22, r24
    17c2:	6b bb       	out	0x1b, r22	; 27
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17c4:	80 e0       	ldi	r24, 0x00	; 0
case HIGH:{
switch (GPIO)
{	case GPIOA:
	PORTA_DATA |=(pins);
Ret=E_OK;
	break;
    17c6:	08 95       	ret
	case GPIOB:
	PORTB_DATA |=(pins);
    17c8:	88 b3       	in	r24, 0x18	; 24
    17ca:	68 2b       	or	r22, r24
    17cc:	68 bb       	out	0x18, r22	; 24
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17ce:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOB:
	PORTB_DATA |=(pins);
Ret=E_OK;
	break;
    17d0:	08 95       	ret
	case GPIOC:
	PORTC_DATA |=(pins);
    17d2:	85 b3       	in	r24, 0x15	; 21
    17d4:	68 2b       	or	r22, r24
    17d6:	65 bb       	out	0x15, r22	; 21
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17d8:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOC:
	PORTC_DATA |=(pins);
Ret=E_OK;
	break;
    17da:	08 95       	ret
	case GPIOD:
	PORTD_DATA |=(pins);
    17dc:	82 b3       	in	r24, 0x12	; 18
    17de:	68 2b       	or	r22, r24
    17e0:	62 bb       	out	0x12, r22	; 18
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17e2:	80 e0       	ldi	r24, 0x00	; 0
Ret=E_OK;
	break;
	case GPIOD:
	PORTD_DATA |=(pins);
Ret=E_OK;
	break;
    17e4:	08 95       	ret
}
Ret=E_OK;
break;
}
default:
Ret=E_NOK;
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	08 95       	ret
	break;
	default:
	Ret=E_NOK;
	break;
	}
Ret=E_OK;
    17ea:	80 e0       	ldi	r24, 0x00	; 0
    17ec:	08 95       	ret
	break;
	default:
	Ret=E_NOK;
	break;
}
Ret=E_OK;
    17ee:	80 e0       	ldi	r24, 0x00	; 0
default:
Ret=E_NOK;
break;
}
return Ret;
}
    17f0:	08 95       	ret

000017f2 <DIO_Read>:


ERROR_STATUS DIO_Read (uint8_t GPIO,uint8_t pins, uint8_t *data)
{
    17f2:	fa 01       	movw	r30, r20

switch (GPIO)
    17f4:	81 30       	cpi	r24, 0x01	; 1
    17f6:	59 f0       	breq	.+22     	; 0x180e <DIO_Read+0x1c>
    17f8:	81 30       	cpi	r24, 0x01	; 1
    17fa:	28 f0       	brcs	.+10     	; 0x1806 <DIO_Read+0x14>
    17fc:	82 30       	cpi	r24, 0x02	; 2
    17fe:	59 f0       	breq	.+22     	; 0x1816 <DIO_Read+0x24>
    1800:	83 30       	cpi	r24, 0x03	; 3
    1802:	81 f4       	brne	.+32     	; 0x1824 <DIO_Read+0x32>
    1804:	0c c0       	rjmp	.+24     	; 0x181e <DIO_Read+0x2c>
{	case GPIOA:
	*data=(PORTA_PIN & pins);
    1806:	89 b3       	in	r24, 0x19	; 25
    1808:	68 23       	and	r22, r24
    180a:	60 83       	st	Z, r22
	break;
    180c:	0b c0       	rjmp	.+22     	; 0x1824 <DIO_Read+0x32>
	case GPIOB:
	*data=(PORTB_PIN & pins);
    180e:	86 b3       	in	r24, 0x16	; 22
    1810:	68 23       	and	r22, r24
    1812:	60 83       	st	Z, r22
	break;
    1814:	07 c0       	rjmp	.+14     	; 0x1824 <DIO_Read+0x32>
	case GPIOC:
	*data=(PORTC_PIN & pins);
    1816:	83 b3       	in	r24, 0x13	; 19
    1818:	68 23       	and	r22, r24
    181a:	60 83       	st	Z, r22
	break;
    181c:	03 c0       	rjmp	.+6      	; 0x1824 <DIO_Read+0x32>
	case GPIOD:
	*data=(PORTD_PIN & pins);
    181e:	80 b3       	in	r24, 0x10	; 16
    1820:	68 23       	and	r22, r24
    1822:	60 83       	st	Z, r22
	break;
}
if(*data > 0)
    1824:	80 81       	ld	r24, Z
    1826:	88 23       	and	r24, r24
    1828:	11 f0       	breq	.+4      	; 0x182e <DIO_Read+0x3c>
{
	*data = HIGH;
    182a:	8f ef       	ldi	r24, 0xFF	; 255
    182c:	80 83       	st	Z, r24
}


}
    182e:	08 95       	ret

00001830 <DIO_Toggle>:
ERROR_STATUS DIO_Toggle (uint8_t GPIO, uint8_t pins)
{
uint8_t ret=0;
	switch (GPIO)
    1830:	81 30       	cpi	r24, 0x01	; 1
    1832:	61 f0       	breq	.+24     	; 0x184c <DIO_Toggle+0x1c>
    1834:	81 30       	cpi	r24, 0x01	; 1
    1836:	28 f0       	brcs	.+10     	; 0x1842 <DIO_Toggle+0x12>
    1838:	82 30       	cpi	r24, 0x02	; 2
    183a:	69 f0       	breq	.+26     	; 0x1856 <DIO_Toggle+0x26>
    183c:	83 30       	cpi	r24, 0x03	; 3
    183e:	a9 f4       	brne	.+42     	; 0x186a <DIO_Toggle+0x3a>
    1840:	0f c0       	rjmp	.+30     	; 0x1860 <DIO_Toggle+0x30>
	{	case GPIOA:
		PORTA_DATA ^=(pins);
    1842:	8b b3       	in	r24, 0x1b	; 27
    1844:	68 27       	eor	r22, r24
    1846:	6b bb       	out	0x1b, r22	; 27
		ret=E_OK;
    1848:	80 e0       	ldi	r24, 0x00	; 0
		break;
    184a:	08 95       	ret
		case GPIOB:
		PORTB_DATA ^=(pins);
    184c:	88 b3       	in	r24, 0x18	; 24
    184e:	68 27       	eor	r22, r24
    1850:	68 bb       	out	0x18, r22	; 24
ret=E_OK;
    1852:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1854:	08 95       	ret
		case GPIOC:
		PORTC_DATA ^=(pins);
    1856:	85 b3       	in	r24, 0x15	; 21
    1858:	68 27       	eor	r22, r24
    185a:	65 bb       	out	0x15, r22	; 21
ret=E_OK;
    185c:	80 e0       	ldi	r24, 0x00	; 0
		break;
    185e:	08 95       	ret
		case GPIOD:
		PORTD_DATA ^=(pins);
    1860:	82 b3       	in	r24, 0x12	; 18
    1862:	68 27       	eor	r22, r24
    1864:	62 bb       	out	0x12, r22	; 18
ret=E_OK;
    1866:	80 e0       	ldi	r24, 0x00	; 0
		break;
    1868:	08 95       	ret
		default:
		ret=E_NOK;
    186a:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}

return ret;
}
    186c:	08 95       	ret

0000186e <Icu_Init>:
static volatile uint32_t u32_Time_rising_edge=0;
static volatile uint32_t u32_Time_faling_edge=0;
static volatile uint32_t Timer_High=0;
static volatile uint32_t Timer_Low=0;
ERROR_STATUS Icu_Init(Icu_cfg_s * Icu_Cfg)
{
    186e:	cf 93       	push	r28
    1870:	df 93       	push	r29
    1872:	ec 01       	movw	r28, r24
	uint8_t Ret=0;
//Enable Global int
G_interrupt_Enable();
    1874:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
//Enable EXTI
switch(Icu_Cfg->ICU_Ch_No)
    1878:	88 81       	ld	r24, Y
    187a:	81 30       	cpi	r24, 0x01	; 1
    187c:	41 f0       	breq	.+16     	; 0x188e <Icu_Init+0x20>
    187e:	81 30       	cpi	r24, 0x01	; 1
    1880:	18 f0       	brcs	.+6      	; 0x1888 <Icu_Init+0x1a>
    1882:	82 30       	cpi	r24, 0x02	; 2
    1884:	49 f4       	brne	.+18     	; 0x1898 <Icu_Init+0x2a>
    1886:	06 c0       	rjmp	.+12     	; 0x1894 <Icu_Init+0x26>
{
case ICU_CH0:
EX_interrupt_enable0();
    1888:	0e 94 53 07 	call	0xea6	; 0xea6 <EX_interrupt_enable0>
break;
    188c:	05 c0       	rjmp	.+10     	; 0x1898 <Icu_Init+0x2a>
case ICU_CH1:
EX_interrupt_enable1();
    188e:	0e 94 47 07 	call	0xe8e	; 0xe8e <EX_interrupt_enable1>
break;
    1892:	02 c0       	rjmp	.+4      	; 0x1898 <Icu_Init+0x2a>
case ICU_CH2:
EX_interrupt_enable2();
    1894:	0e 94 3e 07 	call	0xe7c	; 0xe7c <EX_interrupt_enable2>
break;
}

switch(Icu_Cfg->ICU_Ch_Timer)
    1898:	89 81       	ldd	r24, Y+1	; 0x01
    189a:	81 30       	cpi	r24, 0x01	; 1
    189c:	51 f0       	breq	.+20     	; 0x18b2 <Icu_Init+0x44>
    189e:	81 30       	cpi	r24, 0x01	; 1
    18a0:	18 f0       	brcs	.+6      	; 0x18a8 <Icu_Init+0x3a>
    18a2:	82 30       	cpi	r24, 0x02	; 2
    18a4:	89 f4       	brne	.+34     	; 0x18c8 <Icu_Init+0x5a>
    18a6:	0c c0       	rjmp	.+24     	; 0x18c0 <Icu_Init+0x52>
{
	case ICU_TIMER_CH0:
		//Enable Timer0
		TCCR0=0x05;
    18a8:	85 e0       	ldi	r24, 0x05	; 5
    18aa:	83 bf       	out	0x33, r24	; 51
		TIMSK=0x01;
    18ac:	81 e0       	ldi	r24, 0x01	; 1
    18ae:	89 bf       	out	0x39, r24	; 57
		break;
    18b0:	0b c0       	rjmp	.+22     	; 0x18c8 <Icu_Init+0x5a>
	case ICU_TIMER_CH1:
		TCCR1=0x0005;
    18b2:	85 e0       	ldi	r24, 0x05	; 5
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	9f bd       	out	0x2f, r25	; 47
    18b8:	8e bd       	out	0x2e, r24	; 46
		TIMSK=0x04;
    18ba:	84 e0       	ldi	r24, 0x04	; 4
    18bc:	89 bf       	out	0x39, r24	; 57
		break;
    18be:	04 c0       	rjmp	.+8      	; 0x18c8 <Icu_Init+0x5a>
	case ICU_TIMER_CH2:
		TCCR2=0x07;
    18c0:	87 e0       	ldi	r24, 0x07	; 7
    18c2:	85 bd       	out	0x25, r24	; 37
		TIMSK=0x04;
    18c4:	84 e0       	ldi	r24, 0x04	; 4
    18c6:	89 bf       	out	0x39, r24	; 57
		break;
}

return Ret;
}
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	df 91       	pop	r29
    18cc:	cf 91       	pop	r28
    18ce:	08 95       	ret

000018d0 <Icu_ReadTime>:
 * 				  - E_OK : successful									   *
 *				  - E_NOK : not successful								   *
 * Description	: calculates the time between 2 edges				       *
 ***************************************************************************/
ERROR_STATUS Icu_ReadTime(uint8_t Icu_Channel, uint8_t Icu_EdgeToEdge, uint32_t * Icu_Time)
{
    18d0:	0f 93       	push	r16
    18d2:	1f 93       	push	r17
uint8_t Ret=0;
switch(Icu_Channel)
    18d4:	81 30       	cpi	r24, 0x01	; 1
    18d6:	49 f0       	breq	.+18     	; 0x18ea <Icu_ReadTime+0x1a>
    18d8:	81 30       	cpi	r24, 0x01	; 1
    18da:	18 f0       	brcs	.+6      	; 0x18e2 <Icu_ReadTime+0x12>
    18dc:	82 30       	cpi	r24, 0x02	; 2
    18de:	71 f4       	brne	.+28     	; 0x18fc <Icu_ReadTime+0x2c>
    18e0:	0a c0       	rjmp	.+20     	; 0x18f6 <Icu_ReadTime+0x26>
{
	case ICU_TIMER_CH0:
	TCCR0|=0x03;
    18e2:	83 b7       	in	r24, 0x33	; 51
    18e4:	83 60       	ori	r24, 0x03	; 3
    18e6:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
	break;
    18e8:	09 c0       	rjmp	.+18     	; 0x18fc <Icu_ReadTime+0x2c>
	case ICU_TIMER_CH1:
	TCCR1|=0x0005;
    18ea:	8e b5       	in	r24, 0x2e	; 46
    18ec:	9f b5       	in	r25, 0x2f	; 47
    18ee:	85 60       	ori	r24, 0x05	; 5
    18f0:	9f bd       	out	0x2f, r25	; 47
    18f2:	8e bd       	out	0x2e, r24	; 46
	Ret=E_OK;	
	break;
    18f4:	03 c0       	rjmp	.+6      	; 0x18fc <Icu_ReadTime+0x2c>
	case ICU_TIMER_CH2:
	TCCR2|=0x07;
    18f6:	85 b5       	in	r24, 0x25	; 37
    18f8:	87 60       	ori	r24, 0x07	; 7
    18fa:	85 bd       	out	0x25, r24	; 37
	default:
	Ret=E_NOK;
	break;
}  

switch(Icu_EdgeToEdge)
    18fc:	61 30       	cpi	r22, 0x01	; 1
    18fe:	01 f1       	breq	.+64     	; 0x1940 <Icu_ReadTime+0x70>
    1900:	61 30       	cpi	r22, 0x01	; 1
    1902:	18 f0       	brcs	.+6      	; 0x190a <Icu_ReadTime+0x3a>
    1904:	62 30       	cpi	r22, 0x02	; 2
    1906:	d1 f5       	brne	.+116    	; 0x197c <Icu_ReadTime+0xac>
    1908:	2a c0       	rjmp	.+84     	; 0x195e <Icu_ReadTime+0x8e>
{
	case ICU_RISE_TO_RISE:
	*Icu_Time=Timer_High+Timer_Low;
    190a:	80 91 01 01 	lds	r24, 0x0101
    190e:	90 91 02 01 	lds	r25, 0x0102
    1912:	a0 91 03 01 	lds	r26, 0x0103
    1916:	b0 91 04 01 	lds	r27, 0x0104
    191a:	00 91 fd 00 	lds	r16, 0x00FD
    191e:	10 91 fe 00 	lds	r17, 0x00FE
    1922:	20 91 ff 00 	lds	r18, 0x00FF
    1926:	30 91 00 01 	lds	r19, 0x0100
    192a:	80 0f       	add	r24, r16
    192c:	91 1f       	adc	r25, r17
    192e:	a2 1f       	adc	r26, r18
    1930:	b3 1f       	adc	r27, r19
    1932:	fa 01       	movw	r30, r20
    1934:	80 83       	st	Z, r24
    1936:	91 83       	std	Z+1, r25	; 0x01
    1938:	a2 83       	std	Z+2, r26	; 0x02
    193a:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    193c:	80 e0       	ldi	r24, 0x00	; 0
	break;
    193e:	1f c0       	rjmp	.+62     	; 0x197e <Icu_ReadTime+0xae>
	case ICU_RISE_TO_FALL:
	*Icu_Time=Timer_High;
    1940:	80 91 01 01 	lds	r24, 0x0101
    1944:	90 91 02 01 	lds	r25, 0x0102
    1948:	a0 91 03 01 	lds	r26, 0x0103
    194c:	b0 91 04 01 	lds	r27, 0x0104
    1950:	fa 01       	movw	r30, r20
    1952:	80 83       	st	Z, r24
    1954:	91 83       	std	Z+1, r25	; 0x01
    1956:	a2 83       	std	Z+2, r26	; 0x02
    1958:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    195a:	80 e0       	ldi	r24, 0x00	; 0
	break;
    195c:	10 c0       	rjmp	.+32     	; 0x197e <Icu_ReadTime+0xae>
	case ICU_FALE_TO_RISE:
	*Icu_Time=Timer_Low;
    195e:	80 91 fd 00 	lds	r24, 0x00FD
    1962:	90 91 fe 00 	lds	r25, 0x00FE
    1966:	a0 91 ff 00 	lds	r26, 0x00FF
    196a:	b0 91 00 01 	lds	r27, 0x0100
    196e:	fa 01       	movw	r30, r20
    1970:	80 83       	st	Z, r24
    1972:	91 83       	std	Z+1, r25	; 0x01
    1974:	a2 83       	std	Z+2, r26	; 0x02
    1976:	b3 83       	std	Z+3, r27	; 0x03
	Ret=E_OK;
    1978:	80 e0       	ldi	r24, 0x00	; 0
	break;
    197a:	01 c0       	rjmp	.+2      	; 0x197e <Icu_ReadTime+0xae>
	
	default:
	Ret=E_NOK;
    197c:	81 e0       	ldi	r24, 0x01	; 1
	break;
}

return Ret;
}
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	08 95       	ret

00001984 <EXTI>:
void EXTI(void)
{	u32_sgv_TimerVal=(uint32_t)TCNT0+((uint32_t)u8_ovf_happend*255);
    1984:	cf 93       	push	r28
    1986:	c2 b7       	in	r28, 0x32	; 50
    1988:	60 91 0d 01 	lds	r22, 0x010D
    198c:	70 e0       	ldi	r23, 0x00	; 0
    198e:	80 e0       	ldi	r24, 0x00	; 0
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	2f ef       	ldi	r18, 0xFF	; 255
    1994:	30 e0       	ldi	r19, 0x00	; 0
    1996:	40 e0       	ldi	r20, 0x00	; 0
    1998:	50 e0       	ldi	r21, 0x00	; 0
    199a:	0e 94 8a 2a 	call	0x5514	; 0x5514 <__mulsi3>
    199e:	dc 01       	movw	r26, r24
    19a0:	cb 01       	movw	r24, r22
    19a2:	8c 0f       	add	r24, r28
    19a4:	91 1d       	adc	r25, r1
    19a6:	a1 1d       	adc	r26, r1
    19a8:	b1 1d       	adc	r27, r1
    19aa:	80 93 0e 01 	sts	0x010E, r24
    19ae:	90 93 0f 01 	sts	0x010F, r25
    19b2:	a0 93 10 01 	sts	0x0110, r26
    19b6:	b0 93 11 01 	sts	0x0111, r27
	u8_ovf_happend=0;
    19ba:	10 92 0d 01 	sts	0x010D, r1
		if(READBIT(MCUCSR,6))
    19be:	84 b7       	in	r24, 0x34	; 52
    19c0:	82 95       	swap	r24
    19c2:	86 95       	lsr	r24
    19c4:	86 95       	lsr	r24
    19c6:	83 70       	andi	r24, 0x03	; 3
    19c8:	80 ff       	sbrs	r24, 0
    19ca:	30 c0       	rjmp	.+96     	; 0x1a2c <EXTI+0xa8>
		{
		u32_Time_rising_edge=u32_sgv_TimerVal;
    19cc:	80 91 0e 01 	lds	r24, 0x010E
    19d0:	90 91 0f 01 	lds	r25, 0x010F
    19d4:	a0 91 10 01 	lds	r26, 0x0110
    19d8:	b0 91 11 01 	lds	r27, 0x0111
    19dc:	80 93 09 01 	sts	0x0109, r24
    19e0:	90 93 0a 01 	sts	0x010A, r25
    19e4:	a0 93 0b 01 	sts	0x010B, r26
    19e8:	b0 93 0c 01 	sts	0x010C, r27
		Timer_Low = u32_Time_rising_edge - u32_Time_faling_edge;
    19ec:	80 91 09 01 	lds	r24, 0x0109
    19f0:	90 91 0a 01 	lds	r25, 0x010A
    19f4:	a0 91 0b 01 	lds	r26, 0x010B
    19f8:	b0 91 0c 01 	lds	r27, 0x010C
    19fc:	40 91 05 01 	lds	r20, 0x0105
    1a00:	50 91 06 01 	lds	r21, 0x0106
    1a04:	60 91 07 01 	lds	r22, 0x0107
    1a08:	70 91 08 01 	lds	r23, 0x0108
    1a0c:	84 1b       	sub	r24, r20
    1a0e:	95 0b       	sbc	r25, r21
    1a10:	a6 0b       	sbc	r26, r22
    1a12:	b7 0b       	sbc	r27, r23
    1a14:	80 93 fd 00 	sts	0x00FD, r24
    1a18:	90 93 fe 00 	sts	0x00FE, r25
    1a1c:	a0 93 ff 00 	sts	0x00FF, r26
    1a20:	b0 93 00 01 	sts	0x0100, r27
		/*****************************************/	
		CLEAR_BIT(MCUCSR,6);   /*Make it falling*/
    1a24:	84 b7       	in	r24, 0x34	; 52
    1a26:	8f 7b       	andi	r24, 0xBF	; 191
    1a28:	84 bf       	out	0x34, r24	; 52
    1a2a:	2f c0       	rjmp	.+94     	; 0x1a8a <EXTI+0x106>
		/***************************************/
		}else{
			u32_Time_faling_edge=u32_sgv_TimerVal;
    1a2c:	80 91 0e 01 	lds	r24, 0x010E
    1a30:	90 91 0f 01 	lds	r25, 0x010F
    1a34:	a0 91 10 01 	lds	r26, 0x0110
    1a38:	b0 91 11 01 	lds	r27, 0x0111
    1a3c:	80 93 05 01 	sts	0x0105, r24
    1a40:	90 93 06 01 	sts	0x0106, r25
    1a44:	a0 93 07 01 	sts	0x0107, r26
    1a48:	b0 93 08 01 	sts	0x0108, r27
			Timer_High =u32_Time_faling_edge - u32_Time_rising_edge;
    1a4c:	80 91 05 01 	lds	r24, 0x0105
    1a50:	90 91 06 01 	lds	r25, 0x0106
    1a54:	a0 91 07 01 	lds	r26, 0x0107
    1a58:	b0 91 08 01 	lds	r27, 0x0108
    1a5c:	40 91 09 01 	lds	r20, 0x0109
    1a60:	50 91 0a 01 	lds	r21, 0x010A
    1a64:	60 91 0b 01 	lds	r22, 0x010B
    1a68:	70 91 0c 01 	lds	r23, 0x010C
    1a6c:	84 1b       	sub	r24, r20
    1a6e:	95 0b       	sbc	r25, r21
    1a70:	a6 0b       	sbc	r26, r22
    1a72:	b7 0b       	sbc	r27, r23
    1a74:	80 93 01 01 	sts	0x0101, r24
    1a78:	90 93 02 01 	sts	0x0102, r25
    1a7c:	a0 93 03 01 	sts	0x0103, r26
    1a80:	b0 93 04 01 	sts	0x0104, r27
			/*********************************/	
			SET_BIT(MCUCSR,6);		/*Make it Rising*/
    1a84:	84 b7       	in	r24, 0x34	; 52
    1a86:	80 64       	ori	r24, 0x40	; 64
    1a88:	84 bf       	out	0x34, r24	; 52
			/********************************/
			}	

//UDR=Timer_High;
}/*
    1a8a:	cf 91       	pop	r28
    1a8c:	08 95       	ret

00001a8e <pushButtonGetStatus>:

En_buttonStatus_t pushButtonGetStatus(En_buttonId_t en_butotn_id)
{
	static uint8_t u8_Button_press[3];
static uint8_t u8_S_button_status[3];
switch(en_butotn_id)
    1a8e:	81 30       	cpi	r24, 0x01	; 1
    1a90:	c1 f0       	breq	.+48     	; 0x1ac2 <pushButtonGetStatus+0x34>
    1a92:	81 30       	cpi	r24, 0x01	; 1
    1a94:	18 f0       	brcs	.+6      	; 0x1a9c <pushButtonGetStatus+0xe>
    1a96:	82 30       	cpi	r24, 0x02	; 2
    1a98:	d1 f5       	brne	.+116    	; 0x1b0e <pushButtonGetStatus+0x80>
    1a9a:	26 c0       	rjmp	.+76     	; 0x1ae8 <pushButtonGetStatus+0x5a>
{
case BTN_0:
{DIO_Read(BTN_0_GPIO,BTN_0_BIT,&(u8_Button_press[0]));
    1a9c:	82 e0       	ldi	r24, 0x02	; 2
    1a9e:	61 e0       	ldi	r22, 0x01	; 1
    1aa0:	42 e1       	ldi	r20, 0x12	; 18
    1aa2:	51 e0       	ldi	r21, 0x01	; 1
    1aa4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
if( u8_Button_press[0]== Pressed)
    1aa8:	80 91 12 01 	lds	r24, 0x0112
    1aac:	81 30       	cpi	r24, 0x01	; 1
    1aae:	81 f5       	brne	.+96     	; 0x1b10 <pushButtonGetStatus+0x82>
{ 
	(u8_S_button_status[0])++;
    1ab0:	90 91 15 01 	lds	r25, 0x0115
    1ab4:	9f 5f       	subi	r25, 0xFF	; 255
    1ab6:	90 93 15 01 	sts	0x0115, r25
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1aba:	93 33       	cpi	r25, 0x33	; 51
    1abc:	70 f5       	brcc	.+92     	; 0x1b1a <pushButtonGetStatus+0x8c>
    1abe:	80 e0       	ldi	r24, 0x00	; 0
    1ac0:	08 95       	ret
	else {return Released;}
}else{return Released;}
break;
}
case BTN_1:
{DIO_Read(BTN_1_GPIO,BTN_1_BIT,&(u8_Button_press[1]));
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	64 e0       	ldi	r22, 0x04	; 4
    1ac6:	43 e1       	ldi	r20, 0x13	; 19
    1ac8:	51 e0       	ldi	r21, 0x01	; 1
    1aca:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
if( u8_Button_press[1] == Pressed)
    1ace:	80 91 13 01 	lds	r24, 0x0113
    1ad2:	81 30       	cpi	r24, 0x01	; 1
    1ad4:	f9 f4       	brne	.+62     	; 0x1b14 <pushButtonGetStatus+0x86>
{
	(u8_S_button_status[0])++;
    1ad6:	90 91 15 01 	lds	r25, 0x0115
    1ada:	9f 5f       	subi	r25, 0xFF	; 255
    1adc:	90 93 15 01 	sts	0x0115, r25
	(u8_S_button_status[0])++;
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1ae0:	93 33       	cpi	r25, 0x33	; 51
    1ae2:	d8 f4       	brcc	.+54     	; 0x1b1a <pushButtonGetStatus+0x8c>
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	08 95       	ret
	else {return Released;}
}else{return Released;}
break;
}
case BTN_2:
{DIO_Read(BTN_2_GPIO,BTN_2_BIT,&(u8_Button_press[2]));
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	64 e0       	ldi	r22, 0x04	; 4
    1aec:	44 e1       	ldi	r20, 0x14	; 20
    1aee:	51 e0       	ldi	r21, 0x01	; 1
    1af0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
if((u8_Button_press[2])== Pressed)
    1af4:	80 91 14 01 	lds	r24, 0x0114
    1af8:	81 30       	cpi	r24, 0x01	; 1
    1afa:	71 f4       	brne	.+28     	; 0x1b18 <pushButtonGetStatus+0x8a>
{	(u8_S_button_status[1])++;
    1afc:	90 91 16 01 	lds	r25, 0x0116
    1b00:	9f 5f       	subi	r25, 0xFF	; 255
    1b02:	90 93 16 01 	sts	0x0116, r25
	(u8_S_button_status[0])++;
	/************************************************************************/
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
	return Pressed;
    1b06:	95 31       	cpi	r25, 0x15	; 21
    1b08:	40 f4       	brcc	.+16     	; 0x1b1a <pushButtonGetStatus+0x8c>
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	08 95       	ret
    1b0e:	08 95       	ret
	else {return Released;}
}else{return Released;}
    1b10:	80 e0       	ldi	r24, 0x00	; 0
    1b12:	08 95       	ret
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[0]) > 50)
return Pressed;
	else {return Released;}
}else{return Released;}
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	08 95       	ret
	/*         Debouncing Using Counting Algorithm			                */
	/************************************************************************/
	if( (u8_S_button_status[1]) > 20)
	return Pressed;
else {return Released;}
}else{return Released;}
    1b18:	80 e0       	ldi	r24, 0x00	; 0


	}


}
    1b1a:	08 95       	ret

00001b1c <Pwm_Init>:
/*                                                                               */
/* Description: initialize the PWM configuration                                 */
/*********************************************************************************/

ERROR_STATUS Pwm_Init(Pwm_Cfg_s *Pwm_Cfg)
{uint8_t Ret=0;
    1b1c:	fc 01       	movw	r30, r24
	switch(Pwm_Cfg->Channel)
    1b1e:	80 81       	ld	r24, Z
    1b20:	81 30       	cpi	r24, 0x01	; 1
    1b22:	61 f0       	breq	.+24     	; 0x1b3c <Pwm_Init+0x20>
    1b24:	81 30       	cpi	r24, 0x01	; 1
    1b26:	28 f0       	brcs	.+10     	; 0x1b32 <Pwm_Init+0x16>
    1b28:	82 30       	cpi	r24, 0x02	; 2
    1b2a:	81 f0       	breq	.+32     	; 0x1b4c <Pwm_Init+0x30>
    1b2c:	83 30       	cpi	r24, 0x03	; 3
    1b2e:	d9 f4       	brne	.+54     	; 0x1b66 <Pwm_Init+0x4a>
    1b30:	15 c0       	rjmp	.+42     	; 0x1b5c <Pwm_Init+0x40>
		{
			case PWM_CH0:
			TCCR0|=T0_PWM_FAST |T0_NON_INVERTING;
    1b32:	83 b7       	in	r24, 0x33	; 51
    1b34:	88 66       	ori	r24, 0x68	; 104
    1b36:	83 bf       	out	0x33, r24	; 51
			Ret=E_OK;
    1b38:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b3a:	16 c0       	rjmp	.+44     	; 0x1b68 <Pwm_Init+0x4c>

			case PWM_CH1A:
			TCCR1 |= T1_PWM_Phase_8 | T1_OC1A_OC1B|0x0020;
    1b3c:	8e b5       	in	r24, 0x2e	; 46
    1b3e:	9f b5       	in	r25, 0x2f	; 47
    1b40:	80 62       	ori	r24, 0x20	; 32
    1b42:	91 6a       	ori	r25, 0xA1	; 161
    1b44:	9f bd       	out	0x2f, r25	; 47
    1b46:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
    1b48:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b4a:	0e c0       	rjmp	.+28     	; 0x1b68 <Pwm_Init+0x4c>

			case PWM_CH1B:
			TCCR1 |= T1_PWM_Phase_8 | T1_OC1A_OC1B;
    1b4c:	8e b5       	in	r24, 0x2e	; 46
    1b4e:	9f b5       	in	r25, 0x2f	; 47
    1b50:	80 62       	ori	r24, 0x20	; 32
    1b52:	91 6a       	ori	r25, 0xA1	; 161
    1b54:	9f bd       	out	0x2f, r25	; 47
    1b56:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
    1b58:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b5a:	06 c0       	rjmp	.+12     	; 0x1b68 <Pwm_Init+0x4c>


			case PWM_CH2:
			TCCR2 |=T2_PWM_FAST |T2_NON_INVERTING;
    1b5c:	85 b5       	in	r24, 0x25	; 37
    1b5e:	88 66       	ori	r24, 0x68	; 104
    1b60:	85 bd       	out	0x25, r24	; 37
			Ret=E_OK;
    1b62:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1b64:	01 c0       	rjmp	.+2      	; 0x1b68 <Pwm_Init+0x4c>
			default:
			Ret=E_NOK;
    1b66:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
	sgl_Prescaler=Pwm_Cfg->Prescaler;
    1b68:	91 81       	ldd	r25, Z+1	; 0x01
    1b6a:	90 93 18 01 	sts	0x0118, r25
	u32g_T1_Prescaler=en_prescal;
	OCR1A =u16_outputCompareA;
	OCR1B =u16_outputCompareB;
	TCNT1=u16_initialValue;
	*/
}
    1b6e:	08 95       	ret

00001b70 <Pwm_Start>:
/*-------------------------------------------------------                        */
/*((all this calculations are for phase correct mode))                           */
/*all this calculation for F_CPU 16MHz                                           */
/*********************************************************************************/
ERROR_STATUS Pwm_Start(uint8_t Channel,uint8_t Duty,uint32_t Frequncy)
{uint8_t Ret=0;
    1b70:	cf 92       	push	r12
    1b72:	df 92       	push	r13
    1b74:	ef 92       	push	r14
    1b76:	ff 92       	push	r15
    1b78:	0f 93       	push	r16
    1b7a:	1f 93       	push	r17
    1b7c:	89 01       	movw	r16, r18
    1b7e:	9a 01       	movw	r18, r20
	float dutyReal;
uint32_t pwm_time_on = MAX_HOLD;

if(Frequncy <= 31372 && Frequncy > 3921 )
    1b80:	0f 2e       	mov	r0, r31
    1b82:	fe ea       	ldi	r31, 0xAE	; 174
    1b84:	cf 2e       	mov	r12, r31
    1b86:	f0 ef       	ldi	r31, 0xF0	; 240
    1b88:	df 2e       	mov	r13, r31
    1b8a:	ff ef       	ldi	r31, 0xFF	; 255
    1b8c:	ef 2e       	mov	r14, r31
    1b8e:	ff ef       	ldi	r31, 0xFF	; 255
    1b90:	ff 2e       	mov	r15, r31
    1b92:	f0 2d       	mov	r31, r0
    1b94:	c0 0e       	add	r12, r16
    1b96:	d1 1e       	adc	r13, r17
    1b98:	e2 1e       	adc	r14, r18
    1b9a:	f3 1e       	adc	r15, r19
    1b9c:	9b e3       	ldi	r25, 0x3B	; 59
    1b9e:	c9 16       	cp	r12, r25
    1ba0:	9b e6       	ldi	r25, 0x6B	; 107
    1ba2:	d9 06       	cpc	r13, r25
    1ba4:	90 e0       	ldi	r25, 0x00	; 0
    1ba6:	e9 06       	cpc	r14, r25
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	f9 06       	cpc	r15, r25
    1bac:	18 f4       	brcc	.+6      	; 0x1bb4 <Pwm_Start+0x44>
	sgl_Prescaler=PWM_PRESCALER_NO;
    1bae:	10 92 18 01 	sts	0x0118, r1
    1bb2:	a2 c0       	rjmp	.+324    	; 0x1cf8 <Pwm_Start+0x188>
else if(Frequncy <= 3921 && Frequncy > 980)
    1bb4:	0f 2e       	mov	r0, r31
    1bb6:	fb e2       	ldi	r31, 0x2B	; 43
    1bb8:	cf 2e       	mov	r12, r31
    1bba:	fc ef       	ldi	r31, 0xFC	; 252
    1bbc:	df 2e       	mov	r13, r31
    1bbe:	ff ef       	ldi	r31, 0xFF	; 255
    1bc0:	ef 2e       	mov	r14, r31
    1bc2:	ff ef       	ldi	r31, 0xFF	; 255
    1bc4:	ff 2e       	mov	r15, r31
    1bc6:	f0 2d       	mov	r31, r0
    1bc8:	c0 0e       	add	r12, r16
    1bca:	d1 1e       	adc	r13, r17
    1bcc:	e2 1e       	adc	r14, r18
    1bce:	f3 1e       	adc	r15, r19
    1bd0:	9d e7       	ldi	r25, 0x7D	; 125
    1bd2:	c9 16       	cp	r12, r25
    1bd4:	9b e0       	ldi	r25, 0x0B	; 11
    1bd6:	d9 06       	cpc	r13, r25
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	e9 06       	cpc	r14, r25
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	f9 06       	cpc	r15, r25
    1be0:	20 f4       	brcc	.+8      	; 0x1bea <Pwm_Start+0x7a>
	sgl_Prescaler=PWM_PRESCALER_8;
    1be2:	91 e0       	ldi	r25, 0x01	; 1
    1be4:	90 93 18 01 	sts	0x0118, r25
    1be8:	a5 c0       	rjmp	.+330    	; 0x1d34 <Pwm_Start+0x1c4>
else if(Frequncy <= 980 && Frequncy > 490)
    1bea:	0f 2e       	mov	r0, r31
    1bec:	f5 e1       	ldi	r31, 0x15	; 21
    1bee:	cf 2e       	mov	r12, r31
    1bf0:	fe ef       	ldi	r31, 0xFE	; 254
    1bf2:	df 2e       	mov	r13, r31
    1bf4:	ff ef       	ldi	r31, 0xFF	; 255
    1bf6:	ef 2e       	mov	r14, r31
    1bf8:	ff ef       	ldi	r31, 0xFF	; 255
    1bfa:	ff 2e       	mov	r15, r31
    1bfc:	f0 2d       	mov	r31, r0
    1bfe:	c0 0e       	add	r12, r16
    1c00:	d1 1e       	adc	r13, r17
    1c02:	e2 1e       	adc	r14, r18
    1c04:	f3 1e       	adc	r15, r19
    1c06:	9a ee       	ldi	r25, 0xEA	; 234
    1c08:	c9 16       	cp	r12, r25
    1c0a:	91 e0       	ldi	r25, 0x01	; 1
    1c0c:	d9 06       	cpc	r13, r25
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	e9 06       	cpc	r14, r25
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	f9 06       	cpc	r15, r25
    1c16:	20 f4       	brcc	.+8      	; 0x1c20 <Pwm_Start+0xb0>
	sgl_Prescaler=PWM_PRESCALER_32;
    1c18:	92 e0       	ldi	r25, 0x02	; 2
    1c1a:	90 93 18 01 	sts	0x0118, r25
    1c1e:	a1 c0       	rjmp	.+322    	; 0x1d62 <Pwm_Start+0x1f2>
else if(Frequncy <= 490 && Frequncy > 245)
    1c20:	0f 2e       	mov	r0, r31
    1c22:	fa e0       	ldi	r31, 0x0A	; 10
    1c24:	cf 2e       	mov	r12, r31
    1c26:	ff ef       	ldi	r31, 0xFF	; 255
    1c28:	df 2e       	mov	r13, r31
    1c2a:	ff ef       	ldi	r31, 0xFF	; 255
    1c2c:	ef 2e       	mov	r14, r31
    1c2e:	ff ef       	ldi	r31, 0xFF	; 255
    1c30:	ff 2e       	mov	r15, r31
    1c32:	f0 2d       	mov	r31, r0
    1c34:	c0 0e       	add	r12, r16
    1c36:	d1 1e       	adc	r13, r17
    1c38:	e2 1e       	adc	r14, r18
    1c3a:	f3 1e       	adc	r15, r19
    1c3c:	95 ef       	ldi	r25, 0xF5	; 245
    1c3e:	c9 16       	cp	r12, r25
    1c40:	d1 04       	cpc	r13, r1
    1c42:	e1 04       	cpc	r14, r1
    1c44:	f1 04       	cpc	r15, r1
    1c46:	20 f4       	brcc	.+8      	; 0x1c50 <Pwm_Start+0xe0>
	sgl_Prescaler=PWM_PRESCALER_64;
    1c48:	93 e0       	ldi	r25, 0x03	; 3
    1c4a:	90 93 18 01 	sts	0x0118, r25
    1c4e:	90 c0       	rjmp	.+288    	; 0x1d70 <Pwm_Start+0x200>
else if(Frequncy <= 245 && Frequncy > 122)
    1c50:	0f 2e       	mov	r0, r31
    1c52:	f5 e8       	ldi	r31, 0x85	; 133
    1c54:	cf 2e       	mov	r12, r31
    1c56:	ff ef       	ldi	r31, 0xFF	; 255
    1c58:	df 2e       	mov	r13, r31
    1c5a:	ff ef       	ldi	r31, 0xFF	; 255
    1c5c:	ef 2e       	mov	r14, r31
    1c5e:	ff ef       	ldi	r31, 0xFF	; 255
    1c60:	ff 2e       	mov	r15, r31
    1c62:	f0 2d       	mov	r31, r0
    1c64:	c0 0e       	add	r12, r16
    1c66:	d1 1e       	adc	r13, r17
    1c68:	e2 1e       	adc	r14, r18
    1c6a:	f3 1e       	adc	r15, r19
    1c6c:	9b e7       	ldi	r25, 0x7B	; 123
    1c6e:	c9 16       	cp	r12, r25
    1c70:	d1 04       	cpc	r13, r1
    1c72:	e1 04       	cpc	r14, r1
    1c74:	f1 04       	cpc	r15, r1
    1c76:	20 f4       	brcc	.+8      	; 0x1c80 <Pwm_Start+0x110>
	sgl_Prescaler=PWM_PRESCALER_128;
    1c78:	94 e0       	ldi	r25, 0x04	; 4
    1c7a:	90 93 18 01 	sts	0x0118, r25
    1c7e:	a5 c0       	rjmp	.+330    	; 0x1dca <Pwm_Start+0x25a>
else if(Frequncy <= 122 && Frequncy > 31)
    1c80:	0f 2e       	mov	r0, r31
    1c82:	f0 ee       	ldi	r31, 0xE0	; 224
    1c84:	cf 2e       	mov	r12, r31
    1c86:	ff ef       	ldi	r31, 0xFF	; 255
    1c88:	df 2e       	mov	r13, r31
    1c8a:	ff ef       	ldi	r31, 0xFF	; 255
    1c8c:	ef 2e       	mov	r14, r31
    1c8e:	ff ef       	ldi	r31, 0xFF	; 255
    1c90:	ff 2e       	mov	r15, r31
    1c92:	f0 2d       	mov	r31, r0
    1c94:	c0 0e       	add	r12, r16
    1c96:	d1 1e       	adc	r13, r17
    1c98:	e2 1e       	adc	r14, r18
    1c9a:	f3 1e       	adc	r15, r19
    1c9c:	9b e5       	ldi	r25, 0x5B	; 91
    1c9e:	c9 16       	cp	r12, r25
    1ca0:	d1 04       	cpc	r13, r1
    1ca2:	e1 04       	cpc	r14, r1
    1ca4:	f1 04       	cpc	r15, r1
    1ca6:	20 f4       	brcc	.+8      	; 0x1cb0 <Pwm_Start+0x140>
	sgl_Prescaler=PWM_PRESCALER_256;
    1ca8:	95 e0       	ldi	r25, 0x05	; 5
    1caa:	90 93 18 01 	sts	0x0118, r25
    1cae:	77 c0       	rjmp	.+238    	; 0x1d9e <Pwm_Start+0x22e>
else if(Frequncy <= 31 && Frequncy > 0)
    1cb0:	01 50       	subi	r16, 0x01	; 1
    1cb2:	10 40       	sbci	r17, 0x00	; 0
    1cb4:	20 40       	sbci	r18, 0x00	; 0
    1cb6:	30 40       	sbci	r19, 0x00	; 0
    1cb8:	0f 31       	cpi	r16, 0x1F	; 31
    1cba:	11 05       	cpc	r17, r1
    1cbc:	21 05       	cpc	r18, r1
    1cbe:	31 05       	cpc	r19, r1
    1cc0:	20 f4       	brcc	.+8      	; 0x1cca <Pwm_Start+0x15a>
	sgl_Prescaler=PWM_PRESCALER_1024;
    1cc2:	96 e0       	ldi	r25, 0x06	; 6
    1cc4:	90 93 18 01 	sts	0x0118, r25
    1cc8:	86 c0       	rjmp	.+268    	; 0x1dd6 <Pwm_Start+0x266>
else{Ret=E_NOK;}
switch(sgl_Prescaler)
    1cca:	90 91 18 01 	lds	r25, 0x0118
    1cce:	93 30       	cpi	r25, 0x03	; 3
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <Pwm_Start+0x164>
    1cd2:	4e c0       	rjmp	.+156    	; 0x1d70 <Pwm_Start+0x200>
    1cd4:	94 30       	cpi	r25, 0x04	; 4
    1cd6:	30 f4       	brcc	.+12     	; 0x1ce4 <Pwm_Start+0x174>
    1cd8:	91 30       	cpi	r25, 0x01	; 1
    1cda:	61 f1       	breq	.+88     	; 0x1d34 <Pwm_Start+0x1c4>
    1cdc:	92 30       	cpi	r25, 0x02	; 2
    1cde:	08 f0       	brcs	.+2      	; 0x1ce2 <Pwm_Start+0x172>
    1ce0:	40 c0       	rjmp	.+128    	; 0x1d62 <Pwm_Start+0x1f2>
    1ce2:	0a c0       	rjmp	.+20     	; 0x1cf8 <Pwm_Start+0x188>
    1ce4:	95 30       	cpi	r25, 0x05	; 5
    1ce6:	09 f4       	brne	.+2      	; 0x1cea <Pwm_Start+0x17a>
    1ce8:	5a c0       	rjmp	.+180    	; 0x1d9e <Pwm_Start+0x22e>
    1cea:	95 30       	cpi	r25, 0x05	; 5
    1cec:	08 f4       	brcc	.+2      	; 0x1cf0 <Pwm_Start+0x180>
    1cee:	6d c0       	rjmp	.+218    	; 0x1dca <Pwm_Start+0x25a>
    1cf0:	96 30       	cpi	r25, 0x06	; 6
    1cf2:	09 f0       	breq	.+2      	; 0x1cf6 <Pwm_Start+0x186>
    1cf4:	8d c0       	rjmp	.+282    	; 0x1e10 <Pwm_Start+0x2a0>
    1cf6:	6f c0       	rjmp	.+222    	; 0x1dd6 <Pwm_Start+0x266>
{
	case PWM_PRESCALER_NO:
	{
		switch(Channel)
    1cf8:	81 30       	cpi	r24, 0x01	; 1
    1cfa:	61 f0       	breq	.+24     	; 0x1d14 <Pwm_Start+0x1a4>
    1cfc:	81 30       	cpi	r24, 0x01	; 1
    1cfe:	30 f0       	brcs	.+12     	; 0x1d0c <Pwm_Start+0x19c>
    1d00:	82 30       	cpi	r24, 0x02	; 2
    1d02:	71 f0       	breq	.+28     	; 0x1d20 <Pwm_Start+0x1b0>
    1d04:	83 30       	cpi	r24, 0x03	; 3
    1d06:	09 f0       	breq	.+2      	; 0x1d0a <Pwm_Start+0x19a>
    1d08:	83 c0       	rjmp	.+262    	; 0x1e10 <Pwm_Start+0x2a0>
    1d0a:	10 c0       	rjmp	.+32     	; 0x1d2c <Pwm_Start+0x1bc>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_NO_CONFIG;
    1d0c:	83 b7       	in	r24, 0x33	; 51
    1d0e:	81 60       	ori	r24, 0x01	; 1
    1d10:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d12:	88 c0       	rjmp	.+272    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			{
			TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1d14:	8e b5       	in	r24, 0x2e	; 46
    1d16:	9f b5       	in	r25, 0x2f	; 47
    1d18:	81 60       	ori	r24, 0x01	; 1
    1d1a:	9f bd       	out	0x2f, r25	; 47
    1d1c:	8e bd       	out	0x2e, r24	; 46
			Ret=E_OK;
			break;
    1d1e:	98 c0       	rjmp	.+304    	; 0x1e50 <Pwm_Start+0x2e0>
			}			
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1d20:	8e b5       	in	r24, 0x2e	; 46
    1d22:	9f b5       	in	r25, 0x2f	; 47
    1d24:	81 60       	ori	r24, 0x01	; 1
    1d26:	9f bd       	out	0x2f, r25	; 47
    1d28:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1d2a:	ad c0       	rjmp	.+346    	; 0x1e86 <Pwm_Start+0x316>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_NO_CONFIG;
    1d2c:	85 b5       	in	r24, 0x25	; 37
    1d2e:	81 60       	ori	r24, 0x01	; 1
    1d30:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d32:	c4 c0       	rjmp	.+392    	; 0x1ebc <Pwm_Start+0x34c>
	}

	
	case PWM_PRESCALER_8:
	{
		switch(Channel)
    1d34:	83 30       	cpi	r24, 0x03	; 3
    1d36:	18 f4       	brcc	.+6      	; 0x1d3e <Pwm_Start+0x1ce>
    1d38:	81 30       	cpi	r24, 0x01	; 1
    1d3a:	48 f4       	brcc	.+18     	; 0x1d4e <Pwm_Start+0x1de>
    1d3c:	04 c0       	rjmp	.+8      	; 0x1d46 <Pwm_Start+0x1d6>
    1d3e:	83 30       	cpi	r24, 0x03	; 3
    1d40:	09 f0       	breq	.+2      	; 0x1d44 <Pwm_Start+0x1d4>
    1d42:	66 c0       	rjmp	.+204    	; 0x1e10 <Pwm_Start+0x2a0>
    1d44:	0a c0       	rjmp	.+20     	; 0x1d5a <Pwm_Start+0x1ea>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_8_CONFIG;
    1d46:	83 b7       	in	r24, 0x33	; 51
    1d48:	82 60       	ori	r24, 0x02	; 2
    1d4a:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d4c:	6b c0       	rjmp	.+214    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_8_CONFIG;
    1d4e:	2e b5       	in	r18, 0x2e	; 46
    1d50:	3f b5       	in	r19, 0x2f	; 47
    1d52:	22 60       	ori	r18, 0x02	; 2
    1d54:	3f bd       	out	0x2f, r19	; 47
    1d56:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1d58:	5b c0       	rjmp	.+182    	; 0x1e10 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_8_CONFIG;
    1d5a:	85 b5       	in	r24, 0x25	; 37
    1d5c:	82 60       	ori	r24, 0x02	; 2
    1d5e:	85 bd       	out	0x25, r24	; 37
			Ret=E_OK;	
				break;
    1d60:	ad c0       	rjmp	.+346    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_32:
	{
		switch(Channel)
    1d62:	83 30       	cpi	r24, 0x03	; 3
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <Pwm_Start+0x1f8>
    1d66:	54 c0       	rjmp	.+168    	; 0x1e10 <Pwm_Start+0x2a0>
		{
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_32_CONFIG_T2;
    1d68:	85 b5       	in	r24, 0x25	; 37
    1d6a:	83 60       	ori	r24, 0x03	; 3
    1d6c:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d6e:	a6 c0       	rjmp	.+332    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_64:
	{
		switch(Channel)
    1d70:	83 30       	cpi	r24, 0x03	; 3
    1d72:	18 f4       	brcc	.+6      	; 0x1d7a <Pwm_Start+0x20a>
    1d74:	81 30       	cpi	r24, 0x01	; 1
    1d76:	48 f4       	brcc	.+18     	; 0x1d8a <Pwm_Start+0x21a>
    1d78:	04 c0       	rjmp	.+8      	; 0x1d82 <Pwm_Start+0x212>
    1d7a:	83 30       	cpi	r24, 0x03	; 3
    1d7c:	09 f0       	breq	.+2      	; 0x1d80 <Pwm_Start+0x210>
    1d7e:	48 c0       	rjmp	.+144    	; 0x1e10 <Pwm_Start+0x2a0>
    1d80:	0a c0       	rjmp	.+20     	; 0x1d96 <Pwm_Start+0x226>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_64_CONFIG;
    1d82:	83 b7       	in	r24, 0x33	; 51
    1d84:	83 60       	ori	r24, 0x03	; 3
    1d86:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1d88:	4d c0       	rjmp	.+154    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_64_CONFIG;
    1d8a:	2e b5       	in	r18, 0x2e	; 46
    1d8c:	3f b5       	in	r19, 0x2f	; 47
    1d8e:	23 60       	ori	r18, 0x03	; 3
    1d90:	3f bd       	out	0x2f, r19	; 47
    1d92:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1d94:	3d c0       	rjmp	.+122    	; 0x1e10 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_64_CONFIG_T2;
    1d96:	85 b5       	in	r24, 0x25	; 37
    1d98:	84 60       	ori	r24, 0x04	; 4
    1d9a:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1d9c:	8f c0       	rjmp	.+286    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_256:
	{
		switch(Channel)
    1d9e:	83 30       	cpi	r24, 0x03	; 3
    1da0:	18 f4       	brcc	.+6      	; 0x1da8 <Pwm_Start+0x238>
    1da2:	81 30       	cpi	r24, 0x01	; 1
    1da4:	40 f4       	brcc	.+16     	; 0x1db6 <Pwm_Start+0x246>
    1da6:	03 c0       	rjmp	.+6      	; 0x1dae <Pwm_Start+0x23e>
    1da8:	83 30       	cpi	r24, 0x03	; 3
    1daa:	91 f5       	brne	.+100    	; 0x1e10 <Pwm_Start+0x2a0>
    1dac:	0a c0       	rjmp	.+20     	; 0x1dc2 <Pwm_Start+0x252>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_64_CONFIG;
    1dae:	83 b7       	in	r24, 0x33	; 51
    1db0:	83 60       	ori	r24, 0x03	; 3
    1db2:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1db4:	37 c0       	rjmp	.+110    	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_64_CONFIG;
    1db6:	2e b5       	in	r18, 0x2e	; 46
    1db8:	3f b5       	in	r19, 0x2f	; 47
    1dba:	23 60       	ori	r18, 0x03	; 3
    1dbc:	3f bd       	out	0x2f, r19	; 47
    1dbe:	2e bd       	out	0x2e, r18	; 46
				Ret=E_OK;
				break;
    1dc0:	27 c0       	rjmp	.+78     	; 0x1e10 <Pwm_Start+0x2a0>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_64_CONFIG_T2;
    1dc2:	85 b5       	in	r24, 0x25	; 37
    1dc4:	84 60       	ori	r24, 0x04	; 4
    1dc6:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1dc8:	79 c0       	rjmp	.+242    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_128:
	{
		switch(Channel)
    1dca:	83 30       	cpi	r24, 0x03	; 3
    1dcc:	09 f5       	brne	.+66     	; 0x1e10 <Pwm_Start+0x2a0>
		{
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_128_CONFIG_T2;
    1dce:	85 b5       	in	r24, 0x25	; 37
    1dd0:	85 60       	ori	r24, 0x05	; 5
    1dd2:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1dd4:	73 c0       	rjmp	.+230    	; 0x1ebc <Pwm_Start+0x34c>
		break;
	}
	
	case PWM_PRESCALER_1024:
	{
		switch(Channel)
    1dd6:	81 30       	cpi	r24, 0x01	; 1
    1dd8:	59 f0       	breq	.+22     	; 0x1df0 <Pwm_Start+0x280>
    1dda:	81 30       	cpi	r24, 0x01	; 1
    1ddc:	28 f0       	brcs	.+10     	; 0x1de8 <Pwm_Start+0x278>
    1dde:	82 30       	cpi	r24, 0x02	; 2
    1de0:	69 f0       	breq	.+26     	; 0x1dfc <Pwm_Start+0x28c>
    1de2:	83 30       	cpi	r24, 0x03	; 3
    1de4:	a9 f4       	brne	.+42     	; 0x1e10 <Pwm_Start+0x2a0>
    1de6:	10 c0       	rjmp	.+32     	; 0x1e08 <Pwm_Start+0x298>
		{
			case PWM_CH0:
			{
				TCCR0|=PWM_PRESCALER_1024_CONFIG;
    1de8:	83 b7       	in	r24, 0x33	; 51
    1dea:	85 60       	ori	r24, 0x05	; 5
    1dec:	83 bf       	out	0x33, r24	; 51
				Ret=E_OK;
				break;
    1dee:	1a c0       	rjmp	.+52     	; 0x1e24 <Pwm_Start+0x2b4>
			}
			case PWM_CH1A:
			{	TCCR1|=PWM_PRESCALER_NO_CONFIG;
    1df0:	8e b5       	in	r24, 0x2e	; 46
    1df2:	9f b5       	in	r25, 0x2f	; 47
    1df4:	81 60       	ori	r24, 0x01	; 1
    1df6:	9f bd       	out	0x2f, r25	; 47
    1df8:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1dfa:	2a c0       	rjmp	.+84     	; 0x1e50 <Pwm_Start+0x2e0>
			}
			case PWM_CH1B:
			{	TCCR1|=PWM_PRESCALER_1024_CONFIG;
    1dfc:	8e b5       	in	r24, 0x2e	; 46
    1dfe:	9f b5       	in	r25, 0x2f	; 47
    1e00:	85 60       	ori	r24, 0x05	; 5
    1e02:	9f bd       	out	0x2f, r25	; 47
    1e04:	8e bd       	out	0x2e, r24	; 46
				Ret=E_OK;
				break;
    1e06:	3f c0       	rjmp	.+126    	; 0x1e86 <Pwm_Start+0x316>
			}
			case PWM_CH2:
			{TCCR2|=PWM_PRESCALER_1024_CONFIG_T2;
    1e08:	85 b5       	in	r24, 0x25	; 37
    1e0a:	87 60       	ori	r24, 0x07	; 7
    1e0c:	85 bd       	out	0x25, r24	; 37
				Ret=E_OK;
				break;
    1e0e:	56 c0       	rjmp	.+172    	; 0x1ebc <Pwm_Start+0x34c>

	
	
}

switch(Channel)
    1e10:	81 30       	cpi	r24, 0x01	; 1
    1e12:	f1 f0       	breq	.+60     	; 0x1e50 <Pwm_Start+0x2e0>
    1e14:	81 30       	cpi	r24, 0x01	; 1
    1e16:	30 f0       	brcs	.+12     	; 0x1e24 <Pwm_Start+0x2b4>
    1e18:	82 30       	cpi	r24, 0x02	; 2
    1e1a:	a9 f1       	breq	.+106    	; 0x1e86 <Pwm_Start+0x316>
    1e1c:	83 30       	cpi	r24, 0x03	; 3
    1e1e:	09 f0       	breq	.+2      	; 0x1e22 <Pwm_Start+0x2b2>
    1e20:	63 c0       	rjmp	.+198    	; 0x1ee8 <Pwm_Start+0x378>
    1e22:	4c c0       	rjmp	.+152    	; 0x1ebc <Pwm_Start+0x34c>
		{
			case PWM_CH0:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	80 e0       	ldi	r24, 0x00	; 0
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	0e 94 99 29 	call	0x5332	; 0x5332 <__floatunsisf>
    1e2e:	20 e0       	ldi	r18, 0x00	; 0
    1e30:	30 e0       	ldi	r19, 0x00	; 0
    1e32:	48 ec       	ldi	r20, 0xC8	; 200
    1e34:	52 e4       	ldi	r21, 0x42	; 66
    1e36:	0e 94 05 29 	call	0x520a	; 0x520a <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1e3a:	20 e0       	ldi	r18, 0x00	; 0
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	4f e7       	ldi	r20, 0x7F	; 127
    1e40:	53 e4       	ldi	r21, 0x43	; 67
    1e42:	0e 94 27 2a 	call	0x544e	; 0x544e <__mulsf3>
    1e46:	0e 94 6d 29 	call	0x52da	; 0x52da <__fixunssfsi>
			OCR0=pwm_time_on;
    1e4a:	6c bf       	out	0x3c, r22	; 60
			Ret=E_OK;
    1e4c:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1e4e:	4d c0       	rjmp	.+154    	; 0x1eea <Pwm_Start+0x37a>
			}			
			case PWM_CH1A:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1e50:	70 e0       	ldi	r23, 0x00	; 0
    1e52:	80 e0       	ldi	r24, 0x00	; 0
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	0e 94 99 29 	call	0x5332	; 0x5332 <__floatunsisf>
    1e5a:	20 e0       	ldi	r18, 0x00	; 0
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	48 ec       	ldi	r20, 0xC8	; 200
    1e60:	52 e4       	ldi	r21, 0x42	; 66
    1e62:	0e 94 05 29 	call	0x520a	; 0x520a <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1e66:	20 e0       	ldi	r18, 0x00	; 0
    1e68:	30 e0       	ldi	r19, 0x00	; 0
    1e6a:	4f e7       	ldi	r20, 0x7F	; 127
    1e6c:	53 e4       	ldi	r21, 0x43	; 67
    1e6e:	0e 94 27 2a 	call	0x544e	; 0x544e <__mulsf3>
    1e72:	0e 94 6d 29 	call	0x52da	; 0x52da <__fixunssfsi>
    1e76:	dc 01       	movw	r26, r24
    1e78:	cb 01       	movw	r24, r22
			OCR1A=pwm_time_on;
    1e7a:	9b bd       	out	0x2b, r25	; 43
    1e7c:	8a bd       	out	0x2a, r24	; 42
			OCR1B=pwm_time_on;
    1e7e:	99 bd       	out	0x29, r25	; 41
    1e80:	88 bd       	out	0x28, r24	; 40
			Ret=E_OK;
    1e82:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1e84:	32 c0       	rjmp	.+100    	; 0x1eea <Pwm_Start+0x37a>
			}			
			case PWM_CH1B:{
			pwm_time_on=MAX_HOLD;
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1e86:	70 e0       	ldi	r23, 0x00	; 0
    1e88:	80 e0       	ldi	r24, 0x00	; 0
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	0e 94 99 29 	call	0x5332	; 0x5332 <__floatunsisf>
    1e90:	20 e0       	ldi	r18, 0x00	; 0
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	48 ec       	ldi	r20, 0xC8	; 200
    1e96:	52 e4       	ldi	r21, 0x42	; 66
    1e98:	0e 94 05 29 	call	0x520a	; 0x520a <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1e9c:	20 e0       	ldi	r18, 0x00	; 0
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	4f e7       	ldi	r20, 0x7F	; 127
    1ea2:	53 e4       	ldi	r21, 0x43	; 67
    1ea4:	0e 94 27 2a 	call	0x544e	; 0x544e <__mulsf3>
    1ea8:	0e 94 6d 29 	call	0x52da	; 0x52da <__fixunssfsi>
    1eac:	dc 01       	movw	r26, r24
    1eae:	cb 01       	movw	r24, r22
			OCR1A=pwm_time_on;
    1eb0:	9b bd       	out	0x2b, r25	; 43
    1eb2:	8a bd       	out	0x2a, r24	; 42
			OCR1B=pwm_time_on;
    1eb4:	99 bd       	out	0x29, r25	; 41
    1eb6:	88 bd       	out	0x28, r24	; 40
			Ret=E_OK;
    1eb8:	80 e0       	ldi	r24, 0x00	; 0
			break;
    1eba:	17 c0       	rjmp	.+46     	; 0x1eea <Pwm_Start+0x37a>
			}
			case PWM_CH2:{
			pwm_time_on=MAX_HOLD;	
			dutyReal=((float)Duty/(float)FULL_SPEED);
    1ebc:	70 e0       	ldi	r23, 0x00	; 0
    1ebe:	80 e0       	ldi	r24, 0x00	; 0
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	0e 94 99 29 	call	0x5332	; 0x5332 <__floatunsisf>
    1ec6:	20 e0       	ldi	r18, 0x00	; 0
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	48 ec       	ldi	r20, 0xC8	; 200
    1ecc:	52 e4       	ldi	r21, 0x42	; 66
    1ece:	0e 94 05 29 	call	0x520a	; 0x520a <__divsf3>
			pwm_time_on=(float)pwm_time_on*dutyReal;
    1ed2:	20 e0       	ldi	r18, 0x00	; 0
    1ed4:	30 e0       	ldi	r19, 0x00	; 0
    1ed6:	4f e7       	ldi	r20, 0x7F	; 127
    1ed8:	53 e4       	ldi	r21, 0x43	; 67
    1eda:	0e 94 27 2a 	call	0x544e	; 0x544e <__mulsf3>
    1ede:	0e 94 6d 29 	call	0x52da	; 0x52da <__fixunssfsi>
			OCR2=pwm_time_on;
    1ee2:	63 bd       	out	0x23, r22	; 35
			Ret=E_OK;
    1ee4:	80 e0       	ldi	r24, 0x00	; 0
			}			
			break;
    1ee6:	01 c0       	rjmp	.+2      	; 0x1eea <Pwm_Start+0x37a>
			default:
			Ret=E_NOK;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
			break;
		}
sgl_is_started=1;
    1eea:	91 e0       	ldi	r25, 0x01	; 1
    1eec:	90 93 19 01 	sts	0x0119, r25
return Ret;
}
    1ef0:	1f 91       	pop	r17
    1ef2:	0f 91       	pop	r16
    1ef4:	ff 90       	pop	r15
    1ef6:	ef 90       	pop	r14
    1ef8:	df 90       	pop	r13
    1efa:	cf 90       	pop	r12
    1efc:	08 95       	ret

00001efe <Pwm_Update>:


ERROR_STATUS Pwm_Update(uint8_t Channel,uint8_t Duty,uint32_t Frequncy)
{
uint8_t Ret=0;
if (sgl_is_started == 1)
    1efe:	90 91 19 01 	lds	r25, 0x0119
    1f02:	91 30       	cpi	r25, 0x01	; 1
    1f04:	21 f4       	brne	.+8      	; 0x1f0e <Pwm_Update+0x10>
{
	Pwm_Start( Channel,Duty,Frequncy);
    1f06:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <Pwm_Start>
Ret=E_OK;
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	08 95       	ret
}else{Ret=E_NOK;}
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
	

return Ret;
}
    1f10:	08 95       	ret

00001f12 <Pwm_Stop>:
/*********************************************************************************/

ERROR_STATUS Pwm_Stop(uint8_t Channel)
{
uint8_t Ret=0;
switch(Channel)
    1f12:	83 30       	cpi	r24, 0x03	; 3
    1f14:	18 f4       	brcc	.+6      	; 0x1f1c <Pwm_Stop+0xa>
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	48 f4       	brcc	.+18     	; 0x1f2c <Pwm_Stop+0x1a>
    1f1a:	03 c0       	rjmp	.+6      	; 0x1f22 <Pwm_Stop+0x10>
    1f1c:	83 30       	cpi	r24, 0x03	; 3
    1f1e:	81 f4       	brne	.+32     	; 0x1f40 <Pwm_Stop+0x2e>
    1f20:	0a c0       	rjmp	.+20     	; 0x1f36 <Pwm_Stop+0x24>
{
	case PWM_CH0:
	TCCR0 &=TIMER_STOPT02;
    1f22:	83 b7       	in	r24, 0x33	; 51
    1f24:	88 7f       	andi	r24, 0xF8	; 248
    1f26:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
    1f28:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1f2a:	08 95       	ret

	case PWM_CH1A:
	case PWM_CH1B:
	TCCR0 &=TIMER_STOPT1;
    1f2c:	83 b7       	in	r24, 0x33	; 51
    1f2e:	88 7f       	andi	r24, 0xF8	; 248
    1f30:	83 bf       	out	0x33, r24	; 51
	Ret=E_OK;
    1f32:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1f34:	08 95       	ret


	case PWM_CH2:
	TCCR2 &=TIMER_STOPT02;
    1f36:	85 b5       	in	r24, 0x25	; 37
    1f38:	88 7f       	andi	r24, 0xF8	; 248
    1f3a:	85 bd       	out	0x25, r24	; 37
	Ret=E_OK;
    1f3c:	80 e0       	ldi	r24, 0x00	; 0
	break;
    1f3e:	08 95       	ret
	default:
	Ret=E_NOK;
    1f40:	81 e0       	ldi	r24, 0x01	; 1
	break;
}

return Ret;
}
    1f42:	08 95       	ret

00001f44 <Timer_Init>:
 *
 */
 static uint8_t prescaler_value=0;
 
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{uint8_t Ret=E_OK;
    1f44:	1f 93       	push	r17
    1f46:	cf 93       	push	r28
    1f48:	df 93       	push	r29
    1f4a:	ec 01       	movw	r28, r24
prescaler_value=Timer_cfg->Timer_Prescaler;
    1f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4e:	80 93 1a 01 	sts	0x011A, r24
if (Timer_cfg==NULL)
    1f52:	20 97       	sbiw	r28, 0x00	; 0
    1f54:	11 f0       	breq	.+4      	; 0x1f5a <Timer_Init+0x16>
 *
 */
 static uint8_t prescaler_value=0;
 
ERROR_STATUS Timer_Init(Timer_cfg_s* Timer_cfg)
{uint8_t Ret=E_OK;
    1f56:	10 e0       	ldi	r17, 0x00	; 0
    1f58:	01 c0       	rjmp	.+2      	; 0x1f5c <Timer_Init+0x18>
prescaler_value=Timer_cfg->Timer_Prescaler;
if (Timer_cfg==NULL)
{
	Ret=TIMER_MODULE+NULL_PTR;
    1f5a:	10 e2       	ldi	r17, 0x20	; 32
}
switch (Timer_cfg->Timer_CH_NO) {
    1f5c:	88 81       	ld	r24, Y
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <Timer_Init+0x20>
    1f62:	4c c0       	rjmp	.+152    	; 0x1ffc <Timer_Init+0xb8>
    1f64:	81 30       	cpi	r24, 0x01	; 1
    1f66:	20 f0       	brcs	.+8      	; 0x1f70 <Timer_Init+0x2c>
    1f68:	82 30       	cpi	r24, 0x02	; 2
    1f6a:	09 f0       	breq	.+2      	; 0x1f6e <Timer_Init+0x2a>
    1f6c:	d8 c0       	rjmp	.+432    	; 0x211e <Timer_Init+0x1da>
    1f6e:	93 c0       	rjmp	.+294    	; 0x2096 <Timer_Init+0x152>
/*************************************************************************/
/*                             TIMER 0                                   */
/*************************************************************************/
    case TIMER_CH0:
        {
  TCCR0 |=T0_NORMAL_MODE;
    1f70:	83 b7       	in	r24, 0x33	; 51
    1f72:	83 bf       	out	0x33, r24	; 51
  
          switch (Timer_cfg->Timer_Mode) {
    1f74:	89 81       	ldd	r24, Y+1	; 0x01
    1f76:	81 30       	cpi	r24, 0x01	; 1
    1f78:	b9 f0       	breq	.+46     	; 0x1fa8 <Timer_Init+0x64>
    1f7a:	81 30       	cpi	r24, 0x01	; 1
    1f7c:	18 f0       	brcs	.+6      	; 0x1f84 <Timer_Init+0x40>
    1f7e:	82 30       	cpi	r24, 0x02	; 2
    1f80:	e1 f5       	brne	.+120    	; 0x1ffa <Timer_Init+0xb6>
    1f82:	26 c0       	rjmp	.+76     	; 0x1fd0 <Timer_Init+0x8c>
          case TIMER_MODE:
              {
                switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    1f84:	8a 81       	ldd	r24, Y+2	; 0x02
    1f86:	88 23       	and	r24, r24
    1f88:	19 f0       	breq	.+6      	; 0x1f90 <Timer_Init+0x4c>
    1f8a:	81 30       	cpi	r24, 0x01	; 1
    1f8c:	59 f4       	brne	.+22     	; 0x1fa4 <Timer_Init+0x60>
    1f8e:	04 c0       	rjmp	.+8      	; 0x1f98 <Timer_Init+0x54>
				{
                    case TIMER_POLLING_MODE:
                        {/*Disable interrupts for T0 without effecting any other timer*/
                         /*without Disabling Global interrupt*/
                        TIMSK &=T0_INTERRUPT_DISABLE;
    1f90:	89 b7       	in	r24, 0x39	; 57
    1f92:	8c 7f       	andi	r24, 0xFC	; 252
    1f94:	89 bf       	out	0x39, r24	; 57
                            break;
    1f96:	32 c0       	rjmp	.+100    	; 0x1ffc <Timer_Init+0xb8>
                         }
                                  case TIMER_INTERRUPT_MODE:
                                  { /*Enable Global INTERRUPT
                                    Enable Timer0 interrupt
                                    */
                                    G_interrupt_Enable();
    1f98:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                                    TIMSK |= T0_INTERRUPT_NORMAL;
    1f9c:	89 b7       	in	r24, 0x39	; 57
    1f9e:	81 60       	ori	r24, 0x01	; 1
    1fa0:	89 bf       	out	0x39, r24	; 57
                                    break;
    1fa2:	2c c0       	rjmp	.+88     	; 0x1ffc <Timer_Init+0xb8>
                                  }
                                  default :
                                  Ret+=E_NOK;
    1fa4:	1f 5f       	subi	r17, 0xFF	; 255
								  break;
    1fa6:	2a c0       	rjmp	.+84     	; 0x1ffc <Timer_Init+0xb8>
/*                             TIMER 0 As a COUNTER_RISING_MODE          */
/*************************************************************************/

                          case COUNTER_RISING_MODE:
                            {
                                  TCCR0 |=T0_COUNTER_RISING_MODE_CONFIG;
    1fa8:	83 b7       	in	r24, 0x33	; 51
    1faa:	8d 60       	ori	r24, 0x0D	; 13
    1fac:	83 bf       	out	0x33, r24	; 51
                                    switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1fae:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb0:	88 23       	and	r24, r24
    1fb2:	19 f0       	breq	.+6      	; 0x1fba <Timer_Init+0x76>
    1fb4:	81 30       	cpi	r24, 0x01	; 1
    1fb6:	59 f4       	brne	.+22     	; 0x1fce <Timer_Init+0x8a>
    1fb8:	04 c0       	rjmp	.+8      	; 0x1fc2 <Timer_Init+0x7e>
                                        case TIMER_POLLING_MODE:
                                          {
            /*Disable interrupts for T0 without effecting any other timer*/
              /*without Disabling Global interrupt*/
                                            TIMSK &=T0_INTERRUPT_DISABLE;
    1fba:	89 b7       	in	r24, 0x39	; 57
    1fbc:	8c 7f       	andi	r24, 0xFC	; 252
    1fbe:	89 bf       	out	0x39, r24	; 57
                                            break;
    1fc0:	07 c0       	rjmp	.+14     	; 0x1fd0 <Timer_Init+0x8c>

                                          case TIMER_INTERRUPT_MODE:
                                           /*Enable Global INTERRUPT
                                              Enable Timer0 interrupt
                                              */
                                              G_interrupt_Enable();
    1fc2:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                                              TIMSK |= T0_INTERRUPT_NORMAL;
    1fc6:	89 b7       	in	r24, 0x39	; 57
    1fc8:	81 60       	ori	r24, 0x01	; 1
    1fca:	89 bf       	out	0x39, r24	; 57
                                              break;
    1fcc:	01 c0       	rjmp	.+2      	; 0x1fd0 <Timer_Init+0x8c>

                                          default :
                                          Ret+=E_NOK;
    1fce:	1f 5f       	subi	r17, 0xFF	; 255
/*                             TIMER 0 As a COUNTER_FALLING_MODE         */
/*************************************************************************/

                                    case COUNTER_FALLING_MODE:
                                    {
                                        TCCR0 |=T0_COUNTER_FALLING_MODE_CONFIG;
    1fd0:	83 b7       	in	r24, 0x33	; 51
    1fd2:	8c 60       	ori	r24, 0x0C	; 12
    1fd4:	83 bf       	out	0x33, r24	; 51
                                          switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    1fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fd8:	88 23       	and	r24, r24
    1fda:	19 f0       	breq	.+6      	; 0x1fe2 <Timer_Init+0x9e>
    1fdc:	81 30       	cpi	r24, 0x01	; 1
    1fde:	59 f4       	brne	.+22     	; 0x1ff6 <Timer_Init+0xb2>
    1fe0:	04 c0       	rjmp	.+8      	; 0x1fea <Timer_Init+0xa6>
                                              case TIMER_POLLING_MODE:
                                                {

            /*Disable interrupts for T0 without effecting any other timer*/
                /*without Disabling Global interrupt*/
                                                  TIMSK &=T0_INTERRUPT_DISABLE;
    1fe2:	89 b7       	in	r24, 0x39	; 57
    1fe4:	8c 7f       	andi	r24, 0xFC	; 252
    1fe6:	89 bf       	out	0x39, r24	; 57

                                                  break;
    1fe8:	09 c0       	rjmp	.+18     	; 0x1ffc <Timer_Init+0xb8>
                                                case TIMER_INTERRUPT_MODE:
                                                  {
                                                    /*Enable Global INTERRUPT
                                                    Enable Timer0 interrupt
                                                    */
                                                    G_interrupt_Enable();
    1fea:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                                                    TIMSK |= T0_INTERRUPT_NORMAL;
    1fee:	89 b7       	in	r24, 0x39	; 57
    1ff0:	81 60       	ori	r24, 0x01	; 1
    1ff2:	89 bf       	out	0x39, r24	; 57

                                                    break;
    1ff4:	03 c0       	rjmp	.+6      	; 0x1ffc <Timer_Init+0xb8>
                                                  }
                                                  default:
                                                  Ret+=E_NOK;
    1ff6:	1f 5f       	subi	r17, 0xFF	; 255
												  break;
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <Timer_Init+0xb8>
                                                }
                                      break;
                                      }
                                      default:
                                      Ret+=E_NOK;
    1ffa:	1f 5f       	subi	r17, 0xFF	; 255
/*************************************************************************/

    case TIMER_CH1:
        {

    switch (Timer_cfg->Timer_Mode)
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	81 30       	cpi	r24, 0x01	; 1
    2000:	d1 f0       	breq	.+52     	; 0x2036 <Timer_Init+0xf2>
    2002:	81 30       	cpi	r24, 0x01	; 1
    2004:	20 f0       	brcs	.+8      	; 0x200e <Timer_Init+0xca>
    2006:	82 30       	cpi	r24, 0x02	; 2
    2008:	09 f0       	breq	.+2      	; 0x200c <Timer_Init+0xc8>
    200a:	43 c0       	rjmp	.+134    	; 0x2092 <Timer_Init+0x14e>
    200c:	2b c0       	rjmp	.+86     	; 0x2064 <Timer_Init+0x120>
    {
      case TIMER_MODE:
      {
        TCCR1 = T1_NORMAL_MODE_CONFIG;
    200e:	1f bc       	out	0x2f, r1	; 47
    2010:	1e bc       	out	0x2e, r1	; 46
              switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    2012:	8a 81       	ldd	r24, Y+2	; 0x02
    2014:	88 23       	and	r24, r24
    2016:	19 f0       	breq	.+6      	; 0x201e <Timer_Init+0xda>
    2018:	81 30       	cpi	r24, 0x01	; 1
    201a:	59 f4       	brne	.+22     	; 0x2032 <Timer_Init+0xee>
    201c:	04 c0       	rjmp	.+8      	; 0x2026 <Timer_Init+0xe2>
              case TIMER_POLLING_MODE:
                {
                  /*Disable interrupts for T1 without effecting any other timer*/
                   /*without Disabling Global interrupt*/
                  TIMSK &=T1_INTERRUPT_DISABLE;
    201e:	89 b7       	in	r24, 0x39	; 57
    2020:	83 7c       	andi	r24, 0xC3	; 195
    2022:	89 bf       	out	0x39, r24	; 57

                break;
    2024:	7c c0       	rjmp	.+248    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2026:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    202a:	89 b7       	in	r24, 0x39	; 57
    202c:	84 60       	ori	r24, 0x04	; 4
    202e:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */
                break;
    2030:	76 c0       	rjmp	.+236    	; 0x211e <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    2032:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    2034:	74 c0       	rjmp	.+232    	; 0x211e <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_RISING_MODE:
      {
            TCCR1|=T1_COUNTER_RISING_MODE_CONFIG;
    2036:	8e b5       	in	r24, 0x2e	; 46
    2038:	9f b5       	in	r25, 0x2f	; 47
    203a:	87 60       	ori	r24, 0x07	; 7
    203c:	9f bd       	out	0x2f, r25	; 47
    203e:	8e bd       	out	0x2e, r24	; 46

            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    2040:	8a 81       	ldd	r24, Y+2	; 0x02
    2042:	88 23       	and	r24, r24
    2044:	19 f0       	breq	.+6      	; 0x204c <Timer_Init+0x108>
    2046:	81 30       	cpi	r24, 0x01	; 1
    2048:	59 f4       	brne	.+22     	; 0x2060 <Timer_Init+0x11c>
    204a:	04 c0       	rjmp	.+8      	; 0x2054 <Timer_Init+0x110>
              case TIMER_POLLING_MODE:
              {
                /*Disable interrupts for T1 without effecting any other timer*/
                 /*without Disabling Global interrupt*/
                TIMSK &=T1_INTERRUPT_DISABLE;
    204c:	89 b7       	in	r24, 0x39	; 57
    204e:	83 7c       	andi	r24, 0xC3	; 195
    2050:	89 bf       	out	0x39, r24	; 57

                break;
    2052:	65 c0       	rjmp	.+202    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2054:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    2058:	89 b7       	in	r24, 0x39	; 57
    205a:	84 60       	ori	r24, 0x04	; 4
    205c:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */
                break;
    205e:	5f c0       	rjmp	.+190    	; 0x211e <Timer_Init+0x1da>
              }
              default:
              Ret+=E_NOK;
    2060:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    2062:	5d c0       	rjmp	.+186    	; 0x211e <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_FALLING_MODE:
      {
            TCCR1|=T1_COUNTER_FALLING_MODE_CONFIG;
    2064:	8e b5       	in	r24, 0x2e	; 46
    2066:	9f b5       	in	r25, 0x2f	; 47
    2068:	86 60       	ori	r24, 0x06	; 6
    206a:	9f bd       	out	0x2f, r25	; 47
    206c:	8e bd       	out	0x2e, r24	; 46
            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    206e:	8a 81       	ldd	r24, Y+2	; 0x02
    2070:	88 23       	and	r24, r24
    2072:	19 f0       	breq	.+6      	; 0x207a <Timer_Init+0x136>
    2074:	81 30       	cpi	r24, 0x01	; 1
    2076:	59 f4       	brne	.+22     	; 0x208e <Timer_Init+0x14a>
    2078:	04 c0       	rjmp	.+8      	; 0x2082 <Timer_Init+0x13e>
              case TIMER_POLLING_MODE:
              {
                /*Disable interrupts for T1 without effecting any other timer*/
                 /*without Disabling Global interrupt*/
                TIMSK &=T1_INTERRUPT_DISABLE;
    207a:	89 b7       	in	r24, 0x39	; 57
    207c:	83 7c       	andi	r24, 0xC3	; 195
    207e:	89 bf       	out	0x39, r24	; 57
                break;
    2080:	4e c0       	rjmp	.+156    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    2082:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                TIMSK |=T1_INTERRUPT_NORMAL;
    2086:	89 b7       	in	r24, 0x39	; 57
    2088:	84 60       	ori	r24, 0x04	; 4
    208a:	89 bf       	out	0x39, r24	; 57
                /*Enable Global INTERRUPT
                Enable Timer0 interrupt
                */

                break;
    208c:	48 c0       	rjmp	.+144    	; 0x211e <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    208e:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    2090:	46 c0       	rjmp	.+140    	; 0x211e <Timer_Init+0x1da>
            }
      break;
      }
      default :
      Ret+=E_NOK;
    2092:	1f 5f       	subi	r17, 0xFF	; 255
    break;
    2094:	44 c0       	rjmp	.+136    	; 0x211e <Timer_Init+0x1da>
  /*                             TIMER 2                                   */
  /*************************************************************************/

  case TIMER_CH2:
  {
TCCR2 |=T2_NORMAL_MODE_CONFIG;
    2096:	85 b5       	in	r24, 0x25	; 37
    2098:	85 bd       	out	0x25, r24	; 37
    switch (Timer_cfg->Timer_Mode) {
    209a:	89 81       	ldd	r24, Y+1	; 0x01
    209c:	88 23       	and	r24, r24
    209e:	19 f0       	breq	.+6      	; 0x20a6 <Timer_Init+0x162>
    20a0:	81 30       	cpi	r24, 0x01	; 1
    20a2:	e1 f5       	brne	.+120    	; 0x211c <Timer_Init+0x1d8>
    20a4:	12 c0       	rjmp	.+36     	; 0x20ca <Timer_Init+0x186>
      case TIMER_MODE:
      {
            switch (Timer_cfg->Timer_Polling_Or_Interrupt) {
    20a6:	8a 81       	ldd	r24, Y+2	; 0x02
    20a8:	88 23       	and	r24, r24
    20aa:	19 f0       	breq	.+6      	; 0x20b2 <Timer_Init+0x16e>
    20ac:	81 30       	cpi	r24, 0x01	; 1
    20ae:	59 f4       	brne	.+22     	; 0x20c6 <Timer_Init+0x182>
    20b0:	04 c0       	rjmp	.+8      	; 0x20ba <Timer_Init+0x176>
              case TIMER_POLLING_MODE:
              {
                  TIMSK &= T2_INTERRUPT_DISABLE;
    20b2:	89 b7       	in	r24, 0x39	; 57
    20b4:	8f 73       	andi	r24, 0x3F	; 63
    20b6:	89 bf       	out	0x39, r24	; 57
                break;
    20b8:	32 c0       	rjmp	.+100    	; 0x211e <Timer_Init+0x1da>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    20ba:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                  TIMSK|=T2_INTERRUPT_NORMAL;
    20be:	89 b7       	in	r24, 0x39	; 57
    20c0:	80 6c       	ori	r24, 0xC0	; 192
    20c2:	89 bf       	out	0x39, r24	; 57

                break;
    20c4:	2c c0       	rjmp	.+88     	; 0x211e <Timer_Init+0x1da>
              }
              default :
              Ret+=E_NOK;
    20c6:	1f 5f       	subi	r17, 0xFF	; 255
			  break;
    20c8:	2a c0       	rjmp	.+84     	; 0x211e <Timer_Init+0x1da>
            }
        break;
      }
      case COUNTER_RISING_MODE:
      {
          ASSR |=0x08;
    20ca:	82 b5       	in	r24, 0x22	; 34
    20cc:	88 60       	ori	r24, 0x08	; 8
    20ce:	82 bd       	out	0x22, r24	; 34
            switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    20d0:	8a 81       	ldd	r24, Y+2	; 0x02
    20d2:	81 30       	cpi	r24, 0x01	; 1
    20d4:	49 f0       	breq	.+18     	; 0x20e8 <Timer_Init+0x1a4>
    20d6:	81 30       	cpi	r24, 0x01	; 1
    20d8:	18 f0       	brcs	.+6      	; 0x20e0 <Timer_Init+0x19c>
    20da:	82 30       	cpi	r24, 0x02	; 2
    20dc:	f9 f4       	brne	.+62     	; 0x211c <Timer_Init+0x1d8>
    20de:	0a c0       	rjmp	.+20     	; 0x20f4 <Timer_Init+0x1b0>
            {
              case TIMER_POLLING_MODE:
              {
                TIMSK &= T2_INTERRUPT_DISABLE;
    20e0:	89 b7       	in	r24, 0x39	; 57
    20e2:	8f 73       	andi	r24, 0x3F	; 63
    20e4:	89 bf       	out	0x39, r24	; 57

                break;
    20e6:	1a c0       	rjmp	.+52     	; 0x211c <Timer_Init+0x1d8>
              }
              case TIMER_INTERRUPT_MODE:
              {
                G_interrupt_Enable();
    20e8:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                  TIMSK|=T2_INTERRUPT_NORMAL;
    20ec:	89 b7       	in	r24, 0x39	; 57
    20ee:	80 6c       	ori	r24, 0xC0	; 192
    20f0:	89 bf       	out	0x39, r24	; 57
                break;
    20f2:	14 c0       	rjmp	.+40     	; 0x211c <Timer_Init+0x1d8>
              }
              case COUNTER_FALLING_MODE:
              {
                  ASSR |=0x08;
    20f4:	82 b5       	in	r24, 0x22	; 34
    20f6:	88 60       	ori	r24, 0x08	; 8
    20f8:	82 bd       	out	0x22, r24	; 34
                    switch (Timer_cfg->Timer_Polling_Or_Interrupt)
    20fa:	8a 81       	ldd	r24, Y+2	; 0x02
    20fc:	88 23       	and	r24, r24
    20fe:	19 f0       	breq	.+6      	; 0x2106 <Timer_Init+0x1c2>
    2100:	81 30       	cpi	r24, 0x01	; 1
    2102:	59 f4       	brne	.+22     	; 0x211a <Timer_Init+0x1d6>
    2104:	04 c0       	rjmp	.+8      	; 0x210e <Timer_Init+0x1ca>
                    {
                      case TIMER_POLLING_MODE:
                      {
                        TIMSK &= T2_INTERRUPT_DISABLE;
    2106:	89 b7       	in	r24, 0x39	; 57
    2108:	8f 73       	andi	r24, 0x3F	; 63
    210a:	89 bf       	out	0x39, r24	; 57

                        break;
    210c:	07 c0       	rjmp	.+14     	; 0x211c <Timer_Init+0x1d8>
                      }
                      case TIMER_INTERRUPT_MODE:
                      {
                        G_interrupt_Enable();
    210e:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
                          TIMSK|=T2_INTERRUPT_NORMAL;
    2112:	89 b7       	in	r24, 0x39	; 57
    2114:	80 6c       	ori	r24, 0xC0	; 192
    2116:	89 bf       	out	0x39, r24	; 57
                        break;
    2118:	01 c0       	rjmp	.+2      	; 0x211c <Timer_Init+0x1d8>
                      }

              default :
              Ret+=E_NOK;
    211a:	1f 5f       	subi	r17, 0xFF	; 255
            }
        break;
            }
            }
  default:
  Ret+=E_NOK;
    211c:	1f 5f       	subi	r17, 0xFF	; 255
}
 }

}
return Ret;
}
    211e:	81 2f       	mov	r24, r17
    2120:	df 91       	pop	r29
    2122:	cf 91       	pop	r28
    2124:	1f 91       	pop	r17
    2126:	08 95       	ret

00002128 <Timer_Start>:
 * Description: This function strats the needed timer.
 *
 */
ERROR_STATUS Timer_Start(uint8_t Timer_CH_NO, uint16_t Timer_Count){
uint8_t Ret;
switch (Timer_CH_NO) {
    2128:	81 30       	cpi	r24, 0x01	; 1
    212a:	09 f4       	brne	.+2      	; 0x212e <Timer_Start+0x6>
    212c:	4f c0       	rjmp	.+158    	; 0x21cc <Timer_Start+0xa4>
    212e:	81 30       	cpi	r24, 0x01	; 1
    2130:	20 f0       	brcs	.+8      	; 0x213a <Timer_Start+0x12>
    2132:	82 30       	cpi	r24, 0x02	; 2
    2134:	09 f0       	breq	.+2      	; 0x2138 <Timer_Start+0x10>
    2136:	f3 c0       	rjmp	.+486    	; 0x231e <Timer_Start+0x1f6>
    2138:	97 c0       	rjmp	.+302    	; 0x2268 <Timer_Start+0x140>
case TIMER_CH0:{
/***********************************************************************************************************************/
switch(prescaler_value){
    213a:	80 91 1a 01 	lds	r24, 0x011A
    213e:	84 30       	cpi	r24, 0x04	; 4
    2140:	21 f1       	breq	.+72     	; 0x218a <Timer_Start+0x62>
    2142:	85 30       	cpi	r24, 0x05	; 5
    2144:	30 f4       	brcc	.+12     	; 0x2152 <Timer_Start+0x2a>
    2146:	81 30       	cpi	r24, 0x01	; 1
    2148:	51 f0       	breq	.+20     	; 0x215e <Timer_Start+0x36>
    214a:	82 30       	cpi	r24, 0x02	; 2
    214c:	09 f0       	breq	.+2      	; 0x2150 <Timer_Start+0x28>
    214e:	e9 c0       	rjmp	.+466    	; 0x2322 <Timer_Start+0x1fa>
    2150:	11 c0       	rjmp	.+34     	; 0x2174 <Timer_Start+0x4c>
    2152:	86 30       	cpi	r24, 0x06	; 6
    2154:	29 f1       	breq	.+74     	; 0x21a0 <Timer_Start+0x78>
    2156:	87 30       	cpi	r24, 0x07	; 7
    2158:	09 f0       	breq	.+2      	; 0x215c <Timer_Start+0x34>
    215a:	e3 c0       	rjmp	.+454    	; 0x2322 <Timer_Start+0x1fa>
    215c:	2c c0       	rjmp	.+88     	; 0x21b6 <Timer_Start+0x8e>
case TIMER_PRESCALER_NO :{
if(Timer_Count < MAX0){
    215e:	6f 3f       	cpi	r22, 0xFF	; 255
    2160:	71 05       	cpc	r23, r1
    2162:	08 f0       	brcs	.+2      	; 0x2166 <Timer_Start+0x3e>
    2164:	e0 c0       	rjmp	.+448    	; 0x2326 <Timer_Start+0x1fe>
TCCR0 |=TIMER_PRESCALER_NO;
    2166:	83 b7       	in	r24, 0x33	; 51
    2168:	81 60       	ori	r24, 0x01	; 1
    216a:	83 bf       	out	0x33, r24	; 51
TCNT0 =	MAX0 - Timer_Count;
    216c:	60 95       	com	r22
    216e:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_8 :{
if(Timer_Count < MAX0){
    2174:	6f 3f       	cpi	r22, 0xFF	; 255
    2176:	71 05       	cpc	r23, r1
    2178:	08 f0       	brcs	.+2      	; 0x217c <Timer_Start+0x54>
    217a:	d7 c0       	rjmp	.+430    	; 0x232a <Timer_Start+0x202>
TCCR0 |=TIMER0_PRESCALER_8_CONFIG;
    217c:	83 b7       	in	r24, 0x33	; 51
    217e:	82 60       	ori	r24, 0x02	; 2
    2180:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    2182:	60 95       	com	r22
    2184:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2186:	80 e0       	ldi	r24, 0x00	; 0
    2188:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_64 :{
if(Timer_Count < MAX0){
    218a:	6f 3f       	cpi	r22, 0xFF	; 255
    218c:	71 05       	cpc	r23, r1
    218e:	08 f0       	brcs	.+2      	; 0x2192 <Timer_Start+0x6a>
    2190:	ce c0       	rjmp	.+412    	; 0x232e <Timer_Start+0x206>
TCCR0 |=TIMER0_PRESCALER_64_CONFIG;
    2192:	83 b7       	in	r24, 0x33	; 51
    2194:	83 60       	ori	r24, 0x03	; 3
    2196:	83 bf       	out	0x33, r24	; 51
TCNT0 = MAX0 - Timer_Count;
    2198:	60 95       	com	r22
    219a:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    219c:	80 e0       	ldi	r24, 0x00	; 0
    219e:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_256 :{
if(Timer_Count < MAX0){
    21a0:	6f 3f       	cpi	r22, 0xFF	; 255
    21a2:	71 05       	cpc	r23, r1
    21a4:	08 f0       	brcs	.+2      	; 0x21a8 <Timer_Start+0x80>
    21a6:	c5 c0       	rjmp	.+394    	; 0x2332 <Timer_Start+0x20a>
TCCR0 |=TIMER0_PRESCALER_256_CONFIG;
    21a8:	83 b7       	in	r24, 0x33	; 51
    21aa:	84 60       	ori	r24, 0x04	; 4
    21ac:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    21ae:	60 95       	com	r22
    21b0:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    21b2:	80 e0       	ldi	r24, 0x00	; 0
    21b4:	08 95       	ret
Ret=E_NOK;
}
break;
}
case TIMER_PRESCALER_1024 :{
if(Timer_Count < MAX0){
    21b6:	6f 3f       	cpi	r22, 0xFF	; 255
    21b8:	71 05       	cpc	r23, r1
    21ba:	08 f0       	brcs	.+2      	; 0x21be <Timer_Start+0x96>
    21bc:	bc c0       	rjmp	.+376    	; 0x2336 <Timer_Start+0x20e>
TCCR0 |=TIMER0_PRESCALER_1024_CONFIG;
    21be:	83 b7       	in	r24, 0x33	; 51
    21c0:	85 60       	ori	r24, 0x05	; 5
    21c2:	83 bf       	out	0x33, r24	; 51
TCNT0 =MAX0 - Timer_Count;
    21c4:	60 95       	com	r22
    21c6:	62 bf       	out	0x32, r22	; 50
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    21c8:	80 e0       	ldi	r24, 0x00	; 0
    21ca:	08 95       	ret
break;
}
case TIMER_CH1:{

  switch(prescaler_value){
    21cc:	80 91 1a 01 	lds	r24, 0x011A
    21d0:	84 30       	cpi	r24, 0x04	; 4
    21d2:	31 f1       	breq	.+76     	; 0x2220 <Timer_Start+0xf8>
    21d4:	85 30       	cpi	r24, 0x05	; 5
    21d6:	30 f4       	brcc	.+12     	; 0x21e4 <Timer_Start+0xbc>
    21d8:	81 30       	cpi	r24, 0x01	; 1
    21da:	51 f0       	breq	.+20     	; 0x21f0 <Timer_Start+0xc8>
    21dc:	82 30       	cpi	r24, 0x02	; 2
    21de:	09 f0       	breq	.+2      	; 0x21e2 <Timer_Start+0xba>
    21e0:	ac c0       	rjmp	.+344    	; 0x233a <Timer_Start+0x212>
    21e2:	12 c0       	rjmp	.+36     	; 0x2208 <Timer_Start+0xe0>
    21e4:	86 30       	cpi	r24, 0x06	; 6
    21e6:	41 f1       	breq	.+80     	; 0x2238 <Timer_Start+0x110>
    21e8:	87 30       	cpi	r24, 0x07	; 7
    21ea:	09 f0       	breq	.+2      	; 0x21ee <Timer_Start+0xc6>
    21ec:	a6 c0       	rjmp	.+332    	; 0x233a <Timer_Start+0x212>
    21ee:	30 c0       	rjmp	.+96     	; 0x2250 <Timer_Start+0x128>
  case TIMER_PRESCALER_NO :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER_PRESCALER_NO;
    21f0:	8e b5       	in	r24, 0x2e	; 46
    21f2:	9f b5       	in	r25, 0x2f	; 47
    21f4:	81 60       	ori	r24, 0x01	; 1
    21f6:	9f bd       	out	0x2f, r25	; 47
    21f8:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    21fa:	70 95       	com	r23
    21fc:	61 95       	neg	r22
    21fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2200:	7d bd       	out	0x2d, r23	; 45
    2202:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2204:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret=E_NOK;
  }
  break;
    2206:	08 95       	ret
  }
  case TIMER_PRESCALER_8 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_8_CONFIG;
    2208:	8e b5       	in	r24, 0x2e	; 46
    220a:	9f b5       	in	r25, 0x2f	; 47
    220c:	82 60       	ori	r24, 0x02	; 2
    220e:	9f bd       	out	0x2f, r25	; 47
    2210:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2212:	70 95       	com	r23
    2214:	61 95       	neg	r22
    2216:	7f 4f       	sbci	r23, 0xFF	; 255
    2218:	7d bd       	out	0x2d, r23	; 45
    221a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    221c:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret= E_NOK;
  }
  break;
    221e:	08 95       	ret
  }
  case TIMER_PRESCALER_64 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_64_CONFIG;
    2220:	8e b5       	in	r24, 0x2e	; 46
    2222:	9f b5       	in	r25, 0x2f	; 47
    2224:	83 60       	ori	r24, 0x03	; 3
    2226:	9f bd       	out	0x2f, r25	; 47
    2228:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    222a:	70 95       	com	r23
    222c:	61 95       	neg	r22
    222e:	7f 4f       	sbci	r23, 0xFF	; 255
    2230:	7d bd       	out	0x2d, r23	; 45
    2232:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2234:	80 e0       	ldi	r24, 0x00	; 0
  TCNT1 =MAX1 - Timer_Count;
  }else
  {
  Ret= E_NOK;
  }
  break;
    2236:	08 95       	ret
  }
  case TIMER_PRESCALER_256 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_256_CONFIG;
    2238:	8e b5       	in	r24, 0x2e	; 46
    223a:	9f b5       	in	r25, 0x2f	; 47
    223c:	84 60       	ori	r24, 0x04	; 4
    223e:	9f bd       	out	0x2f, r25	; 47
    2240:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    2242:	70 95       	com	r23
    2244:	61 95       	neg	r22
    2246:	7f 4f       	sbci	r23, 0xFF	; 255
    2248:	7d bd       	out	0x2d, r23	; 45
    224a:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    224c:	80 e0       	ldi	r24, 0x00	; 0
  }else
  {
  Ret= E_NOK;

  }
  break;
    224e:	08 95       	ret
  }
  case TIMER_PRESCALER_1024 :{
  if(Timer_Count < MAX1){
  TCCR1 |=TIMER1_PRESCALER_1024_CONFIG;
    2250:	8e b5       	in	r24, 0x2e	; 46
    2252:	9f b5       	in	r25, 0x2f	; 47
    2254:	85 60       	ori	r24, 0x05	; 5
    2256:	9f bd       	out	0x2f, r25	; 47
    2258:	8e bd       	out	0x2e, r24	; 46
  TCNT1 =MAX1 - Timer_Count;
    225a:	70 95       	com	r23
    225c:	61 95       	neg	r22
    225e:	7f 4f       	sbci	r23, 0xFF	; 255
    2260:	7d bd       	out	0x2d, r23	; 45
    2262:	6c bd       	out	0x2c, r22	; 44
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    2264:	80 e0       	ldi	r24, 0x00	; 0
  }else
  {
  Ret= E_NOK;

  }
  break;
    2266:	08 95       	ret
	break;
}
case TIMER_CH2:
	{
  
		switch(prescaler_value){
    2268:	80 91 1a 01 	lds	r24, 0x011A
    226c:	84 30       	cpi	r24, 0x04	; 4
    226e:	79 f1       	breq	.+94     	; 0x22ce <Timer_Start+0x1a6>
    2270:	85 30       	cpi	r24, 0x05	; 5
    2272:	40 f4       	brcc	.+16     	; 0x2284 <Timer_Start+0x15c>
    2274:	82 30       	cpi	r24, 0x02	; 2
    2276:	c9 f0       	breq	.+50     	; 0x22aa <Timer_Start+0x182>
    2278:	83 30       	cpi	r24, 0x03	; 3
    227a:	10 f5       	brcc	.+68     	; 0x22c0 <Timer_Start+0x198>
    227c:	81 30       	cpi	r24, 0x01	; 1
    227e:	09 f0       	breq	.+2      	; 0x2282 <Timer_Start+0x15a>
    2280:	5e c0       	rjmp	.+188    	; 0x233e <Timer_Start+0x216>
    2282:	08 c0       	rjmp	.+16     	; 0x2294 <Timer_Start+0x16c>
    2284:	86 30       	cpi	r24, 0x06	; 6
    2286:	b9 f1       	breq	.+110    	; 0x22f6 <Timer_Start+0x1ce>
    2288:	86 30       	cpi	r24, 0x06	; 6
    228a:	58 f1       	brcs	.+86     	; 0x22e2 <Timer_Start+0x1ba>
    228c:	87 30       	cpi	r24, 0x07	; 7
    228e:	09 f0       	breq	.+2      	; 0x2292 <Timer_Start+0x16a>
    2290:	56 c0       	rjmp	.+172    	; 0x233e <Timer_Start+0x216>
    2292:	3b c0       	rjmp	.+118    	; 0x230a <Timer_Start+0x1e2>
   
		  case TIMER_PRESCALER_NO :
			{
    
				if(Timer_Count < MAX0){
    2294:	6f 3f       	cpi	r22, 0xFF	; 255
    2296:	71 05       	cpc	r23, r1
    2298:	08 f0       	brcs	.+2      	; 0x229c <Timer_Start+0x174>
    229a:	53 c0       	rjmp	.+166    	; 0x2342 <Timer_Start+0x21a>
     
			      TCCR2 |= TIMER_PRESCALER_NO;
    229c:	85 b5       	in	r24, 0x25	; 37
    229e:	81 60       	ori	r24, 0x01	; 1
    22a0:	85 bd       	out	0x25, r24	; 37
		      
				  TCNT2 = MAX2 - Timer_Count;
    22a2:	60 95       	com	r22
    22a4:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	08 95       	ret
			break;
			}

case TIMER_PRESCALER_8 :
  {
          if(Timer_Count < MAX0)
    22aa:	6f 3f       	cpi	r22, 0xFF	; 255
    22ac:	71 05       	cpc	r23, r1
    22ae:	08 f0       	brcs	.+2      	; 0x22b2 <Timer_Start+0x18a>
    22b0:	4a c0       	rjmp	.+148    	; 0x2346 <Timer_Start+0x21e>
            {
           TCCR2 |=TIMER_PRESCALER_8;
    22b2:	85 b5       	in	r24, 0x25	; 37
    22b4:	82 60       	ori	r24, 0x02	; 2
    22b6:	85 bd       	out	0x25, r24	; 37
           TCNT2 =MAX2 - Timer_Count;
    22b8:	60 95       	com	r22
    22ba:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22bc:	80 e0       	ldi	r24, 0x00	; 0
    22be:	08 95       	ret
  }
  case TIMER_PRESCALER_32:
  {
    if(Timer_Count < MAX1)
         {
         TCCR2 |=TIMER_PRESCALER_32;
    22c0:	85 b5       	in	r24, 0x25	; 37
    22c2:	83 60       	ori	r24, 0x03	; 3
    22c4:	85 bd       	out	0x25, r24	; 37
         TCNT2 =MAX2 - Timer_Count;
    22c6:	60 95       	com	r22
    22c8:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22ca:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
    Ret=E_NOK;
  }

    break;
    22cc:	08 95       	ret
  }
  case TIMER_PRESCALER_64 :
  {
       if(Timer_Count < MAX2)
    22ce:	6f 3f       	cpi	r22, 0xFF	; 255
    22d0:	71 05       	cpc	r23, r1
    22d2:	d8 f5       	brcc	.+118    	; 0x234a <Timer_Start+0x222>
       {
       TCCR2 |=TIMER_PRESCALER_64;
    22d4:	85 b5       	in	r24, 0x25	; 37
    22d6:	84 60       	ori	r24, 0x04	; 4
    22d8:	85 bd       	out	0x25, r24	; 37
       TCNT2 =MAX2 - Timer_Count;
    22da:	60 95       	com	r22
    22dc:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22de:	80 e0       	ldi	r24, 0x00	; 0
    22e0:	08 95       	ret
  Ret=E_NOK;
  }
  break;
  }
  case TIMER_PRESCALER_128 :{
  if(Timer_Count < MAX2){
    22e2:	6f 3f       	cpi	r22, 0xFF	; 255
    22e4:	71 05       	cpc	r23, r1
    22e6:	98 f5       	brcc	.+102    	; 0x234e <Timer_Start+0x226>
  TCCR2 |= TIMER_PRESCALER_128;
    22e8:	85 b5       	in	r24, 0x25	; 37
    22ea:	85 60       	ori	r24, 0x05	; 5
    22ec:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    22ee:	60 95       	com	r22
    22f0:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    22f2:	80 e0       	ldi	r24, 0x00	; 0
    22f4:	08 95       	ret
  Ret= E_NOK;
    }
  break;
  }
  case TIMER_PRESCALER_256 :{
  if(Timer_Count < MAX2){
    22f6:	6f 3f       	cpi	r22, 0xFF	; 255
    22f8:	71 05       	cpc	r23, r1
    22fa:	58 f5       	brcc	.+86     	; 0x2352 <Timer_Start+0x22a>
  TCCR2 |= TIMER_PRESCALER_256;
    22fc:	85 b5       	in	r24, 0x25	; 37
    22fe:	86 60       	ori	r24, 0x06	; 6
    2300:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    2302:	60 95       	com	r22
    2304:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    2306:	80 e0       	ldi	r24, 0x00	; 0
    2308:	08 95       	ret

  }
  break;
  }
  case TIMER_PRESCALER_1024 :{
  if(Timer_Count < MAX2){
    230a:	6f 3f       	cpi	r22, 0xFF	; 255
    230c:	71 05       	cpc	r23, r1
    230e:	18 f5       	brcc	.+70     	; 0x2356 <Timer_Start+0x22e>
  TCCR2 |=TIMER_PRESCALER_1024;
    2310:	85 b5       	in	r24, 0x25	; 37
    2312:	87 60       	ori	r24, 0x07	; 7
    2314:	85 bd       	out	0x25, r24	; 37
  TCNT2 =MAX2 - Timer_Count;
    2316:	60 95       	com	r22
    2318:	64 bd       	out	0x24, r22	; 36
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    231a:	80 e0       	ldi	r24, 0x00	; 0
    231c:	08 95       	ret
break;
}
default:
Ret= E_NOK;
    231e:	81 e0       	ldi	r24, 0x01	; 1
    2320:	08 95       	ret
default :
Ret=E_NOK;
break;
}

Ret=E_OK;
    2322:	80 e0       	ldi	r24, 0x00	; 0
    2324:	08 95       	ret
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	08 95       	ret
    232a:	80 e0       	ldi	r24, 0x00	; 0
    232c:	08 95       	ret
    232e:	80 e0       	ldi	r24, 0x00	; 0
    2330:	08 95       	ret
    2332:	80 e0       	ldi	r24, 0x00	; 0
    2334:	08 95       	ret
    2336:	80 e0       	ldi	r24, 0x00	; 0
    2338:	08 95       	ret
  Ret= E_NOK;
  break;
  }


  Ret= E_OK;
    233a:	80 e0       	ldi	r24, 0x00	; 0
    233c:	08 95       	ret
  }
  default :
  Ret= E_NOK;

  }
Ret=E_OK;
    233e:	80 e0       	ldi	r24, 0x00	; 0
    2340:	08 95       	ret
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	08 95       	ret
    2346:	80 e0       	ldi	r24, 0x00	; 0
    2348:	08 95       	ret
    234a:	80 e0       	ldi	r24, 0x00	; 0
    234c:	08 95       	ret
    234e:	80 e0       	ldi	r24, 0x00	; 0
    2350:	08 95       	ret
    2352:	80 e0       	ldi	r24, 0x00	; 0
    2354:	08 95       	ret
    2356:	80 e0       	ldi	r24, 0x00	; 0
Ret= E_NOK;
break;
}
return Ret;

}
    2358:	08 95       	ret

0000235a <Timer_Stop>:
 * Description: This function stops the needed timer.
 *
 */
ERROR_STATUS Timer_Stop(uint8_t Timer_CH_NO)
{uint8_t Ret;
switch (Timer_CH_NO) {
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	51 f0       	breq	.+20     	; 0x2372 <Timer_Stop+0x18>
    235e:	81 30       	cpi	r24, 0x01	; 1
    2360:	18 f0       	brcs	.+6      	; 0x2368 <Timer_Stop+0xe>
    2362:	82 30       	cpi	r24, 0x02	; 2
    2364:	91 f4       	brne	.+36     	; 0x238a <Timer_Stop+0x30>
    2366:	0c c0       	rjmp	.+24     	; 0x2380 <Timer_Stop+0x26>
  case TIMER_CH0:
  {
		TCCR0 &=0xF8;
    2368:	83 b7       	in	r24, 0x33	; 51
    236a:	88 7f       	andi	r24, 0xF8	; 248
    236c:	83 bf       	out	0x33, r24	; 51
		Ret=E_OK;
    236e:	80 e0       	ldi	r24, 0x00	; 0
		break;
    2370:	08 95       	ret
  }
  case TIMER_CH1:
  {
	     TCCR1 &=0xFFF8;
    2372:	8e b5       	in	r24, 0x2e	; 46
    2374:	9f b5       	in	r25, 0x2f	; 47
    2376:	88 7f       	andi	r24, 0xF8	; 248
    2378:	9f bd       	out	0x2f, r25	; 47
    237a:	8e bd       	out	0x2e, r24	; 46
		 Ret=E_OK;
    237c:	80 e0       	ldi	r24, 0x00	; 0
		 break;
    237e:	08 95       	ret
  }
  case TIMER_CH2:
    {
		 TCCR2 &= 0xF8;
    2380:	85 b5       	in	r24, 0x25	; 37
    2382:	88 7f       	andi	r24, 0xF8	; 248
    2384:	85 bd       	out	0x25, r24	; 37
		 Ret=E_OK;
    2386:	80 e0       	ldi	r24, 0x00	; 0
		 break;
    2388:	08 95       	ret
    }
  default :
  Ret=E_NOK;
    238a:	81 e0       	ldi	r24, 0x01	; 1
  break;
}

return Ret;

}
    238c:	08 95       	ret

0000238e <Timer_GetStatus>:
 * Description: This function is used to return if the flag of the timer is raised or not.
 *
 */
ERROR_STATUS Timer_GetStatus(uint8_t Timer_CH_NO,uint8_t* Data)
{
  switch (Timer_CH_NO) {
    238e:	81 30       	cpi	r24, 0x01	; 1
    2390:	59 f0       	breq	.+22     	; 0x23a8 <Timer_GetStatus+0x1a>
    2392:	81 30       	cpi	r24, 0x01	; 1
    2394:	18 f0       	brcs	.+6      	; 0x239c <Timer_GetStatus+0xe>
    2396:	82 30       	cpi	r24, 0x02	; 2
    2398:	c9 f4       	brne	.+50     	; 0x23cc <Timer_GetStatus+0x3e>
    239a:	0e c0       	rjmp	.+28     	; 0x23b8 <Timer_GetStatus+0x2a>
    case TIMER_CH0:
    {
  *Data =((TIFR>>TOV0)&1);
    239c:	88 b7       	in	r24, 0x38	; 56
    239e:	81 70       	andi	r24, 0x01	; 1
    23a0:	fb 01       	movw	r30, r22
    23a2:	80 83       	st	Z, r24
    return E_OK;
    23a4:	80 e0       	ldi	r24, 0x00	; 0
    23a6:	08 95       	ret
    }
    case TIMER_CH1:
    {
    *Data =((TIFR>>TOV1)&1);
    23a8:	88 b7       	in	r24, 0x38	; 56
    23aa:	86 95       	lsr	r24
    23ac:	86 95       	lsr	r24
    23ae:	81 70       	andi	r24, 0x01	; 1
    23b0:	fb 01       	movw	r30, r22
    23b2:	80 83       	st	Z, r24
    return E_OK;
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	08 95       	ret
    }
     case TIMER_CH2:
      {
  *Data =((TIFR>>TOV2)&1);
    23b8:	88 b7       	in	r24, 0x38	; 56
    23ba:	82 95       	swap	r24
    23bc:	86 95       	lsr	r24
    23be:	86 95       	lsr	r24
    23c0:	83 70       	andi	r24, 0x03	; 3
    23c2:	81 70       	andi	r24, 0x01	; 1
    23c4:	fb 01       	movw	r30, r22
    23c6:	80 83       	st	Z, r24
    return E_OK;
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	08 95       	ret
      }
    default :
    return E_NOK;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
  }
}
    23ce:	08 95       	ret

000023d0 <Timer_GetValue>:
 * Return: The error status of the function.
 * Description: This function is used to return the value of the timer.
 *
 */
ERROR_STATUS Timer_GetValue(uint8_t Timer_CH_NO, uint16_t* Data)
{
    23d0:	fb 01       	movw	r30, r22
	uint8_t Ret=0;
	switch (Timer_CH_NO) {
    23d2:	81 30       	cpi	r24, 0x01	; 1
    23d4:	51 f0       	breq	.+20     	; 0x23ea <Timer_GetValue+0x1a>
    23d6:	81 30       	cpi	r24, 0x01	; 1
    23d8:	18 f0       	brcs	.+6      	; 0x23e0 <Timer_GetValue+0x10>
    23da:	82 30       	cpi	r24, 0x02	; 2
    23dc:	89 f4       	brne	.+34     	; 0x2400 <Timer_GetValue+0x30>
    23de:	0b c0       	rjmp	.+22     	; 0x23f6 <Timer_GetValue+0x26>
		case TIMER_CH0:
		{
			*Data =TCNT0;
    23e0:	82 b7       	in	r24, 0x32	; 50
    23e2:	80 83       	st	Z, r24
    23e4:	11 82       	std	Z+1, r1	; 0x01
			Ret= E_OK;
    23e6:	80 e0       	ldi	r24, 0x00	; 0
			break;
    23e8:	08 95       	ret
		}
		case TIMER_CH1:
		{
			*Data =TCNT1;
    23ea:	8c b5       	in	r24, 0x2c	; 44
    23ec:	9d b5       	in	r25, 0x2d	; 45
    23ee:	91 83       	std	Z+1, r25	; 0x01
    23f0:	80 83       	st	Z, r24
			Ret= E_OK;
    23f2:	80 e0       	ldi	r24, 0x00	; 0
			break;
    23f4:	08 95       	ret
		}
		case TIMER_CH2:
		{
			*Data =TCNT2;
    23f6:	84 b5       	in	r24, 0x24	; 36
    23f8:	80 83       	st	Z, r24
    23fa:	11 82       	std	Z+1, r1	; 0x01
			Ret = E_OK;
    23fc:	80 e0       	ldi	r24, 0x00	; 0
			break;
    23fe:	08 95       	ret
		}
		default :
		Ret= E_NOK;
    2400:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
return Ret;

}
    2402:	08 95       	ret

00002404 <Uart_Init>:
uint8_t BufferRequested[Buffer_Size];
//volatile uint8_t u8_index=0;
volatile uint8_t buf_is_full=0;
/****************************************************************************************************************************************/
void Uart_Init(En_BAUD_Rate Baud_rate,En_Stop_config Stop_bits_num, EN_Parity parity_Bit,EN_Data_Size data_num_bits,EN_UartMode uart_mode)
{
    2404:	0f 93       	push	r16
uint8_t Buffer=0;
switch (Baud_rate) {
    2406:	83 33       	cpi	r24, 0x33	; 51
    2408:	71 f0       	breq	.+28     	; 0x2426 <Uart_Init+0x22>
    240a:	84 33       	cpi	r24, 0x34	; 52
    240c:	18 f4       	brcc	.+6      	; 0x2414 <Uart_Init+0x10>
    240e:	89 31       	cpi	r24, 0x19	; 25
    2410:	79 f4       	brne	.+30     	; 0x2430 <Uart_Init+0x2c>
    2412:	0c c0       	rjmp	.+24     	; 0x242c <Uart_Init+0x28>
    2414:	84 34       	cpi	r24, 0x44	; 68
    2416:	21 f0       	breq	.+8      	; 0x2420 <Uart_Init+0x1c>
    2418:	87 36       	cpi	r24, 0x67	; 103
    241a:	51 f4       	brne	.+20     	; 0x2430 <Uart_Init+0x2c>
  case Baud9600:
  UBRRL=Baud9600;
    241c:	89 b9       	out	0x09, r24	; 9
  break;
    241e:	08 c0       	rjmp	.+16     	; 0x2430 <Uart_Init+0x2c>
  case Baud14400:
  UBRRL=Baud14400;
    2420:	84 e4       	ldi	r24, 0x44	; 68
    2422:	89 b9       	out	0x09, r24	; 9
  break;
    2424:	05 c0       	rjmp	.+10     	; 0x2430 <Uart_Init+0x2c>
  case Baud19200:
  UBRRL=Baud19200;
    2426:	83 e3       	ldi	r24, 0x33	; 51
    2428:	89 b9       	out	0x09, r24	; 9
  break;
    242a:	02 c0       	rjmp	.+4      	; 0x2430 <Uart_Init+0x2c>
  case Baud38400:
  UBRRL=Baud38400;
    242c:	89 e1       	ldi	r24, 0x19	; 25
    242e:	89 b9       	out	0x09, r24	; 9
  break;
}
switch (Stop_bits_num) {
    2430:	66 23       	and	r22, r22
    2432:	31 f0       	breq	.+12     	; 0x2440 <Uart_Init+0x3c>
    2434:	61 30       	cpi	r22, 0x01	; 1
    2436:	11 f0       	breq	.+4      	; 0x243c <Uart_Init+0x38>
//volatile uint8_t u8_index=0;
volatile uint8_t buf_is_full=0;
/****************************************************************************************************************************************/
void Uart_Init(En_BAUD_Rate Baud_rate,En_Stop_config Stop_bits_num, EN_Parity parity_Bit,EN_Data_Size data_num_bits,EN_UartMode uart_mode)
{
uint8_t Buffer=0;
    2438:	80 e0       	ldi	r24, 0x00	; 0
    243a:	03 c0       	rjmp	.+6      	; 0x2442 <Uart_Init+0x3e>
  break;
}
case TwoStopBits:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,USBS);
    243c:	88 e8       	ldi	r24, 0x88	; 136
  break;
    243e:	01 c0       	rjmp	.+2      	; 0x2442 <Uart_Init+0x3e>
  break;
}
switch (Stop_bits_num) {
case OneStopBit:
{ SET_BIT(Buffer,URSEL);
  CLEAR_BIT(Buffer,USBS);
    2440:	80 e8       	ldi	r24, 0x80	; 128
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,USBS);
  break;
}
}
switch (data_num_bits)
    2442:	22 30       	cpi	r18, 0x02	; 2
    2444:	a1 f0       	breq	.+40     	; 0x246e <Uart_Init+0x6a>
    2446:	23 30       	cpi	r18, 0x03	; 3
    2448:	28 f4       	brcc	.+10     	; 0x2454 <Uart_Init+0x50>
    244a:	22 23       	and	r18, r18
    244c:	41 f0       	breq	.+16     	; 0x245e <Uart_Init+0x5a>
    244e:	21 30       	cpi	r18, 0x01	; 1
    2450:	b9 f4       	brne	.+46     	; 0x2480 <Uart_Init+0x7c>
    2452:	09 c0       	rjmp	.+18     	; 0x2466 <Uart_Init+0x62>
    2454:	23 30       	cpi	r18, 0x03	; 3
    2456:	79 f0       	breq	.+30     	; 0x2476 <Uart_Init+0x72>
    2458:	24 30       	cpi	r18, 0x04	; 4
    245a:	91 f4       	brne	.+36     	; 0x2480 <Uart_Init+0x7c>
    245c:	0f c0       	rjmp	.+30     	; 0x247c <Uart_Init+0x78>
{
case FiveBits:
{
SET_BIT(Buffer,URSEL);
    245e:	80 68       	ori	r24, 0x80	; 128
CLEAR_BIT(Buffer,UCSZ0);
CLEAR_BIT(Buffer,UCSZ1);
    2460:	89 7f       	andi	r24, 0xF9	; 249
CLEAR_BIT(UCSRB,UCSZ2);
    2462:	52 98       	cbi	0x0a, 2	; 10
break;
    2464:	0d c0       	rjmp	.+26     	; 0x2480 <Uart_Init+0x7c>
}
case SexBits:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,UCSZ0);
    2466:	82 68       	ori	r24, 0x82	; 130
  CLEAR_BIT(Buffer,UCSZ1);
    2468:	8b 7f       	andi	r24, 0xFB	; 251
  CLEAR_BIT(UCSRB,UCSZ2);
    246a:	52 98       	cbi	0x0a, 2	; 10
  break;
    246c:	09 c0       	rjmp	.+18     	; 0x2480 <Uart_Init+0x7c>
}
case SevenBits:
{
  SET_BIT(Buffer,URSEL);
  CLEAR_BIT(Buffer,UCSZ0);
    246e:	89 77       	andi	r24, 0x79	; 121
  SET_BIT(Buffer,UCSZ1);
    2470:	84 68       	ori	r24, 0x84	; 132
  CLEAR_BIT(UCSRB,UCSZ2);
    2472:	52 98       	cbi	0x0a, 2	; 10
  break;
    2474:	05 c0       	rjmp	.+10     	; 0x2480 <Uart_Init+0x7c>
}
case EightBits:
{   SET_BIT(Buffer,URSEL);
    SET_BIT(Buffer,UCSZ0);
    SET_BIT(Buffer,UCSZ1);
    2476:	86 68       	ori	r24, 0x86	; 134
    CLEAR_BIT(UCSRB,UCSZ2);
    2478:	52 98       	cbi	0x0a, 2	; 10
break;
    247a:	02 c0       	rjmp	.+4      	; 0x2480 <Uart_Init+0x7c>
}

case NineBits:
{   SET_BIT(Buffer,URSEL);
	SET_BIT(Buffer,UCSZ0);
	SET_BIT(Buffer,UCSZ1);
    247c:	86 68       	ori	r24, 0x86	; 134
	SET_BIT(UCSRB,UCSZ2);
    247e:	52 9a       	sbi	0x0a, 2	; 10
	break;
}

}

switch (uart_mode) {
    2480:	00 23       	and	r16, r16
    2482:	19 f0       	breq	.+6      	; 0x248a <Uart_Init+0x86>
    2484:	01 30       	cpi	r16, 0x01	; 1
    2486:	29 f4       	brne	.+10     	; 0x2492 <Uart_Init+0x8e>
    2488:	03 c0       	rjmp	.+6      	; 0x2490 <Uart_Init+0x8c>
  case ASynchronous:
  {
  SET_BIT(Buffer,URSEL);
    248a:	80 68       	ori	r24, 0x80	; 128
  CLEAR_BIT(Buffer,UMSEL);
    248c:	8f 7b       	andi	r24, 0xBF	; 191
  break;
    248e:	01 c0       	rjmp	.+2      	; 0x2492 <Uart_Init+0x8e>
  }
case Synchronous:
{
  SET_BIT(Buffer,URSEL);
  SET_BIT(Buffer,UMSEL);
    2490:	80 6c       	ori	r24, 0xC0	; 192
  break;
}
}
switch (parity_Bit) {
    2492:	41 30       	cpi	r20, 0x01	; 1
    2494:	41 f0       	breq	.+16     	; 0x24a6 <Uart_Init+0xa2>
    2496:	41 30       	cpi	r20, 0x01	; 1
    2498:	18 f0       	brcs	.+6      	; 0x24a0 <Uart_Init+0x9c>
    249a:	42 30       	cpi	r20, 0x02	; 2
    249c:	41 f4       	brne	.+16     	; 0x24ae <Uart_Init+0xaa>
    249e:	06 c0       	rjmp	.+12     	; 0x24ac <Uart_Init+0xa8>
  case NoParity:
{
SET_BIT(Buffer,URSEL);
    24a0:	80 68       	ori	r24, 0x80	; 128
CLEAR_BIT(Buffer,UPM0);
CLEAR_BIT(Buffer,UPM1);
    24a2:	8f 7c       	andi	r24, 0xCF	; 207
  break;
    24a4:	04 c0       	rjmp	.+8      	; 0x24ae <Uart_Init+0xaa>
}
case EvenParity:
{
SET_BIT(Buffer,URSEL);
CLEAR_BIT(Buffer,UPM0);
    24a6:	8f 74       	andi	r24, 0x4F	; 79
SET_BIT(Buffer,UPM1);
    24a8:	80 6a       	ori	r24, 0xA0	; 160
break;
    24aa:	01 c0       	rjmp	.+2      	; 0x24ae <Uart_Init+0xaa>
}
case OddParity:
{
SET_BIT(Buffer,URSEL);
SET_BIT(Buffer,UPM1);
SET_BIT(Buffer,UPM0);
    24ac:	80 6b       	ori	r24, 0xB0	; 176
}


}

UCSRC=Buffer;
    24ae:	80 bd       	out	0x20, r24	; 32
SET_BIT(UCSRB,TXEN);/*TXEN*/
    24b0:	53 9a       	sbi	0x0a, 3	; 10
SET_BIT(UCSRB,RXEN);/*RXEN*/
    24b2:	54 9a       	sbi	0x0a, 4	; 10
}
    24b4:	0f 91       	pop	r16
    24b6:	08 95       	ret

000024b8 <UartTransmitPooling>:
void UartTransmitPooling(uint8_t Data)
{
while( !( UCSRA & (1<<UDRE)));
    24b8:	5d 9b       	sbis	0x0b, 5	; 11
    24ba:	fe cf       	rjmp	.-4      	; 0x24b8 <UartTransmitPooling>
UDR=Data;
    24bc:	8c b9       	out	0x0c, r24	; 12
}
    24be:	08 95       	ret

000024c0 <UartRecievePooling>:
uint8_t UartRecievePooling(void)
{
	uint8_t data=0;
while (!( UCSRA & (1 << RXC)));/* Wait until new data receive*/
    24c0:	5f 9b       	sbis	0x0b, 7	; 11
    24c2:	fe cf       	rjmp	.-4      	; 0x24c0 <UartRecievePooling>
data=UDR;
    24c4:	8c b1       	in	r24, 0x0c	; 12
return data;									/* Get and return received data */
}
    24c6:	08 95       	ret

000024c8 <Enable_communication_interrupt>:


void Enable_communication_interrupt(void)
{
G_interrupt_Enable();
    24c8:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
SET_BIT(UCSRB,RXCIE);
    24cc:	57 9a       	sbi	0x0a, 7	; 10
SET_BIT(UCSRB,TXCIE);
    24ce:	56 9a       	sbi	0x0a, 6	; 10
SET_BIT(SPCR,SPIE);
    24d0:	6f 9a       	sbi	0x0d, 7	; 13
}
    24d2:	08 95       	ret

000024d4 <UartRecieveInterrupt>:
//  buf_is_full=1;
//  u16_index=0;
//      }
/*if(u8_index<Buffer_Size)
{
  */u8_DATA=UDR;/*
    24d4:	8c b1       	in	r24, 0x0c	; 12
    24d6:	80 93 ad 05 	sts	0x05AD, r24
  u8_index++;
}
  else{
    u8_index=0;
  }*/
}
    24da:	08 95       	ret

000024dc <UartTransmitInterrupt>:
{
/*When void Uart_tryansmitfirstbyte(uint8_t data) sends first byte before while(1) we start here sendine the next bytes
gU8_Data_transmited is shared with void UartTransmitdataInt(uint8_t data_to_transmit)
that changes its data
*/
UDR=u8_DATA;
    24dc:	80 91 ad 05 	lds	r24, 0x05AD
    24e0:	8c b9       	out	0x0c, r24	; 12
//G_interrupt_Enable();
//u8_DATA ^=0xFF;
}
    24e2:	08 95       	ret

000024e4 <UartTransmitdataInt>:
void UartTransmitdataInt(uint8_t data_to_transmit)
{
	  u8_DATA=data_to_transmit;
    24e4:	80 93 ad 05 	sts	0x05AD, r24
}
    24e8:	08 95       	ret

000024ea <Uart_tryansmitfirstbyte>:

void Uart_tryansmitfirstbyte(uint8_t data)
{
UDR=data;
    24ea:	8c b9       	out	0x0c, r24	; 12
}
    24ec:	08 95       	ret

000024ee <Uart_De_Init>:
void Uart_De_Init(void)
{
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
    24ee:	53 98       	cbi	0x0a, 3	; 10
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/
    24f0:	54 98       	cbi	0x0a, 4	; 10

}
    24f2:	08 95       	ret

000024f4 <uart_transmit_u16>:

void uart_transmit_u16(uint16_t sixtee_bits_var)
{
    24f4:	ef 92       	push	r14
    24f6:	ff 92       	push	r15
    24f8:	0f 93       	push	r16
    24fa:	1f 93       	push	r17
    24fc:	cf 93       	push	r28
    24fe:	df 93       	push	r29
    2500:	e4 e2       	ldi	r30, 0x24	; 36
    2502:	f1 e0       	ldi	r31, 0x01	; 1
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/

}

void uart_transmit_u16(uint16_t sixtee_bits_var)
    2504:	0f 2e       	mov	r0, r31
    2506:	fb ef       	ldi	r31, 0xFB	; 251
    2508:	ef 2e       	mov	r14, r31
    250a:	ff ef       	ldi	r31, 0xFF	; 255
    250c:	ff 2e       	mov	r15, r31
    250e:	f0 2d       	mov	r31, r0
    2510:	ee 0e       	add	r14, r30
    2512:	ff 1e       	adc	r15, r31
    2514:	ef 01       	movw	r28, r30
    2516:	24 97       	sbiw	r28, 0x04	; 4
uint8_t buffer_index=0;

for (i=4;i>0;i--)
{
	
	transmit_buffer[i]=sixtee_bits_var%10;
    2518:	2a e0       	ldi	r18, 0x0A	; 10
    251a:	30 e0       	ldi	r19, 0x00	; 0
    251c:	b9 01       	movw	r22, r18
    251e:	0e 94 a9 2a 	call	0x5552	; 0x5552 <__udivmodhi4>
    2522:	82 93       	st	-Z, r24
	sixtee_bits_var/=10;
    2524:	86 2f       	mov	r24, r22
    2526:	97 2f       	mov	r25, r23
void uart_transmit_u16(uint16_t sixtee_bits_var)
{
uint8_t i=5;
uint8_t buffer_index=0;

for (i=4;i>0;i--)
    2528:	ec 17       	cp	r30, r28
    252a:	fd 07       	cpc	r31, r29
    252c:	b9 f7       	brne	.-18     	; 0x251c <uart_transmit_u16+0x28>
	
	transmit_buffer[i]=sixtee_bits_var%10;
	sixtee_bits_var/=10;

}
	transmit_buffer[i]=sixtee_bits_var;
    252e:	60 93 1f 01 	sts	0x011F, r22
    2532:	0f e1       	ldi	r16, 0x1F	; 31
    2534:	11 e0       	ldi	r17, 0x01	; 1
  CLEAR_BIT(UCSRB,TXEN);/*TXEN*/
  CLEAR_BIT(UCSRB,RXEN);/*RXEN*/

}

void uart_transmit_u16(uint16_t sixtee_bits_var)
    2536:	e7 01       	movw	r28, r14
    2538:	25 96       	adiw	r28, 0x05	; 5

}
	transmit_buffer[i]=sixtee_bits_var;

	for(buffer_index=0;buffer_index < 5;buffer_index++)
	UartTransmitPooling(transmit_buffer[buffer_index]+48);
    253a:	f8 01       	movw	r30, r16
    253c:	81 91       	ld	r24, Z+
    253e:	8f 01       	movw	r16, r30
    2540:	80 5d       	subi	r24, 0xD0	; 208
    2542:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	sixtee_bits_var/=10;

}
	transmit_buffer[i]=sixtee_bits_var;

	for(buffer_index=0;buffer_index < 5;buffer_index++)
    2546:	0c 17       	cp	r16, r28
    2548:	1d 07       	cpc	r17, r29
    254a:	b9 f7       	brne	.-18     	; 0x253a <uart_transmit_u16+0x46>
	UartTransmitPooling(transmit_buffer[buffer_index]+48);



    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	ff 90       	pop	r15
    2556:	ef 90       	pop	r14
    2558:	08 95       	ret

0000255a <debug>:
		DIO_Toggle(GPIOB, BIT4);
	}
}

void debug(void)
{	UartTransmitPooling('B');
    255a:	82 e4       	ldi	r24, 0x42	; 66
    255c:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(PORTB_DATA);
    2560:	88 b3       	in	r24, 0x18	; 24
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('C');
    2568:	83 e4       	ldi	r24, 0x43	; 67
    256a:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(PORTC_DATA);
    256e:	85 b3       	in	r24, 0x15	; 21
    2570:	90 e0       	ldi	r25, 0x00	; 0
    2572:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
	UartTransmitPooling('D');
    2576:	84 e4       	ldi	r24, 0x44	; 68
    2578:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <UartTransmitPooling>
	uart_transmit_u16(PORTD_DATA);
    257c:	82 b3       	in	r24, 0x12	; 18
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <uart_transmit_u16>
}
    2584:	08 95       	ret

00002586 <alarm_flashing>:
	
}

void alarm_flashing(void)
{
	if (u8_plastic_state == FIRST_SAFE_POS || u8_plastic_state == SECOND_SAFE_POS)
    2586:	80 91 2a 01 	lds	r24, 0x012A
    258a:	81 50       	subi	r24, 0x01	; 1
    258c:	82 30       	cpi	r24, 0x02	; 2
    258e:	20 f4       	brcc	.+8      	; 0x2598 <alarm_flashing+0x12>
	{
		DIO_Toggle(GPIOB, BIT4);
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	60 e1       	ldi	r22, 0x10	; 16
    2594:	0e 94 18 0c 	call	0x1830	; 0x1830 <DIO_Toggle>
    2598:	08 95       	ret

0000259a <plastic_breaker_loop>:

void plastic_breaker_loop(void)
{
	static uint8_t on_state = 0, off_state = 0, sw1_state = 0, sw2_state = 0;
	/*check if on pressed*/
	DIO_Read(GPIOB, BIT1, &on_state);
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	62 e0       	ldi	r22, 0x02	; 2
    259e:	46 e2       	ldi	r20, 0x26	; 38
    25a0:	51 e0       	ldi	r21, 0x01	; 1
    25a2:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	DIO_Read(GPIOB, BIT2, &off_state);
    25a6:	81 e0       	ldi	r24, 0x01	; 1
    25a8:	64 e0       	ldi	r22, 0x04	; 4
    25aa:	47 e2       	ldi	r20, 0x27	; 39
    25ac:	51 e0       	ldi	r21, 0x01	; 1
    25ae:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	DIO_Read(GPIOD, BIT2, &sw1_state);
    25b2:	83 e0       	ldi	r24, 0x03	; 3
    25b4:	64 e0       	ldi	r22, 0x04	; 4
    25b6:	48 e2       	ldi	r20, 0x28	; 40
    25b8:	51 e0       	ldi	r21, 0x01	; 1
    25ba:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	DIO_Read(GPIOD, BIT3, &sw2_state);
    25be:	83 e0       	ldi	r24, 0x03	; 3
    25c0:	68 e0       	ldi	r22, 0x08	; 8
    25c2:	49 e2       	ldi	r20, 0x29	; 41
    25c4:	51 e0       	ldi	r21, 0x01	; 1
    25c6:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <DIO_Read>
	if ((on_state == HIGH && off_state == LOW && sw2_state == HIGH && sw1_state == HIGH) && (u8_plastic_state == NO_ACTION_PLAS) || (sw1_state == LOW || sw2_state ==LOW))
    25ca:	80 91 26 01 	lds	r24, 0x0126
    25ce:	8f 3f       	cpi	r24, 0xFF	; 255
    25d0:	89 f4       	brne	.+34     	; 0x25f4 <plastic_breaker_loop+0x5a>
    25d2:	80 91 27 01 	lds	r24, 0x0127
    25d6:	88 23       	and	r24, r24
    25d8:	69 f4       	brne	.+26     	; 0x25f4 <plastic_breaker_loop+0x5a>
    25da:	80 91 29 01 	lds	r24, 0x0129
    25de:	8f 3f       	cpi	r24, 0xFF	; 255
    25e0:	49 f4       	brne	.+18     	; 0x25f4 <plastic_breaker_loop+0x5a>
    25e2:	80 91 28 01 	lds	r24, 0x0128
    25e6:	8f 3f       	cpi	r24, 0xFF	; 255
    25e8:	29 f4       	brne	.+10     	; 0x25f4 <plastic_breaker_loop+0x5a>
    25ea:	80 91 2a 01 	lds	r24, 0x012A
    25ee:	88 23       	and	r24, r24
    25f0:	49 f0       	breq	.+18     	; 0x2604 <plastic_breaker_loop+0x6a>
    25f2:	1f c0       	rjmp	.+62     	; 0x2632 <plastic_breaker_loop+0x98>
    25f4:	80 91 28 01 	lds	r24, 0x0128
    25f8:	88 23       	and	r24, r24
    25fa:	21 f0       	breq	.+8      	; 0x2604 <plastic_breaker_loop+0x6a>
    25fc:	80 91 29 01 	lds	r24, 0x0129
    2600:	88 23       	and	r24, r24
    2602:	b9 f4       	brne	.+46     	; 0x2632 <plastic_breaker_loop+0x98>
	{
		/*ALARM_START*/
		DIO_Write(GPIOB, BIT4, HIGH);
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	60 e1       	ldi	r22, 0x10	; 16
    2608:	4f ef       	ldi	r20, 0xFF	; 255
    260a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB,BIT5,LOW);
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	60 e2       	ldi	r22, 0x20	; 32
    2612:	40 e0       	ldi	r20, 0x00	; 0
    2614:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB,BIT6,LOW);
    2618:	81 e0       	ldi	r24, 0x01	; 1
    261a:	60 e4       	ldi	r22, 0x40	; 64
    261c:	40 e0       	ldi	r20, 0x00	; 0
    261e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB,BIT7,LOW);
    2622:	81 e0       	ldi	r24, 0x01	; 1
    2624:	60 e8       	ldi	r22, 0x80	; 128
    2626:	40 e0       	ldi	r20, 0x00	; 0
    2628:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		u8_plastic_state = FIRST_SAFE_POS;
    262c:	81 e0       	ldi	r24, 0x01	; 1
    262e:	80 93 2a 01 	sts	0x012A, r24
	}
	if (on_state == LOW && u8_plastic_state == FIRST_SAFE_POS)
    2632:	80 91 26 01 	lds	r24, 0x0126
    2636:	88 23       	and	r24, r24
    2638:	39 f4       	brne	.+14     	; 0x2648 <plastic_breaker_loop+0xae>
    263a:	80 91 2a 01 	lds	r24, 0x012A
    263e:	81 30       	cpi	r24, 0x01	; 1
    2640:	19 f4       	brne	.+6      	; 0x2648 <plastic_breaker_loop+0xae>
	{
		u8_plastic_state = SECOND_SAFE_POS;
    2642:	82 e0       	ldi	r24, 0x02	; 2
    2644:	80 93 2a 01 	sts	0x012A, r24
	}

	if ((sw2_state == HIGH && sw1_state == HIGH && off_state == LOW && on_state == HIGH) && (u8_plastic_state == SECOND_SAFE_POS))
    2648:	80 91 29 01 	lds	r24, 0x0129
    264c:	8f 3f       	cpi	r24, 0xFF	; 255
    264e:	29 f5       	brne	.+74     	; 0x269a <plastic_breaker_loop+0x100>
    2650:	80 91 28 01 	lds	r24, 0x0128
    2654:	8f 3f       	cpi	r24, 0xFF	; 255
    2656:	09 f5       	brne	.+66     	; 0x269a <plastic_breaker_loop+0x100>
    2658:	80 91 27 01 	lds	r24, 0x0127
    265c:	88 23       	and	r24, r24
    265e:	e9 f4       	brne	.+58     	; 0x269a <plastic_breaker_loop+0x100>
    2660:	80 91 26 01 	lds	r24, 0x0126
    2664:	8f 3f       	cpi	r24, 0xFF	; 255
    2666:	c9 f4       	brne	.+50     	; 0x269a <plastic_breaker_loop+0x100>
    2668:	80 91 2a 01 	lds	r24, 0x012A
    266c:	82 30       	cpi	r24, 0x02	; 2
    266e:	a9 f4       	brne	.+42     	; 0x269a <plastic_breaker_loop+0x100>
	{
		/*MOTOR_WORKING_START*/
		//SwDelay_ms(3000);
		
		DIO_Write(GPIOB, BIT4, LOW);
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	60 e1       	ldi	r22, 0x10	; 16
    2674:	40 e0       	ldi	r20, 0x00	; 0
    2676:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT5, HIGH);
    267a:	81 e0       	ldi	r24, 0x01	; 1
    267c:	60 e2       	ldi	r22, 0x20	; 32
    267e:	4f ef       	ldi	r20, 0xFF	; 255
    2680:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
				DIO_Write(GPIOB, BIT7, LOW);
    2684:	81 e0       	ldi	r24, 0x01	; 1
    2686:	60 e8       	ldi	r22, 0x80	; 128
    2688:	40 e0       	ldi	r20, 0x00	; 0
    268a:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT6, HIGH);
    268e:	81 e0       	ldi	r24, 0x01	; 1
    2690:	60 e4       	ldi	r22, 0x40	; 64
    2692:	4f ef       	ldi	r20, 0xFF	; 255
    2694:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
    2698:	05 c0       	rjmp	.+10     	; 0x26a4 <plastic_breaker_loop+0x10a>
		u8_plastic_state = MOTOR_WORKING_STAR;
	}if (u8_plastic_state == MOTOR_WORKING_STAR || u8_plastic_state == COUNTING_TRANS)
    269a:	80 91 2a 01 	lds	r24, 0x012A
    269e:	83 50       	subi	r24, 0x03	; 3
    26a0:	82 30       	cpi	r24, 0x02	; 2
    26a2:	60 f4       	brcc	.+24     	; 0x26bc <plastic_breaker_loop+0x122>
	{
		u16_delay++;
    26a4:	80 91 24 01 	lds	r24, 0x0124
    26a8:	90 91 25 01 	lds	r25, 0x0125
    26ac:	01 96       	adiw	r24, 0x01	; 1
    26ae:	90 93 25 01 	sts	0x0125, r25
    26b2:	80 93 24 01 	sts	0x0124, r24
		u8_plastic_state= COUNTING_TRANS;
    26b6:	84 e0       	ldi	r24, 0x04	; 4
    26b8:	80 93 2a 01 	sts	0x012A, r24
	}
	if ((sw2_state == HIGH && sw1_state == HIGH && off_state == LOW ) &&(u8_plastic_state==COUNTING_TRANS && u16_delay >= 600))
    26bc:	80 91 29 01 	lds	r24, 0x0129
    26c0:	8f 3f       	cpi	r24, 0xFF	; 255
    26c2:	81 f5       	brne	.+96     	; 0x2724 <plastic_breaker_loop+0x18a>
    26c4:	80 91 28 01 	lds	r24, 0x0128
    26c8:	8f 3f       	cpi	r24, 0xFF	; 255
    26ca:	61 f5       	brne	.+88     	; 0x2724 <plastic_breaker_loop+0x18a>
    26cc:	80 91 27 01 	lds	r24, 0x0127
    26d0:	88 23       	and	r24, r24
    26d2:	41 f5       	brne	.+80     	; 0x2724 <plastic_breaker_loop+0x18a>
    26d4:	80 91 2a 01 	lds	r24, 0x012A
    26d8:	84 30       	cpi	r24, 0x04	; 4
    26da:	21 f5       	brne	.+72     	; 0x2724 <plastic_breaker_loop+0x18a>
    26dc:	80 91 24 01 	lds	r24, 0x0124
    26e0:	90 91 25 01 	lds	r25, 0x0125
    26e4:	22 e0       	ldi	r18, 0x02	; 2
    26e6:	88 35       	cpi	r24, 0x58	; 88
    26e8:	92 07       	cpc	r25, r18
    26ea:	e0 f0       	brcs	.+56     	; 0x2724 <plastic_breaker_loop+0x18a>
	{	u16_delay=0;
    26ec:	10 92 25 01 	sts	0x0125, r1
    26f0:	10 92 24 01 	sts	0x0124, r1
		/*MOTOR_WORKING_START*/
		//SwDelay_ms(3000);
		DIO_Write(GPIOB, BIT4, LOW);
    26f4:	81 e0       	ldi	r24, 0x01	; 1
    26f6:	60 e1       	ldi	r22, 0x10	; 16
    26f8:	40 e0       	ldi	r20, 0x00	; 0
    26fa:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT5, HIGH);
    26fe:	81 e0       	ldi	r24, 0x01	; 1
    2700:	60 e2       	ldi	r22, 0x20	; 32
    2702:	4f ef       	ldi	r20, 0xFF	; 255
    2704:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT6, LOW);
    2708:	81 e0       	ldi	r24, 0x01	; 1
    270a:	60 e4       	ldi	r22, 0x40	; 64
    270c:	40 e0       	ldi	r20, 0x00	; 0
    270e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		DIO_Write(GPIOB, BIT7, HIGH);
    2712:	81 e0       	ldi	r24, 0x01	; 1
    2714:	60 e8       	ldi	r22, 0x80	; 128
    2716:	4f ef       	ldi	r20, 0xFF	; 255
    2718:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
		u8_plastic_state = MOTOR_WORKING_DELTA;
    271c:	85 e0       	ldi	r24, 0x05	; 5
    271e:	80 93 2a 01 	sts	0x012A, r24
    2722:	06 c0       	rjmp	.+12     	; 0x2730 <plastic_breaker_loop+0x196>
	
	}

		if (((u8_plastic_state == MOTOR_WORKING_DELTA || u8_plastic_state == MOTOR_WORKING_STAR) && (off_state == HIGH)) || ((u8_plastic_state == MOTOR_WORKING_DELTA || u8_plastic_state == MOTOR_WORKING_STAR) && (sw1_state == LOW || sw2_state == LOW)))
    2724:	80 91 2a 01 	lds	r24, 0x012A
    2728:	85 30       	cpi	r24, 0x05	; 5
    272a:	11 f0       	breq	.+4      	; 0x2730 <plastic_breaker_loop+0x196>
    272c:	83 30       	cpi	r24, 0x03	; 3
    272e:	11 f5       	brne	.+68     	; 0x2774 <plastic_breaker_loop+0x1da>
    2730:	80 91 27 01 	lds	r24, 0x0127
    2734:	8f 3f       	cpi	r24, 0xFF	; 255
    2736:	41 f0       	breq	.+16     	; 0x2748 <plastic_breaker_loop+0x1ae>
    2738:	80 91 28 01 	lds	r24, 0x0128
    273c:	88 23       	and	r24, r24
    273e:	21 f0       	breq	.+8      	; 0x2748 <plastic_breaker_loop+0x1ae>
    2740:	80 91 29 01 	lds	r24, 0x0129
    2744:	88 23       	and	r24, r24
    2746:	b1 f4       	brne	.+44     	; 0x2774 <plastic_breaker_loop+0x1da>
		{

			/*turn off the machine*/
			DIO_Write(GPIOB, BIT4, LOW);
    2748:	81 e0       	ldi	r24, 0x01	; 1
    274a:	60 e1       	ldi	r22, 0x10	; 16
    274c:	40 e0       	ldi	r20, 0x00	; 0
    274e:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			DIO_Write(GPIOB, BIT5, LOW);
    2752:	81 e0       	ldi	r24, 0x01	; 1
    2754:	60 e2       	ldi	r22, 0x20	; 32
    2756:	40 e0       	ldi	r20, 0x00	; 0
    2758:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			DIO_Write(GPIOB, BIT6, LOW);
    275c:	81 e0       	ldi	r24, 0x01	; 1
    275e:	60 e4       	ldi	r22, 0x40	; 64
    2760:	40 e0       	ldi	r20, 0x00	; 0
    2762:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			DIO_Write(GPIOB, BIT7, LOW);
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	60 e8       	ldi	r22, 0x80	; 128
    276a:	40 e0       	ldi	r20, 0x00	; 0
    276c:	0e 94 af 0b 	call	0x175e	; 0x175e <DIO_Write>
			u8_plastic_state = NO_ACTION_PLAS;
    2770:	10 92 2a 01 	sts	0x012A, r1
    2774:	08 95       	ret

00002776 <badawy_machine_init>:
/*Badawy machine init */
static uint8_t u8_plastic_state = NO_ACTION_PLAS;
uint16_t u16_delay = 0 ;

void badawy_machine_init(void)
{
    2776:	0f 93       	push	r16
	Uart_Init(Baud9600, OneStopBit, NoParity, EightBits, ASynchronous);
    2778:	87 e6       	ldi	r24, 0x67	; 103
    277a:	60 e0       	ldi	r22, 0x00	; 0
    277c:	40 e0       	ldi	r20, 0x00	; 0
    277e:	23 e0       	ldi	r18, 0x03	; 3
    2780:	00 e0       	ldi	r16, 0x00	; 0
    2782:	0e 94 02 12 	call	0x2404	; 0x2404 <Uart_Init>
	DIO_init(&Dio_configurationB);
    2786:	84 ec       	ldi	r24, 0xC4	; 196
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
	DIO_init(&Dio_configurationC);
    278e:	81 ec       	ldi	r24, 0xC1	; 193
    2790:	90 e0       	ldi	r25, 0x00	; 0
    2792:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
	DIO_init(&Dio_configurationD);
    2796:	8e eb       	ldi	r24, 0xBE	; 190
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <DIO_init>
	SOS_Init(&TMU_Configuration);
    279e:	8b ee       	ldi	r24, 0xEB	; 235
    27a0:	90 e0       	ldi	r25, 0x00	; 0
    27a2:	0e 94 15 28 	call	0x502a	; 0x502a <SOS_Init>
	SOS_Create_Task(Read_Time_Task, 1, 1, 5);
    27a6:	80 eb       	ldi	r24, 0xB0	; 176
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	61 e0       	ldi	r22, 0x01	; 1
    27ac:	41 e0       	ldi	r20, 0x01	; 1
    27ae:	25 e0       	ldi	r18, 0x05	; 5
    27b0:	30 e0       	ldi	r19, 0x00	; 0
    27b2:	0e 94 68 28 	call	0x50d0	; 0x50d0 <SOS_Create_Task>
	SOS_Create_Task(update_timing, 1, 4, 1);
    27b6:	83 e2       	ldi	r24, 0x23	; 35
    27b8:	91 e0       	ldi	r25, 0x01	; 1
    27ba:	61 e0       	ldi	r22, 0x01	; 1
    27bc:	44 e0       	ldi	r20, 0x04	; 4
    27be:	21 e0       	ldi	r18, 0x01	; 1
    27c0:	30 e0       	ldi	r19, 0x00	; 0
    27c2:	0e 94 68 28 	call	0x50d0	; 0x50d0 <SOS_Create_Task>
	SOS_Create_Task(Push_Task1, 1, 3, 2);
    27c6:	80 ea       	ldi	r24, 0xA0	; 160
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	61 e0       	ldi	r22, 0x01	; 1
    27cc:	43 e0       	ldi	r20, 0x03	; 3
    27ce:	22 e0       	ldi	r18, 0x02	; 2
    27d0:	30 e0       	ldi	r19, 0x00	; 0
    27d2:	0e 94 68 28 	call	0x50d0	; 0x50d0 <SOS_Create_Task>
}
    27d6:	0f 91       	pop	r16
    27d8:	08 95       	ret

000027da <plastic_breaker_init>:
	uart_transmit_u16(PORTC_DATA);
	UartTransmitPooling('D');
	uart_transmit_u16(PORTD_DATA);
}
void plastic_breaker_init(void)
{
    27da:	0f 93       	push	r16
	Uart_Init(Baud9600, OneStopBit, NoParity, EightBits, ASynchronous);
    27dc:	87 e6       	ldi	r24, 0x67	; 103
    27de:	60 e0       	ldi	r22, 0x00	; 0
    27e0:	40 e0       	ldi	r20, 0x00	; 0
    27e2:	23 e0       	ldi	r18, 0x03	; 3
    27e4:	00 e0       	ldi	r16, 0x00	; 0
    27e6:	0e 94 02 12 	call	0x2404	; 0x2404 <Uart_Init>
	init_fun_plastic();
    27ea:	0e 94 67 00 	call	0xce	; 0xce <init_fun_plastic>
	SOS_Init(&TMU_Configuration);
    27ee:	8b ee       	ldi	r24, 0xEB	; 235
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	0e 94 15 28 	call	0x502a	; 0x502a <SOS_Init>
	SOS_Create_Task(plastic_breaker_loop, 1, 1, 5);
    27f6:	8d ec       	ldi	r24, 0xCD	; 205
    27f8:	92 e1       	ldi	r25, 0x12	; 18
    27fa:	61 e0       	ldi	r22, 0x01	; 1
    27fc:	41 e0       	ldi	r20, 0x01	; 1
    27fe:	25 e0       	ldi	r18, 0x05	; 5
    2800:	30 e0       	ldi	r19, 0x00	; 0
    2802:	0e 94 68 28 	call	0x50d0	; 0x50d0 <SOS_Create_Task>
	SOS_Create_Task(alarm_flashing, 1, 2, 100);
    2806:	83 ec       	ldi	r24, 0xC3	; 195
    2808:	92 e1       	ldi	r25, 0x12	; 18
    280a:	61 e0       	ldi	r22, 0x01	; 1
    280c:	42 e0       	ldi	r20, 0x02	; 2
    280e:	24 e6       	ldi	r18, 0x64	; 100
    2810:	30 e0       	ldi	r19, 0x00	; 0
    2812:	0e 94 68 28 	call	0x50d0	; 0x50d0 <SOS_Create_Task>
	SOS_Create_Task(debug, 1, 3, 1000);
    2816:	8d ea       	ldi	r24, 0xAD	; 173
    2818:	92 e1       	ldi	r25, 0x12	; 18
    281a:	61 e0       	ldi	r22, 0x01	; 1
    281c:	43 e0       	ldi	r20, 0x03	; 3
    281e:	28 ee       	ldi	r18, 0xE8	; 232
    2820:	33 e0       	ldi	r19, 0x03	; 3
    2822:	0e 94 68 28 	call	0x50d0	; 0x50d0 <SOS_Create_Task>
}
    2826:	0f 91       	pop	r16
    2828:	08 95       	ret

0000282a <main>:

int main(void)
{
	plastic_breaker_init();
    282a:	0e 94 ed 13 	call	0x27da	; 0x27da <plastic_breaker_init>
	/*badawy_machine_init();*/
	
	while (1)
	{
		SOS_Run();
    282e:	0e 94 85 28 	call	0x510a	; 0x510a <SOS_Run>
    2832:	fd cf       	rjmp	.-6      	; 0x282e <main+0x4>

00002834 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    2834:	44 23       	and	r20, r20
    2836:	41 f4       	brne	.+16     	; 0x2848 <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2838:	68 23       	and	r22, r24
    283a:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
    283c:	81 e0       	ldi	r24, 0x01	; 1
    283e:	61 15       	cp	r22, r1
    2840:	71 05       	cpc	r23, r1
    2842:	51 f4       	brne	.+20     	; 0x2858 <prvTestWaitCondition+0x24>
    2844:	80 e0       	ldi	r24, 0x00	; 0
    2846:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2848:	9b 01       	movw	r18, r22
    284a:	28 23       	and	r18, r24
    284c:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
    284e:	81 e0       	ldi	r24, 0x01	; 1
    2850:	62 17       	cp	r22, r18
    2852:	73 07       	cpc	r23, r19
    2854:	09 f0       	breq	.+2      	; 0x2858 <prvTestWaitCondition+0x24>
    2856:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
    2858:	08 95       	ret

0000285a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    285a:	cf 93       	push	r28
    285c:	df 93       	push	r29
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    285e:	8b e0       	ldi	r24, 0x0B	; 11
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <pvPortMalloc>
    2866:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
    2868:	00 97       	sbiw	r24, 0x00	; 0
    286a:	31 f0       	breq	.+12     	; 0x2878 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
    286c:	fc 01       	movw	r30, r24
    286e:	11 92       	st	Z+, r1
    2870:	11 92       	st	Z+, r1
    2872:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2874:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
	}
    2878:	8c 2f       	mov	r24, r28
    287a:	9d 2f       	mov	r25, r29
    287c:	df 91       	pop	r29
    287e:	cf 91       	pop	r28
    2880:	08 95       	ret

00002882 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2882:	af 92       	push	r10
    2884:	bf 92       	push	r11
    2886:	cf 92       	push	r12
    2888:	df 92       	push	r13
    288a:	ef 92       	push	r14
    288c:	ff 92       	push	r15
    288e:	0f 93       	push	r16
    2890:	1f 93       	push	r17
    2892:	cf 93       	push	r28
    2894:	df 93       	push	r29
    2896:	5c 01       	movw	r10, r24
    2898:	6b 01       	movw	r12, r22
    289a:	e4 2e       	mov	r14, r20
    289c:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    289e:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    28a2:	f5 01       	movw	r30, r10
    28a4:	c0 81       	ld	r28, Z
    28a6:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    28a8:	ce 01       	movw	r24, r28
    28aa:	b6 01       	movw	r22, r12
    28ac:	4f 2d       	mov	r20, r15
    28ae:	0e 94 1a 14 	call	0x2834	; 0x2834 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
    28b2:	88 23       	and	r24, r24
    28b4:	51 f0       	breq	.+20     	; 0x28ca <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    28b6:	ee 20       	and	r14, r14
    28b8:	01 f1       	breq	.+64     	; 0x28fa <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    28ba:	c0 94       	com	r12
    28bc:	d0 94       	com	r13
    28be:	cc 22       	and	r12, r28
    28c0:	dd 22       	and	r13, r29
    28c2:	f5 01       	movw	r30, r10
    28c4:	d1 82       	std	Z+1, r13	; 0x01
    28c6:	c0 82       	st	Z, r12
    28c8:	18 c0       	rjmp	.+48     	; 0x28fa <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    28ca:	01 15       	cp	r16, r1
    28cc:	11 05       	cpc	r17, r1
    28ce:	a9 f0       	breq	.+42     	; 0x28fa <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    28d0:	ee 20       	and	r14, r14
    28d2:	19 f4       	brne	.+6      	; 0x28da <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
    28d4:	60 e0       	ldi	r22, 0x00	; 0
    28d6:	70 e0       	ldi	r23, 0x00	; 0
    28d8:	02 c0       	rjmp	.+4      	; 0x28de <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    28da:	60 e0       	ldi	r22, 0x00	; 0
    28dc:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    28de:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    28e0:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    28e2:	6c 29       	or	r22, r12
    28e4:	7d 29       	or	r23, r13
    28e6:	c5 01       	movw	r24, r10
    28e8:	02 96       	adiw	r24, 0x02	; 2
    28ea:	a8 01       	movw	r20, r16
    28ec:	0e 94 bd 24 	call	0x497a	; 0x497a <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    28f0:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
    28f4:	88 23       	and	r24, r24
    28f6:	39 f4       	brne	.+14     	; 0x2906 <xEventGroupWaitBits+0x84>
    28f8:	04 c0       	rjmp	.+8      	; 0x2902 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    28fa:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    28fe:	ce 01       	movw	r24, r28
    2900:	21 c0       	rjmp	.+66     	; 0x2944 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2902:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2906:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <uxTaskResetEventItemValue>
    290a:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    290c:	91 fd       	sbrc	r25, 1
    290e:	18 c0       	rjmp	.+48     	; 0x2940 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
    2910:	0f b6       	in	r0, 0x3f	; 63
    2912:	f8 94       	cli
    2914:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2916:	f5 01       	movw	r30, r10
    2918:	c0 81       	ld	r28, Z
    291a:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    291c:	ce 01       	movw	r24, r28
    291e:	b6 01       	movw	r22, r12
    2920:	4f 2d       	mov	r20, r15
    2922:	0e 94 1a 14 	call	0x2834	; 0x2834 <prvTestWaitCondition>
    2926:	88 23       	and	r24, r24
    2928:	49 f0       	breq	.+18     	; 0x293c <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
    292a:	ee 20       	and	r14, r14
    292c:	39 f0       	breq	.+14     	; 0x293c <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    292e:	c0 94       	com	r12
    2930:	d0 94       	com	r13
    2932:	cc 22       	and	r12, r28
    2934:	dd 22       	and	r13, r29
    2936:	f5 01       	movw	r30, r10
    2938:	d1 82       	std	Z+1, r13	; 0x01
    293a:	c0 82       	st	Z, r12
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
			}
			taskEXIT_CRITICAL();
    293c:	0f 90       	pop	r0
    293e:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2940:	ce 01       	movw	r24, r28
    2942:	90 70       	andi	r25, 0x00	; 0

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
}
    2944:	df 91       	pop	r29
    2946:	cf 91       	pop	r28
    2948:	1f 91       	pop	r17
    294a:	0f 91       	pop	r16
    294c:	ff 90       	pop	r15
    294e:	ef 90       	pop	r14
    2950:	df 90       	pop	r13
    2952:	cf 90       	pop	r12
    2954:	bf 90       	pop	r11
    2956:	af 90       	pop	r10
    2958:	08 95       	ret

0000295a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    295a:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    295c:	0f b6       	in	r0, 0x3f	; 63
    295e:	f8 94       	cli
    2960:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2962:	80 81       	ld	r24, Z
    2964:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2966:	60 95       	com	r22
    2968:	70 95       	com	r23
    296a:	68 23       	and	r22, r24
    296c:	79 23       	and	r23, r25
    296e:	71 83       	std	Z+1, r23	; 0x01
    2970:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
    2972:	0f 90       	pop	r0
    2974:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2976:	08 95       	ret

00002978 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2978:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    297a:	80 81       	ld	r24, Z
    297c:	91 81       	ldd	r25, Z+1	; 0x01
    297e:	08 95       	ret

00002980 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2980:	af 92       	push	r10
    2982:	bf 92       	push	r11
    2984:	cf 92       	push	r12
    2986:	df 92       	push	r13
    2988:	ef 92       	push	r14
    298a:	ff 92       	push	r15
    298c:	0f 93       	push	r16
    298e:	1f 93       	push	r17
    2990:	cf 93       	push	r28
    2992:	df 93       	push	r29
    2994:	8c 01       	movw	r16, r24
    2996:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2998:	0f 2e       	mov	r0, r31
    299a:	f5 e0       	ldi	r31, 0x05	; 5
    299c:	cf 2e       	mov	r12, r31
    299e:	dd 24       	eor	r13, r13
    29a0:	f0 2d       	mov	r31, r0
    29a2:	c8 0e       	add	r12, r24
    29a4:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
    29a6:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    29aa:	d8 01       	movw	r26, r16
    29ac:	17 96       	adiw	r26, 0x07	; 7
    29ae:	ed 91       	ld	r30, X+
    29b0:	fc 91       	ld	r31, X
    29b2:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    29b4:	8d 91       	ld	r24, X+
    29b6:	9c 91       	ld	r25, X
    29b8:	11 97       	sbiw	r26, 0x01	; 1
    29ba:	8c 2b       	or	r24, r28
    29bc:	9d 2b       	or	r25, r29
    29be:	11 96       	adiw	r26, 0x01	; 1
    29c0:	9c 93       	st	X, r25
    29c2:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    29c4:	ce 16       	cp	r12, r30
    29c6:	df 06       	cpc	r13, r31
    29c8:	c1 f1       	breq	.+112    	; 0x2a3a <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    29ca:	aa 24       	eor	r10, r10
    29cc:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    29ce:	ff 24       	eor	r15, r15
    29d0:	f3 94       	inc	r15
    29d2:	ee 24       	eor	r14, r14
    29d4:	01 c0       	rjmp	.+2      	; 0x29d8 <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    29d6:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
    29d8:	c2 81       	ldd	r28, Z+2	; 0x02
    29da:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    29dc:	80 81       	ld	r24, Z
    29de:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    29e0:	bc 01       	movw	r22, r24
    29e2:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    29e4:	9c 01       	movw	r18, r24
    29e6:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    29e8:	92 fd       	sbrc	r25, 2
    29ea:	0b c0       	rjmp	.+22     	; 0x2a02 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    29ec:	d8 01       	movw	r26, r16
    29ee:	8d 91       	ld	r24, X+
    29f0:	9c 91       	ld	r25, X
    29f2:	11 97       	sbiw	r26, 0x01	; 1
    29f4:	82 23       	and	r24, r18
    29f6:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
    29f8:	4f 2d       	mov	r20, r15
    29fa:	00 97       	sbiw	r24, 0x00	; 0
    29fc:	69 f4       	brne	.+26     	; 0x2a18 <xEventGroupSetBits+0x98>
    29fe:	4e 2d       	mov	r20, r14
    2a00:	0b c0       	rjmp	.+22     	; 0x2a18 <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2a02:	d8 01       	movw	r26, r16
    2a04:	8d 91       	ld	r24, X+
    2a06:	9c 91       	ld	r25, X
    2a08:	11 97       	sbiw	r26, 0x01	; 1
    2a0a:	82 23       	and	r24, r18
    2a0c:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
    2a0e:	4f 2d       	mov	r20, r15
    2a10:	28 17       	cp	r18, r24
    2a12:	39 07       	cpc	r19, r25
    2a14:	09 f0       	breq	.+2      	; 0x2a18 <xEventGroupSetBits+0x98>
    2a16:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    2a18:	44 23       	and	r20, r20
    2a1a:	59 f0       	breq	.+22     	; 0x2a32 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2a1c:	70 ff       	sbrs	r23, 0
    2a1e:	02 c0       	rjmp	.+4      	; 0x2a24 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2a20:	a2 2a       	or	r10, r18
    2a22:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2a24:	d8 01       	movw	r26, r16
    2a26:	6d 91       	ld	r22, X+
    2a28:	7c 91       	ld	r23, X
    2a2a:	72 60       	ori	r23, 0x02	; 2
    2a2c:	cf 01       	movw	r24, r30
    2a2e:	0e 94 21 25 	call	0x4a42	; 0x4a42 <vTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2a32:	cc 16       	cp	r12, r28
    2a34:	dd 06       	cpc	r13, r29
    2a36:	79 f6       	brne	.-98     	; 0x29d6 <xEventGroupSetBits+0x56>
    2a38:	02 c0       	rjmp	.+4      	; 0x2a3e <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2a3a:	aa 24       	eor	r10, r10
    2a3c:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2a3e:	c5 01       	movw	r24, r10
    2a40:	80 95       	com	r24
    2a42:	90 95       	com	r25
    2a44:	f8 01       	movw	r30, r16
    2a46:	a0 80       	ld	r10, Z
    2a48:	b1 80       	ldd	r11, Z+1	; 0x01
    2a4a:	a8 22       	and	r10, r24
    2a4c:	b9 22       	and	r11, r25
    2a4e:	b1 82       	std	Z+1, r11	; 0x01
    2a50:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
    2a52:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
    2a56:	d8 01       	movw	r26, r16
    2a58:	8c 91       	ld	r24, X
    2a5a:	11 96       	adiw	r26, 0x01	; 1
    2a5c:	9c 91       	ld	r25, X
    2a5e:	11 97       	sbiw	r26, 0x01	; 1
    2a60:	df 91       	pop	r29
    2a62:	cf 91       	pop	r28
    2a64:	1f 91       	pop	r17
    2a66:	0f 91       	pop	r16
    2a68:	ff 90       	pop	r15
    2a6a:	ef 90       	pop	r14
    2a6c:	df 90       	pop	r13
    2a6e:	cf 90       	pop	r12
    2a70:	bf 90       	pop	r11
    2a72:	af 90       	pop	r10
    2a74:	08 95       	ret

00002a76 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2a76:	af 92       	push	r10
    2a78:	bf 92       	push	r11
    2a7a:	cf 92       	push	r12
    2a7c:	df 92       	push	r13
    2a7e:	ef 92       	push	r14
    2a80:	ff 92       	push	r15
    2a82:	0f 93       	push	r16
    2a84:	1f 93       	push	r17
    2a86:	cf 93       	push	r28
    2a88:	df 93       	push	r29
    2a8a:	6c 01       	movw	r12, r24
    2a8c:	eb 01       	movw	r28, r22
    2a8e:	7a 01       	movw	r14, r20
    2a90:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2a92:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2a96:	f6 01       	movw	r30, r12
    2a98:	00 81       	ld	r16, Z
    2a9a:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2a9c:	c6 01       	movw	r24, r12
    2a9e:	be 01       	movw	r22, r28
    2aa0:	0e 94 c0 14 	call	0x2980	; 0x2980 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2aa4:	c0 2b       	or	r28, r16
    2aa6:	d1 2b       	or	r29, r17
    2aa8:	c7 01       	movw	r24, r14
    2aaa:	8c 23       	and	r24, r28
    2aac:	9d 23       	and	r25, r29
    2aae:	8e 15       	cp	r24, r14
    2ab0:	9f 05       	cpc	r25, r15
    2ab2:	51 f4       	brne	.+20     	; 0x2ac8 <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2ab4:	80 95       	com	r24
    2ab6:	90 95       	com	r25
    2ab8:	f6 01       	movw	r30, r12
    2aba:	20 81       	ld	r18, Z
    2abc:	31 81       	ldd	r19, Z+1	; 0x01
    2abe:	82 23       	and	r24, r18
    2ac0:	93 23       	and	r25, r19
    2ac2:	91 83       	std	Z+1, r25	; 0x01
    2ac4:	80 83       	st	Z, r24
    2ac6:	12 c0       	rjmp	.+36     	; 0x2aec <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2ac8:	a1 14       	cp	r10, r1
    2aca:	b1 04       	cpc	r11, r1
    2acc:	61 f0       	breq	.+24     	; 0x2ae6 <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2ace:	b7 01       	movw	r22, r14
    2ad0:	75 60       	ori	r23, 0x05	; 5
    2ad2:	c6 01       	movw	r24, r12
    2ad4:	02 96       	adiw	r24, 0x02	; 2
    2ad6:	a5 01       	movw	r20, r10
    2ad8:	0e 94 bd 24 	call	0x497a	; 0x497a <vTaskPlaceOnUnorderedEventList>
				uxReturn = pxEventBits->uxEventBits;
				xTimeoutOccurred = pdTRUE;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2adc:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
    2ae0:	88 23       	and	r24, r24
    2ae2:	49 f4       	brne	.+18     	; 0x2af6 <xEventGroupSync+0x80>
    2ae4:	06 c0       	rjmp	.+12     	; 0x2af2 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2ae6:	f6 01       	movw	r30, r12
    2ae8:	c0 81       	ld	r28, Z
    2aea:	d1 81       	ldd	r29, Z+1	; 0x01
				xTimeoutOccurred = pdTRUE;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2aec:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    2af0:	1c c0       	rjmp	.+56     	; 0x2b2a <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2af2:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2af6:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2afa:	91 fd       	sbrc	r25, 1
    2afc:	14 c0       	rjmp	.+40     	; 0x2b26 <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2afe:	0f b6       	in	r0, 0x3f	; 63
    2b00:	f8 94       	cli
    2b02:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2b04:	f6 01       	movw	r30, r12
    2b06:	80 81       	ld	r24, Z
    2b08:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2b0a:	97 01       	movw	r18, r14
    2b0c:	28 23       	and	r18, r24
    2b0e:	39 23       	and	r19, r25
    2b10:	2e 15       	cp	r18, r14
    2b12:	3f 05       	cpc	r19, r15
    2b14:	31 f4       	brne	.+12     	; 0x2b22 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2b16:	20 95       	com	r18
    2b18:	30 95       	com	r19
    2b1a:	28 23       	and	r18, r24
    2b1c:	39 23       	and	r19, r25
    2b1e:	31 83       	std	Z+1, r19	; 0x01
    2b20:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2b22:	0f 90       	pop	r0
    2b24:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2b26:	ec 01       	movw	r28, r24
    2b28:	d0 70       	andi	r29, 0x00	; 0

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
}
    2b2a:	8c 2f       	mov	r24, r28
    2b2c:	9d 2f       	mov	r25, r29
    2b2e:	df 91       	pop	r29
    2b30:	cf 91       	pop	r28
    2b32:	1f 91       	pop	r17
    2b34:	0f 91       	pop	r16
    2b36:	ff 90       	pop	r15
    2b38:	ef 90       	pop	r14
    2b3a:	df 90       	pop	r13
    2b3c:	cf 90       	pop	r12
    2b3e:	bf 90       	pop	r11
    2b40:	af 90       	pop	r10
    2b42:	08 95       	ret

00002b44 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2b44:	cf 93       	push	r28
    2b46:	df 93       	push	r29
    2b48:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
    2b4a:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2b4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b50:	88 23       	and	r24, r24
    2b52:	49 f0       	breq	.+18     	; 0x2b66 <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2b54:	8f 81       	ldd	r24, Y+7	; 0x07
    2b56:	98 85       	ldd	r25, Y+8	; 0x08
    2b58:	60 e0       	ldi	r22, 0x00	; 0
    2b5a:	72 e0       	ldi	r23, 0x02	; 2
    2b5c:	0e 94 21 25 	call	0x4a42	; 0x4a42 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2b60:	8a 81       	ldd	r24, Y+2	; 0x02
    2b62:	88 23       	and	r24, r24
    2b64:	b9 f7       	brne	.-18     	; 0x2b54 <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2b66:	ce 01       	movw	r24, r28
    2b68:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2b6c:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
}
    2b70:	df 91       	pop	r29
    2b72:	cf 91       	pop	r28
    2b74:	08 95       	ret

00002b76 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2b76:	ba 01       	movw	r22, r20
    2b78:	0e 94 c0 14 	call	0x2980	; 0x2980 <xEventGroupSetBits>
}
    2b7c:	08 95       	ret

00002b7e <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2b7e:	ba 01       	movw	r22, r20
    2b80:	0e 94 ad 14 	call	0x295a	; 0x295a <xEventGroupClearBits>
}
    2b84:	08 95       	ret

00002b86 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2b86:	cf 93       	push	r28
    2b88:	df 93       	push	r29
    2b8a:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2b8c:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2b90:	80 91 2b 01 	lds	r24, 0x012B
    2b94:	90 91 2c 01 	lds	r25, 0x012C
    2b98:	00 97       	sbiw	r24, 0x00	; 0
    2b9a:	31 f4       	brne	.+12     	; 0x2ba8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2b9c:	8e e2       	ldi	r24, 0x2E	; 46
    2b9e:	91 e0       	ldi	r25, 0x01	; 1
    2ba0:	90 93 2c 01 	sts	0x012C, r25
    2ba4:	80 93 2b 01 	sts	0x012B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2ba8:	20 91 15 05 	lds	r18, 0x0515
    2bac:	30 91 16 05 	lds	r19, 0x0516
    2bb0:	ce 01       	movw	r24, r28
    2bb2:	82 0f       	add	r24, r18
    2bb4:	93 1f       	adc	r25, r19
    2bb6:	43 e0       	ldi	r20, 0x03	; 3
    2bb8:	87 3e       	cpi	r24, 0xE7	; 231
    2bba:	94 07       	cpc	r25, r20
    2bbc:	70 f4       	brcc	.+28     	; 0x2bda <pvPortMalloc+0x54>
    2bbe:	28 17       	cp	r18, r24
    2bc0:	39 07       	cpc	r19, r25
    2bc2:	70 f4       	brcc	.+28     	; 0x2be0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2bc4:	c0 91 2b 01 	lds	r28, 0x012B
    2bc8:	d0 91 2c 01 	lds	r29, 0x012C
    2bcc:	c2 0f       	add	r28, r18
    2bce:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2bd0:	90 93 16 05 	sts	0x0516, r25
    2bd4:	80 93 15 05 	sts	0x0515, r24
    2bd8:	05 c0       	rjmp	.+10     	; 0x2be4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2bda:	c0 e0       	ldi	r28, 0x00	; 0
    2bdc:	d0 e0       	ldi	r29, 0x00	; 0
    2bde:	02 c0       	rjmp	.+4      	; 0x2be4 <pvPortMalloc+0x5e>
    2be0:	c0 e0       	ldi	r28, 0x00	; 0
    2be2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2be4:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2be8:	8c 2f       	mov	r24, r28
    2bea:	9d 2f       	mov	r25, r29
    2bec:	df 91       	pop	r29
    2bee:	cf 91       	pop	r28
    2bf0:	08 95       	ret

00002bf2 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2bf2:	08 95       	ret

00002bf4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2bf4:	10 92 16 05 	sts	0x0516, r1
    2bf8:	10 92 15 05 	sts	0x0515, r1
}
    2bfc:	08 95       	ret

00002bfe <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2bfe:	20 91 15 05 	lds	r18, 0x0515
    2c02:	30 91 16 05 	lds	r19, 0x0516
    2c06:	87 ee       	ldi	r24, 0xE7	; 231
    2c08:	93 e0       	ldi	r25, 0x03	; 3
    2c0a:	82 1b       	sub	r24, r18
    2c0c:	93 0b       	sbc	r25, r19
}
    2c0e:	08 95       	ret

00002c10 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2c10:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c12:	03 96       	adiw	r24, 0x03	; 3
    2c14:	92 83       	std	Z+2, r25	; 0x02
    2c16:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2c18:	2f ef       	ldi	r18, 0xFF	; 255
    2c1a:	3f ef       	ldi	r19, 0xFF	; 255
    2c1c:	34 83       	std	Z+4, r19	; 0x04
    2c1e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c20:	96 83       	std	Z+6, r25	; 0x06
    2c22:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c24:	90 87       	std	Z+8, r25	; 0x08
    2c26:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2c28:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2c2a:	08 95       	ret

00002c2c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2c2c:	fc 01       	movw	r30, r24
    2c2e:	11 86       	std	Z+9, r1	; 0x09
    2c30:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2c32:	08 95       	ret

00002c34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2c34:	cf 93       	push	r28
    2c36:	df 93       	push	r29
    2c38:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2c3a:	dc 01       	movw	r26, r24
    2c3c:	11 96       	adiw	r26, 0x01	; 1
    2c3e:	cd 91       	ld	r28, X+
    2c40:	dc 91       	ld	r29, X
    2c42:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2c44:	d3 83       	std	Z+3, r29	; 0x03
    2c46:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2c48:	2c 81       	ldd	r18, Y+4	; 0x04
    2c4a:	3d 81       	ldd	r19, Y+5	; 0x05
    2c4c:	35 83       	std	Z+5, r19	; 0x05
    2c4e:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2c50:	ac 81       	ldd	r26, Y+4	; 0x04
    2c52:	bd 81       	ldd	r27, Y+5	; 0x05
    2c54:	13 96       	adiw	r26, 0x03	; 3
    2c56:	7c 93       	st	X, r23
    2c58:	6e 93       	st	-X, r22
    2c5a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    2c5c:	7d 83       	std	Y+5, r23	; 0x05
    2c5e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2c60:	91 87       	std	Z+9, r25	; 0x09
    2c62:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2c64:	fc 01       	movw	r30, r24
    2c66:	20 81       	ld	r18, Z
    2c68:	2f 5f       	subi	r18, 0xFF	; 255
    2c6a:	20 83       	st	Z, r18
}
    2c6c:	df 91       	pop	r29
    2c6e:	cf 91       	pop	r28
    2c70:	08 95       	ret

00002c72 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2c72:	cf 93       	push	r28
    2c74:	df 93       	push	r29
    2c76:	ac 01       	movw	r20, r24
    2c78:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2c7a:	28 81       	ld	r18, Y
    2c7c:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2c7e:	8f ef       	ldi	r24, 0xFF	; 255
    2c80:	2f 3f       	cpi	r18, 0xFF	; 255
    2c82:	38 07       	cpc	r19, r24
    2c84:	21 f4       	brne	.+8      	; 0x2c8e <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2c86:	fa 01       	movw	r30, r20
    2c88:	a7 81       	ldd	r26, Z+7	; 0x07
    2c8a:	b0 85       	ldd	r27, Z+8	; 0x08
    2c8c:	0d c0       	rjmp	.+26     	; 0x2ca8 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2c8e:	da 01       	movw	r26, r20
    2c90:	13 96       	adiw	r26, 0x03	; 3
    2c92:	01 c0       	rjmp	.+2      	; 0x2c96 <vListInsert+0x24>
    2c94:	df 01       	movw	r26, r30
    2c96:	12 96       	adiw	r26, 0x02	; 2
    2c98:	ed 91       	ld	r30, X+
    2c9a:	fc 91       	ld	r31, X
    2c9c:	13 97       	sbiw	r26, 0x03	; 3
    2c9e:	80 81       	ld	r24, Z
    2ca0:	91 81       	ldd	r25, Z+1	; 0x01
    2ca2:	28 17       	cp	r18, r24
    2ca4:	39 07       	cpc	r19, r25
    2ca6:	b0 f7       	brcc	.-20     	; 0x2c94 <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2ca8:	12 96       	adiw	r26, 0x02	; 2
    2caa:	ed 91       	ld	r30, X+
    2cac:	fc 91       	ld	r31, X
    2cae:	13 97       	sbiw	r26, 0x03	; 3
    2cb0:	fb 83       	std	Y+3, r31	; 0x03
    2cb2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2cb4:	d5 83       	std	Z+5, r29	; 0x05
    2cb6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2cb8:	bd 83       	std	Y+5, r27	; 0x05
    2cba:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2cbc:	13 96       	adiw	r26, 0x03	; 3
    2cbe:	dc 93       	st	X, r29
    2cc0:	ce 93       	st	-X, r28
    2cc2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2cc4:	59 87       	std	Y+9, r21	; 0x09
    2cc6:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    2cc8:	fa 01       	movw	r30, r20
    2cca:	80 81       	ld	r24, Z
    2ccc:	8f 5f       	subi	r24, 0xFF	; 255
    2cce:	80 83       	st	Z, r24
}
    2cd0:	df 91       	pop	r29
    2cd2:	cf 91       	pop	r28
    2cd4:	08 95       	ret

00002cd6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2cdc:	c0 85       	ldd	r28, Z+8	; 0x08
    2cde:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2ce0:	a2 81       	ldd	r26, Z+2	; 0x02
    2ce2:	b3 81       	ldd	r27, Z+3	; 0x03
    2ce4:	84 81       	ldd	r24, Z+4	; 0x04
    2ce6:	95 81       	ldd	r25, Z+5	; 0x05
    2ce8:	15 96       	adiw	r26, 0x05	; 5
    2cea:	9c 93       	st	X, r25
    2cec:	8e 93       	st	-X, r24
    2cee:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2cf0:	a4 81       	ldd	r26, Z+4	; 0x04
    2cf2:	b5 81       	ldd	r27, Z+5	; 0x05
    2cf4:	82 81       	ldd	r24, Z+2	; 0x02
    2cf6:	93 81       	ldd	r25, Z+3	; 0x03
    2cf8:	13 96       	adiw	r26, 0x03	; 3
    2cfa:	9c 93       	st	X, r25
    2cfc:	8e 93       	st	-X, r24
    2cfe:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2d00:	a9 81       	ldd	r26, Y+1	; 0x01
    2d02:	ba 81       	ldd	r27, Y+2	; 0x02
    2d04:	ae 17       	cp	r26, r30
    2d06:	bf 07       	cpc	r27, r31
    2d08:	31 f4       	brne	.+12     	; 0x2d16 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2d0a:	14 96       	adiw	r26, 0x04	; 4
    2d0c:	8d 91       	ld	r24, X+
    2d0e:	9c 91       	ld	r25, X
    2d10:	15 97       	sbiw	r26, 0x05	; 5
    2d12:	9a 83       	std	Y+2, r25	; 0x02
    2d14:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2d16:	11 86       	std	Z+9, r1	; 0x09
    2d18:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2d1a:	88 81       	ld	r24, Y
    2d1c:	81 50       	subi	r24, 0x01	; 1
    2d1e:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
    2d20:	88 81       	ld	r24, Y
}
    2d22:	df 91       	pop	r29
    2d24:	cf 91       	pop	r28
    2d26:	08 95       	ret

00002d28 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2d28:	21 e1       	ldi	r18, 0x11	; 17
    2d2a:	fc 01       	movw	r30, r24
    2d2c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2d2e:	31 97       	sbiw	r30, 0x01	; 1
    2d30:	32 e2       	ldi	r19, 0x22	; 34
    2d32:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2d34:	fc 01       	movw	r30, r24
    2d36:	32 97       	sbiw	r30, 0x02	; 2
    2d38:	a3 e3       	ldi	r26, 0x33	; 51
    2d3a:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	33 97       	sbiw	r30, 0x03	; 3
    2d40:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2d42:	fc 01       	movw	r30, r24
    2d44:	34 97       	sbiw	r30, 0x04	; 4
    2d46:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2d48:	fc 01       	movw	r30, r24
    2d4a:	35 97       	sbiw	r30, 0x05	; 5
    2d4c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2d4e:	fc 01       	movw	r30, r24
    2d50:	36 97       	sbiw	r30, 0x06	; 6
    2d52:	60 e8       	ldi	r22, 0x80	; 128
    2d54:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2d56:	fc 01       	movw	r30, r24
    2d58:	37 97       	sbiw	r30, 0x07	; 7
    2d5a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2d5c:	fc 01       	movw	r30, r24
    2d5e:	38 97       	sbiw	r30, 0x08	; 8
    2d60:	62 e0       	ldi	r22, 0x02	; 2
    2d62:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2d64:	fc 01       	movw	r30, r24
    2d66:	39 97       	sbiw	r30, 0x09	; 9
    2d68:	63 e0       	ldi	r22, 0x03	; 3
    2d6a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2d6c:	fc 01       	movw	r30, r24
    2d6e:	3a 97       	sbiw	r30, 0x0a	; 10
    2d70:	64 e0       	ldi	r22, 0x04	; 4
    2d72:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2d74:	fc 01       	movw	r30, r24
    2d76:	3b 97       	sbiw	r30, 0x0b	; 11
    2d78:	65 e0       	ldi	r22, 0x05	; 5
    2d7a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	3c 97       	sbiw	r30, 0x0c	; 12
    2d80:	66 e0       	ldi	r22, 0x06	; 6
    2d82:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2d84:	fc 01       	movw	r30, r24
    2d86:	3d 97       	sbiw	r30, 0x0d	; 13
    2d88:	67 e0       	ldi	r22, 0x07	; 7
    2d8a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2d8c:	fc 01       	movw	r30, r24
    2d8e:	3e 97       	sbiw	r30, 0x0e	; 14
    2d90:	68 e0       	ldi	r22, 0x08	; 8
    2d92:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2d94:	fc 01       	movw	r30, r24
    2d96:	3f 97       	sbiw	r30, 0x0f	; 15
    2d98:	69 e0       	ldi	r22, 0x09	; 9
    2d9a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2d9c:	fc 01       	movw	r30, r24
    2d9e:	70 97       	sbiw	r30, 0x10	; 16
    2da0:	60 e1       	ldi	r22, 0x10	; 16
    2da2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2da4:	fc 01       	movw	r30, r24
    2da6:	71 97       	sbiw	r30, 0x11	; 17
    2da8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2daa:	fc 01       	movw	r30, r24
    2dac:	72 97       	sbiw	r30, 0x12	; 18
    2dae:	22 e1       	ldi	r18, 0x12	; 18
    2db0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2db2:	fc 01       	movw	r30, r24
    2db4:	73 97       	sbiw	r30, 0x13	; 19
    2db6:	23 e1       	ldi	r18, 0x13	; 19
    2db8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2dba:	fc 01       	movw	r30, r24
    2dbc:	74 97       	sbiw	r30, 0x14	; 20
    2dbe:	24 e1       	ldi	r18, 0x14	; 20
    2dc0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2dc2:	fc 01       	movw	r30, r24
    2dc4:	75 97       	sbiw	r30, 0x15	; 21
    2dc6:	25 e1       	ldi	r18, 0x15	; 21
    2dc8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2dca:	fc 01       	movw	r30, r24
    2dcc:	76 97       	sbiw	r30, 0x16	; 22
    2dce:	26 e1       	ldi	r18, 0x16	; 22
    2dd0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2dd2:	fc 01       	movw	r30, r24
    2dd4:	77 97       	sbiw	r30, 0x17	; 23
    2dd6:	27 e1       	ldi	r18, 0x17	; 23
    2dd8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2dda:	fc 01       	movw	r30, r24
    2ddc:	78 97       	sbiw	r30, 0x18	; 24
    2dde:	28 e1       	ldi	r18, 0x18	; 24
    2de0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2de2:	fc 01       	movw	r30, r24
    2de4:	79 97       	sbiw	r30, 0x19	; 25
    2de6:	29 e1       	ldi	r18, 0x19	; 25
    2de8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2dea:	fc 01       	movw	r30, r24
    2dec:	7a 97       	sbiw	r30, 0x1a	; 26
    2dee:	20 e2       	ldi	r18, 0x20	; 32
    2df0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2df2:	fc 01       	movw	r30, r24
    2df4:	7b 97       	sbiw	r30, 0x1b	; 27
    2df6:	21 e2       	ldi	r18, 0x21	; 33
    2df8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2dfa:	fc 01       	movw	r30, r24
    2dfc:	7c 97       	sbiw	r30, 0x1c	; 28
    2dfe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2e00:	fc 01       	movw	r30, r24
    2e02:	7d 97       	sbiw	r30, 0x1d	; 29
    2e04:	23 e2       	ldi	r18, 0x23	; 35
    2e06:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2e08:	fc 01       	movw	r30, r24
    2e0a:	7e 97       	sbiw	r30, 0x1e	; 30
    2e0c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2e0e:	fc 01       	movw	r30, r24
    2e10:	7f 97       	sbiw	r30, 0x1f	; 31
    2e12:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2e14:	fc 01       	movw	r30, r24
    2e16:	b0 97       	sbiw	r30, 0x20	; 32
    2e18:	26 e2       	ldi	r18, 0x26	; 38
    2e1a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2e1c:	fc 01       	movw	r30, r24
    2e1e:	b1 97       	sbiw	r30, 0x21	; 33
    2e20:	27 e2       	ldi	r18, 0x27	; 39
    2e22:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2e24:	fc 01       	movw	r30, r24
    2e26:	b2 97       	sbiw	r30, 0x22	; 34
    2e28:	28 e2       	ldi	r18, 0x28	; 40
    2e2a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2e2c:	fc 01       	movw	r30, r24
    2e2e:	b3 97       	sbiw	r30, 0x23	; 35
    2e30:	29 e2       	ldi	r18, 0x29	; 41
    2e32:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2e34:	fc 01       	movw	r30, r24
    2e36:	b4 97       	sbiw	r30, 0x24	; 36
    2e38:	20 e3       	ldi	r18, 0x30	; 48
    2e3a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2e3c:	fc 01       	movw	r30, r24
    2e3e:	b5 97       	sbiw	r30, 0x25	; 37
    2e40:	21 e3       	ldi	r18, 0x31	; 49
    2e42:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2e44:	86 97       	sbiw	r24, 0x26	; 38
}
    2e46:	08 95       	ret

00002e48 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2e48:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    2e4a:	89 ef       	ldi	r24, 0xF9	; 249
    2e4c:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2e4e:	8b e0       	ldi	r24, 0x0B	; 11
    2e50:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2e52:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2e54:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    2e56:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2e58:	a0 91 17 05 	lds	r26, 0x0517
    2e5c:	b0 91 18 05 	lds	r27, 0x0518
    2e60:	cd 91       	ld	r28, X+
    2e62:	cd bf       	out	0x3d, r28	; 61
    2e64:	dd 91       	ld	r29, X+
    2e66:	de bf       	out	0x3e, r29	; 62
    2e68:	ff 91       	pop	r31
    2e6a:	ef 91       	pop	r30
    2e6c:	df 91       	pop	r29
    2e6e:	cf 91       	pop	r28
    2e70:	bf 91       	pop	r27
    2e72:	af 91       	pop	r26
    2e74:	9f 91       	pop	r25
    2e76:	8f 91       	pop	r24
    2e78:	7f 91       	pop	r23
    2e7a:	6f 91       	pop	r22
    2e7c:	5f 91       	pop	r21
    2e7e:	4f 91       	pop	r20
    2e80:	3f 91       	pop	r19
    2e82:	2f 91       	pop	r18
    2e84:	1f 91       	pop	r17
    2e86:	0f 91       	pop	r16
    2e88:	ff 90       	pop	r15
    2e8a:	ef 90       	pop	r14
    2e8c:	df 90       	pop	r13
    2e8e:	cf 90       	pop	r12
    2e90:	bf 90       	pop	r11
    2e92:	af 90       	pop	r10
    2e94:	9f 90       	pop	r9
    2e96:	8f 90       	pop	r8
    2e98:	7f 90       	pop	r7
    2e9a:	6f 90       	pop	r6
    2e9c:	5f 90       	pop	r5
    2e9e:	4f 90       	pop	r4
    2ea0:	3f 90       	pop	r3
    2ea2:	2f 90       	pop	r2
    2ea4:	1f 90       	pop	r1
    2ea6:	0f 90       	pop	r0
    2ea8:	0f be       	out	0x3f, r0	; 63
    2eaa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2eac:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2eae:	81 e0       	ldi	r24, 0x01	; 1
    2eb0:	08 95       	ret

00002eb2 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2eb2:	08 95       	ret

00002eb4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2eb4:	0f 92       	push	r0
    2eb6:	0f b6       	in	r0, 0x3f	; 63
    2eb8:	f8 94       	cli
    2eba:	0f 92       	push	r0
    2ebc:	1f 92       	push	r1
    2ebe:	11 24       	eor	r1, r1
    2ec0:	2f 92       	push	r2
    2ec2:	3f 92       	push	r3
    2ec4:	4f 92       	push	r4
    2ec6:	5f 92       	push	r5
    2ec8:	6f 92       	push	r6
    2eca:	7f 92       	push	r7
    2ecc:	8f 92       	push	r8
    2ece:	9f 92       	push	r9
    2ed0:	af 92       	push	r10
    2ed2:	bf 92       	push	r11
    2ed4:	cf 92       	push	r12
    2ed6:	df 92       	push	r13
    2ed8:	ef 92       	push	r14
    2eda:	ff 92       	push	r15
    2edc:	0f 93       	push	r16
    2ede:	1f 93       	push	r17
    2ee0:	2f 93       	push	r18
    2ee2:	3f 93       	push	r19
    2ee4:	4f 93       	push	r20
    2ee6:	5f 93       	push	r21
    2ee8:	6f 93       	push	r22
    2eea:	7f 93       	push	r23
    2eec:	8f 93       	push	r24
    2eee:	9f 93       	push	r25
    2ef0:	af 93       	push	r26
    2ef2:	bf 93       	push	r27
    2ef4:	cf 93       	push	r28
    2ef6:	df 93       	push	r29
    2ef8:	ef 93       	push	r30
    2efa:	ff 93       	push	r31
    2efc:	a0 91 17 05 	lds	r26, 0x0517
    2f00:	b0 91 18 05 	lds	r27, 0x0518
    2f04:	0d b6       	in	r0, 0x3d	; 61
    2f06:	0d 92       	st	X+, r0
    2f08:	0e b6       	in	r0, 0x3e	; 62
    2f0a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2f0c:	0e 94 4f 24 	call	0x489e	; 0x489e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2f10:	a0 91 17 05 	lds	r26, 0x0517
    2f14:	b0 91 18 05 	lds	r27, 0x0518
    2f18:	cd 91       	ld	r28, X+
    2f1a:	cd bf       	out	0x3d, r28	; 61
    2f1c:	dd 91       	ld	r29, X+
    2f1e:	de bf       	out	0x3e, r29	; 62
    2f20:	ff 91       	pop	r31
    2f22:	ef 91       	pop	r30
    2f24:	df 91       	pop	r29
    2f26:	cf 91       	pop	r28
    2f28:	bf 91       	pop	r27
    2f2a:	af 91       	pop	r26
    2f2c:	9f 91       	pop	r25
    2f2e:	8f 91       	pop	r24
    2f30:	7f 91       	pop	r23
    2f32:	6f 91       	pop	r22
    2f34:	5f 91       	pop	r21
    2f36:	4f 91       	pop	r20
    2f38:	3f 91       	pop	r19
    2f3a:	2f 91       	pop	r18
    2f3c:	1f 91       	pop	r17
    2f3e:	0f 91       	pop	r16
    2f40:	ff 90       	pop	r15
    2f42:	ef 90       	pop	r14
    2f44:	df 90       	pop	r13
    2f46:	cf 90       	pop	r12
    2f48:	bf 90       	pop	r11
    2f4a:	af 90       	pop	r10
    2f4c:	9f 90       	pop	r9
    2f4e:	8f 90       	pop	r8
    2f50:	7f 90       	pop	r7
    2f52:	6f 90       	pop	r6
    2f54:	5f 90       	pop	r5
    2f56:	4f 90       	pop	r4
    2f58:	3f 90       	pop	r3
    2f5a:	2f 90       	pop	r2
    2f5c:	1f 90       	pop	r1
    2f5e:	0f 90       	pop	r0
    2f60:	0f be       	out	0x3f, r0	; 63
    2f62:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2f64:	08 95       	ret

00002f66 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2f66:	0f 92       	push	r0
    2f68:	0f b6       	in	r0, 0x3f	; 63
    2f6a:	f8 94       	cli
    2f6c:	0f 92       	push	r0
    2f6e:	1f 92       	push	r1
    2f70:	11 24       	eor	r1, r1
    2f72:	2f 92       	push	r2
    2f74:	3f 92       	push	r3
    2f76:	4f 92       	push	r4
    2f78:	5f 92       	push	r5
    2f7a:	6f 92       	push	r6
    2f7c:	7f 92       	push	r7
    2f7e:	8f 92       	push	r8
    2f80:	9f 92       	push	r9
    2f82:	af 92       	push	r10
    2f84:	bf 92       	push	r11
    2f86:	cf 92       	push	r12
    2f88:	df 92       	push	r13
    2f8a:	ef 92       	push	r14
    2f8c:	ff 92       	push	r15
    2f8e:	0f 93       	push	r16
    2f90:	1f 93       	push	r17
    2f92:	2f 93       	push	r18
    2f94:	3f 93       	push	r19
    2f96:	4f 93       	push	r20
    2f98:	5f 93       	push	r21
    2f9a:	6f 93       	push	r22
    2f9c:	7f 93       	push	r23
    2f9e:	8f 93       	push	r24
    2fa0:	9f 93       	push	r25
    2fa2:	af 93       	push	r26
    2fa4:	bf 93       	push	r27
    2fa6:	cf 93       	push	r28
    2fa8:	df 93       	push	r29
    2faa:	ef 93       	push	r30
    2fac:	ff 93       	push	r31
    2fae:	a0 91 17 05 	lds	r26, 0x0517
    2fb2:	b0 91 18 05 	lds	r27, 0x0518
    2fb6:	0d b6       	in	r0, 0x3d	; 61
    2fb8:	0d 92       	st	X+, r0
    2fba:	0e b6       	in	r0, 0x3e	; 62
    2fbc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2fbe:	0e 94 fd 22 	call	0x45fa	; 0x45fa <xTaskIncrementTick>
    2fc2:	88 23       	and	r24, r24
    2fc4:	11 f0       	breq	.+4      	; 0x2fca <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2fc6:	0e 94 4f 24 	call	0x489e	; 0x489e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2fca:	a0 91 17 05 	lds	r26, 0x0517
    2fce:	b0 91 18 05 	lds	r27, 0x0518
    2fd2:	cd 91       	ld	r28, X+
    2fd4:	cd bf       	out	0x3d, r28	; 61
    2fd6:	dd 91       	ld	r29, X+
    2fd8:	de bf       	out	0x3e, r29	; 62
    2fda:	ff 91       	pop	r31
    2fdc:	ef 91       	pop	r30
    2fde:	df 91       	pop	r29
    2fe0:	cf 91       	pop	r28
    2fe2:	bf 91       	pop	r27
    2fe4:	af 91       	pop	r26
    2fe6:	9f 91       	pop	r25
    2fe8:	8f 91       	pop	r24
    2fea:	7f 91       	pop	r23
    2fec:	6f 91       	pop	r22
    2fee:	5f 91       	pop	r21
    2ff0:	4f 91       	pop	r20
    2ff2:	3f 91       	pop	r19
    2ff4:	2f 91       	pop	r18
    2ff6:	1f 91       	pop	r17
    2ff8:	0f 91       	pop	r16
    2ffa:	ff 90       	pop	r15
    2ffc:	ef 90       	pop	r14
    2ffe:	df 90       	pop	r13
    3000:	cf 90       	pop	r12
    3002:	bf 90       	pop	r11
    3004:	af 90       	pop	r10
    3006:	9f 90       	pop	r9
    3008:	8f 90       	pop	r8
    300a:	7f 90       	pop	r7
    300c:	6f 90       	pop	r6
    300e:	5f 90       	pop	r5
    3010:	4f 90       	pop	r4
    3012:	3f 90       	pop	r3
    3014:	2f 90       	pop	r2
    3016:	1f 90       	pop	r1
    3018:	0f 90       	pop	r0
    301a:	0f be       	out	0x3f, r0	; 63
    301c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    301e:	08 95       	ret

00003020 <SIG_OUTPUT_COMPARE1A>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3020:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3024:	18 95       	reti

00003026 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3026:	0f b6       	in	r0, 0x3f	; 63
    3028:	f8 94       	cli
    302a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    302c:	fc 01       	movw	r30, r24
    302e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3030:	0f 90       	pop	r0
    3032:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
    3034:	81 e0       	ldi	r24, 0x01	; 1
    3036:	91 11       	cpse	r25, r1
    3038:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    303a:	08 95       	ret

0000303c <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    303c:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    303e:	44 8d       	ldd	r20, Z+28	; 0x1c
    3040:	44 23       	and	r20, r20
    3042:	c1 f0       	breq	.+48     	; 0x3074 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3044:	26 81       	ldd	r18, Z+6	; 0x06
    3046:	37 81       	ldd	r19, Z+7	; 0x07
    3048:	24 0f       	add	r18, r20
    304a:	31 1d       	adc	r19, r1
    304c:	37 83       	std	Z+7, r19	; 0x07
    304e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3050:	a4 81       	ldd	r26, Z+4	; 0x04
    3052:	b5 81       	ldd	r27, Z+5	; 0x05
    3054:	2a 17       	cp	r18, r26
    3056:	3b 07       	cpc	r19, r27
    3058:	20 f0       	brcs	.+8      	; 0x3062 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    305a:	20 81       	ld	r18, Z
    305c:	31 81       	ldd	r19, Z+1	; 0x01
    305e:	37 83       	std	Z+7, r19	; 0x07
    3060:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3062:	36 81       	ldd	r19, Z+6	; 0x06
    3064:	27 81       	ldd	r18, Z+7	; 0x07
    3066:	86 2f       	mov	r24, r22
    3068:	97 2f       	mov	r25, r23
    306a:	63 2f       	mov	r22, r19
    306c:	72 2f       	mov	r23, r18
    306e:	50 e0       	ldi	r21, 0x00	; 0
    3070:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>
    3074:	08 95       	ret

00003076 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3076:	0f 93       	push	r16
    3078:	1f 93       	push	r17
    307a:	cf 93       	push	r28
    307c:	df 93       	push	r29
    307e:	ec 01       	movw	r28, r24
    3080:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3082:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3084:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3086:	44 23       	and	r20, r20
    3088:	b9 f1       	breq	.+110    	; 0x30f8 <prvCopyDataToQueue+0x82>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    308a:	11 23       	and	r17, r17
    308c:	b1 f4       	brne	.+44     	; 0x30ba <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    308e:	8a 81       	ldd	r24, Y+2	; 0x02
    3090:	9b 81       	ldd	r25, Y+3	; 0x03
    3092:	50 e0       	ldi	r21, 0x00	; 0
    3094:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3098:	2c 8d       	ldd	r18, Y+28	; 0x1c
    309a:	8a 81       	ldd	r24, Y+2	; 0x02
    309c:	9b 81       	ldd	r25, Y+3	; 0x03
    309e:	82 0f       	add	r24, r18
    30a0:	91 1d       	adc	r25, r1
    30a2:	9b 83       	std	Y+3, r25	; 0x03
    30a4:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    30a6:	2c 81       	ldd	r18, Y+4	; 0x04
    30a8:	3d 81       	ldd	r19, Y+5	; 0x05
    30aa:	82 17       	cp	r24, r18
    30ac:	93 07       	cpc	r25, r19
    30ae:	20 f1       	brcs	.+72     	; 0x30f8 <prvCopyDataToQueue+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    30b0:	88 81       	ld	r24, Y
    30b2:	99 81       	ldd	r25, Y+1	; 0x01
    30b4:	9b 83       	std	Y+3, r25	; 0x03
    30b6:	8a 83       	std	Y+2, r24	; 0x02
    30b8:	1f c0       	rjmp	.+62     	; 0x30f8 <prvCopyDataToQueue+0x82>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    30ba:	8e 81       	ldd	r24, Y+6	; 0x06
    30bc:	9f 81       	ldd	r25, Y+7	; 0x07
    30be:	50 e0       	ldi	r21, 0x00	; 0
    30c0:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    30c4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    30c6:	50 e0       	ldi	r21, 0x00	; 0
    30c8:	50 95       	com	r21
    30ca:	41 95       	neg	r20
    30cc:	5f 4f       	sbci	r21, 0xFF	; 255
    30ce:	8e 81       	ldd	r24, Y+6	; 0x06
    30d0:	9f 81       	ldd	r25, Y+7	; 0x07
    30d2:	84 0f       	add	r24, r20
    30d4:	95 1f       	adc	r25, r21
    30d6:	9f 83       	std	Y+7, r25	; 0x07
    30d8:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    30da:	28 81       	ld	r18, Y
    30dc:	39 81       	ldd	r19, Y+1	; 0x01
    30de:	82 17       	cp	r24, r18
    30e0:	93 07       	cpc	r25, r19
    30e2:	30 f4       	brcc	.+12     	; 0x30f0 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    30e4:	8c 81       	ldd	r24, Y+4	; 0x04
    30e6:	9d 81       	ldd	r25, Y+5	; 0x05
    30e8:	84 0f       	add	r24, r20
    30ea:	95 1f       	adc	r25, r21
    30ec:	9f 83       	std	Y+7, r25	; 0x07
    30ee:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    30f0:	12 30       	cpi	r17, 0x02	; 2
    30f2:	11 f4       	brne	.+4      	; 0x30f8 <prvCopyDataToQueue+0x82>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    30f4:	01 11       	cpse	r16, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    30f6:	01 50       	subi	r16, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    30f8:	0f 5f       	subi	r16, 0xFF	; 255
    30fa:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
    30fc:	80 e0       	ldi	r24, 0x00	; 0
    30fe:	df 91       	pop	r29
    3100:	cf 91       	pop	r28
    3102:	1f 91       	pop	r17
    3104:	0f 91       	pop	r16
    3106:	08 95       	ret

00003108 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3108:	ef 92       	push	r14
    310a:	ff 92       	push	r15
    310c:	0f 93       	push	r16
    310e:	1f 93       	push	r17
    3110:	cf 93       	push	r28
    3112:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3114:	0f b6       	in	r0, 0x3f	; 63
    3116:	f8 94       	cli
    3118:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    311a:	fc 01       	movw	r30, r24
    311c:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    311e:	1c 16       	cp	r1, r28
    3120:	cc f4       	brge	.+50     	; 0x3154 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3122:	81 89       	ldd	r24, Z+17	; 0x11
    3124:	88 23       	and	r24, r24
    3126:	31 f4       	brne	.+12     	; 0x3134 <prvUnlockQueue+0x2c>
    3128:	15 c0       	rjmp	.+42     	; 0x3154 <prvUnlockQueue+0x4c>
    312a:	f8 01       	movw	r30, r16
    312c:	81 89       	ldd	r24, Z+17	; 0x11
    312e:	88 23       	and	r24, r24
    3130:	41 f4       	brne	.+16     	; 0x3142 <prvUnlockQueue+0x3a>
    3132:	10 c0       	rjmp	.+32     	; 0x3154 <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3134:	0f 2e       	mov	r0, r31
    3136:	f1 e1       	ldi	r31, 0x11	; 17
    3138:	ef 2e       	mov	r14, r31
    313a:	ff 24       	eor	r15, r15
    313c:	f0 2d       	mov	r31, r0
    313e:	e0 0e       	add	r14, r16
    3140:	f1 1e       	adc	r15, r17
    3142:	c7 01       	movw	r24, r14
    3144:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3148:	88 23       	and	r24, r24
    314a:	11 f0       	breq	.+4      	; 0x3150 <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    314c:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3150:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3152:	59 f7       	brne	.-42     	; 0x312a <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3154:	8f ef       	ldi	r24, 0xFF	; 255
    3156:	f8 01       	movw	r30, r16
    3158:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    315a:	0f 90       	pop	r0
    315c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    315e:	0f b6       	in	r0, 0x3f	; 63
    3160:	f8 94       	cli
    3162:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3164:	f8 01       	movw	r30, r16
    3166:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3168:	1c 16       	cp	r1, r28
    316a:	c4 f4       	brge	.+48     	; 0x319c <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    316c:	80 85       	ldd	r24, Z+8	; 0x08
    316e:	88 23       	and	r24, r24
    3170:	31 f4       	brne	.+12     	; 0x317e <prvUnlockQueue+0x76>
    3172:	14 c0       	rjmp	.+40     	; 0x319c <prvUnlockQueue+0x94>
    3174:	f8 01       	movw	r30, r16
    3176:	80 85       	ldd	r24, Z+8	; 0x08
    3178:	88 23       	and	r24, r24
    317a:	39 f4       	brne	.+14     	; 0x318a <prvUnlockQueue+0x82>
    317c:	0f c0       	rjmp	.+30     	; 0x319c <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    317e:	ee 24       	eor	r14, r14
    3180:	ff 24       	eor	r15, r15
    3182:	68 94       	set
    3184:	e3 f8       	bld	r14, 3
    3186:	e0 0e       	add	r14, r16
    3188:	f1 1e       	adc	r15, r17
    318a:	c7 01       	movw	r24, r14
    318c:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3190:	88 23       	and	r24, r24
    3192:	11 f0       	breq	.+4      	; 0x3198 <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
    3194:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3198:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    319a:	61 f7       	brne	.-40     	; 0x3174 <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    319c:	8f ef       	ldi	r24, 0xFF	; 255
    319e:	f8 01       	movw	r30, r16
    31a0:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    31a2:	0f 90       	pop	r0
    31a4:	0f be       	out	0x3f, r0	; 63
}
    31a6:	cf 91       	pop	r28
    31a8:	1f 91       	pop	r17
    31aa:	0f 91       	pop	r16
    31ac:	ff 90       	pop	r15
    31ae:	ef 90       	pop	r14
    31b0:	08 95       	ret

000031b2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    31b2:	cf 93       	push	r28
    31b4:	df 93       	push	r29
    31b6:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    31b8:	0f b6       	in	r0, 0x3f	; 63
    31ba:	f8 94       	cli
    31bc:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    31be:	48 81       	ld	r20, Y
    31c0:	59 81       	ldd	r21, Y+1	; 0x01
    31c2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    31c4:	ec 8d       	ldd	r30, Y+28	; 0x1c
    31c6:	30 e0       	ldi	r19, 0x00	; 0
    31c8:	f0 e0       	ldi	r31, 0x00	; 0
    31ca:	2e 9f       	mul	r18, r30
    31cc:	c0 01       	movw	r24, r0
    31ce:	2f 9f       	mul	r18, r31
    31d0:	90 0d       	add	r25, r0
    31d2:	3e 9f       	mul	r19, r30
    31d4:	90 0d       	add	r25, r0
    31d6:	11 24       	eor	r1, r1
    31d8:	84 0f       	add	r24, r20
    31da:	95 1f       	adc	r25, r21
    31dc:	9d 83       	std	Y+5, r25	; 0x05
    31de:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    31e0:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    31e2:	5b 83       	std	Y+3, r21	; 0x03
    31e4:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    31e6:	c9 01       	movw	r24, r18
    31e8:	01 97       	sbiw	r24, 0x01	; 1
    31ea:	8e 9f       	mul	r24, r30
    31ec:	90 01       	movw	r18, r0
    31ee:	8f 9f       	mul	r24, r31
    31f0:	30 0d       	add	r19, r0
    31f2:	9e 9f       	mul	r25, r30
    31f4:	30 0d       	add	r19, r0
    31f6:	11 24       	eor	r1, r1
    31f8:	24 0f       	add	r18, r20
    31fa:	35 1f       	adc	r19, r21
    31fc:	3f 83       	std	Y+7, r19	; 0x07
    31fe:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    3200:	8f ef       	ldi	r24, 0xFF	; 255
    3202:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    3204:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3206:	66 23       	and	r22, r22
    3208:	61 f4       	brne	.+24     	; 0x3222 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    320a:	88 85       	ldd	r24, Y+8	; 0x08
    320c:	88 23       	and	r24, r24
    320e:	89 f0       	breq	.+34     	; 0x3232 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3210:	ce 01       	movw	r24, r28
    3212:	08 96       	adiw	r24, 0x08	; 8
    3214:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3218:	88 23       	and	r24, r24
    321a:	59 f0       	breq	.+22     	; 0x3232 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    321c:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    3220:	08 c0       	rjmp	.+16     	; 0x3232 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3222:	ce 01       	movw	r24, r28
    3224:	08 96       	adiw	r24, 0x08	; 8
    3226:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    322a:	ce 01       	movw	r24, r28
    322c:	41 96       	adiw	r24, 0x11	; 17
    322e:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3232:	0f 90       	pop	r0
    3234:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    3236:	81 e0       	ldi	r24, 0x01	; 1
    3238:	df 91       	pop	r29
    323a:	cf 91       	pop	r28
    323c:	08 95       	ret

0000323e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    323e:	0f 93       	push	r16
    3240:	1f 93       	push	r17
    3242:	cf 93       	push	r28
    3244:	df 93       	push	r29
    3246:	08 2f       	mov	r16, r24
    3248:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    324a:	66 23       	and	r22, r22
    324c:	21 f0       	breq	.+8      	; 0x3256 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    324e:	68 9f       	mul	r22, r24
    3250:	c0 01       	movw	r24, r0
    3252:	11 24       	eor	r1, r1
    3254:	02 c0       	rjmp	.+4      	; 0x325a <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    3256:	80 e0       	ldi	r24, 0x00	; 0
    3258:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    325a:	4f 96       	adiw	r24, 0x1f	; 31
    325c:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <pvPortMalloc>
    3260:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    3262:	00 97       	sbiw	r24, 0x00	; 0
    3264:	71 f0       	breq	.+28     	; 0x3282 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3266:	11 23       	and	r17, r17
    3268:	19 f4       	brne	.+6      	; 0x3270 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    326a:	99 83       	std	Y+1, r25	; 0x01
    326c:	88 83       	st	Y, r24
    326e:	03 c0       	rjmp	.+6      	; 0x3276 <xQueueGenericCreate+0x38>
		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3270:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3272:	99 83       	std	Y+1, r25	; 0x01
    3274:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    3276:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    3278:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    327a:	ce 01       	movw	r24, r28
    327c:	61 e0       	ldi	r22, 0x01	; 1
    327e:	0e 94 d9 18 	call	0x31b2	; 0x31b2 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    3282:	8c 2f       	mov	r24, r28
    3284:	9d 2f       	mov	r25, r29
    3286:	df 91       	pop	r29
    3288:	cf 91       	pop	r28
    328a:	1f 91       	pop	r17
    328c:	0f 91       	pop	r16
    328e:	08 95       	ret

00003290 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3290:	8f 92       	push	r8
    3292:	9f 92       	push	r9
    3294:	bf 92       	push	r11
    3296:	cf 92       	push	r12
    3298:	df 92       	push	r13
    329a:	ef 92       	push	r14
    329c:	ff 92       	push	r15
    329e:	0f 93       	push	r16
    32a0:	1f 93       	push	r17
    32a2:	cf 93       	push	r28
    32a4:	df 93       	push	r29
    32a6:	00 d0       	rcall	.+0      	; 0x32a8 <xQueueGenericSend+0x18>
    32a8:	00 d0       	rcall	.+0      	; 0x32aa <xQueueGenericSend+0x1a>
    32aa:	0f 92       	push	r0
    32ac:	cd b7       	in	r28, 0x3d	; 61
    32ae:	de b7       	in	r29, 0x3e	; 62
    32b0:	8c 01       	movw	r16, r24
    32b2:	4b 01       	movw	r8, r22
    32b4:	5d 83       	std	Y+5, r21	; 0x05
    32b6:	4c 83       	std	Y+4, r20	; 0x04
    32b8:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    32ba:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    32bc:	bb 24       	eor	r11, r11
    32be:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    32c0:	cc 24       	eor	r12, r12
    32c2:	dd 24       	eor	r13, r13
    32c4:	68 94       	set
    32c6:	c3 f8       	bld	r12, 3
    32c8:	c8 0e       	add	r12, r24
    32ca:	d9 1e       	adc	r13, r25
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    32cc:	0f b6       	in	r0, 0x3f	; 63
    32ce:	f8 94       	cli
    32d0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    32d2:	f8 01       	movw	r30, r16
    32d4:	92 8d       	ldd	r25, Z+26	; 0x1a
    32d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    32d8:	98 17       	cp	r25, r24
    32da:	18 f0       	brcs	.+6      	; 0x32e2 <xQueueGenericSend+0x52>
    32dc:	f2 e0       	ldi	r31, 0x02	; 2
    32de:	ef 16       	cp	r14, r31
    32e0:	d1 f4       	brne	.+52     	; 0x3316 <xQueueGenericSend+0x86>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    32e2:	c8 01       	movw	r24, r16
    32e4:	b4 01       	movw	r22, r8
    32e6:	4e 2d       	mov	r20, r14
    32e8:	0e 94 3b 18 	call	0x3076	; 0x3076 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32ec:	f8 01       	movw	r30, r16
    32ee:	91 89       	ldd	r25, Z+17	; 0x11
    32f0:	99 23       	and	r25, r25
    32f2:	49 f0       	breq	.+18     	; 0x3306 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32f4:	c8 01       	movw	r24, r16
    32f6:	41 96       	adiw	r24, 0x11	; 17
    32f8:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    32fc:	88 23       	and	r24, r24
    32fe:	39 f0       	breq	.+14     	; 0x330e <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    3300:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    3304:	04 c0       	rjmp	.+8      	; 0x330e <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3306:	88 23       	and	r24, r24
    3308:	11 f0       	breq	.+4      	; 0x330e <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    330a:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    330e:	0f 90       	pop	r0
    3310:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3312:	81 e0       	ldi	r24, 0x01	; 1
    3314:	52 c0       	rjmp	.+164    	; 0x33ba <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3316:	8c 81       	ldd	r24, Y+4	; 0x04
    3318:	9d 81       	ldd	r25, Y+5	; 0x05
    331a:	00 97       	sbiw	r24, 0x00	; 0
    331c:	21 f4       	brne	.+8      	; 0x3326 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    331e:	0f 90       	pop	r0
    3320:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3322:	80 e0       	ldi	r24, 0x00	; 0
    3324:	4a c0       	rjmp	.+148    	; 0x33ba <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    3326:	ff 20       	and	r15, r15
    3328:	29 f4       	brne	.+10     	; 0x3334 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    332a:	ce 01       	movw	r24, r28
    332c:	01 96       	adiw	r24, 0x01	; 1
    332e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3332:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3334:	0f 90       	pop	r0
    3336:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3338:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    333c:	0f b6       	in	r0, 0x3f	; 63
    333e:	f8 94       	cli
    3340:	0f 92       	push	r0
    3342:	f8 01       	movw	r30, r16
    3344:	85 8d       	ldd	r24, Z+29	; 0x1d
    3346:	8f 3f       	cpi	r24, 0xFF	; 255
    3348:	09 f4       	brne	.+2      	; 0x334c <xQueueGenericSend+0xbc>
    334a:	15 8e       	std	Z+29, r1	; 0x1d
    334c:	f8 01       	movw	r30, r16
    334e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3350:	8f 3f       	cpi	r24, 0xFF	; 255
    3352:	09 f4       	brne	.+2      	; 0x3356 <xQueueGenericSend+0xc6>
    3354:	16 8e       	std	Z+30, r1	; 0x1e
    3356:	0f 90       	pop	r0
    3358:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    335a:	ce 01       	movw	r24, r28
    335c:	01 96       	adiw	r24, 0x01	; 1
    335e:	be 01       	movw	r22, r28
    3360:	6c 5f       	subi	r22, 0xFC	; 252
    3362:	7f 4f       	sbci	r23, 0xFF	; 255
    3364:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskCheckForTimeOut>
    3368:	88 23       	and	r24, r24
    336a:	09 f5       	brne	.+66     	; 0x33ae <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    336c:	0f b6       	in	r0, 0x3f	; 63
    336e:	f8 94       	cli
    3370:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3372:	f8 01       	movw	r30, r16
    3374:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3376:	0f 90       	pop	r0
    3378:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    337a:	f8 01       	movw	r30, r16
    337c:	83 8d       	ldd	r24, Z+27	; 0x1b
    337e:	98 17       	cp	r25, r24
    3380:	81 f4       	brne	.+32     	; 0x33a2 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3382:	6c 81       	ldd	r22, Y+4	; 0x04
    3384:	7d 81       	ldd	r23, Y+5	; 0x05
    3386:	c6 01       	movw	r24, r12
    3388:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    338c:	c8 01       	movw	r24, r16
    338e:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3392:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    3396:	88 23       	and	r24, r24
    3398:	09 f0       	breq	.+2      	; 0x339c <xQueueGenericSend+0x10c>
    339a:	98 cf       	rjmp	.-208    	; 0x32cc <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    339c:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    33a0:	95 cf       	rjmp	.-214    	; 0x32cc <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    33a2:	c8 01       	movw	r24, r16
    33a4:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    33a8:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    33ac:	8f cf       	rjmp	.-226    	; 0x32cc <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    33ae:	c8 01       	movw	r24, r16
    33b0:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    33b4:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    33b8:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    33ba:	0f 90       	pop	r0
    33bc:	0f 90       	pop	r0
    33be:	0f 90       	pop	r0
    33c0:	0f 90       	pop	r0
    33c2:	0f 90       	pop	r0
    33c4:	df 91       	pop	r29
    33c6:	cf 91       	pop	r28
    33c8:	1f 91       	pop	r17
    33ca:	0f 91       	pop	r16
    33cc:	ff 90       	pop	r15
    33ce:	ef 90       	pop	r14
    33d0:	df 90       	pop	r13
    33d2:	cf 90       	pop	r12
    33d4:	bf 90       	pop	r11
    33d6:	9f 90       	pop	r9
    33d8:	8f 90       	pop	r8
    33da:	08 95       	ret

000033dc <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    33dc:	ef 92       	push	r14
    33de:	ff 92       	push	r15
    33e0:	0f 93       	push	r16
    33e2:	1f 93       	push	r17
    33e4:	cf 93       	push	r28
    33e6:	8c 01       	movw	r16, r24
    33e8:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    33ea:	fc 01       	movw	r30, r24
    33ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    33ee:	83 8d       	ldd	r24, Z+27	; 0x1b
    33f0:	98 17       	cp	r25, r24
    33f2:	10 f0       	brcs	.+4      	; 0x33f8 <xQueueGenericSendFromISR+0x1c>
    33f4:	22 30       	cpi	r18, 0x02	; 2
    33f6:	f1 f4       	brne	.+60     	; 0x3434 <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    33f8:	f8 01       	movw	r30, r16
    33fa:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    33fc:	c8 01       	movw	r24, r16
    33fe:	42 2f       	mov	r20, r18
    3400:	0e 94 3b 18 	call	0x3076	; 0x3076 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3404:	cf 3f       	cpi	r28, 0xFF	; 255
    3406:	89 f4       	brne	.+34     	; 0x342a <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3408:	f8 01       	movw	r30, r16
    340a:	81 89       	ldd	r24, Z+17	; 0x11
    340c:	88 23       	and	r24, r24
    340e:	a1 f0       	breq	.+40     	; 0x3438 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3410:	c8 01       	movw	r24, r16
    3412:	41 96       	adiw	r24, 0x11	; 17
    3414:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3418:	88 23       	and	r24, r24
    341a:	81 f0       	breq	.+32     	; 0x343c <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    341c:	e1 14       	cp	r14, r1
    341e:	f1 04       	cpc	r15, r1
    3420:	79 f0       	breq	.+30     	; 0x3440 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3422:	81 e0       	ldi	r24, 0x01	; 1
    3424:	f7 01       	movw	r30, r14
    3426:	80 83       	st	Z, r24
    3428:	0c c0       	rjmp	.+24     	; 0x3442 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    342a:	cf 5f       	subi	r28, 0xFF	; 255
    342c:	f8 01       	movw	r30, r16
    342e:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
    3430:	81 e0       	ldi	r24, 0x01	; 1
    3432:	07 c0       	rjmp	.+14     	; 0x3442 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3434:	80 e0       	ldi	r24, 0x00	; 0
    3436:	05 c0       	rjmp	.+10     	; 0x3442 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    3438:	81 e0       	ldi	r24, 0x01	; 1
    343a:	03 c0       	rjmp	.+6      	; 0x3442 <xQueueGenericSendFromISR+0x66>
    343c:	81 e0       	ldi	r24, 0x01	; 1
    343e:	01 c0       	rjmp	.+2      	; 0x3442 <xQueueGenericSendFromISR+0x66>
    3440:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3442:	cf 91       	pop	r28
    3444:	1f 91       	pop	r17
    3446:	0f 91       	pop	r16
    3448:	ff 90       	pop	r15
    344a:	ef 90       	pop	r14
    344c:	08 95       	ret

0000344e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    344e:	cf 93       	push	r28
    3450:	df 93       	push	r29
    3452:	fc 01       	movw	r30, r24
    3454:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3456:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    3458:	93 8d       	ldd	r25, Z+27	; 0x1b
    345a:	89 17       	cp	r24, r25
    345c:	b8 f4       	brcc	.+46     	; 0x348c <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    345e:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3460:	8f 5f       	subi	r24, 0xFF	; 255
    3462:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3464:	9f 3f       	cpi	r25, 0xFF	; 255
    3466:	71 f4       	brne	.+28     	; 0x3484 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3468:	81 89       	ldd	r24, Z+17	; 0x11
    346a:	88 23       	and	r24, r24
    346c:	89 f0       	breq	.+34     	; 0x3490 <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    346e:	cf 01       	movw	r24, r30
    3470:	41 96       	adiw	r24, 0x11	; 17
    3472:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3476:	88 23       	and	r24, r24
    3478:	69 f0       	breq	.+26     	; 0x3494 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    347a:	20 97       	sbiw	r28, 0x00	; 0
    347c:	69 f0       	breq	.+26     	; 0x3498 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    347e:	81 e0       	ldi	r24, 0x01	; 1
    3480:	88 83       	st	Y, r24
    3482:	0b c0       	rjmp	.+22     	; 0x349a <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3484:	9f 5f       	subi	r25, 0xFF	; 255
    3486:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    3488:	81 e0       	ldi	r24, 0x01	; 1
    348a:	07 c0       	rjmp	.+14     	; 0x349a <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    348c:	80 e0       	ldi	r24, 0x00	; 0
    348e:	05 c0       	rjmp	.+10     	; 0x349a <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    3490:	81 e0       	ldi	r24, 0x01	; 1
    3492:	03 c0       	rjmp	.+6      	; 0x349a <xQueueGiveFromISR+0x4c>
    3494:	81 e0       	ldi	r24, 0x01	; 1
    3496:	01 c0       	rjmp	.+2      	; 0x349a <xQueueGiveFromISR+0x4c>
    3498:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    349a:	df 91       	pop	r29
    349c:	cf 91       	pop	r28
    349e:	08 95       	ret

000034a0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    34a0:	8f 92       	push	r8
    34a2:	9f 92       	push	r9
    34a4:	af 92       	push	r10
    34a6:	bf 92       	push	r11
    34a8:	df 92       	push	r13
    34aa:	ef 92       	push	r14
    34ac:	ff 92       	push	r15
    34ae:	0f 93       	push	r16
    34b0:	1f 93       	push	r17
    34b2:	cf 93       	push	r28
    34b4:	df 93       	push	r29
    34b6:	00 d0       	rcall	.+0      	; 0x34b8 <xQueueReceive+0x18>
    34b8:	00 d0       	rcall	.+0      	; 0x34ba <xQueueReceive+0x1a>
    34ba:	0f 92       	push	r0
    34bc:	cd b7       	in	r28, 0x3d	; 61
    34be:	de b7       	in	r29, 0x3e	; 62
    34c0:	7c 01       	movw	r14, r24
    34c2:	4b 01       	movw	r8, r22
    34c4:	5d 83       	std	Y+5, r21	; 0x05
    34c6:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    34c8:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    34ca:	dd 24       	eor	r13, r13
    34cc:	d3 94       	inc	r13
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    34ce:	0f 2e       	mov	r0, r31
    34d0:	f1 e1       	ldi	r31, 0x11	; 17
    34d2:	af 2e       	mov	r10, r31
    34d4:	bb 24       	eor	r11, r11
    34d6:	f0 2d       	mov	r31, r0
    34d8:	a8 0e       	add	r10, r24
    34da:	b9 1e       	adc	r11, r25
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    34dc:	0f b6       	in	r0, 0x3f	; 63
    34de:	f8 94       	cli
    34e0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34e2:	f7 01       	movw	r30, r14
    34e4:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    34e6:	11 23       	and	r17, r17
    34e8:	b1 f0       	breq	.+44     	; 0x3516 <xQueueReceive+0x76>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    34ea:	c7 01       	movw	r24, r14
    34ec:	b4 01       	movw	r22, r8
    34ee:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    34f2:	11 50       	subi	r17, 0x01	; 1
    34f4:	f7 01       	movw	r30, r14
    34f6:	12 8f       	std	Z+26, r17	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    34f8:	80 85       	ldd	r24, Z+8	; 0x08
    34fa:	88 23       	and	r24, r24
    34fc:	41 f0       	breq	.+16     	; 0x350e <xQueueReceive+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    34fe:	c7 01       	movw	r24, r14
    3500:	08 96       	adiw	r24, 0x08	; 8
    3502:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3506:	88 23       	and	r24, r24
    3508:	11 f0       	breq	.+4      	; 0x350e <xQueueReceive+0x6e>
					{
						queueYIELD_IF_USING_PREEMPTION();
    350a:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    350e:	0f 90       	pop	r0
    3510:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3512:	81 e0       	ldi	r24, 0x01	; 1
    3514:	52 c0       	rjmp	.+164    	; 0x35ba <xQueueReceive+0x11a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3516:	8c 81       	ldd	r24, Y+4	; 0x04
    3518:	9d 81       	ldd	r25, Y+5	; 0x05
    351a:	00 97       	sbiw	r24, 0x00	; 0
    351c:	21 f4       	brne	.+8      	; 0x3526 <xQueueReceive+0x86>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    351e:	0f 90       	pop	r0
    3520:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3522:	80 e0       	ldi	r24, 0x00	; 0
    3524:	4a c0       	rjmp	.+148    	; 0x35ba <xQueueReceive+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    3526:	00 23       	and	r16, r16
    3528:	29 f4       	brne	.+10     	; 0x3534 <xQueueReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    352a:	ce 01       	movw	r24, r28
    352c:	01 96       	adiw	r24, 0x01	; 1
    352e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3532:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3534:	0f 90       	pop	r0
    3536:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3538:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    353c:	0f b6       	in	r0, 0x3f	; 63
    353e:	f8 94       	cli
    3540:	0f 92       	push	r0
    3542:	f7 01       	movw	r30, r14
    3544:	85 8d       	ldd	r24, Z+29	; 0x1d
    3546:	8f 3f       	cpi	r24, 0xFF	; 255
    3548:	09 f4       	brne	.+2      	; 0x354c <xQueueReceive+0xac>
    354a:	15 8e       	std	Z+29, r1	; 0x1d
    354c:	f7 01       	movw	r30, r14
    354e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3550:	8f 3f       	cpi	r24, 0xFF	; 255
    3552:	09 f4       	brne	.+2      	; 0x3556 <xQueueReceive+0xb6>
    3554:	16 8e       	std	Z+30, r1	; 0x1e
    3556:	0f 90       	pop	r0
    3558:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    355a:	ce 01       	movw	r24, r28
    355c:	01 96       	adiw	r24, 0x01	; 1
    355e:	be 01       	movw	r22, r28
    3560:	6c 5f       	subi	r22, 0xFC	; 252
    3562:	7f 4f       	sbci	r23, 0xFF	; 255
    3564:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskCheckForTimeOut>
    3568:	88 23       	and	r24, r24
    356a:	d9 f4       	brne	.+54     	; 0x35a2 <xQueueReceive+0x102>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    356c:	c7 01       	movw	r24, r14
    356e:	0e 94 13 18 	call	0x3026	; 0x3026 <prvIsQueueEmpty>
    3572:	88 23       	and	r24, r24
    3574:	81 f0       	breq	.+32     	; 0x3596 <xQueueReceive+0xf6>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3576:	6c 81       	ldd	r22, Y+4	; 0x04
    3578:	7d 81       	ldd	r23, Y+5	; 0x05
    357a:	c5 01       	movw	r24, r10
    357c:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3580:	c7 01       	movw	r24, r14
    3582:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3586:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    358a:	88 23       	and	r24, r24
    358c:	09 f0       	breq	.+2      	; 0x3590 <xQueueReceive+0xf0>
    358e:	a6 cf       	rjmp	.-180    	; 0x34dc <xQueueReceive+0x3c>
				{
					portYIELD_WITHIN_API();
    3590:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    3594:	a3 cf       	rjmp	.-186    	; 0x34dc <xQueueReceive+0x3c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    3596:	c7 01       	movw	r24, r14
    3598:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    359c:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    35a0:	9d cf       	rjmp	.-198    	; 0x34dc <xQueueReceive+0x3c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    35a2:	c7 01       	movw	r24, r14
    35a4:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    35a8:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    35ac:	c7 01       	movw	r24, r14
    35ae:	0e 94 13 18 	call	0x3026	; 0x3026 <prvIsQueueEmpty>
    35b2:	88 23       	and	r24, r24
    35b4:	09 f4       	brne	.+2      	; 0x35b8 <xQueueReceive+0x118>
    35b6:	92 cf       	rjmp	.-220    	; 0x34dc <xQueueReceive+0x3c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    35b8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    35ba:	0f 90       	pop	r0
    35bc:	0f 90       	pop	r0
    35be:	0f 90       	pop	r0
    35c0:	0f 90       	pop	r0
    35c2:	0f 90       	pop	r0
    35c4:	df 91       	pop	r29
    35c6:	cf 91       	pop	r28
    35c8:	1f 91       	pop	r17
    35ca:	0f 91       	pop	r16
    35cc:	ff 90       	pop	r15
    35ce:	ef 90       	pop	r14
    35d0:	df 90       	pop	r13
    35d2:	bf 90       	pop	r11
    35d4:	af 90       	pop	r10
    35d6:	9f 90       	pop	r9
    35d8:	8f 90       	pop	r8
    35da:	08 95       	ret

000035dc <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    35dc:	cf 92       	push	r12
    35de:	df 92       	push	r13
    35e0:	ef 92       	push	r14
    35e2:	ff 92       	push	r15
    35e4:	0f 93       	push	r16
    35e6:	1f 93       	push	r17
    35e8:	cf 93       	push	r28
    35ea:	df 93       	push	r29
    35ec:	00 d0       	rcall	.+0      	; 0x35ee <xQueueSemaphoreTake+0x12>
    35ee:	00 d0       	rcall	.+0      	; 0x35f0 <xQueueSemaphoreTake+0x14>
    35f0:	0f 92       	push	r0
    35f2:	cd b7       	in	r28, 0x3d	; 61
    35f4:	de b7       	in	r29, 0x3e	; 62
    35f6:	8c 01       	movw	r16, r24
    35f8:	7d 83       	std	Y+5, r23	; 0x05
    35fa:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    35fc:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    35fe:	ee 24       	eor	r14, r14
    3600:	e3 94       	inc	r14
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3602:	0f 2e       	mov	r0, r31
    3604:	f1 e1       	ldi	r31, 0x11	; 17
    3606:	cf 2e       	mov	r12, r31
    3608:	dd 24       	eor	r13, r13
    360a:	f0 2d       	mov	r31, r0
    360c:	c8 0e       	add	r12, r24
    360e:	d9 1e       	adc	r13, r25
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3610:	0f b6       	in	r0, 0x3f	; 63
    3612:	f8 94       	cli
    3614:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3616:	f8 01       	movw	r30, r16
    3618:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    361a:	88 23       	and	r24, r24
    361c:	89 f0       	breq	.+34     	; 0x3640 <xQueueSemaphoreTake+0x64>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    361e:	81 50       	subi	r24, 0x01	; 1
    3620:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3622:	80 85       	ldd	r24, Z+8	; 0x08
    3624:	88 23       	and	r24, r24
    3626:	41 f0       	breq	.+16     	; 0x3638 <xQueueSemaphoreTake+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3628:	c8 01       	movw	r24, r16
    362a:	08 96       	adiw	r24, 0x08	; 8
    362c:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3630:	88 23       	and	r24, r24
    3632:	11 f0       	breq	.+4      	; 0x3638 <xQueueSemaphoreTake+0x5c>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3634:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3638:	0f 90       	pop	r0
    363a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    363c:	81 e0       	ldi	r24, 0x01	; 1
    363e:	52 c0       	rjmp	.+164    	; 0x36e4 <xQueueSemaphoreTake+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3640:	8c 81       	ldd	r24, Y+4	; 0x04
    3642:	9d 81       	ldd	r25, Y+5	; 0x05
    3644:	00 97       	sbiw	r24, 0x00	; 0
    3646:	21 f4       	brne	.+8      	; 0x3650 <xQueueSemaphoreTake+0x74>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    3648:	0f 90       	pop	r0
    364a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    364c:	80 e0       	ldi	r24, 0x00	; 0
    364e:	4a c0       	rjmp	.+148    	; 0x36e4 <xQueueSemaphoreTake+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
    3650:	ff 20       	and	r15, r15
    3652:	29 f4       	brne	.+10     	; 0x365e <xQueueSemaphoreTake+0x82>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3654:	ce 01       	movw	r24, r28
    3656:	01 96       	adiw	r24, 0x01	; 1
    3658:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    365c:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    365e:	0f 90       	pop	r0
    3660:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    3662:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	0f 92       	push	r0
    366c:	f8 01       	movw	r30, r16
    366e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3670:	8f 3f       	cpi	r24, 0xFF	; 255
    3672:	09 f4       	brne	.+2      	; 0x3676 <xQueueSemaphoreTake+0x9a>
    3674:	15 8e       	std	Z+29, r1	; 0x1d
    3676:	f8 01       	movw	r30, r16
    3678:	86 8d       	ldd	r24, Z+30	; 0x1e
    367a:	8f 3f       	cpi	r24, 0xFF	; 255
    367c:	09 f4       	brne	.+2      	; 0x3680 <xQueueSemaphoreTake+0xa4>
    367e:	16 8e       	std	Z+30, r1	; 0x1e
    3680:	0f 90       	pop	r0
    3682:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3684:	ce 01       	movw	r24, r28
    3686:	01 96       	adiw	r24, 0x01	; 1
    3688:	be 01       	movw	r22, r28
    368a:	6c 5f       	subi	r22, 0xFC	; 252
    368c:	7f 4f       	sbci	r23, 0xFF	; 255
    368e:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskCheckForTimeOut>
    3692:	88 23       	and	r24, r24
    3694:	d9 f4       	brne	.+54     	; 0x36cc <xQueueSemaphoreTake+0xf0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3696:	c8 01       	movw	r24, r16
    3698:	0e 94 13 18 	call	0x3026	; 0x3026 <prvIsQueueEmpty>
    369c:	88 23       	and	r24, r24
    369e:	81 f0       	breq	.+32     	; 0x36c0 <xQueueSemaphoreTake+0xe4>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    36a0:	6c 81       	ldd	r22, Y+4	; 0x04
    36a2:	7d 81       	ldd	r23, Y+5	; 0x05
    36a4:	c6 01       	movw	r24, r12
    36a6:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    36aa:	c8 01       	movw	r24, r16
    36ac:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    36b0:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    36b4:	88 23       	and	r24, r24
    36b6:	09 f0       	breq	.+2      	; 0x36ba <xQueueSemaphoreTake+0xde>
    36b8:	ab cf       	rjmp	.-170    	; 0x3610 <xQueueSemaphoreTake+0x34>
				{
					portYIELD_WITHIN_API();
    36ba:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    36be:	a8 cf       	rjmp	.-176    	; 0x3610 <xQueueSemaphoreTake+0x34>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    36c0:	c8 01       	movw	r24, r16
    36c2:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    36c6:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    36ca:	a2 cf       	rjmp	.-188    	; 0x3610 <xQueueSemaphoreTake+0x34>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    36cc:	c8 01       	movw	r24, r16
    36ce:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    36d2:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    36d6:	c8 01       	movw	r24, r16
    36d8:	0e 94 13 18 	call	0x3026	; 0x3026 <prvIsQueueEmpty>
    36dc:	88 23       	and	r24, r24
    36de:	09 f4       	brne	.+2      	; 0x36e2 <xQueueSemaphoreTake+0x106>
    36e0:	97 cf       	rjmp	.-210    	; 0x3610 <xQueueSemaphoreTake+0x34>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    36e2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    36e4:	0f 90       	pop	r0
    36e6:	0f 90       	pop	r0
    36e8:	0f 90       	pop	r0
    36ea:	0f 90       	pop	r0
    36ec:	0f 90       	pop	r0
    36ee:	df 91       	pop	r29
    36f0:	cf 91       	pop	r28
    36f2:	1f 91       	pop	r17
    36f4:	0f 91       	pop	r16
    36f6:	ff 90       	pop	r15
    36f8:	ef 90       	pop	r14
    36fa:	df 90       	pop	r13
    36fc:	cf 90       	pop	r12
    36fe:	08 95       	ret

00003700 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3700:	af 92       	push	r10
    3702:	bf 92       	push	r11
    3704:	cf 92       	push	r12
    3706:	df 92       	push	r13
    3708:	ef 92       	push	r14
    370a:	ff 92       	push	r15
    370c:	0f 93       	push	r16
    370e:	1f 93       	push	r17
    3710:	cf 93       	push	r28
    3712:	df 93       	push	r29
    3714:	00 d0       	rcall	.+0      	; 0x3716 <xQueuePeek+0x16>
    3716:	00 d0       	rcall	.+0      	; 0x3718 <xQueuePeek+0x18>
    3718:	0f 92       	push	r0
    371a:	cd b7       	in	r28, 0x3d	; 61
    371c:	de b7       	in	r29, 0x3e	; 62
    371e:	8c 01       	movw	r16, r24
    3720:	5b 01       	movw	r10, r22
    3722:	5d 83       	std	Y+5, r21	; 0x05
    3724:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    3726:	ff 24       	eor	r15, r15
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3728:	ee 24       	eor	r14, r14
    372a:	e3 94       	inc	r14
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    372c:	0f 2e       	mov	r0, r31
    372e:	f1 e1       	ldi	r31, 0x11	; 17
    3730:	cf 2e       	mov	r12, r31
    3732:	dd 24       	eor	r13, r13
    3734:	f0 2d       	mov	r31, r0
    3736:	c8 0e       	add	r12, r24
    3738:	d9 1e       	adc	r13, r25
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    373a:	0f b6       	in	r0, 0x3f	; 63
    373c:	f8 94       	cli
    373e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3740:	f8 01       	movw	r30, r16
    3742:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3744:	88 23       	and	r24, r24
    3746:	c1 f0       	breq	.+48     	; 0x3778 <xQueuePeek+0x78>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3748:	e6 80       	ldd	r14, Z+6	; 0x06
    374a:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    374c:	c8 01       	movw	r24, r16
    374e:	b5 01       	movw	r22, r10
    3750:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3754:	f8 01       	movw	r30, r16
    3756:	f7 82       	std	Z+7, r15	; 0x07
    3758:	e6 82       	std	Z+6, r14	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    375a:	81 89       	ldd	r24, Z+17	; 0x11
    375c:	88 23       	and	r24, r24
    375e:	41 f0       	breq	.+16     	; 0x3770 <xQueuePeek+0x70>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3760:	c8 01       	movw	r24, r16
    3762:	41 96       	adiw	r24, 0x11	; 17
    3764:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3768:	88 23       	and	r24, r24
    376a:	11 f0       	breq	.+4      	; 0x3770 <xQueuePeek+0x70>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    376c:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3770:	0f 90       	pop	r0
    3772:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3774:	81 e0       	ldi	r24, 0x01	; 1
    3776:	52 c0       	rjmp	.+164    	; 0x381c <xQueuePeek+0x11c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3778:	8c 81       	ldd	r24, Y+4	; 0x04
    377a:	9d 81       	ldd	r25, Y+5	; 0x05
    377c:	00 97       	sbiw	r24, 0x00	; 0
    377e:	21 f4       	brne	.+8      	; 0x3788 <xQueuePeek+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3780:	0f 90       	pop	r0
    3782:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3784:	80 e0       	ldi	r24, 0x00	; 0
    3786:	4a c0       	rjmp	.+148    	; 0x381c <xQueuePeek+0x11c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3788:	ff 20       	and	r15, r15
    378a:	29 f4       	brne	.+10     	; 0x3796 <xQueuePeek+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    378c:	ce 01       	movw	r24, r28
    378e:	01 96       	adiw	r24, 0x01	; 1
    3790:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3794:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3796:	0f 90       	pop	r0
    3798:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    379a:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    379e:	0f b6       	in	r0, 0x3f	; 63
    37a0:	f8 94       	cli
    37a2:	0f 92       	push	r0
    37a4:	f8 01       	movw	r30, r16
    37a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    37a8:	8f 3f       	cpi	r24, 0xFF	; 255
    37aa:	09 f4       	brne	.+2      	; 0x37ae <xQueuePeek+0xae>
    37ac:	15 8e       	std	Z+29, r1	; 0x1d
    37ae:	f8 01       	movw	r30, r16
    37b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    37b2:	8f 3f       	cpi	r24, 0xFF	; 255
    37b4:	09 f4       	brne	.+2      	; 0x37b8 <xQueuePeek+0xb8>
    37b6:	16 8e       	std	Z+30, r1	; 0x1e
    37b8:	0f 90       	pop	r0
    37ba:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    37bc:	ce 01       	movw	r24, r28
    37be:	01 96       	adiw	r24, 0x01	; 1
    37c0:	be 01       	movw	r22, r28
    37c2:	6c 5f       	subi	r22, 0xFC	; 252
    37c4:	7f 4f       	sbci	r23, 0xFF	; 255
    37c6:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskCheckForTimeOut>
    37ca:	88 23       	and	r24, r24
    37cc:	d9 f4       	brne	.+54     	; 0x3804 <xQueuePeek+0x104>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37ce:	c8 01       	movw	r24, r16
    37d0:	0e 94 13 18 	call	0x3026	; 0x3026 <prvIsQueueEmpty>
    37d4:	88 23       	and	r24, r24
    37d6:	81 f0       	breq	.+32     	; 0x37f8 <xQueuePeek+0xf8>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    37d8:	6c 81       	ldd	r22, Y+4	; 0x04
    37da:	7d 81       	ldd	r23, Y+5	; 0x05
    37dc:	c6 01       	movw	r24, r12
    37de:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    37e2:	c8 01       	movw	r24, r16
    37e4:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    37e8:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    37ec:	88 23       	and	r24, r24
    37ee:	09 f0       	breq	.+2      	; 0x37f2 <xQueuePeek+0xf2>
    37f0:	a4 cf       	rjmp	.-184    	; 0x373a <xQueuePeek+0x3a>
				{
					portYIELD_WITHIN_API();
    37f2:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    37f6:	a1 cf       	rjmp	.-190    	; 0x373a <xQueuePeek+0x3a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    37f8:	c8 01       	movw	r24, r16
    37fa:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    37fe:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    3802:	9b cf       	rjmp	.-202    	; 0x373a <xQueuePeek+0x3a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    3804:	c8 01       	movw	r24, r16
    3806:	0e 94 84 18 	call	0x3108	; 0x3108 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    380a:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    380e:	c8 01       	movw	r24, r16
    3810:	0e 94 13 18 	call	0x3026	; 0x3026 <prvIsQueueEmpty>
    3814:	88 23       	and	r24, r24
    3816:	09 f4       	brne	.+2      	; 0x381a <xQueuePeek+0x11a>
    3818:	90 cf       	rjmp	.-224    	; 0x373a <xQueuePeek+0x3a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    381a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    381c:	0f 90       	pop	r0
    381e:	0f 90       	pop	r0
    3820:	0f 90       	pop	r0
    3822:	0f 90       	pop	r0
    3824:	0f 90       	pop	r0
    3826:	df 91       	pop	r29
    3828:	cf 91       	pop	r28
    382a:	1f 91       	pop	r17
    382c:	0f 91       	pop	r16
    382e:	ff 90       	pop	r15
    3830:	ef 90       	pop	r14
    3832:	df 90       	pop	r13
    3834:	cf 90       	pop	r12
    3836:	bf 90       	pop	r11
    3838:	af 90       	pop	r10
    383a:	08 95       	ret

0000383c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    383c:	ef 92       	push	r14
    383e:	ff 92       	push	r15
    3840:	0f 93       	push	r16
    3842:	1f 93       	push	r17
    3844:	cf 93       	push	r28
    3846:	df 93       	push	r29
    3848:	8c 01       	movw	r16, r24
    384a:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    384c:	fc 01       	movw	r30, r24
    384e:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3850:	cc 23       	and	r28, r28
    3852:	e9 f0       	breq	.+58     	; 0x388e <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    3854:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3856:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    385a:	c1 50       	subi	r28, 0x01	; 1
    385c:	f8 01       	movw	r30, r16
    385e:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3860:	df 3f       	cpi	r29, 0xFF	; 255
    3862:	81 f4       	brne	.+32     	; 0x3884 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3864:	80 85       	ldd	r24, Z+8	; 0x08
    3866:	88 23       	and	r24, r24
    3868:	a1 f0       	breq	.+40     	; 0x3892 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    386a:	c8 01       	movw	r24, r16
    386c:	08 96       	adiw	r24, 0x08	; 8
    386e:	0e 94 d6 24 	call	0x49ac	; 0x49ac <xTaskRemoveFromEventList>
    3872:	88 23       	and	r24, r24
    3874:	81 f0       	breq	.+32     	; 0x3896 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3876:	e1 14       	cp	r14, r1
    3878:	f1 04       	cpc	r15, r1
    387a:	79 f0       	breq	.+30     	; 0x389a <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    387c:	81 e0       	ldi	r24, 0x01	; 1
    387e:	f7 01       	movw	r30, r14
    3880:	80 83       	st	Z, r24
    3882:	0c c0       	rjmp	.+24     	; 0x389c <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3884:	df 5f       	subi	r29, 0xFF	; 255
    3886:	f8 01       	movw	r30, r16
    3888:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    388a:	81 e0       	ldi	r24, 0x01	; 1
    388c:	07 c0       	rjmp	.+14     	; 0x389c <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    388e:	80 e0       	ldi	r24, 0x00	; 0
    3890:	05 c0       	rjmp	.+10     	; 0x389c <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	03 c0       	rjmp	.+6      	; 0x389c <xQueueReceiveFromISR+0x60>
    3896:	81 e0       	ldi	r24, 0x01	; 1
    3898:	01 c0       	rjmp	.+2      	; 0x389c <xQueueReceiveFromISR+0x60>
    389a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    389c:	df 91       	pop	r29
    389e:	cf 91       	pop	r28
    38a0:	1f 91       	pop	r17
    38a2:	0f 91       	pop	r16
    38a4:	ff 90       	pop	r15
    38a6:	ef 90       	pop	r14
    38a8:	08 95       	ret

000038aa <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    38aa:	0f 93       	push	r16
    38ac:	1f 93       	push	r17
    38ae:	cf 93       	push	r28
    38b0:	df 93       	push	r29
    38b2:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    38b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    38b6:	88 23       	and	r24, r24
    38b8:	49 f0       	breq	.+18     	; 0x38cc <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    38ba:	0e 81       	ldd	r16, Y+6	; 0x06
    38bc:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    38be:	ce 01       	movw	r24, r28
    38c0:	0e 94 1e 18 	call	0x303c	; 0x303c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    38c4:	1f 83       	std	Y+7, r17	; 0x07
    38c6:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    38c8:	81 e0       	ldi	r24, 0x01	; 1
    38ca:	01 c0       	rjmp	.+2      	; 0x38ce <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    38cc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    38ce:	df 91       	pop	r29
    38d0:	cf 91       	pop	r28
    38d2:	1f 91       	pop	r17
    38d4:	0f 91       	pop	r16
    38d6:	08 95       	ret

000038d8 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    38d8:	0f b6       	in	r0, 0x3f	; 63
    38da:	f8 94       	cli
    38dc:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    38de:	fc 01       	movw	r30, r24
    38e0:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    38e2:	0f 90       	pop	r0
    38e4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    38e6:	08 95       	ret

000038e8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    38e8:	fc 01       	movw	r30, r24
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    38ea:	0f b6       	in	r0, 0x3f	; 63
    38ec:	f8 94       	cli
    38ee:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    38f0:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    38f2:	0f 90       	pop	r0
    38f4:	0f be       	out	0x3f, r0	; 63

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    38f6:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    38f8:	89 1b       	sub	r24, r25
    38fa:	08 95       	ret

000038fc <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    38fc:	fc 01       	movw	r30, r24
    38fe:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3900:	08 95       	ret

00003902 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3902:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3906:	08 95       	ret

00003908 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3908:	fc 01       	movw	r30, r24
    390a:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    390c:	81 e0       	ldi	r24, 0x01	; 1
    390e:	91 11       	cpse	r25, r1
    3910:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3912:	08 95       	ret

00003914 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3914:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3916:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    3918:	81 e0       	ldi	r24, 0x01	; 1
    391a:	93 8d       	ldd	r25, Z+27	; 0x1b
    391c:	29 13       	cpse	r18, r25
    391e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3920:	08 95       	ret

00003922 <prvBytesInBuffer>:
	return xCount;
}
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3922:	fc 01       	movw	r30, r24
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3924:	24 81       	ldd	r18, Z+4	; 0x04
    3926:	35 81       	ldd	r19, Z+5	; 0x05
    3928:	82 81       	ldd	r24, Z+2	; 0x02
    392a:	93 81       	ldd	r25, Z+3	; 0x03
    392c:	82 0f       	add	r24, r18
    392e:	93 1f       	adc	r25, r19
	xCount -= pxStreamBuffer->xTail;
    3930:	40 81       	ld	r20, Z
    3932:	51 81       	ldd	r21, Z+1	; 0x01
    3934:	84 1b       	sub	r24, r20
    3936:	95 0b       	sbc	r25, r21
	if ( xCount >= pxStreamBuffer->xLength )
    3938:	82 17       	cp	r24, r18
    393a:	93 07       	cpc	r25, r19
    393c:	10 f0       	brcs	.+4      	; 0x3942 <prvBytesInBuffer+0x20>
	{
		xCount -= pxStreamBuffer->xLength;
    393e:	82 1b       	sub	r24, r18
    3940:	93 0b       	sbc	r25, r19
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
}
    3942:	08 95       	ret

00003944 <prvReadBytesFromBuffer>:
	return xCount;
}
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    3944:	af 92       	push	r10
    3946:	bf 92       	push	r11
    3948:	cf 92       	push	r12
    394a:	df 92       	push	r13
    394c:	ef 92       	push	r14
    394e:	ff 92       	push	r15
    3950:	0f 93       	push	r16
    3952:	1f 93       	push	r17
    3954:	cf 93       	push	r28
    3956:	df 93       	push	r29
    3958:	8c 01       	movw	r16, r24
    395a:	6b 01       	movw	r12, r22
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    395c:	c2 2f       	mov	r28, r18
    395e:	d3 2f       	mov	r29, r19
    3960:	4c 17       	cp	r20, r28
    3962:	5d 07       	cpc	r21, r29
    3964:	08 f4       	brcc	.+2      	; 0x3968 <prvReadBytesFromBuffer+0x24>
    3966:	ea 01       	movw	r28, r20

	if( xCount > ( size_t ) 0 )
    3968:	20 97       	sbiw	r28, 0x00	; 0
    396a:	99 f1       	breq	.+102    	; 0x39d2 <prvReadBytesFromBuffer+0x8e>
	{
		xNextTail = pxStreamBuffer->xTail;
    396c:	f8 01       	movw	r30, r16
    396e:	a0 80       	ld	r10, Z
    3970:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3972:	84 81       	ldd	r24, Z+4	; 0x04
    3974:	95 81       	ldd	r25, Z+5	; 0x05
    3976:	8a 19       	sub	r24, r10
    3978:	9b 09       	sbc	r25, r11
    397a:	7e 01       	movw	r14, r28
    397c:	8c 17       	cp	r24, r28
    397e:	9d 07       	cpc	r25, r29
    3980:	08 f4       	brcc	.+2      	; 0x3984 <prvReadBytesFromBuffer+0x40>
    3982:	7c 01       	movw	r14, r24

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3984:	f8 01       	movw	r30, r16
    3986:	64 85       	ldd	r22, Z+12	; 0x0c
    3988:	75 85       	ldd	r23, Z+13	; 0x0d
    398a:	6a 0d       	add	r22, r10
    398c:	7b 1d       	adc	r23, r11
    398e:	8c 2d       	mov	r24, r12
    3990:	9d 2d       	mov	r25, r13
    3992:	4e 2d       	mov	r20, r14
    3994:	5f 2d       	mov	r21, r15
    3996:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    399a:	ec 16       	cp	r14, r28
    399c:	fd 06       	cpc	r15, r29
    399e:	58 f4       	brcc	.+22     	; 0x39b6 <prvReadBytesFromBuffer+0x72>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    39a0:	c6 01       	movw	r24, r12
    39a2:	8e 0d       	add	r24, r14
    39a4:	9f 1d       	adc	r25, r15
    39a6:	ae 01       	movw	r20, r28
    39a8:	4e 19       	sub	r20, r14
    39aa:	5f 09       	sbc	r21, r15
    39ac:	f8 01       	movw	r30, r16
    39ae:	64 85       	ldd	r22, Z+12	; 0x0c
    39b0:	75 85       	ldd	r23, Z+13	; 0x0d
    39b2:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    39b6:	ce 01       	movw	r24, r28
    39b8:	8a 0d       	add	r24, r10
    39ba:	9b 1d       	adc	r25, r11

		if( xNextTail >= pxStreamBuffer->xLength )
    39bc:	f8 01       	movw	r30, r16
    39be:	24 81       	ldd	r18, Z+4	; 0x04
    39c0:	35 81       	ldd	r19, Z+5	; 0x05
    39c2:	82 17       	cp	r24, r18
    39c4:	93 07       	cpc	r25, r19
    39c6:	10 f0       	brcs	.+4      	; 0x39cc <prvReadBytesFromBuffer+0x88>
		{
			xNextTail -= pxStreamBuffer->xLength;
    39c8:	82 1b       	sub	r24, r18
    39ca:	93 0b       	sbc	r25, r19
		}

		pxStreamBuffer->xTail = xNextTail;
    39cc:	f8 01       	movw	r30, r16
    39ce:	91 83       	std	Z+1, r25	; 0x01
    39d0:	80 83       	st	Z, r24
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
}
    39d2:	8c 2f       	mov	r24, r28
    39d4:	9d 2f       	mov	r25, r29
    39d6:	df 91       	pop	r29
    39d8:	cf 91       	pop	r28
    39da:	1f 91       	pop	r17
    39dc:	0f 91       	pop	r16
    39de:	ff 90       	pop	r15
    39e0:	ef 90       	pop	r14
    39e2:	df 90       	pop	r13
    39e4:	cf 90       	pop	r12
    39e6:	bf 90       	pop	r11
    39e8:	af 90       	pop	r10
    39ea:	08 95       	ret

000039ec <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    39ec:	6f 92       	push	r6
    39ee:	7f 92       	push	r7
    39f0:	8f 92       	push	r8
    39f2:	9f 92       	push	r9
    39f4:	af 92       	push	r10
    39f6:	bf 92       	push	r11
    39f8:	cf 92       	push	r12
    39fa:	df 92       	push	r13
    39fc:	ef 92       	push	r14
    39fe:	ff 92       	push	r15
    3a00:	0f 93       	push	r16
    3a02:	1f 93       	push	r17
    3a04:	cf 93       	push	r28
    3a06:	df 93       	push	r29
    3a08:	00 d0       	rcall	.+0      	; 0x3a0a <prvReadMessageFromBuffer+0x1e>
    3a0a:	cd b7       	in	r28, 0x3d	; 61
    3a0c:	de b7       	in	r29, 0x3e	; 62
    3a0e:	5c 01       	movw	r10, r24
    3a10:	4b 01       	movw	r8, r22
    3a12:	7a 01       	movw	r14, r20
    3a14:	69 01       	movw	r12, r18
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3a16:	01 15       	cp	r16, r1
    3a18:	11 05       	cpc	r17, r1
    3a1a:	a9 f0       	breq	.+42     	; 0x3a46 <prvReadMessageFromBuffer+0x5a>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3a1c:	fc 01       	movw	r30, r24
    3a1e:	60 80       	ld	r6, Z
    3a20:	71 80       	ldd	r7, Z+1	; 0x01
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    3a22:	be 01       	movw	r22, r28
    3a24:	6f 5f       	subi	r22, 0xFF	; 255
    3a26:	7f 4f       	sbci	r23, 0xFF	; 255
    3a28:	a8 01       	movw	r20, r16
    3a2a:	0e 94 a2 1c 	call	0x3944	; 0x3944 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3a2e:	49 81       	ldd	r20, Y+1	; 0x01
    3a30:	5a 81       	ldd	r21, Y+2	; 0x02

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3a32:	c0 1a       	sub	r12, r16
    3a34:	d1 0a       	sbc	r13, r17

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    3a36:	e4 16       	cp	r14, r20
    3a38:	f5 06       	cpc	r15, r21
    3a3a:	28 f4       	brcc	.+10     	; 0x3a46 <prvReadMessageFromBuffer+0x5a>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    3a3c:	f5 01       	movw	r30, r10
    3a3e:	71 82       	std	Z+1, r7	; 0x01
    3a40:	60 82       	st	Z, r6
			xNextMessageLength = 0;
    3a42:	40 e0       	ldi	r20, 0x00	; 0
    3a44:	50 e0       	ldi	r21, 0x00	; 0
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3a46:	c5 01       	movw	r24, r10
    3a48:	b4 01       	movw	r22, r8
    3a4a:	96 01       	movw	r18, r12
    3a4c:	0e 94 a2 1c 	call	0x3944	; 0x3944 <prvReadBytesFromBuffer>

	return xReceivedLength;
}
    3a50:	0f 90       	pop	r0
    3a52:	0f 90       	pop	r0
    3a54:	df 91       	pop	r29
    3a56:	cf 91       	pop	r28
    3a58:	1f 91       	pop	r17
    3a5a:	0f 91       	pop	r16
    3a5c:	ff 90       	pop	r15
    3a5e:	ef 90       	pop	r14
    3a60:	df 90       	pop	r13
    3a62:	cf 90       	pop	r12
    3a64:	bf 90       	pop	r11
    3a66:	af 90       	pop	r10
    3a68:	9f 90       	pop	r9
    3a6a:	8f 90       	pop	r8
    3a6c:	7f 90       	pop	r7
    3a6e:	6f 90       	pop	r6
    3a70:	08 95       	ret

00003a72 <prvWriteBytesToBuffer>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3a72:	af 92       	push	r10
    3a74:	bf 92       	push	r11
    3a76:	cf 92       	push	r12
    3a78:	df 92       	push	r13
    3a7a:	ef 92       	push	r14
    3a7c:	ff 92       	push	r15
    3a7e:	0f 93       	push	r16
    3a80:	1f 93       	push	r17
    3a82:	cf 93       	push	r28
    3a84:	df 93       	push	r29
    3a86:	ec 01       	movw	r28, r24
    3a88:	5b 01       	movw	r10, r22
    3a8a:	8a 01       	movw	r16, r20
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3a8c:	ca 80       	ldd	r12, Y+2	; 0x02
    3a8e:	db 80       	ldd	r13, Y+3	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3a90:	8c 81       	ldd	r24, Y+4	; 0x04
    3a92:	9d 81       	ldd	r25, Y+5	; 0x05
    3a94:	8c 19       	sub	r24, r12
    3a96:	9d 09       	sbc	r25, r13
    3a98:	7a 01       	movw	r14, r20
    3a9a:	84 17       	cp	r24, r20
    3a9c:	95 07       	cpc	r25, r21
    3a9e:	08 f4       	brcc	.+2      	; 0x3aa2 <prvWriteBytesToBuffer+0x30>
    3aa0:	7c 01       	movw	r14, r24

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3aa2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3aa4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3aa6:	8c 0d       	add	r24, r12
    3aa8:	9d 1d       	adc	r25, r13
    3aaa:	6a 2d       	mov	r22, r10
    3aac:	7b 2d       	mov	r23, r11
    3aae:	4e 2d       	mov	r20, r14
    3ab0:	5f 2d       	mov	r21, r15
    3ab2:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3ab6:	e0 16       	cp	r14, r16
    3ab8:	f1 06       	cpc	r15, r17
    3aba:	50 f4       	brcc	.+20     	; 0x3ad0 <prvWriteBytesToBuffer+0x5e>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3abc:	a8 01       	movw	r20, r16
    3abe:	4e 19       	sub	r20, r14
    3ac0:	5f 09       	sbc	r21, r15
    3ac2:	b5 01       	movw	r22, r10
    3ac4:	6e 0d       	add	r22, r14
    3ac6:	7f 1d       	adc	r23, r15
    3ac8:	8c 85       	ldd	r24, Y+12	; 0x0c
    3aca:	9d 85       	ldd	r25, Y+13	; 0x0d
    3acc:	0e 94 df 2a 	call	0x55be	; 0x55be <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3ad0:	c8 01       	movw	r24, r16
    3ad2:	8c 0d       	add	r24, r12
    3ad4:	9d 1d       	adc	r25, r13
	if( xNextHead >= pxStreamBuffer->xLength )
    3ad6:	2c 81       	ldd	r18, Y+4	; 0x04
    3ad8:	3d 81       	ldd	r19, Y+5	; 0x05
    3ada:	82 17       	cp	r24, r18
    3adc:	93 07       	cpc	r25, r19
    3ade:	10 f0       	brcs	.+4      	; 0x3ae4 <prvWriteBytesToBuffer+0x72>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3ae0:	82 1b       	sub	r24, r18
    3ae2:	93 0b       	sbc	r25, r19
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    3ae4:	9b 83       	std	Y+3, r25	; 0x03
    3ae6:	8a 83       	std	Y+2, r24	; 0x02

	return xCount;
}
    3ae8:	80 2f       	mov	r24, r16
    3aea:	91 2f       	mov	r25, r17
    3aec:	df 91       	pop	r29
    3aee:	cf 91       	pop	r28
    3af0:	1f 91       	pop	r17
    3af2:	0f 91       	pop	r16
    3af4:	ff 90       	pop	r15
    3af6:	ef 90       	pop	r14
    3af8:	df 90       	pop	r13
    3afa:	cf 90       	pop	r12
    3afc:	bf 90       	pop	r11
    3afe:	af 90       	pop	r10
    3b00:	08 95       	ret

00003b02 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3b02:	cf 92       	push	r12
    3b04:	df 92       	push	r13
    3b06:	ef 92       	push	r14
    3b08:	ff 92       	push	r15
    3b0a:	0f 93       	push	r16
    3b0c:	1f 93       	push	r17
    3b0e:	cf 93       	push	r28
    3b10:	df 93       	push	r29
    3b12:	00 d0       	rcall	.+0      	; 0x3b14 <prvWriteMessageToBuffer+0x12>
    3b14:	cd b7       	in	r28, 0x3d	; 61
    3b16:	de b7       	in	r29, 0x3e	; 62
    3b18:	7c 01       	movw	r14, r24
    3b1a:	6b 01       	movw	r12, r22
    3b1c:	5a 83       	std	Y+2, r21	; 0x02
    3b1e:	49 83       	std	Y+1, r20	; 0x01
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    3b20:	21 15       	cp	r18, r1
    3b22:	31 05       	cpc	r19, r1
    3b24:	b9 f0       	breq	.+46     	; 0x3b54 <prvWriteMessageToBuffer+0x52>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3b26:	fc 01       	movw	r30, r24
    3b28:	86 85       	ldd	r24, Z+14	; 0x0e
    3b2a:	80 fd       	sbrc	r24, 0
    3b2c:	07 c0       	rjmp	.+14     	; 0x3b3c <prvWriteMessageToBuffer+0x3a>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3b2e:	42 17       	cp	r20, r18
    3b30:	53 07       	cpc	r21, r19
    3b32:	08 f4       	brcc	.+2      	; 0x3b36 <prvWriteMessageToBuffer+0x34>
    3b34:	9a 01       	movw	r18, r20
    3b36:	3a 83       	std	Y+2, r19	; 0x02
    3b38:	29 83       	std	Y+1, r18	; 0x01
    3b3a:	1c c0       	rjmp	.+56     	; 0x3b74 <prvWriteMessageToBuffer+0x72>
	}
	else if( xSpace >= xRequiredSpace )
    3b3c:	20 17       	cp	r18, r16
    3b3e:	31 07       	cpc	r19, r17
    3b40:	60 f0       	brcs	.+24     	; 0x3b5a <prvWriteMessageToBuffer+0x58>
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3b42:	c7 01       	movw	r24, r14
    3b44:	be 01       	movw	r22, r28
    3b46:	6f 5f       	subi	r22, 0xFF	; 255
    3b48:	7f 4f       	sbci	r23, 0xFF	; 255
    3b4a:	42 e0       	ldi	r20, 0x02	; 2
    3b4c:	50 e0       	ldi	r21, 0x00	; 0
    3b4e:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <prvWriteBytesToBuffer>
    3b52:	10 c0       	rjmp	.+32     	; 0x3b74 <prvWriteMessageToBuffer+0x72>
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
	}
	else
	{
		xReturn = 0;
    3b54:	80 e0       	ldi	r24, 0x00	; 0
    3b56:	90 e0       	ldi	r25, 0x00	; 0
    3b58:	02 c0       	rjmp	.+4      	; 0x3b5e <prvWriteMessageToBuffer+0x5c>
    3b5a:	80 e0       	ldi	r24, 0x00	; 0
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
	}

	return xReturn;
}
    3b5e:	0f 90       	pop	r0
    3b60:	0f 90       	pop	r0
    3b62:	df 91       	pop	r29
    3b64:	cf 91       	pop	r28
    3b66:	1f 91       	pop	r17
    3b68:	0f 91       	pop	r16
    3b6a:	ff 90       	pop	r15
    3b6c:	ef 90       	pop	r14
    3b6e:	df 90       	pop	r13
    3b70:	cf 90       	pop	r12
    3b72:	08 95       	ret
	}

	if( xShouldWrite != pdFALSE )
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3b74:	49 81       	ldd	r20, Y+1	; 0x01
    3b76:	5a 81       	ldd	r21, Y+2	; 0x02
    3b78:	c7 01       	movw	r24, r14
    3b7a:	b6 01       	movw	r22, r12
    3b7c:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <prvWriteBytesToBuffer>
    3b80:	ee cf       	rjmp	.-36     	; 0x3b5e <prvWriteMessageToBuffer+0x5c>

00003b82 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3b82:	0f 93       	push	r16
    3b84:	fc 01       	movw	r30, r24
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3b86:	8f e0       	ldi	r24, 0x0F	; 15
    3b88:	df 01       	movw	r26, r30
    3b8a:	1d 92       	st	X+, r1
    3b8c:	8a 95       	dec	r24
    3b8e:	e9 f7       	brne	.-6      	; 0x3b8a <prvInitialiseNewStreamBuffer+0x8>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3b90:	75 87       	std	Z+13, r23	; 0x0d
    3b92:	64 87       	std	Z+12, r22	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3b94:	55 83       	std	Z+5, r21	; 0x05
    3b96:	44 83       	std	Z+4, r20	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3b98:	37 83       	std	Z+7, r19	; 0x07
    3b9a:	26 83       	std	Z+6, r18	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3b9c:	06 87       	std	Z+14, r16	; 0x0e
}
    3b9e:	0f 91       	pop	r16
    3ba0:	08 95       	ret

00003ba2 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    3ba2:	df 92       	push	r13
    3ba4:	ef 92       	push	r14
    3ba6:	ff 92       	push	r15
    3ba8:	0f 93       	push	r16
    3baa:	1f 93       	push	r17
    3bac:	cf 93       	push	r28
    3bae:	df 93       	push	r29
    3bb0:	8c 01       	movw	r16, r24
    3bb2:	7b 01       	movw	r14, r22
    3bb4:	d4 2e       	mov	r13, r20
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3bb6:	61 15       	cp	r22, r1
    3bb8:	71 05       	cpc	r23, r1
    3bba:	19 f4       	brne	.+6      	; 0x3bc2 <xStreamBufferGenericCreate+0x20>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3bbc:	ee 24       	eor	r14, r14
    3bbe:	ff 24       	eor	r15, r15
    3bc0:	e3 94       	inc	r14
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    3bc2:	c8 01       	movw	r24, r16
    3bc4:	40 96       	adiw	r24, 0x10	; 16
    3bc6:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <pvPortMalloc>
    3bca:	ec 01       	movw	r28, r24

		if( pucAllocatedMemory != NULL )
    3bcc:	00 97       	sbiw	r24, 0x00	; 0
    3bce:	69 f0       	breq	.+26     	; 0x3bea <xStreamBufferGenericCreate+0x48>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3bd0:	bc 01       	movw	r22, r24
    3bd2:	61 5f       	subi	r22, 0xF1	; 241
    3bd4:	7f 4f       	sbci	r23, 0xFF	; 255
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3bd6:	a8 01       	movw	r20, r16
    3bd8:	4f 5f       	subi	r20, 0xFF	; 255
    3bda:	5f 4f       	sbci	r21, 0xFF	; 255
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3bdc:	01 e0       	ldi	r16, 0x01	; 1
    3bde:	d0 12       	cpse	r13, r16
    3be0:	00 e0       	ldi	r16, 0x00	; 0
		xBufferSizeBytes++;
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */

		if( pucAllocatedMemory != NULL )
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3be2:	ce 01       	movw	r24, r28
    3be4:	97 01       	movw	r18, r14
    3be6:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <prvInitialiseNewStreamBuffer>
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
	}
    3bea:	8c 2f       	mov	r24, r28
    3bec:	9d 2f       	mov	r25, r29
    3bee:	df 91       	pop	r29
    3bf0:	cf 91       	pop	r28
    3bf2:	1f 91       	pop	r17
    3bf4:	0f 91       	pop	r16
    3bf6:	ff 90       	pop	r15
    3bf8:	ef 90       	pop	r14
    3bfa:	df 90       	pop	r13
    3bfc:	08 95       	ret

00003bfe <vStreamBufferDelete>:

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    3bfe:	fc 01       	movw	r30, r24
    3c00:	26 85       	ldd	r18, Z+14	; 0x0e
    3c02:	21 fd       	sbrc	r18, 1
    3c04:	03 c0       	rjmp	.+6      	; 0x3c0c <vStreamBufferDelete+0xe>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    3c06:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <vPortFree>
    3c0a:	08 95       	ret
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3c0c:	2f e0       	ldi	r18, 0x0F	; 15
    3c0e:	fc 01       	movw	r30, r24
    3c10:	11 92       	st	Z+, r1
    3c12:	2a 95       	dec	r18
    3c14:	e9 f7       	brne	.-6      	; 0x3c10 <vStreamBufferDelete+0x12>
    3c16:	08 95       	ret

00003c18 <xStreamBufferReset>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3c18:	0f 93       	push	r16
    3c1a:	fc 01       	movw	r30, r24
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3c1c:	0f b6       	in	r0, 0x3f	; 63
    3c1e:	f8 94       	cli
    3c20:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3c22:	80 85       	ldd	r24, Z+8	; 0x08
    3c24:	91 85       	ldd	r25, Z+9	; 0x09
    3c26:	00 97       	sbiw	r24, 0x00	; 0
    3c28:	81 f4       	brne	.+32     	; 0x3c4a <xStreamBufferReset+0x32>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3c2a:	82 85       	ldd	r24, Z+10	; 0x0a
    3c2c:	93 85       	ldd	r25, Z+11	; 0x0b
    3c2e:	00 97       	sbiw	r24, 0x00	; 0
    3c30:	71 f4       	brne	.+28     	; 0x3c4e <xStreamBufferReset+0x36>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3c32:	64 85       	ldd	r22, Z+12	; 0x0c
    3c34:	75 85       	ldd	r23, Z+13	; 0x0d
    3c36:	44 81       	ldd	r20, Z+4	; 0x04
    3c38:	55 81       	ldd	r21, Z+5	; 0x05
    3c3a:	26 81       	ldd	r18, Z+6	; 0x06
    3c3c:	37 81       	ldd	r19, Z+7	; 0x07
    3c3e:	cf 01       	movw	r24, r30
    3c40:	06 85       	ldd	r16, Z+14	; 0x0e
    3c42:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3c46:	81 e0       	ldi	r24, 0x01	; 1
    3c48:	03 c0       	rjmp	.+6      	; 0x3c50 <xStreamBufferReset+0x38>
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
BaseType_t xReturn = pdFAIL;
    3c4a:	80 e0       	ldi	r24, 0x00	; 0
    3c4c:	01 c0       	rjmp	.+2      	; 0x3c50 <xStreamBufferReset+0x38>
    3c4e:	80 e0       	ldi	r24, 0x00	; 0

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3c50:	0f 90       	pop	r0
    3c52:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3c54:	0f 91       	pop	r16
    3c56:	08 95       	ret

00003c58 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    3c58:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3c5a:	61 15       	cp	r22, r1
    3c5c:	71 05       	cpc	r23, r1
    3c5e:	11 f4       	brne	.+4      	; 0x3c64 <xStreamBufferSetTriggerLevel+0xc>
	{
		xTriggerLevel = ( size_t ) 1;
    3c60:	61 e0       	ldi	r22, 0x01	; 1
    3c62:	70 e0       	ldi	r23, 0x00	; 0
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    3c64:	84 81       	ldd	r24, Z+4	; 0x04
    3c66:	95 81       	ldd	r25, Z+5	; 0x05
    3c68:	86 17       	cp	r24, r22
    3c6a:	97 07       	cpc	r25, r23
    3c6c:	20 f0       	brcs	.+8      	; 0x3c76 <xStreamBufferSetTriggerLevel+0x1e>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3c6e:	77 83       	std	Z+7, r23	; 0x07
    3c70:	66 83       	std	Z+6, r22	; 0x06
		xReturn = pdPASS;
    3c72:	81 e0       	ldi	r24, 0x01	; 1
    3c74:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    3c76:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    3c78:	08 95       	ret

00003c7a <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3c7a:	fc 01       	movw	r30, r24
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3c7c:	24 81       	ldd	r18, Z+4	; 0x04
    3c7e:	35 81       	ldd	r19, Z+5	; 0x05
    3c80:	40 81       	ld	r20, Z
    3c82:	51 81       	ldd	r21, Z+1	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3c84:	62 81       	ldd	r22, Z+2	; 0x02
    3c86:	73 81       	ldd	r23, Z+3	; 0x03
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3c88:	c9 01       	movw	r24, r18
    3c8a:	84 0f       	add	r24, r20
    3c8c:	95 1f       	adc	r25, r21
	xSpace -= pxStreamBuffer->xHead;
    3c8e:	01 97       	sbiw	r24, 0x01	; 1
	xSpace -= ( size_t ) 1;
    3c90:	86 1b       	sub	r24, r22
    3c92:	97 0b       	sbc	r25, r23

	if( xSpace >= pxStreamBuffer->xLength )
    3c94:	82 17       	cp	r24, r18
    3c96:	93 07       	cpc	r25, r19
    3c98:	10 f0       	brcs	.+4      	; 0x3c9e <xStreamBufferSpacesAvailable+0x24>
	{
		xSpace -= pxStreamBuffer->xLength;
    3c9a:	82 1b       	sub	r24, r18
    3c9c:	93 0b       	sbc	r25, r19
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
}
    3c9e:	08 95       	ret

00003ca0 <xStreamBufferBytesAvailable>:
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3ca0:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
	return xReturn;
}
    3ca4:	08 95       	ret

00003ca6 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3ca6:	4f 92       	push	r4
    3ca8:	5f 92       	push	r5
    3caa:	6f 92       	push	r6
    3cac:	7f 92       	push	r7
    3cae:	8f 92       	push	r8
    3cb0:	9f 92       	push	r9
    3cb2:	af 92       	push	r10
    3cb4:	bf 92       	push	r11
    3cb6:	cf 92       	push	r12
    3cb8:	df 92       	push	r13
    3cba:	ef 92       	push	r14
    3cbc:	ff 92       	push	r15
    3cbe:	0f 93       	push	r16
    3cc0:	1f 93       	push	r17
    3cc2:	cf 93       	push	r28
    3cc4:	df 93       	push	r29
    3cc6:	00 d0       	rcall	.+0      	; 0x3cc8 <xStreamBufferSend+0x22>
    3cc8:	00 d0       	rcall	.+0      	; 0x3cca <xStreamBufferSend+0x24>
    3cca:	0f 92       	push	r0
    3ccc:	cd b7       	in	r28, 0x3d	; 61
    3cce:	de b7       	in	r29, 0x3e	; 62
    3cd0:	6c 01       	movw	r12, r24
    3cd2:	2b 01       	movw	r4, r22
    3cd4:	3a 01       	movw	r6, r20
    3cd6:	3d 83       	std	Y+5, r19	; 0x05
    3cd8:	2c 83       	std	Y+4, r18	; 0x04

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3cda:	fc 01       	movw	r30, r24
    3cdc:	86 85       	ldd	r24, Z+14	; 0x0e
    3cde:	80 ff       	sbrs	r24, 0
    3ce0:	07 c0       	rjmp	.+14     	; 0x3cf0 <xStreamBufferSend+0x4a>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3ce2:	88 24       	eor	r8, r8
    3ce4:	99 24       	eor	r9, r9
    3ce6:	68 94       	set
    3ce8:	81 f8       	bld	r8, 1
    3cea:	84 0e       	add	r8, r20
    3cec:	95 1e       	adc	r9, r21
    3cee:	01 c0       	rjmp	.+2      	; 0x3cf2 <xStreamBufferSend+0x4c>
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn, xSpace = 0;
size_t xRequiredSpace = xDataLengthBytes;
    3cf0:	4a 01       	movw	r8, r20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3cf2:	8c 81       	ldd	r24, Y+4	; 0x04
    3cf4:	9d 81       	ldd	r25, Y+5	; 0x05
    3cf6:	00 97       	sbiw	r24, 0x00	; 0
    3cf8:	b9 f1       	breq	.+110    	; 0x3d68 <xStreamBufferSend+0xc2>
	{
		vTaskSetTimeOutState( &xTimeOut );
    3cfa:	ce 01       	movw	r24, r28
    3cfc:	01 96       	adiw	r24, 0x01	; 1
    3cfe:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3d02:	0f b6       	in	r0, 0x3f	; 63
    3d04:	f8 94       	cli
    3d06:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3d08:	c6 01       	movw	r24, r12
    3d0a:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <xStreamBufferSpacesAvailable>
    3d0e:	5c 01       	movw	r10, r24

				if( xSpace < xRequiredSpace )
    3d10:	88 15       	cp	r24, r8
    3d12:	99 05       	cpc	r25, r9
    3d14:	28 f5       	brcc	.+74     	; 0x3d60 <xStreamBufferSend+0xba>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3d16:	80 e0       	ldi	r24, 0x00	; 0
    3d18:	90 e0       	ldi	r25, 0x00	; 0
    3d1a:	0e 94 00 28 	call	0x5000	; 0x5000 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3d1e:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <xTaskGetCurrentTaskHandle>
    3d22:	f6 01       	movw	r30, r12
    3d24:	93 87       	std	Z+11, r25	; 0x0b
    3d26:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3d28:	0f 90       	pop	r0
    3d2a:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3d2c:	ec 80       	ldd	r14, Y+4	; 0x04
    3d2e:	fd 80       	ldd	r15, Y+5	; 0x05
    3d30:	60 e0       	ldi	r22, 0x00	; 0
    3d32:	70 e0       	ldi	r23, 0x00	; 0
    3d34:	cb 01       	movw	r24, r22
    3d36:	20 e0       	ldi	r18, 0x00	; 0
    3d38:	30 e0       	ldi	r19, 0x00	; 0
    3d3a:	a9 01       	movw	r20, r18
    3d3c:	00 e0       	ldi	r16, 0x00	; 0
    3d3e:	10 e0       	ldi	r17, 0x00	; 0
    3d40:	0e 94 1d 26 	call	0x4c3a	; 0x4c3a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3d44:	f6 01       	movw	r30, r12
    3d46:	13 86       	std	Z+11, r1	; 0x0b
    3d48:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3d4a:	ce 01       	movw	r24, r28
    3d4c:	01 96       	adiw	r24, 0x01	; 1
    3d4e:	be 01       	movw	r22, r28
    3d50:	6c 5f       	subi	r22, 0xFC	; 252
    3d52:	7f 4f       	sbci	r23, 0xFF	; 255
    3d54:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <xTaskCheckForTimeOut>
    3d58:	88 23       	and	r24, r24
    3d5a:	99 f2       	breq	.-90     	; 0x3d02 <xStreamBufferSend+0x5c>
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3d5c:	c5 01       	movw	r24, r10
    3d5e:	02 c0       	rjmp	.+4      	; 0x3d64 <xStreamBufferSend+0xbe>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3d60:	0f 90       	pop	r0
    3d62:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3d64:	00 97       	sbiw	r24, 0x00	; 0
    3d66:	21 f4       	brne	.+8      	; 0x3d70 <xStreamBufferSend+0xca>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3d68:	c6 01       	movw	r24, r12
    3d6a:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <xStreamBufferSpacesAvailable>
    3d6e:	5c 01       	movw	r10, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3d70:	c6 01       	movw	r24, r12
    3d72:	b2 01       	movw	r22, r4
    3d74:	a3 01       	movw	r20, r6
    3d76:	95 01       	movw	r18, r10
    3d78:	84 01       	movw	r16, r8
    3d7a:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <prvWriteMessageToBuffer>
    3d7e:	7c 01       	movw	r14, r24

	if( xReturn > ( size_t ) 0 )
    3d80:	00 97       	sbiw	r24, 0x00	; 0
    3d82:	f9 f0       	breq	.+62     	; 0x3dc2 <xStreamBufferSend+0x11c>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3d84:	c6 01       	movw	r24, r12
    3d86:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    3d8a:	f6 01       	movw	r30, r12
    3d8c:	26 81       	ldd	r18, Z+6	; 0x06
    3d8e:	37 81       	ldd	r19, Z+7	; 0x07
    3d90:	82 17       	cp	r24, r18
    3d92:	93 07       	cpc	r25, r19
    3d94:	b0 f0       	brcs	.+44     	; 0x3dc2 <xStreamBufferSend+0x11c>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3d96:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
    3d9a:	f6 01       	movw	r30, r12
    3d9c:	80 85       	ldd	r24, Z+8	; 0x08
    3d9e:	91 85       	ldd	r25, Z+9	; 0x09
    3da0:	00 97       	sbiw	r24, 0x00	; 0
    3da2:	69 f0       	breq	.+26     	; 0x3dbe <xStreamBufferSend+0x118>
    3da4:	80 85       	ldd	r24, Z+8	; 0x08
    3da6:	91 85       	ldd	r25, Z+9	; 0x09
    3da8:	40 e0       	ldi	r20, 0x00	; 0
    3daa:	50 e0       	ldi	r21, 0x00	; 0
    3dac:	ba 01       	movw	r22, r20
    3dae:	20 e0       	ldi	r18, 0x00	; 0
    3db0:	00 e0       	ldi	r16, 0x00	; 0
    3db2:	10 e0       	ldi	r17, 0x00	; 0
    3db4:	0e 94 99 26 	call	0x4d32	; 0x4d32 <xTaskGenericNotify>
    3db8:	f6 01       	movw	r30, r12
    3dba:	11 86       	std	Z+9, r1	; 0x09
    3dbc:	10 86       	std	Z+8, r1	; 0x08
    3dbe:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
}
    3dc2:	8e 2d       	mov	r24, r14
    3dc4:	9f 2d       	mov	r25, r15
    3dc6:	0f 90       	pop	r0
    3dc8:	0f 90       	pop	r0
    3dca:	0f 90       	pop	r0
    3dcc:	0f 90       	pop	r0
    3dce:	0f 90       	pop	r0
    3dd0:	df 91       	pop	r29
    3dd2:	cf 91       	pop	r28
    3dd4:	1f 91       	pop	r17
    3dd6:	0f 91       	pop	r16
    3dd8:	ff 90       	pop	r15
    3dda:	ef 90       	pop	r14
    3ddc:	df 90       	pop	r13
    3dde:	cf 90       	pop	r12
    3de0:	bf 90       	pop	r11
    3de2:	af 90       	pop	r10
    3de4:	9f 90       	pop	r9
    3de6:	8f 90       	pop	r8
    3de8:	7f 90       	pop	r7
    3dea:	6f 90       	pop	r6
    3dec:	5f 90       	pop	r5
    3dee:	4f 90       	pop	r4
    3df0:	08 95       	ret

00003df2 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3df2:	af 92       	push	r10
    3df4:	bf 92       	push	r11
    3df6:	cf 92       	push	r12
    3df8:	df 92       	push	r13
    3dfa:	ef 92       	push	r14
    3dfc:	ff 92       	push	r15
    3dfe:	0f 93       	push	r16
    3e00:	1f 93       	push	r17
    3e02:	cf 93       	push	r28
    3e04:	df 93       	push	r29
    3e06:	ec 01       	movw	r28, r24
    3e08:	6b 01       	movw	r12, r22
    3e0a:	7a 01       	movw	r14, r20
    3e0c:	59 01       	movw	r10, r18

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e10:	80 ff       	sbrs	r24, 0
    3e12:	04 c0       	rjmp	.+8      	; 0x3e1c <xStreamBufferSendFromISR+0x2a>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3e14:	8a 01       	movw	r16, r20
    3e16:	0e 5f       	subi	r16, 0xFE	; 254
    3e18:	1f 4f       	sbci	r17, 0xFF	; 255
    3e1a:	01 c0       	rjmp	.+2      	; 0x3e1e <xStreamBufferSendFromISR+0x2c>
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3e1c:	8a 01       	movw	r16, r20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3e1e:	ce 01       	movw	r24, r28
    3e20:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <xStreamBufferSpacesAvailable>
    3e24:	9c 01       	movw	r18, r24
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3e26:	ce 01       	movw	r24, r28
    3e28:	b6 01       	movw	r22, r12
    3e2a:	a7 01       	movw	r20, r14
    3e2c:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <prvWriteMessageToBuffer>
    3e30:	6c 01       	movw	r12, r24

	if( xReturn > ( size_t ) 0 )
    3e32:	00 97       	sbiw	r24, 0x00	; 0
    3e34:	c9 f0       	breq	.+50     	; 0x3e68 <xStreamBufferSendFromISR+0x76>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3e36:	ce 01       	movw	r24, r28
    3e38:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    3e3c:	2e 81       	ldd	r18, Y+6	; 0x06
    3e3e:	3f 81       	ldd	r19, Y+7	; 0x07
    3e40:	82 17       	cp	r24, r18
    3e42:	93 07       	cpc	r25, r19
    3e44:	88 f0       	brcs	.+34     	; 0x3e68 <xStreamBufferSendFromISR+0x76>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3e46:	88 85       	ldd	r24, Y+8	; 0x08
    3e48:	99 85       	ldd	r25, Y+9	; 0x09
    3e4a:	00 97       	sbiw	r24, 0x00	; 0
    3e4c:	69 f0       	breq	.+26     	; 0x3e68 <xStreamBufferSendFromISR+0x76>
    3e4e:	88 85       	ldd	r24, Y+8	; 0x08
    3e50:	99 85       	ldd	r25, Y+9	; 0x09
    3e52:	40 e0       	ldi	r20, 0x00	; 0
    3e54:	50 e0       	ldi	r21, 0x00	; 0
    3e56:	ba 01       	movw	r22, r20
    3e58:	20 e0       	ldi	r18, 0x00	; 0
    3e5a:	00 e0       	ldi	r16, 0x00	; 0
    3e5c:	10 e0       	ldi	r17, 0x00	; 0
    3e5e:	75 01       	movw	r14, r10
    3e60:	0e 94 16 27 	call	0x4e2c	; 0x4e2c <xTaskGenericNotifyFromISR>
    3e64:	19 86       	std	Y+9, r1	; 0x09
    3e66:	18 86       	std	Y+8, r1	; 0x08
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
}
    3e68:	8c 2d       	mov	r24, r12
    3e6a:	9d 2d       	mov	r25, r13
    3e6c:	df 91       	pop	r29
    3e6e:	cf 91       	pop	r28
    3e70:	1f 91       	pop	r17
    3e72:	0f 91       	pop	r16
    3e74:	ff 90       	pop	r15
    3e76:	ef 90       	pop	r14
    3e78:	df 90       	pop	r13
    3e7a:	cf 90       	pop	r12
    3e7c:	bf 90       	pop	r11
    3e7e:	af 90       	pop	r10
    3e80:	08 95       	ret

00003e82 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3e82:	6f 92       	push	r6
    3e84:	7f 92       	push	r7
    3e86:	8f 92       	push	r8
    3e88:	9f 92       	push	r9
    3e8a:	af 92       	push	r10
    3e8c:	bf 92       	push	r11
    3e8e:	cf 92       	push	r12
    3e90:	df 92       	push	r13
    3e92:	ef 92       	push	r14
    3e94:	ff 92       	push	r15
    3e96:	0f 93       	push	r16
    3e98:	1f 93       	push	r17
    3e9a:	cf 93       	push	r28
    3e9c:	df 93       	push	r29
    3e9e:	5c 01       	movw	r10, r24
    3ea0:	4b 01       	movw	r8, r22
    3ea2:	3a 01       	movw	r6, r20
    3ea4:	79 01       	movw	r14, r18
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3ea6:	fc 01       	movw	r30, r24
    3ea8:	86 85       	ldd	r24, Z+14	; 0x0e
    3eaa:	80 ff       	sbrs	r24, 0
    3eac:	05 c0       	rjmp	.+10     	; 0x3eb8 <xStreamBufferReceive+0x36>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3eae:	cc 24       	eor	r12, r12
    3eb0:	dd 24       	eor	r13, r13
    3eb2:	68 94       	set
    3eb4:	c1 f8       	bld	r12, 1
    3eb6:	02 c0       	rjmp	.+4      	; 0x3ebc <xStreamBufferReceive+0x3a>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3eb8:	cc 24       	eor	r12, r12
    3eba:	dd 24       	eor	r13, r13
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3ebc:	e1 14       	cp	r14, r1
    3ebe:	f1 04       	cpc	r15, r1
    3ec0:	51 f1       	breq	.+84     	; 0x3f16 <xStreamBufferReceive+0x94>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3ec2:	0f b6       	in	r0, 0x3f	; 63
    3ec4:	f8 94       	cli
    3ec6:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3ec8:	c5 01       	movw	r24, r10
    3eca:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    3ece:	ec 01       	movw	r28, r24
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3ed0:	c8 16       	cp	r12, r24
    3ed2:	d9 06       	cpc	r13, r25
    3ed4:	48 f0       	brcs	.+18     	; 0x3ee8 <xStreamBufferReceive+0x66>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3ed6:	80 e0       	ldi	r24, 0x00	; 0
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	0e 94 00 28 	call	0x5000	; 0x5000 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3ede:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <xTaskGetCurrentTaskHandle>
    3ee2:	f5 01       	movw	r30, r10
    3ee4:	91 87       	std	Z+9, r25	; 0x09
    3ee6:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3ee8:	0f 90       	pop	r0
    3eea:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3eec:	cc 16       	cp	r12, r28
    3eee:	dd 06       	cpc	r13, r29
    3ef0:	c8 f0       	brcs	.+50     	; 0x3f24 <xStreamBufferReceive+0xa2>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3ef2:	60 e0       	ldi	r22, 0x00	; 0
    3ef4:	70 e0       	ldi	r23, 0x00	; 0
    3ef6:	cb 01       	movw	r24, r22
    3ef8:	20 e0       	ldi	r18, 0x00	; 0
    3efa:	30 e0       	ldi	r19, 0x00	; 0
    3efc:	a9 01       	movw	r20, r18
    3efe:	00 e0       	ldi	r16, 0x00	; 0
    3f00:	10 e0       	ldi	r17, 0x00	; 0
    3f02:	0e 94 1d 26 	call	0x4c3a	; 0x4c3a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3f06:	f5 01       	movw	r30, r10
    3f08:	11 86       	std	Z+9, r1	; 0x09
    3f0a:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3f0c:	c5 01       	movw	r24, r10
    3f0e:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    3f12:	ec 01       	movw	r28, r24
    3f14:	04 c0       	rjmp	.+8      	; 0x3f1e <xStreamBufferReceive+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3f16:	c5 01       	movw	r24, r10
    3f18:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    3f1c:	ec 01       	movw	r28, r24
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3f1e:	cc 16       	cp	r12, r28
    3f20:	dd 06       	cpc	r13, r29
    3f22:	08 f5       	brcc	.+66     	; 0x3f66 <xStreamBufferReceive+0xe4>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3f24:	c5 01       	movw	r24, r10
    3f26:	b4 01       	movw	r22, r8
    3f28:	a3 01       	movw	r20, r6
    3f2a:	9e 01       	movw	r18, r28
    3f2c:	86 01       	movw	r16, r12
    3f2e:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <prvReadMessageFromBuffer>
    3f32:	ec 01       	movw	r28, r24

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3f34:	00 97       	sbiw	r24, 0x00	; 0
    3f36:	c9 f0       	breq	.+50     	; 0x3f6a <xStreamBufferReceive+0xe8>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3f38:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
    3f3c:	f5 01       	movw	r30, r10
    3f3e:	82 85       	ldd	r24, Z+10	; 0x0a
    3f40:	93 85       	ldd	r25, Z+11	; 0x0b
    3f42:	00 97       	sbiw	r24, 0x00	; 0
    3f44:	69 f0       	breq	.+26     	; 0x3f60 <xStreamBufferReceive+0xde>
    3f46:	82 85       	ldd	r24, Z+10	; 0x0a
    3f48:	93 85       	ldd	r25, Z+11	; 0x0b
    3f4a:	40 e0       	ldi	r20, 0x00	; 0
    3f4c:	50 e0       	ldi	r21, 0x00	; 0
    3f4e:	ba 01       	movw	r22, r20
    3f50:	20 e0       	ldi	r18, 0x00	; 0
    3f52:	00 e0       	ldi	r16, 0x00	; 0
    3f54:	10 e0       	ldi	r17, 0x00	; 0
    3f56:	0e 94 99 26 	call	0x4d32	; 0x4d32 <xTaskGenericNotify>
    3f5a:	f5 01       	movw	r30, r10
    3f5c:	13 86       	std	Z+11, r1	; 0x0b
    3f5e:	12 86       	std	Z+10, r1	; 0x0a
    3f60:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
    3f64:	02 c0       	rjmp	.+4      	; 0x3f6a <xStreamBufferReceive+0xe8>
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3f66:	c0 e0       	ldi	r28, 0x00	; 0
    3f68:	d0 e0       	ldi	r29, 0x00	; 0
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
}
    3f6a:	8c 2f       	mov	r24, r28
    3f6c:	9d 2f       	mov	r25, r29
    3f6e:	df 91       	pop	r29
    3f70:	cf 91       	pop	r28
    3f72:	1f 91       	pop	r17
    3f74:	0f 91       	pop	r16
    3f76:	ff 90       	pop	r15
    3f78:	ef 90       	pop	r14
    3f7a:	df 90       	pop	r13
    3f7c:	cf 90       	pop	r12
    3f7e:	bf 90       	pop	r11
    3f80:	af 90       	pop	r10
    3f82:	9f 90       	pop	r9
    3f84:	8f 90       	pop	r8
    3f86:	7f 90       	pop	r7
    3f88:	6f 90       	pop	r6
    3f8a:	08 95       	ret

00003f8c <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3f8c:	ef 92       	push	r14
    3f8e:	ff 92       	push	r15
    3f90:	0f 93       	push	r16
    3f92:	1f 93       	push	r17
    3f94:	cf 93       	push	r28
    3f96:	df 93       	push	r29
    3f98:	00 d0       	rcall	.+0      	; 0x3f9a <xStreamBufferNextMessageLengthBytes+0xe>
    3f9a:	cd b7       	in	r28, 0x3d	; 61
    3f9c:	de b7       	in	r29, 0x3e	; 62
    3f9e:	8c 01       	movw	r16, r24
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3fa0:	fc 01       	movw	r30, r24
    3fa2:	86 85       	ldd	r24, Z+14	; 0x0e
    3fa4:	80 ff       	sbrs	r24, 0
    3fa6:	18 c0       	rjmp	.+48     	; 0x3fd8 <xStreamBufferNextMessageLengthBytes+0x4c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3fa8:	c8 01       	movw	r24, r16
    3faa:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    3fae:	9c 01       	movw	r18, r24
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3fb0:	83 30       	cpi	r24, 0x03	; 3
    3fb2:	91 05       	cpc	r25, r1
    3fb4:	a0 f0       	brcs	.+40     	; 0x3fde <xStreamBufferNextMessageLengthBytes+0x52>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3fb6:	f8 01       	movw	r30, r16
    3fb8:	e0 80       	ld	r14, Z
    3fba:	f1 80       	ldd	r15, Z+1	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    3fbc:	c8 01       	movw	r24, r16
    3fbe:	be 01       	movw	r22, r28
    3fc0:	6f 5f       	subi	r22, 0xFF	; 255
    3fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    3fc4:	42 e0       	ldi	r20, 0x02	; 2
    3fc6:	50 e0       	ldi	r21, 0x00	; 0
    3fc8:	0e 94 a2 1c 	call	0x3944	; 0x3944 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3fcc:	89 81       	ldd	r24, Y+1	; 0x01
    3fce:	9a 81       	ldd	r25, Y+2	; 0x02
			pxStreamBuffer->xTail = xOriginalTail;
    3fd0:	f8 01       	movw	r30, r16
    3fd2:	f1 82       	std	Z+1, r15	; 0x01
    3fd4:	e0 82       	st	Z, r14
    3fd6:	05 c0       	rjmp	.+10     	; 0x3fe2 <xStreamBufferNextMessageLengthBytes+0x56>
			xReturn = 0;
		}
	}
	else
	{
		xReturn = 0;
    3fd8:	80 e0       	ldi	r24, 0x00	; 0
    3fda:	90 e0       	ldi	r25, 0x00	; 0
    3fdc:	02 c0       	rjmp	.+4      	; 0x3fe2 <xStreamBufferNextMessageLengthBytes+0x56>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    3fde:	80 e0       	ldi	r24, 0x00	; 0
    3fe0:	90 e0       	ldi	r25, 0x00	; 0
	{
		xReturn = 0;
	}

	return xReturn;
}
    3fe2:	0f 90       	pop	r0
    3fe4:	0f 90       	pop	r0
    3fe6:	df 91       	pop	r29
    3fe8:	cf 91       	pop	r28
    3fea:	1f 91       	pop	r17
    3fec:	0f 91       	pop	r16
    3fee:	ff 90       	pop	r15
    3ff0:	ef 90       	pop	r14
    3ff2:	08 95       	ret

00003ff4 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    3ff4:	af 92       	push	r10
    3ff6:	bf 92       	push	r11
    3ff8:	cf 92       	push	r12
    3ffa:	df 92       	push	r13
    3ffc:	ef 92       	push	r14
    3ffe:	ff 92       	push	r15
    4000:	0f 93       	push	r16
    4002:	1f 93       	push	r17
    4004:	cf 93       	push	r28
    4006:	df 93       	push	r29
    4008:	6c 01       	movw	r12, r24
    400a:	eb 01       	movw	r28, r22
    400c:	7a 01       	movw	r14, r20
    400e:	59 01       	movw	r10, r18
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4010:	fc 01       	movw	r30, r24
    4012:	86 85       	ldd	r24, Z+14	; 0x0e
    4014:	80 ff       	sbrs	r24, 0
    4016:	03 c0       	rjmp	.+6      	; 0x401e <xStreamBufferReceiveFromISR+0x2a>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4018:	02 e0       	ldi	r16, 0x02	; 2
    401a:	10 e0       	ldi	r17, 0x00	; 0
    401c:	02 c0       	rjmp	.+4      	; 0x4022 <xStreamBufferReceiveFromISR+0x2e>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    401e:	00 e0       	ldi	r16, 0x00	; 0
    4020:	10 e0       	ldi	r17, 0x00	; 0
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4022:	c6 01       	movw	r24, r12
    4024:	0e 94 91 1c 	call	0x3922	; 0x3922 <prvBytesInBuffer>
    4028:	9c 01       	movw	r18, r24
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    402a:	08 17       	cp	r16, r24
    402c:	19 07       	cpc	r17, r25
    402e:	e0 f4       	brcc	.+56     	; 0x4068 <xStreamBufferReceiveFromISR+0x74>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    4030:	c6 01       	movw	r24, r12
    4032:	be 01       	movw	r22, r28
    4034:	a7 01       	movw	r20, r14
    4036:	0e 94 f6 1c 	call	0x39ec	; 0x39ec <prvReadMessageFromBuffer>
    403a:	ec 01       	movw	r28, r24

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    403c:	00 97       	sbiw	r24, 0x00	; 0
    403e:	b1 f0       	breq	.+44     	; 0x406c <xStreamBufferReceiveFromISR+0x78>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4040:	f6 01       	movw	r30, r12
    4042:	82 85       	ldd	r24, Z+10	; 0x0a
    4044:	93 85       	ldd	r25, Z+11	; 0x0b
    4046:	00 97       	sbiw	r24, 0x00	; 0
    4048:	89 f0       	breq	.+34     	; 0x406c <xStreamBufferReceiveFromISR+0x78>
    404a:	82 85       	ldd	r24, Z+10	; 0x0a
    404c:	93 85       	ldd	r25, Z+11	; 0x0b
    404e:	40 e0       	ldi	r20, 0x00	; 0
    4050:	50 e0       	ldi	r21, 0x00	; 0
    4052:	ba 01       	movw	r22, r20
    4054:	20 e0       	ldi	r18, 0x00	; 0
    4056:	00 e0       	ldi	r16, 0x00	; 0
    4058:	10 e0       	ldi	r17, 0x00	; 0
    405a:	75 01       	movw	r14, r10
    405c:	0e 94 16 27 	call	0x4e2c	; 0x4e2c <xTaskGenericNotifyFromISR>
    4060:	f6 01       	movw	r30, r12
    4062:	13 86       	std	Z+11, r1	; 0x0b
    4064:	12 86       	std	Z+10, r1	; 0x0a
    4066:	02 c0       	rjmp	.+4      	; 0x406c <xStreamBufferReceiveFromISR+0x78>
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    4068:	c0 e0       	ldi	r28, 0x00	; 0
    406a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
}
    406c:	8c 2f       	mov	r24, r28
    406e:	9d 2f       	mov	r25, r29
    4070:	df 91       	pop	r29
    4072:	cf 91       	pop	r28
    4074:	1f 91       	pop	r17
    4076:	0f 91       	pop	r16
    4078:	ff 90       	pop	r15
    407a:	ef 90       	pop	r14
    407c:	df 90       	pop	r13
    407e:	cf 90       	pop	r12
    4080:	bf 90       	pop	r11
    4082:	af 90       	pop	r10
    4084:	08 95       	ret

00004086 <xStreamBufferIsEmpty>:
	return xReceivedLength;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    4086:	fc 01       	movw	r30, r24
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    4088:	40 81       	ld	r20, Z
    408a:	51 81       	ldd	r21, Z+1	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    408c:	22 81       	ldd	r18, Z+2	; 0x02
    408e:	33 81       	ldd	r19, Z+3	; 0x03
	{
		xReturn = pdTRUE;
    4090:	81 e0       	ldi	r24, 0x01	; 1
    4092:	42 17       	cp	r20, r18
    4094:	53 07       	cpc	r21, r19
    4096:	09 f0       	breq	.+2      	; 0x409a <xStreamBufferIsEmpty+0x14>
    4098:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    409a:	08 95       	ret

0000409c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    409c:	cf 93       	push	r28
    409e:	df 93       	push	r29

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    40a0:	fc 01       	movw	r30, r24
    40a2:	26 85       	ldd	r18, Z+14	; 0x0e
    40a4:	20 ff       	sbrs	r18, 0
    40a6:	03 c0       	rjmp	.+6      	; 0x40ae <xStreamBufferIsFull+0x12>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    40a8:	c2 e0       	ldi	r28, 0x02	; 2
    40aa:	d0 e0       	ldi	r29, 0x00	; 0
    40ac:	02 c0       	rjmp	.+4      	; 0x40b2 <xStreamBufferIsFull+0x16>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    40ae:	c0 e0       	ldi	r28, 0x00	; 0
    40b0:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    40b2:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <xStreamBufferSpacesAvailable>
	{
		xReturn = pdTRUE;
    40b6:	21 e0       	ldi	r18, 0x01	; 1
    40b8:	c8 17       	cp	r28, r24
    40ba:	d9 07       	cpc	r29, r25
    40bc:	08 f4       	brcc	.+2      	; 0x40c0 <xStreamBufferIsFull+0x24>
    40be:	20 e0       	ldi	r18, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    40c0:	82 2f       	mov	r24, r18
    40c2:	df 91       	pop	r29
    40c4:	cf 91       	pop	r28
    40c6:	08 95       	ret

000040c8 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    40c8:	ef 92       	push	r14
    40ca:	ff 92       	push	r15
    40cc:	0f 93       	push	r16
    40ce:	1f 93       	push	r17
    40d0:	cf 93       	push	r28
    40d2:	df 93       	push	r29
    40d4:	ec 01       	movw	r28, r24
    40d6:	7b 01       	movw	r14, r22

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    40d8:	88 85       	ldd	r24, Y+8	; 0x08
    40da:	99 85       	ldd	r25, Y+9	; 0x09
    40dc:	00 97       	sbiw	r24, 0x00	; 0
    40de:	71 f0       	breq	.+28     	; 0x40fc <xStreamBufferSendCompletedFromISR+0x34>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    40e0:	88 85       	ldd	r24, Y+8	; 0x08
    40e2:	99 85       	ldd	r25, Y+9	; 0x09
    40e4:	40 e0       	ldi	r20, 0x00	; 0
    40e6:	50 e0       	ldi	r21, 0x00	; 0
    40e8:	ba 01       	movw	r22, r20
    40ea:	20 e0       	ldi	r18, 0x00	; 0
    40ec:	00 e0       	ldi	r16, 0x00	; 0
    40ee:	10 e0       	ldi	r17, 0x00	; 0
    40f0:	0e 94 16 27 	call	0x4e2c	; 0x4e2c <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    40f4:	19 86       	std	Y+9, r1	; 0x09
    40f6:	18 86       	std	Y+8, r1	; 0x08
			xReturn = pdTRUE;
    40f8:	81 e0       	ldi	r24, 0x01	; 1
    40fa:	01 c0       	rjmp	.+2      	; 0x40fe <xStreamBufferSendCompletedFromISR+0x36>
		}
		else
		{
			xReturn = pdFALSE;
    40fc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    40fe:	df 91       	pop	r29
    4100:	cf 91       	pop	r28
    4102:	1f 91       	pop	r17
    4104:	0f 91       	pop	r16
    4106:	ff 90       	pop	r15
    4108:	ef 90       	pop	r14
    410a:	08 95       	ret

0000410c <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    410c:	ef 92       	push	r14
    410e:	ff 92       	push	r15
    4110:	0f 93       	push	r16
    4112:	1f 93       	push	r17
    4114:	cf 93       	push	r28
    4116:	df 93       	push	r29
    4118:	ec 01       	movw	r28, r24
    411a:	7b 01       	movw	r14, r22

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    411c:	8a 85       	ldd	r24, Y+10	; 0x0a
    411e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4120:	00 97       	sbiw	r24, 0x00	; 0
    4122:	71 f0       	breq	.+28     	; 0x4140 <xStreamBufferReceiveCompletedFromISR+0x34>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    4124:	8a 85       	ldd	r24, Y+10	; 0x0a
    4126:	9b 85       	ldd	r25, Y+11	; 0x0b
    4128:	40 e0       	ldi	r20, 0x00	; 0
    412a:	50 e0       	ldi	r21, 0x00	; 0
    412c:	ba 01       	movw	r22, r20
    412e:	20 e0       	ldi	r18, 0x00	; 0
    4130:	00 e0       	ldi	r16, 0x00	; 0
    4132:	10 e0       	ldi	r17, 0x00	; 0
    4134:	0e 94 16 27 	call	0x4e2c	; 0x4e2c <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    4138:	1b 86       	std	Y+11, r1	; 0x0b
    413a:	1a 86       	std	Y+10, r1	; 0x0a
			xReturn = pdTRUE;
    413c:	81 e0       	ldi	r24, 0x01	; 1
    413e:	01 c0       	rjmp	.+2      	; 0x4142 <xStreamBufferReceiveCompletedFromISR+0x36>
		}
		else
		{
			xReturn = pdFALSE;
    4140:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    4142:	df 91       	pop	r29
    4144:	cf 91       	pop	r28
    4146:	1f 91       	pop	r17
    4148:	0f 91       	pop	r16
    414a:	ff 90       	pop	r15
    414c:	ef 90       	pop	r14
    414e:	08 95       	ret

00004150 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4150:	e0 91 27 05 	lds	r30, 0x0527
    4154:	f0 91 28 05 	lds	r31, 0x0528
    4158:	80 81       	ld	r24, Z
    415a:	88 23       	and	r24, r24
    415c:	39 f4       	brne	.+14     	; 0x416c <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    415e:	8f ef       	ldi	r24, 0xFF	; 255
    4160:	9f ef       	ldi	r25, 0xFF	; 255
    4162:	90 93 1b 05 	sts	0x051B, r25
    4166:	80 93 1a 05 	sts	0x051A, r24
    416a:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    416c:	e0 91 27 05 	lds	r30, 0x0527
    4170:	f0 91 28 05 	lds	r31, 0x0528
    4174:	05 80       	ldd	r0, Z+5	; 0x05
    4176:	f6 81       	ldd	r31, Z+6	; 0x06
    4178:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    417a:	06 80       	ldd	r0, Z+6	; 0x06
    417c:	f7 81       	ldd	r31, Z+7	; 0x07
    417e:	e0 2d       	mov	r30, r0
    4180:	82 81       	ldd	r24, Z+2	; 0x02
    4182:	93 81       	ldd	r25, Z+3	; 0x03
    4184:	90 93 1b 05 	sts	0x051B, r25
    4188:	80 93 1a 05 	sts	0x051A, r24
    418c:	08 95       	ret

0000418e <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    418e:	0f 93       	push	r16
    4190:	1f 93       	push	r17
    4192:	cf 93       	push	r28
    4194:	df 93       	push	r29
    4196:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4198:	00 91 21 05 	lds	r16, 0x0521
    419c:	10 91 22 05 	lds	r17, 0x0522
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    41a0:	80 91 17 05 	lds	r24, 0x0517
    41a4:	90 91 18 05 	lds	r25, 0x0518
    41a8:	02 96       	adiw	r24, 0x02	; 2
    41aa:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    41ae:	c0 0f       	add	r28, r16
    41b0:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    41b2:	e0 91 17 05 	lds	r30, 0x0517
    41b6:	f0 91 18 05 	lds	r31, 0x0518
    41ba:	d3 83       	std	Z+3, r29	; 0x03
    41bc:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    41be:	c0 17       	cp	r28, r16
    41c0:	d1 07       	cpc	r29, r17
    41c2:	68 f4       	brcc	.+26     	; 0x41de <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    41c4:	80 91 25 05 	lds	r24, 0x0525
    41c8:	90 91 26 05 	lds	r25, 0x0526
    41cc:	60 91 17 05 	lds	r22, 0x0517
    41d0:	70 91 18 05 	lds	r23, 0x0518
    41d4:	6e 5f       	subi	r22, 0xFE	; 254
    41d6:	7f 4f       	sbci	r23, 0xFF	; 255
    41d8:	0e 94 39 16 	call	0x2c72	; 0x2c72 <vListInsert>
    41dc:	17 c0       	rjmp	.+46     	; 0x420c <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    41de:	80 91 27 05 	lds	r24, 0x0527
    41e2:	90 91 28 05 	lds	r25, 0x0528
    41e6:	60 91 17 05 	lds	r22, 0x0517
    41ea:	70 91 18 05 	lds	r23, 0x0518
    41ee:	6e 5f       	subi	r22, 0xFE	; 254
    41f0:	7f 4f       	sbci	r23, 0xFF	; 255
    41f2:	0e 94 39 16 	call	0x2c72	; 0x2c72 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    41f6:	80 91 1a 05 	lds	r24, 0x051A
    41fa:	90 91 1b 05 	lds	r25, 0x051B
    41fe:	c8 17       	cp	r28, r24
    4200:	d9 07       	cpc	r29, r25
    4202:	20 f4       	brcc	.+8      	; 0x420c <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    4204:	d0 93 1b 05 	sts	0x051B, r29
    4208:	c0 93 1a 05 	sts	0x051A, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    420c:	df 91       	pop	r29
    420e:	cf 91       	pop	r28
    4210:	1f 91       	pop	r17
    4212:	0f 91       	pop	r16
    4214:	08 95       	ret

00004216 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4216:	cf 93       	push	r28
    4218:	df 93       	push	r29
    421a:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    421c:	8f 89       	ldd	r24, Y+23	; 0x17
    421e:	98 8d       	ldd	r25, Y+24	; 0x18
    4220:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <vPortFree>
			vPortFree( pxTCB );
    4224:	ce 01       	movw	r24, r28
    4226:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    422a:	df 91       	pop	r29
    422c:	cf 91       	pop	r28
    422e:	08 95       	ret

00004230 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4230:	1c c0       	rjmp	.+56     	; 0x426a <prvIdleTask+0x3a>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4232:	0f b6       	in	r0, 0x3f	; 63
    4234:	f8 94       	cli
    4236:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4238:	e0 91 6e 05 	lds	r30, 0x056E
    423c:	f0 91 6f 05 	lds	r31, 0x056F
    4240:	c6 81       	ldd	r28, Z+6	; 0x06
    4242:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4244:	ce 01       	movw	r24, r28
    4246:	02 96       	adiw	r24, 0x02	; 2
    4248:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
				--uxCurrentNumberOfTasks;
    424c:	80 91 23 05 	lds	r24, 0x0523
    4250:	81 50       	subi	r24, 0x01	; 1
    4252:	80 93 23 05 	sts	0x0523, r24
				--uxDeletedTasksWaitingCleanUp;
    4256:	80 91 24 05 	lds	r24, 0x0524
    425a:	81 50       	subi	r24, 0x01	; 1
    425c:	80 93 24 05 	sts	0x0524, r24
			}
			taskEXIT_CRITICAL();
    4260:	0f 90       	pop	r0
    4262:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4264:	ce 01       	movw	r24, r28
    4266:	0e 94 0b 21 	call	0x4216	; 0x4216 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    426a:	80 91 24 05 	lds	r24, 0x0524
    426e:	88 23       	and	r24, r24
    4270:	01 f7       	brne	.-64     	; 0x4232 <prvIdleTask+0x2>
    4272:	fb cf       	rjmp	.-10     	; 0x426a <prvIdleTask+0x3a>

00004274 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4274:	2f 92       	push	r2
    4276:	3f 92       	push	r3
    4278:	4f 92       	push	r4
    427a:	5f 92       	push	r5
    427c:	6f 92       	push	r6
    427e:	7f 92       	push	r7
    4280:	8f 92       	push	r8
    4282:	9f 92       	push	r9
    4284:	af 92       	push	r10
    4286:	bf 92       	push	r11
    4288:	df 92       	push	r13
    428a:	ef 92       	push	r14
    428c:	ff 92       	push	r15
    428e:	0f 93       	push	r16
    4290:	1f 93       	push	r17
    4292:	cf 93       	push	r28
    4294:	df 93       	push	r29
    4296:	3c 01       	movw	r6, r24
    4298:	5b 01       	movw	r10, r22
    429a:	ea 01       	movw	r28, r20
    429c:	29 01       	movw	r4, r18
    429e:	d0 2e       	mov	r13, r16
    42a0:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    42a2:	ca 01       	movw	r24, r20
    42a4:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <pvPortMalloc>
    42a8:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    42aa:	00 97       	sbiw	r24, 0x00	; 0
    42ac:	09 f4       	brne	.+2      	; 0x42b0 <xTaskCreate+0x3c>
    42ae:	ec c0       	rjmp	.+472    	; 0x4488 <xTaskCreate+0x214>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    42b0:	86 e2       	ldi	r24, 0x26	; 38
    42b2:	90 e0       	ldi	r25, 0x00	; 0
    42b4:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <pvPortMalloc>
    42b8:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    42ba:	00 97       	sbiw	r24, 0x00	; 0
    42bc:	59 f0       	breq	.+22     	; 0x42d4 <xTaskCreate+0x60>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    42be:	fc 01       	movw	r30, r24
    42c0:	f0 8e       	std	Z+24, r15	; 0x18
    42c2:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    42c4:	21 97       	sbiw	r28, 0x01	; 1
    42c6:	17 01       	movw	r2, r14
    42c8:	2c 0e       	add	r2, r28
    42ca:	3d 1e       	adc	r3, r29
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    42cc:	a1 14       	cp	r10, r1
    42ce:	b1 04       	cpc	r11, r1
    42d0:	31 f4       	brne	.+12     	; 0x42de <xTaskCreate+0x6a>
    42d2:	1e c0       	rjmp	.+60     	; 0x4310 <xTaskCreate+0x9c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    42d4:	c7 01       	movw	r24, r14
    42d6:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    42da:	8f ef       	ldi	r24, 0xFF	; 255
    42dc:	da c0       	rjmp	.+436    	; 0x4492 <xTaskCreate+0x21e>
	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    42de:	f5 01       	movw	r30, r10
    42e0:	80 81       	ld	r24, Z
    42e2:	f8 01       	movw	r30, r16
    42e4:	81 8f       	std	Z+25, r24	; 0x19

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    42e6:	f5 01       	movw	r30, r10
    42e8:	80 81       	ld	r24, Z
    42ea:	88 23       	and	r24, r24
    42ec:	71 f0       	breq	.+28     	; 0x430a <xTaskCreate+0x96>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    42ee:	e8 01       	movw	r28, r16
    42f0:	6a 96       	adiw	r28, 0x1a	; 26
    42f2:	d5 01       	movw	r26, r10
    42f4:	11 96       	adiw	r26, 0x01	; 1
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    42f6:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    42f8:	fd 01       	movw	r30, r26
	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    42fa:	9d 91       	ld	r25, X+
    42fc:	99 93       	st	Y+, r25

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    42fe:	90 81       	ld	r25, Z
    4300:	99 23       	and	r25, r25
    4302:	19 f0       	breq	.+6      	; 0x430a <xTaskCreate+0x96>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4304:	8f 5f       	subi	r24, 0xFF	; 255
    4306:	88 30       	cpi	r24, 0x08	; 8
    4308:	b9 f7       	brne	.-18     	; 0x42f8 <xTaskCreate+0x84>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    430a:	f8 01       	movw	r30, r16
    430c:	10 a2       	lds	r17, 0x90
    430e:	02 c0       	rjmp	.+4      	; 0x4314 <xTaskCreate+0xa0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4310:	fc 01       	movw	r30, r24
    4312:	11 8e       	std	Z+25, r1	; 0x19
    4314:	cd 2d       	mov	r28, r13
    4316:	c4 30       	cpi	r28, 0x04	; 4
    4318:	08 f0       	brcs	.+2      	; 0x431c <xTaskCreate+0xa8>
    431a:	c3 e0       	ldi	r28, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    431c:	f8 01       	movw	r30, r16
    431e:	c6 8b       	std	Z+22, r28	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4320:	ee 24       	eor	r14, r14
    4322:	ff 24       	eor	r15, r15
    4324:	68 94       	set
    4326:	e1 f8       	bld	r14, 1
    4328:	e0 0e       	add	r14, r16
    432a:	f1 1e       	adc	r15, r17
    432c:	c7 01       	movw	r24, r14
    432e:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4332:	c8 01       	movw	r24, r16
    4334:	0c 96       	adiw	r24, 0x0c	; 12
    4336:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    433a:	f8 01       	movw	r30, r16
    433c:	11 87       	std	Z+9, r17	; 0x09
    433e:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4340:	84 e0       	ldi	r24, 0x04	; 4
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	8c 1b       	sub	r24, r28
    4346:	91 09       	sbc	r25, r1
    4348:	95 87       	std	Z+13, r25	; 0x0d
    434a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    434c:	13 8b       	std	Z+19, r17	; 0x13
    434e:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4350:	11 a2       	lds	r17, 0x91
    4352:	12 a2       	lds	r17, 0x92
    4354:	13 a2       	lds	r17, 0x93
    4356:	14 a2       	lds	r17, 0x94
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4358:	15 a2       	lds	r17, 0x95
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    435a:	c1 01       	movw	r24, r2
    435c:	b3 01       	movw	r22, r6
    435e:	a2 01       	movw	r20, r4
    4360:	0e 94 94 16 	call	0x2d28	; 0x2d28 <pxPortInitialiseStack>
    4364:	f8 01       	movw	r30, r16
    4366:	91 83       	std	Z+1, r25	; 0x01
    4368:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    436a:	81 14       	cp	r8, r1
    436c:	91 04       	cpc	r9, r1
    436e:	19 f0       	breq	.+6      	; 0x4376 <xTaskCreate+0x102>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4370:	f4 01       	movw	r30, r8
    4372:	11 83       	std	Z+1, r17	; 0x01
    4374:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4376:	0f b6       	in	r0, 0x3f	; 63
    4378:	f8 94       	cli
    437a:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    437c:	80 91 23 05 	lds	r24, 0x0523
    4380:	8f 5f       	subi	r24, 0xFF	; 255
    4382:	80 93 23 05 	sts	0x0523, r24
		if( pxCurrentTCB == NULL )
    4386:	80 91 17 05 	lds	r24, 0x0517
    438a:	90 91 18 05 	lds	r25, 0x0518
    438e:	00 97       	sbiw	r24, 0x00	; 0
    4390:	d9 f5       	brne	.+118    	; 0x4408 <xTaskCreate+0x194>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4392:	10 93 18 05 	sts	0x0518, r17
    4396:	00 93 17 05 	sts	0x0517, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    439a:	80 91 23 05 	lds	r24, 0x0523
    439e:	81 30       	cpi	r24, 0x01	; 1
    43a0:	09 f0       	breq	.+2      	; 0x43a4 <xTaskCreate+0x130>
    43a2:	43 c0       	rjmp	.+134    	; 0x442a <xTaskCreate+0x1b6>
    43a4:	c0 e0       	ldi	r28, 0x00	; 0
    43a6:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    43a8:	ce 01       	movw	r24, r28
    43aa:	88 0f       	add	r24, r24
    43ac:	99 1f       	adc	r25, r25
    43ae:	88 0f       	add	r24, r24
    43b0:	99 1f       	adc	r25, r25
    43b2:	88 0f       	add	r24, r24
    43b4:	99 1f       	adc	r25, r25
    43b6:	8c 0f       	add	r24, r28
    43b8:	9d 1f       	adc	r25, r29
    43ba:	86 5d       	subi	r24, 0xD6	; 214
    43bc:	9a 4f       	sbci	r25, 0xFA	; 250
    43be:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
    43c2:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    43c4:	c4 30       	cpi	r28, 0x04	; 4
    43c6:	d1 05       	cpc	r29, r1
    43c8:	79 f7       	brne	.-34     	; 0x43a8 <xTaskCreate+0x134>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    43ca:	ce e4       	ldi	r28, 0x4E	; 78
    43cc:	d5 e0       	ldi	r29, 0x05	; 5
    43ce:	ce 01       	movw	r24, r28
    43d0:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    43d4:	0f 2e       	mov	r0, r31
    43d6:	f7 e5       	ldi	r31, 0x57	; 87
    43d8:	af 2e       	mov	r10, r31
    43da:	f5 e0       	ldi	r31, 0x05	; 5
    43dc:	bf 2e       	mov	r11, r31
    43de:	f0 2d       	mov	r31, r0
    43e0:	c5 01       	movw	r24, r10
    43e2:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    43e6:	80 e6       	ldi	r24, 0x60	; 96
    43e8:	95 e0       	ldi	r25, 0x05	; 5
    43ea:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    43ee:	89 e6       	ldi	r24, 0x69	; 105
    43f0:	95 e0       	ldi	r25, 0x05	; 5
    43f2:	0e 94 08 16 	call	0x2c10	; 0x2c10 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    43f6:	d0 93 28 05 	sts	0x0528, r29
    43fa:	c0 93 27 05 	sts	0x0527, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    43fe:	b0 92 26 05 	sts	0x0526, r11
    4402:	a0 92 25 05 	sts	0x0525, r10
    4406:	11 c0       	rjmp	.+34     	; 0x442a <xTaskCreate+0x1b6>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4408:	80 91 1f 05 	lds	r24, 0x051F
    440c:	88 23       	and	r24, r24
    440e:	69 f4       	brne	.+26     	; 0x442a <xTaskCreate+0x1b6>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4410:	e0 91 17 05 	lds	r30, 0x0517
    4414:	f0 91 18 05 	lds	r31, 0x0518
    4418:	96 89       	ldd	r25, Z+22	; 0x16
    441a:	f8 01       	movw	r30, r16
    441c:	86 89       	ldd	r24, Z+22	; 0x16
    441e:	89 17       	cp	r24, r25
    4420:	20 f0       	brcs	.+8      	; 0x442a <xTaskCreate+0x1b6>
				{
					pxCurrentTCB = pxNewTCB;
    4422:	10 93 18 05 	sts	0x0518, r17
    4426:	00 93 17 05 	sts	0x0517, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    442a:	80 91 29 05 	lds	r24, 0x0529
    442e:	8f 5f       	subi	r24, 0xFF	; 255
    4430:	80 93 29 05 	sts	0x0529, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4434:	f8 01       	movw	r30, r16
    4436:	86 89       	ldd	r24, Z+22	; 0x16
    4438:	90 91 20 05 	lds	r25, 0x0520
    443c:	98 17       	cp	r25, r24
    443e:	10 f4       	brcc	.+4      	; 0x4444 <xTaskCreate+0x1d0>
    4440:	80 93 20 05 	sts	0x0520, r24
    4444:	90 e0       	ldi	r25, 0x00	; 0
    4446:	9c 01       	movw	r18, r24
    4448:	22 0f       	add	r18, r18
    444a:	33 1f       	adc	r19, r19
    444c:	22 0f       	add	r18, r18
    444e:	33 1f       	adc	r19, r19
    4450:	22 0f       	add	r18, r18
    4452:	33 1f       	adc	r19, r19
    4454:	82 0f       	add	r24, r18
    4456:	93 1f       	adc	r25, r19
    4458:	86 5d       	subi	r24, 0xD6	; 214
    445a:	9a 4f       	sbci	r25, 0xFA	; 250
    445c:	b7 01       	movw	r22, r14
    445e:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4462:	0f 90       	pop	r0
    4464:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4466:	80 91 1f 05 	lds	r24, 0x051F
    446a:	88 23       	and	r24, r24
    446c:	79 f0       	breq	.+30     	; 0x448c <xTaskCreate+0x218>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    446e:	e0 91 17 05 	lds	r30, 0x0517
    4472:	f0 91 18 05 	lds	r31, 0x0518
    4476:	96 89       	ldd	r25, Z+22	; 0x16
    4478:	f8 01       	movw	r30, r16
    447a:	86 89       	ldd	r24, Z+22	; 0x16
    447c:	98 17       	cp	r25, r24
    447e:	40 f4       	brcc	.+16     	; 0x4490 <xTaskCreate+0x21c>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4480:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    4484:	81 e0       	ldi	r24, 0x01	; 1
    4486:	05 c0       	rjmp	.+10     	; 0x4492 <xTaskCreate+0x21e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4488:	8f ef       	ldi	r24, 0xFF	; 255
    448a:	03 c0       	rjmp	.+6      	; 0x4492 <xTaskCreate+0x21e>
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    448c:	81 e0       	ldi	r24, 0x01	; 1
    448e:	01 c0       	rjmp	.+2      	; 0x4492 <xTaskCreate+0x21e>
    4490:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    4492:	df 91       	pop	r29
    4494:	cf 91       	pop	r28
    4496:	1f 91       	pop	r17
    4498:	0f 91       	pop	r16
    449a:	ff 90       	pop	r15
    449c:	ef 90       	pop	r14
    449e:	df 90       	pop	r13
    44a0:	bf 90       	pop	r11
    44a2:	af 90       	pop	r10
    44a4:	9f 90       	pop	r9
    44a6:	8f 90       	pop	r8
    44a8:	7f 90       	pop	r7
    44aa:	6f 90       	pop	r6
    44ac:	5f 90       	pop	r5
    44ae:	4f 90       	pop	r4
    44b0:	3f 90       	pop	r3
    44b2:	2f 90       	pop	r2
    44b4:	08 95       	ret

000044b6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    44b6:	0f 93       	push	r16
    44b8:	1f 93       	push	r17
    44ba:	cf 93       	push	r28
    44bc:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    44be:	0f b6       	in	r0, 0x3f	; 63
    44c0:	f8 94       	cli
    44c2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    44c4:	00 97       	sbiw	r24, 0x00	; 0
    44c6:	29 f4       	brne	.+10     	; 0x44d2 <vTaskDelete+0x1c>
    44c8:	c0 91 17 05 	lds	r28, 0x0517
    44cc:	d0 91 18 05 	lds	r29, 0x0518
    44d0:	01 c0       	rjmp	.+2      	; 0x44d4 <vTaskDelete+0x1e>
    44d2:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    44d4:	8e 01       	movw	r16, r28
    44d6:	0e 5f       	subi	r16, 0xFE	; 254
    44d8:	1f 4f       	sbci	r17, 0xFF	; 255
    44da:	c8 01       	movw	r24, r16
    44dc:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    44e0:	8c 89       	ldd	r24, Y+20	; 0x14
    44e2:	9d 89       	ldd	r25, Y+21	; 0x15
    44e4:	00 97       	sbiw	r24, 0x00	; 0
    44e6:	21 f0       	breq	.+8      	; 0x44f0 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    44e8:	ce 01       	movw	r24, r28
    44ea:	0c 96       	adiw	r24, 0x0c	; 12
    44ec:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    44f0:	80 91 29 05 	lds	r24, 0x0529
    44f4:	8f 5f       	subi	r24, 0xFF	; 255
    44f6:	80 93 29 05 	sts	0x0529, r24

			if( pxTCB == pxCurrentTCB )
    44fa:	80 91 17 05 	lds	r24, 0x0517
    44fe:	90 91 18 05 	lds	r25, 0x0518
    4502:	c8 17       	cp	r28, r24
    4504:	d9 07       	cpc	r29, r25
    4506:	59 f4       	brne	.+22     	; 0x451e <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4508:	89 e6       	ldi	r24, 0x69	; 105
    450a:	95 e0       	ldi	r25, 0x05	; 5
    450c:	b8 01       	movw	r22, r16
    450e:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4512:	80 91 24 05 	lds	r24, 0x0524
    4516:	8f 5f       	subi	r24, 0xFF	; 255
    4518:	80 93 24 05 	sts	0x0524, r24
    451c:	0a c0       	rjmp	.+20     	; 0x4532 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    451e:	80 91 23 05 	lds	r24, 0x0523
    4522:	81 50       	subi	r24, 0x01	; 1
    4524:	80 93 23 05 	sts	0x0523, r24
				prvDeleteTCB( pxTCB );
    4528:	ce 01       	movw	r24, r28
    452a:	0e 94 0b 21 	call	0x4216	; 0x4216 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    452e:	0e 94 a8 20 	call	0x4150	; 0x4150 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4532:	0f 90       	pop	r0
    4534:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4536:	80 91 1f 05 	lds	r24, 0x051F
    453a:	88 23       	and	r24, r24
    453c:	49 f0       	breq	.+18     	; 0x4550 <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    453e:	80 91 17 05 	lds	r24, 0x0517
    4542:	90 91 18 05 	lds	r25, 0x0518
    4546:	c8 17       	cp	r28, r24
    4548:	d9 07       	cpc	r29, r25
    454a:	11 f4       	brne	.+4      	; 0x4550 <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    454c:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4550:	df 91       	pop	r29
    4552:	cf 91       	pop	r28
    4554:	1f 91       	pop	r17
    4556:	0f 91       	pop	r16
    4558:	08 95       	ret

0000455a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    455a:	ef 92       	push	r14
    455c:	ff 92       	push	r15
    455e:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4560:	88 e1       	ldi	r24, 0x18	; 24
    4562:	91 e2       	ldi	r25, 0x21	; 33
    4564:	66 ee       	ldi	r22, 0xE6	; 230
    4566:	70 e0       	ldi	r23, 0x00	; 0
    4568:	45 e5       	ldi	r20, 0x55	; 85
    456a:	50 e0       	ldi	r21, 0x00	; 0
    456c:	20 e0       	ldi	r18, 0x00	; 0
    456e:	30 e0       	ldi	r19, 0x00	; 0
    4570:	00 e0       	ldi	r16, 0x00	; 0
    4572:	0f 2e       	mov	r0, r31
    4574:	f2 e7       	ldi	r31, 0x72	; 114
    4576:	ef 2e       	mov	r14, r31
    4578:	f5 e0       	ldi	r31, 0x05	; 5
    457a:	ff 2e       	mov	r15, r31
    457c:	f0 2d       	mov	r31, r0
    457e:	0e 94 3a 21 	call	0x4274	; 0x4274 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4582:	81 30       	cpi	r24, 0x01	; 1
    4584:	81 f4       	brne	.+32     	; 0x45a6 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4586:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4588:	8f ef       	ldi	r24, 0xFF	; 255
    458a:	9f ef       	ldi	r25, 0xFF	; 255
    458c:	90 93 1b 05 	sts	0x051B, r25
    4590:	80 93 1a 05 	sts	0x051A, r24
		xSchedulerRunning = pdTRUE;
    4594:	81 e0       	ldi	r24, 0x01	; 1
    4596:	80 93 1f 05 	sts	0x051F, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    459a:	10 92 22 05 	sts	0x0522, r1
    459e:	10 92 21 05 	sts	0x0521, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    45a2:	0e 94 24 17 	call	0x2e48	; 0x2e48 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    45a6:	0f 91       	pop	r16
    45a8:	ff 90       	pop	r15
    45aa:	ef 90       	pop	r14
    45ac:	08 95       	ret

000045ae <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    45ae:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    45b0:	10 92 1f 05 	sts	0x051F, r1
	vPortEndScheduler();
    45b4:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vPortEndScheduler>
}
    45b8:	08 95       	ret

000045ba <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    45ba:	80 91 19 05 	lds	r24, 0x0519
    45be:	8f 5f       	subi	r24, 0xFF	; 255
    45c0:	80 93 19 05 	sts	0x0519, r24
}
    45c4:	08 95       	ret

000045c6 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    45c6:	0f b6       	in	r0, 0x3f	; 63
    45c8:	f8 94       	cli
    45ca:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    45cc:	80 91 21 05 	lds	r24, 0x0521
    45d0:	90 91 22 05 	lds	r25, 0x0522
	}
	portTICK_TYPE_EXIT_CRITICAL();
    45d4:	0f 90       	pop	r0
    45d6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    45d8:	08 95       	ret

000045da <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    45da:	80 91 21 05 	lds	r24, 0x0521
    45de:	90 91 22 05 	lds	r25, 0x0522
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    45e2:	08 95       	ret

000045e4 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    45e4:	80 91 23 05 	lds	r24, 0x0523
}
    45e8:	08 95       	ret

000045ea <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    45ea:	00 97       	sbiw	r24, 0x00	; 0
    45ec:	21 f4       	brne	.+8      	; 0x45f6 <pcTaskGetName+0xc>
    45ee:	80 91 17 05 	lds	r24, 0x0517
    45f2:	90 91 18 05 	lds	r25, 0x0518
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    45f6:	49 96       	adiw	r24, 0x19	; 25
}
    45f8:	08 95       	ret

000045fa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    45fa:	cf 92       	push	r12
    45fc:	df 92       	push	r13
    45fe:	ef 92       	push	r14
    4600:	ff 92       	push	r15
    4602:	0f 93       	push	r16
    4604:	1f 93       	push	r17
    4606:	cf 93       	push	r28
    4608:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    460a:	80 91 19 05 	lds	r24, 0x0519
    460e:	88 23       	and	r24, r24
    4610:	09 f0       	breq	.+2      	; 0x4614 <xTaskIncrementTick+0x1a>
    4612:	98 c0       	rjmp	.+304    	; 0x4744 <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4614:	c0 90 21 05 	lds	r12, 0x0521
    4618:	d0 90 22 05 	lds	r13, 0x0522
    461c:	08 94       	sec
    461e:	c1 1c       	adc	r12, r1
    4620:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4622:	d0 92 22 05 	sts	0x0522, r13
    4626:	c0 92 21 05 	sts	0x0521, r12

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    462a:	c1 14       	cp	r12, r1
    462c:	d1 04       	cpc	r13, r1
    462e:	b9 f4       	brne	.+46     	; 0x465e <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    4630:	80 91 27 05 	lds	r24, 0x0527
    4634:	90 91 28 05 	lds	r25, 0x0528
    4638:	20 91 25 05 	lds	r18, 0x0525
    463c:	30 91 26 05 	lds	r19, 0x0526
    4640:	30 93 28 05 	sts	0x0528, r19
    4644:	20 93 27 05 	sts	0x0527, r18
    4648:	90 93 26 05 	sts	0x0526, r25
    464c:	80 93 25 05 	sts	0x0525, r24
    4650:	80 91 1c 05 	lds	r24, 0x051C
    4654:	8f 5f       	subi	r24, 0xFF	; 255
    4656:	80 93 1c 05 	sts	0x051C, r24
    465a:	0e 94 a8 20 	call	0x4150	; 0x4150 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    465e:	80 91 1a 05 	lds	r24, 0x051A
    4662:	90 91 1b 05 	lds	r25, 0x051B
    4666:	c8 16       	cp	r12, r24
    4668:	d9 06       	cpc	r13, r25
    466a:	20 f4       	brcc	.+8      	; 0x4674 <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    466c:	ff 24       	eor	r15, r15
    466e:	54 c0       	rjmp	.+168    	; 0x4718 <xTaskIncrementTick+0x11e>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    4670:	fe 2c       	mov	r15, r14
    4672:	03 c0       	rjmp	.+6      	; 0x467a <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4674:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    4676:	ee 24       	eor	r14, r14
    4678:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    467a:	e0 91 27 05 	lds	r30, 0x0527
    467e:	f0 91 28 05 	lds	r31, 0x0528
    4682:	80 81       	ld	r24, Z
    4684:	88 23       	and	r24, r24
    4686:	39 f4       	brne	.+14     	; 0x4696 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4688:	8f ef       	ldi	r24, 0xFF	; 255
    468a:	9f ef       	ldi	r25, 0xFF	; 255
    468c:	90 93 1b 05 	sts	0x051B, r25
    4690:	80 93 1a 05 	sts	0x051A, r24
					break;
    4694:	41 c0       	rjmp	.+130    	; 0x4718 <xTaskIncrementTick+0x11e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4696:	e0 91 27 05 	lds	r30, 0x0527
    469a:	f0 91 28 05 	lds	r31, 0x0528
    469e:	05 80       	ldd	r0, Z+5	; 0x05
    46a0:	f6 81       	ldd	r31, Z+6	; 0x06
    46a2:	e0 2d       	mov	r30, r0
    46a4:	c6 81       	ldd	r28, Z+6	; 0x06
    46a6:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    46a8:	8a 81       	ldd	r24, Y+2	; 0x02
    46aa:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    46ac:	c8 16       	cp	r12, r24
    46ae:	d9 06       	cpc	r13, r25
    46b0:	28 f4       	brcc	.+10     	; 0x46bc <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    46b2:	90 93 1b 05 	sts	0x051B, r25
    46b6:	80 93 1a 05 	sts	0x051A, r24
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    46ba:	2e c0       	rjmp	.+92     	; 0x4718 <xTaskIncrementTick+0x11e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    46bc:	8e 01       	movw	r16, r28
    46be:	0e 5f       	subi	r16, 0xFE	; 254
    46c0:	1f 4f       	sbci	r17, 0xFF	; 255
    46c2:	c8 01       	movw	r24, r16
    46c4:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    46c8:	8c 89       	ldd	r24, Y+20	; 0x14
    46ca:	9d 89       	ldd	r25, Y+21	; 0x15
    46cc:	00 97       	sbiw	r24, 0x00	; 0
    46ce:	21 f0       	breq	.+8      	; 0x46d8 <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    46d0:	ce 01       	movw	r24, r28
    46d2:	0c 96       	adiw	r24, 0x0c	; 12
    46d4:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    46d8:	8e 89       	ldd	r24, Y+22	; 0x16
    46da:	90 91 20 05 	lds	r25, 0x0520
    46de:	98 17       	cp	r25, r24
    46e0:	10 f4       	brcc	.+4      	; 0x46e6 <xTaskIncrementTick+0xec>
    46e2:	80 93 20 05 	sts	0x0520, r24
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	9c 01       	movw	r18, r24
    46ea:	22 0f       	add	r18, r18
    46ec:	33 1f       	adc	r19, r19
    46ee:	22 0f       	add	r18, r18
    46f0:	33 1f       	adc	r19, r19
    46f2:	22 0f       	add	r18, r18
    46f4:	33 1f       	adc	r19, r19
    46f6:	82 0f       	add	r24, r18
    46f8:	93 1f       	adc	r25, r19
    46fa:	86 5d       	subi	r24, 0xD6	; 214
    46fc:	9a 4f       	sbci	r25, 0xFA	; 250
    46fe:	b8 01       	movw	r22, r16
    4700:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4704:	e0 91 17 05 	lds	r30, 0x0517
    4708:	f0 91 18 05 	lds	r31, 0x0518
    470c:	9e 89       	ldd	r25, Y+22	; 0x16
    470e:	86 89       	ldd	r24, Z+22	; 0x16
    4710:	98 17       	cp	r25, r24
    4712:	08 f0       	brcs	.+2      	; 0x4716 <xTaskIncrementTick+0x11c>
    4714:	ad cf       	rjmp	.-166    	; 0x4670 <xTaskIncrementTick+0x76>
    4716:	b1 cf       	rjmp	.-158    	; 0x467a <xTaskIncrementTick+0x80>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4718:	e0 91 17 05 	lds	r30, 0x0517
    471c:	f0 91 18 05 	lds	r31, 0x0518
    4720:	86 89       	ldd	r24, Z+22	; 0x16
    4722:	90 e0       	ldi	r25, 0x00	; 0
    4724:	fc 01       	movw	r30, r24
    4726:	ee 0f       	add	r30, r30
    4728:	ff 1f       	adc	r31, r31
    472a:	ee 0f       	add	r30, r30
    472c:	ff 1f       	adc	r31, r31
    472e:	ee 0f       	add	r30, r30
    4730:	ff 1f       	adc	r31, r31
    4732:	8e 0f       	add	r24, r30
    4734:	9f 1f       	adc	r25, r31
    4736:	fc 01       	movw	r30, r24
    4738:	e6 5d       	subi	r30, 0xD6	; 214
    473a:	fa 4f       	sbci	r31, 0xFA	; 250
    473c:	80 81       	ld	r24, Z
    473e:	82 30       	cpi	r24, 0x02	; 2
    4740:	40 f4       	brcc	.+16     	; 0x4752 <xTaskIncrementTick+0x158>
    4742:	09 c0       	rjmp	.+18     	; 0x4756 <xTaskIncrementTick+0x15c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4744:	80 91 1e 05 	lds	r24, 0x051E
    4748:	8f 5f       	subi	r24, 0xFF	; 255
    474a:	80 93 1e 05 	sts	0x051E, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    474e:	ff 24       	eor	r15, r15
    4750:	02 c0       	rjmp	.+4      	; 0x4756 <xTaskIncrementTick+0x15c>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    4752:	ff 24       	eor	r15, r15
    4754:	f3 94       	inc	r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4756:	80 91 1d 05 	lds	r24, 0x051D
    475a:	88 23       	and	r24, r24
    475c:	11 f0       	breq	.+4      	; 0x4762 <xTaskIncrementTick+0x168>
		{
			xSwitchRequired = pdTRUE;
    475e:	ff 24       	eor	r15, r15
    4760:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    4762:	8f 2d       	mov	r24, r15
    4764:	df 91       	pop	r29
    4766:	cf 91       	pop	r28
    4768:	1f 91       	pop	r17
    476a:	0f 91       	pop	r16
    476c:	ff 90       	pop	r15
    476e:	ef 90       	pop	r14
    4770:	df 90       	pop	r13
    4772:	cf 90       	pop	r12
    4774:	08 95       	ret

00004776 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4776:	df 92       	push	r13
    4778:	ef 92       	push	r14
    477a:	ff 92       	push	r15
    477c:	0f 93       	push	r16
    477e:	1f 93       	push	r17
    4780:	cf 93       	push	r28
    4782:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4784:	0f b6       	in	r0, 0x3f	; 63
    4786:	f8 94       	cli
    4788:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    478a:	80 91 19 05 	lds	r24, 0x0519
    478e:	81 50       	subi	r24, 0x01	; 1
    4790:	80 93 19 05 	sts	0x0519, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4794:	80 91 19 05 	lds	r24, 0x0519
    4798:	88 23       	and	r24, r24
    479a:	09 f0       	breq	.+2      	; 0x479e <xTaskResumeAll+0x28>
    479c:	5f c0       	rjmp	.+190    	; 0x485c <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    479e:	80 91 23 05 	lds	r24, 0x0523
    47a2:	88 23       	and	r24, r24
    47a4:	91 f5       	brne	.+100    	; 0x480a <xTaskResumeAll+0x94>
    47a6:	5d c0       	rjmp	.+186    	; 0x4862 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    47a8:	e0 91 65 05 	lds	r30, 0x0565
    47ac:	f0 91 66 05 	lds	r31, 0x0566
    47b0:	c6 81       	ldd	r28, Z+6	; 0x06
    47b2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    47b4:	ce 01       	movw	r24, r28
    47b6:	0c 96       	adiw	r24, 0x0c	; 12
    47b8:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    47bc:	8e 01       	movw	r16, r28
    47be:	0e 5f       	subi	r16, 0xFE	; 254
    47c0:	1f 4f       	sbci	r17, 0xFF	; 255
    47c2:	c8 01       	movw	r24, r16
    47c4:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    47c8:	8e 89       	ldd	r24, Y+22	; 0x16
    47ca:	90 91 20 05 	lds	r25, 0x0520
    47ce:	98 17       	cp	r25, r24
    47d0:	10 f4       	brcc	.+4      	; 0x47d6 <xTaskResumeAll+0x60>
    47d2:	80 93 20 05 	sts	0x0520, r24
    47d6:	90 e0       	ldi	r25, 0x00	; 0
    47d8:	9c 01       	movw	r18, r24
    47da:	22 0f       	add	r18, r18
    47dc:	33 1f       	adc	r19, r19
    47de:	22 0f       	add	r18, r18
    47e0:	33 1f       	adc	r19, r19
    47e2:	22 0f       	add	r18, r18
    47e4:	33 1f       	adc	r19, r19
    47e6:	82 0f       	add	r24, r18
    47e8:	93 1f       	adc	r25, r19
    47ea:	86 5d       	subi	r24, 0xD6	; 214
    47ec:	9a 4f       	sbci	r25, 0xFA	; 250
    47ee:	b8 01       	movw	r22, r16
    47f0:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47f4:	e0 91 17 05 	lds	r30, 0x0517
    47f8:	f0 91 18 05 	lds	r31, 0x0518
    47fc:	9e 89       	ldd	r25, Y+22	; 0x16
    47fe:	86 89       	ldd	r24, Z+22	; 0x16
    4800:	98 17       	cp	r25, r24
    4802:	68 f0       	brcs	.+26     	; 0x481e <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    4804:	d0 92 1d 05 	sts	0x051D, r13
    4808:	0a c0       	rjmp	.+20     	; 0x481e <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    480a:	c0 e0       	ldi	r28, 0x00	; 0
    480c:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    480e:	0f 2e       	mov	r0, r31
    4810:	f0 e6       	ldi	r31, 0x60	; 96
    4812:	ef 2e       	mov	r14, r31
    4814:	f5 e0       	ldi	r31, 0x05	; 5
    4816:	ff 2e       	mov	r15, r31
    4818:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    481a:	dd 24       	eor	r13, r13
    481c:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    481e:	f7 01       	movw	r30, r14
    4820:	80 81       	ld	r24, Z
    4822:	88 23       	and	r24, r24
    4824:	09 f6       	brne	.-126    	; 0x47a8 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4826:	20 97       	sbiw	r28, 0x00	; 0
    4828:	11 f0       	breq	.+4      	; 0x482e <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    482a:	0e 94 a8 20 	call	0x4150	; 0x4150 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    482e:	c0 91 1e 05 	lds	r28, 0x051E

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4832:	cc 23       	and	r28, r28
    4834:	59 f0       	breq	.+22     	; 0x484c <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    4836:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4838:	0e 94 fd 22 	call	0x45fa	; 0x45fa <xTaskIncrementTick>
    483c:	88 23       	and	r24, r24
    483e:	11 f0       	breq	.+4      	; 0x4844 <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    4840:	00 93 1d 05 	sts	0x051D, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4844:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4846:	c1 f7       	brne	.-16     	; 0x4838 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    4848:	10 92 1e 05 	sts	0x051E, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    484c:	80 91 1d 05 	lds	r24, 0x051D
    4850:	88 23       	and	r24, r24
    4852:	31 f0       	breq	.+12     	; 0x4860 <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4854:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4858:	81 e0       	ldi	r24, 0x01	; 1
    485a:	03 c0       	rjmp	.+6      	; 0x4862 <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    485c:	80 e0       	ldi	r24, 0x00	; 0
    485e:	01 c0       	rjmp	.+2      	; 0x4862 <xTaskResumeAll+0xec>
    4860:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4862:	0f 90       	pop	r0
    4864:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    4866:	df 91       	pop	r29
    4868:	cf 91       	pop	r28
    486a:	1f 91       	pop	r17
    486c:	0f 91       	pop	r16
    486e:	ff 90       	pop	r15
    4870:	ef 90       	pop	r14
    4872:	df 90       	pop	r13
    4874:	08 95       	ret

00004876 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4876:	cf 93       	push	r28
    4878:	df 93       	push	r29
    487a:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    487c:	00 97       	sbiw	r24, 0x00	; 0
    487e:	51 f0       	breq	.+20     	; 0x4894 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4880:	0e 94 dd 22 	call	0x45ba	; 0x45ba <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4884:	ce 01       	movw	r24, r28
    4886:	60 e0       	ldi	r22, 0x00	; 0
    4888:	0e 94 c7 20 	call	0x418e	; 0x418e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    488c:	0e 94 bb 23 	call	0x4776	; 0x4776 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4890:	88 23       	and	r24, r24
    4892:	11 f4       	brne	.+4      	; 0x4898 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    4894:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4898:	df 91       	pop	r29
    489a:	cf 91       	pop	r28
    489c:	08 95       	ret

0000489e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    489e:	80 91 19 05 	lds	r24, 0x0519
    48a2:	88 23       	and	r24, r24
    48a4:	21 f0       	breq	.+8      	; 0x48ae <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    48a6:	81 e0       	ldi	r24, 0x01	; 1
    48a8:	80 93 1d 05 	sts	0x051D, r24
    48ac:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    48ae:	10 92 1d 05 	sts	0x051D, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    48b2:	20 91 20 05 	lds	r18, 0x0520
    48b6:	82 2f       	mov	r24, r18
    48b8:	90 e0       	ldi	r25, 0x00	; 0
    48ba:	fc 01       	movw	r30, r24
    48bc:	ee 0f       	add	r30, r30
    48be:	ff 1f       	adc	r31, r31
    48c0:	ee 0f       	add	r30, r30
    48c2:	ff 1f       	adc	r31, r31
    48c4:	ee 0f       	add	r30, r30
    48c6:	ff 1f       	adc	r31, r31
    48c8:	e8 0f       	add	r30, r24
    48ca:	f9 1f       	adc	r31, r25
    48cc:	e6 5d       	subi	r30, 0xD6	; 214
    48ce:	fa 4f       	sbci	r31, 0xFA	; 250
    48d0:	30 81       	ld	r19, Z
    48d2:	33 23       	and	r19, r19
    48d4:	89 f4       	brne	.+34     	; 0x48f8 <vTaskSwitchContext+0x5a>
    48d6:	21 50       	subi	r18, 0x01	; 1
    48d8:	82 2f       	mov	r24, r18
    48da:	90 e0       	ldi	r25, 0x00	; 0
    48dc:	fc 01       	movw	r30, r24
    48de:	ee 0f       	add	r30, r30
    48e0:	ff 1f       	adc	r31, r31
    48e2:	ee 0f       	add	r30, r30
    48e4:	ff 1f       	adc	r31, r31
    48e6:	ee 0f       	add	r30, r30
    48e8:	ff 1f       	adc	r31, r31
    48ea:	e8 0f       	add	r30, r24
    48ec:	f9 1f       	adc	r31, r25
    48ee:	e6 5d       	subi	r30, 0xD6	; 214
    48f0:	fa 4f       	sbci	r31, 0xFA	; 250
    48f2:	30 81       	ld	r19, Z
    48f4:	33 23       	and	r19, r19
    48f6:	79 f3       	breq	.-34     	; 0x48d6 <vTaskSwitchContext+0x38>
    48f8:	dc 01       	movw	r26, r24
    48fa:	aa 0f       	add	r26, r26
    48fc:	bb 1f       	adc	r27, r27
    48fe:	aa 0f       	add	r26, r26
    4900:	bb 1f       	adc	r27, r27
    4902:	aa 0f       	add	r26, r26
    4904:	bb 1f       	adc	r27, r27
    4906:	8a 0f       	add	r24, r26
    4908:	9b 1f       	adc	r25, r27
    490a:	dc 01       	movw	r26, r24
    490c:	a6 5d       	subi	r26, 0xD6	; 214
    490e:	ba 4f       	sbci	r27, 0xFA	; 250
    4910:	11 96       	adiw	r26, 0x01	; 1
    4912:	ed 91       	ld	r30, X+
    4914:	fc 91       	ld	r31, X
    4916:	12 97       	sbiw	r26, 0x02	; 2
    4918:	02 80       	ldd	r0, Z+2	; 0x02
    491a:	f3 81       	ldd	r31, Z+3	; 0x03
    491c:	e0 2d       	mov	r30, r0
    491e:	12 96       	adiw	r26, 0x02	; 2
    4920:	fc 93       	st	X, r31
    4922:	ee 93       	st	-X, r30
    4924:	11 97       	sbiw	r26, 0x01	; 1
    4926:	cd 01       	movw	r24, r26
    4928:	03 96       	adiw	r24, 0x03	; 3
    492a:	e8 17       	cp	r30, r24
    492c:	f9 07       	cpc	r31, r25
    492e:	31 f4       	brne	.+12     	; 0x493c <vTaskSwitchContext+0x9e>
    4930:	82 81       	ldd	r24, Z+2	; 0x02
    4932:	93 81       	ldd	r25, Z+3	; 0x03
    4934:	12 96       	adiw	r26, 0x02	; 2
    4936:	9c 93       	st	X, r25
    4938:	8e 93       	st	-X, r24
    493a:	11 97       	sbiw	r26, 0x01	; 1
    493c:	11 96       	adiw	r26, 0x01	; 1
    493e:	ed 91       	ld	r30, X+
    4940:	fc 91       	ld	r31, X
    4942:	12 97       	sbiw	r26, 0x02	; 2
    4944:	86 81       	ldd	r24, Z+6	; 0x06
    4946:	97 81       	ldd	r25, Z+7	; 0x07
    4948:	90 93 18 05 	sts	0x0518, r25
    494c:	80 93 17 05 	sts	0x0517, r24
    4950:	20 93 20 05 	sts	0x0520, r18
    4954:	08 95       	ret

00004956 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4956:	cf 93       	push	r28
    4958:	df 93       	push	r29
    495a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    495c:	60 91 17 05 	lds	r22, 0x0517
    4960:	70 91 18 05 	lds	r23, 0x0518
    4964:	64 5f       	subi	r22, 0xF4	; 244
    4966:	7f 4f       	sbci	r23, 0xFF	; 255
    4968:	0e 94 39 16 	call	0x2c72	; 0x2c72 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    496c:	ce 01       	movw	r24, r28
    496e:	61 e0       	ldi	r22, 0x01	; 1
    4970:	0e 94 c7 20 	call	0x418e	; 0x418e <prvAddCurrentTaskToDelayedList>
}
    4974:	df 91       	pop	r29
    4976:	cf 91       	pop	r28
    4978:	08 95       	ret

0000497a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    497a:	cf 93       	push	r28
    497c:	df 93       	push	r29
    497e:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4980:	e0 91 17 05 	lds	r30, 0x0517
    4984:	f0 91 18 05 	lds	r31, 0x0518
    4988:	70 68       	ori	r23, 0x80	; 128
    498a:	75 87       	std	Z+13, r23	; 0x0d
    498c:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    498e:	60 91 17 05 	lds	r22, 0x0517
    4992:	70 91 18 05 	lds	r23, 0x0518
    4996:	64 5f       	subi	r22, 0xF4	; 244
    4998:	7f 4f       	sbci	r23, 0xFF	; 255
    499a:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    499e:	ce 01       	movw	r24, r28
    49a0:	61 e0       	ldi	r22, 0x01	; 1
    49a2:	0e 94 c7 20 	call	0x418e	; 0x418e <prvAddCurrentTaskToDelayedList>
}
    49a6:	df 91       	pop	r29
    49a8:	cf 91       	pop	r28
    49aa:	08 95       	ret

000049ac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    49ac:	0f 93       	push	r16
    49ae:	1f 93       	push	r17
    49b0:	cf 93       	push	r28
    49b2:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49b4:	dc 01       	movw	r26, r24
    49b6:	15 96       	adiw	r26, 0x05	; 5
    49b8:	ed 91       	ld	r30, X+
    49ba:	fc 91       	ld	r31, X
    49bc:	16 97       	sbiw	r26, 0x06	; 6
    49be:	06 81       	ldd	r16, Z+6	; 0x06
    49c0:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    49c2:	e8 01       	movw	r28, r16
    49c4:	2c 96       	adiw	r28, 0x0c	; 12
    49c6:	ce 01       	movw	r24, r28
    49c8:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    49cc:	80 91 19 05 	lds	r24, 0x0519
    49d0:	88 23       	and	r24, r24
    49d2:	e9 f4       	brne	.+58     	; 0x4a0e <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    49d4:	e8 01       	movw	r28, r16
    49d6:	22 96       	adiw	r28, 0x02	; 2
    49d8:	ce 01       	movw	r24, r28
    49da:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    49de:	f8 01       	movw	r30, r16
    49e0:	86 89       	ldd	r24, Z+22	; 0x16
    49e2:	90 91 20 05 	lds	r25, 0x0520
    49e6:	98 17       	cp	r25, r24
    49e8:	10 f4       	brcc	.+4      	; 0x49ee <xTaskRemoveFromEventList+0x42>
    49ea:	80 93 20 05 	sts	0x0520, r24
    49ee:	90 e0       	ldi	r25, 0x00	; 0
    49f0:	9c 01       	movw	r18, r24
    49f2:	22 0f       	add	r18, r18
    49f4:	33 1f       	adc	r19, r19
    49f6:	22 0f       	add	r18, r18
    49f8:	33 1f       	adc	r19, r19
    49fa:	22 0f       	add	r18, r18
    49fc:	33 1f       	adc	r19, r19
    49fe:	82 0f       	add	r24, r18
    4a00:	93 1f       	adc	r25, r19
    4a02:	86 5d       	subi	r24, 0xD6	; 214
    4a04:	9a 4f       	sbci	r25, 0xFA	; 250
    4a06:	be 01       	movw	r22, r28
    4a08:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
    4a0c:	05 c0       	rjmp	.+10     	; 0x4a18 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4a0e:	80 e6       	ldi	r24, 0x60	; 96
    4a10:	95 e0       	ldi	r25, 0x05	; 5
    4a12:	be 01       	movw	r22, r28
    4a14:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a18:	e0 91 17 05 	lds	r30, 0x0517
    4a1c:	f0 91 18 05 	lds	r31, 0x0518
    4a20:	d8 01       	movw	r26, r16
    4a22:	56 96       	adiw	r26, 0x16	; 22
    4a24:	9c 91       	ld	r25, X
    4a26:	56 97       	sbiw	r26, 0x16	; 22
    4a28:	86 89       	ldd	r24, Z+22	; 0x16
    4a2a:	89 17       	cp	r24, r25
    4a2c:	20 f4       	brcc	.+8      	; 0x4a36 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4a2e:	81 e0       	ldi	r24, 0x01	; 1
    4a30:	80 93 1d 05 	sts	0x051D, r24
    4a34:	01 c0       	rjmp	.+2      	; 0x4a38 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    4a36:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    4a38:	df 91       	pop	r29
    4a3a:	cf 91       	pop	r28
    4a3c:	1f 91       	pop	r17
    4a3e:	0f 91       	pop	r16
    4a40:	08 95       	ret

00004a42 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4a42:	0f 93       	push	r16
    4a44:	1f 93       	push	r17
    4a46:	cf 93       	push	r28
    4a48:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4a4a:	70 68       	ori	r23, 0x80	; 128
    4a4c:	fc 01       	movw	r30, r24
    4a4e:	71 83       	std	Z+1, r23	; 0x01
    4a50:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a52:	c6 81       	ldd	r28, Z+6	; 0x06
    4a54:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4a56:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4a5a:	8e 01       	movw	r16, r28
    4a5c:	0e 5f       	subi	r16, 0xFE	; 254
    4a5e:	1f 4f       	sbci	r17, 0xFF	; 255
    4a60:	c8 01       	movw	r24, r16
    4a62:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4a66:	8e 89       	ldd	r24, Y+22	; 0x16
    4a68:	90 91 20 05 	lds	r25, 0x0520
    4a6c:	98 17       	cp	r25, r24
    4a6e:	10 f4       	brcc	.+4      	; 0x4a74 <vTaskRemoveFromUnorderedEventList+0x32>
    4a70:	80 93 20 05 	sts	0x0520, r24
    4a74:	90 e0       	ldi	r25, 0x00	; 0
    4a76:	9c 01       	movw	r18, r24
    4a78:	22 0f       	add	r18, r18
    4a7a:	33 1f       	adc	r19, r19
    4a7c:	22 0f       	add	r18, r18
    4a7e:	33 1f       	adc	r19, r19
    4a80:	22 0f       	add	r18, r18
    4a82:	33 1f       	adc	r19, r19
    4a84:	82 0f       	add	r24, r18
    4a86:	93 1f       	adc	r25, r19
    4a88:	86 5d       	subi	r24, 0xD6	; 214
    4a8a:	9a 4f       	sbci	r25, 0xFA	; 250
    4a8c:	b8 01       	movw	r22, r16
    4a8e:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a92:	e0 91 17 05 	lds	r30, 0x0517
    4a96:	f0 91 18 05 	lds	r31, 0x0518
    4a9a:	9e 89       	ldd	r25, Y+22	; 0x16
    4a9c:	86 89       	ldd	r24, Z+22	; 0x16
    4a9e:	89 17       	cp	r24, r25
    4aa0:	18 f4       	brcc	.+6      	; 0x4aa8 <vTaskRemoveFromUnorderedEventList+0x66>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4aa2:	81 e0       	ldi	r24, 0x01	; 1
    4aa4:	80 93 1d 05 	sts	0x051D, r24
	}
}
    4aa8:	df 91       	pop	r29
    4aaa:	cf 91       	pop	r28
    4aac:	1f 91       	pop	r17
    4aae:	0f 91       	pop	r16
    4ab0:	08 95       	ret

00004ab2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4ab2:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4ab4:	0f b6       	in	r0, 0x3f	; 63
    4ab6:	f8 94       	cli
    4ab8:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4aba:	80 91 1c 05 	lds	r24, 0x051C
    4abe:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4ac0:	80 91 21 05 	lds	r24, 0x0521
    4ac4:	90 91 22 05 	lds	r25, 0x0522
    4ac8:	92 83       	std	Z+2, r25	; 0x02
    4aca:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4acc:	0f 90       	pop	r0
    4ace:	0f be       	out	0x3f, r0	; 63
}
    4ad0:	08 95       	ret

00004ad2 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4ad2:	fc 01       	movw	r30, r24
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4ad4:	80 91 1c 05 	lds	r24, 0x051C
    4ad8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4ada:	80 91 21 05 	lds	r24, 0x0521
    4ade:	90 91 22 05 	lds	r25, 0x0522
    4ae2:	92 83       	std	Z+2, r25	; 0x02
    4ae4:	81 83       	std	Z+1, r24	; 0x01
}
    4ae6:	08 95       	ret

00004ae8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4ae8:	fc 01       	movw	r30, r24
    4aea:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4aec:	0f b6       	in	r0, 0x3f	; 63
    4aee:	f8 94       	cli
    4af0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4af2:	20 91 21 05 	lds	r18, 0x0521
    4af6:	30 91 22 05 	lds	r19, 0x0522
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4afa:	81 81       	ldd	r24, Z+1	; 0x01
    4afc:	92 81       	ldd	r25, Z+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4afe:	40 91 1c 05 	lds	r20, 0x051C
    4b02:	50 81       	ld	r21, Z
    4b04:	54 17       	cp	r21, r20
    4b06:	19 f0       	breq	.+6      	; 0x4b0e <xTaskCheckForTimeOut+0x26>
    4b08:	28 17       	cp	r18, r24
    4b0a:	39 07       	cpc	r19, r25
    4b0c:	b0 f4       	brcc	.+44     	; 0x4b3a <xTaskCheckForTimeOut+0x52>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4b0e:	28 1b       	sub	r18, r24
    4b10:	39 0b       	sbc	r19, r25
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4b12:	8d 91       	ld	r24, X+
    4b14:	9c 91       	ld	r25, X
    4b16:	11 97       	sbiw	r26, 0x01	; 1
    4b18:	28 17       	cp	r18, r24
    4b1a:	39 07       	cpc	r19, r25
    4b1c:	48 f4       	brcc	.+18     	; 0x4b30 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4b1e:	82 1b       	sub	r24, r18
    4b20:	93 0b       	sbc	r25, r19
    4b22:	8d 93       	st	X+, r24
    4b24:	9c 93       	st	X, r25
			vTaskInternalSetTimeOutState( pxTimeOut );
    4b26:	cf 01       	movw	r24, r30
    4b28:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4b2c:	80 e0       	ldi	r24, 0x00	; 0
    4b2e:	06 c0       	rjmp	.+12     	; 0x4b3c <xTaskCheckForTimeOut+0x54>
		}
		else
		{
			*pxTicksToWait = 0;
    4b30:	11 96       	adiw	r26, 0x01	; 1
    4b32:	1c 92       	st	X, r1
    4b34:	1e 92       	st	-X, r1
			xReturn = pdTRUE;
    4b36:	81 e0       	ldi	r24, 0x01	; 1
    4b38:	01 c0       	rjmp	.+2      	; 0x4b3c <xTaskCheckForTimeOut+0x54>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4b3a:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    4b3c:	0f 90       	pop	r0
    4b3e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    4b40:	08 95       	ret

00004b42 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    4b42:	81 e0       	ldi	r24, 0x01	; 1
    4b44:	80 93 1d 05 	sts	0x051D, r24
}
    4b48:	08 95       	ret

00004b4a <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4b4a:	80 91 17 05 	lds	r24, 0x0517
    4b4e:	90 91 18 05 	lds	r25, 0x0518

		return xReturn;
	}
    4b52:	08 95       	ret

00004b54 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4b54:	e0 91 17 05 	lds	r30, 0x0517
    4b58:	f0 91 18 05 	lds	r31, 0x0518
    4b5c:	84 85       	ldd	r24, Z+12	; 0x0c
    4b5e:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b60:	e0 91 17 05 	lds	r30, 0x0517
    4b64:	f0 91 18 05 	lds	r31, 0x0518
    4b68:	a0 91 17 05 	lds	r26, 0x0517
    4b6c:	b0 91 18 05 	lds	r27, 0x0518
    4b70:	56 96       	adiw	r26, 0x16	; 22
    4b72:	4c 91       	ld	r20, X
    4b74:	56 97       	sbiw	r26, 0x16	; 22
    4b76:	24 e0       	ldi	r18, 0x04	; 4
    4b78:	30 e0       	ldi	r19, 0x00	; 0
    4b7a:	24 1b       	sub	r18, r20
    4b7c:	31 09       	sbc	r19, r1
    4b7e:	35 87       	std	Z+13, r19	; 0x0d
    4b80:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    4b82:	08 95       	ret

00004b84 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4b84:	0f 93       	push	r16
    4b86:	1f 93       	push	r17
    4b88:	cf 93       	push	r28
    4b8a:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4b8c:	0f b6       	in	r0, 0x3f	; 63
    4b8e:	f8 94       	cli
    4b90:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4b92:	e0 91 17 05 	lds	r30, 0x0517
    4b96:	f0 91 18 05 	lds	r31, 0x0518
    4b9a:	81 a1       	lds	r24, 0x41
    4b9c:	92 a1       	lds	r25, 0x42
    4b9e:	a3 a1       	lds	r26, 0x43
    4ba0:	b4 a1       	lds	r27, 0x44
    4ba2:	00 97       	sbiw	r24, 0x00	; 0
    4ba4:	a1 05       	cpc	r26, r1
    4ba6:	b1 05       	cpc	r27, r1
    4ba8:	79 f4       	brne	.+30     	; 0x4bc8 <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4baa:	e0 91 17 05 	lds	r30, 0x0517
    4bae:	f0 91 18 05 	lds	r31, 0x0518
    4bb2:	81 e0       	ldi	r24, 0x01	; 1
    4bb4:	85 a3       	lds	r24, 0x55

				if( xTicksToWait > ( TickType_t ) 0 )
    4bb6:	61 15       	cp	r22, r1
    4bb8:	71 05       	cpc	r23, r1
    4bba:	31 f0       	breq	.+12     	; 0x4bc8 <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4bbc:	cb 01       	movw	r24, r22
    4bbe:	61 e0       	ldi	r22, 0x01	; 1
    4bc0:	0e 94 c7 20 	call	0x418e	; 0x418e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4bc4:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4bc8:	0f 90       	pop	r0
    4bca:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4bcc:	0f b6       	in	r0, 0x3f	; 63
    4bce:	f8 94       	cli
    4bd0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4bd2:	e0 91 17 05 	lds	r30, 0x0517
    4bd6:	f0 91 18 05 	lds	r31, 0x0518
    4bda:	01 a1       	lds	r16, 0x41
    4bdc:	12 a1       	lds	r17, 0x42
    4bde:	23 a1       	lds	r18, 0x43
    4be0:	34 a1       	lds	r19, 0x44

			if( ulReturn != 0UL )
    4be2:	01 15       	cp	r16, r1
    4be4:	11 05       	cpc	r17, r1
    4be6:	21 05       	cpc	r18, r1
    4be8:	31 05       	cpc	r19, r1
    4bea:	c1 f0       	breq	.+48     	; 0x4c1c <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    4bec:	cc 23       	and	r28, r28
    4bee:	49 f0       	breq	.+18     	; 0x4c02 <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4bf0:	e0 91 17 05 	lds	r30, 0x0517
    4bf4:	f0 91 18 05 	lds	r31, 0x0518
    4bf8:	11 a2       	lds	r17, 0x91
    4bfa:	12 a2       	lds	r17, 0x92
    4bfc:	13 a2       	lds	r17, 0x93
    4bfe:	14 a2       	lds	r17, 0x94
    4c00:	0d c0       	rjmp	.+26     	; 0x4c1c <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4c02:	e0 91 17 05 	lds	r30, 0x0517
    4c06:	f0 91 18 05 	lds	r31, 0x0518
    4c0a:	d9 01       	movw	r26, r18
    4c0c:	c8 01       	movw	r24, r16
    4c0e:	01 97       	sbiw	r24, 0x01	; 1
    4c10:	a1 09       	sbc	r26, r1
    4c12:	b1 09       	sbc	r27, r1
    4c14:	81 a3       	lds	r24, 0x51
    4c16:	92 a3       	lds	r25, 0x52
    4c18:	a3 a3       	lds	r26, 0x53
    4c1a:	b4 a3       	lds	r27, 0x54
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4c1c:	e0 91 17 05 	lds	r30, 0x0517
    4c20:	f0 91 18 05 	lds	r31, 0x0518
    4c24:	15 a2       	lds	r17, 0x95
		}
		taskEXIT_CRITICAL();
    4c26:	0f 90       	pop	r0
    4c28:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    4c2a:	60 2f       	mov	r22, r16
    4c2c:	71 2f       	mov	r23, r17
    4c2e:	82 2f       	mov	r24, r18
    4c30:	93 2f       	mov	r25, r19
    4c32:	cf 91       	pop	r28
    4c34:	1f 91       	pop	r17
    4c36:	0f 91       	pop	r16
    4c38:	08 95       	ret

00004c3a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4c3a:	8f 92       	push	r8
    4c3c:	9f 92       	push	r9
    4c3e:	af 92       	push	r10
    4c40:	bf 92       	push	r11
    4c42:	ef 92       	push	r14
    4c44:	ff 92       	push	r15
    4c46:	0f 93       	push	r16
    4c48:	1f 93       	push	r17
    4c4a:	dc 01       	movw	r26, r24
    4c4c:	cb 01       	movw	r24, r22
    4c4e:	49 01       	movw	r8, r18
    4c50:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4c52:	0f b6       	in	r0, 0x3f	; 63
    4c54:	f8 94       	cli
    4c56:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4c58:	e0 91 17 05 	lds	r30, 0x0517
    4c5c:	f0 91 18 05 	lds	r31, 0x0518
    4c60:	25 a1       	lds	r18, 0x45
    4c62:	22 30       	cpi	r18, 0x02	; 2
    4c64:	19 f1       	breq	.+70     	; 0x4cac <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4c66:	e0 91 17 05 	lds	r30, 0x0517
    4c6a:	f0 91 18 05 	lds	r31, 0x0518
    4c6e:	41 a1       	lds	r20, 0x41
    4c70:	52 a1       	lds	r21, 0x42
    4c72:	63 a1       	lds	r22, 0x43
    4c74:	74 a1       	lds	r23, 0x44
    4c76:	80 95       	com	r24
    4c78:	90 95       	com	r25
    4c7a:	a0 95       	com	r26
    4c7c:	b0 95       	com	r27
    4c7e:	84 23       	and	r24, r20
    4c80:	95 23       	and	r25, r21
    4c82:	a6 23       	and	r26, r22
    4c84:	b7 23       	and	r27, r23
    4c86:	81 a3       	lds	r24, 0x51
    4c88:	92 a3       	lds	r25, 0x52
    4c8a:	a3 a3       	lds	r26, 0x53
    4c8c:	b4 a3       	lds	r27, 0x54

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c8e:	e0 91 17 05 	lds	r30, 0x0517
    4c92:	f0 91 18 05 	lds	r31, 0x0518
    4c96:	81 e0       	ldi	r24, 0x01	; 1
    4c98:	85 a3       	lds	r24, 0x55

				if( xTicksToWait > ( TickType_t ) 0 )
    4c9a:	e1 14       	cp	r14, r1
    4c9c:	f1 04       	cpc	r15, r1
    4c9e:	31 f0       	breq	.+12     	; 0x4cac <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4ca0:	c7 01       	movw	r24, r14
    4ca2:	61 e0       	ldi	r22, 0x01	; 1
    4ca4:	0e 94 c7 20 	call	0x418e	; 0x418e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4ca8:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4cac:	0f 90       	pop	r0
    4cae:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4cb0:	0f b6       	in	r0, 0x3f	; 63
    4cb2:	f8 94       	cli
    4cb4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4cb6:	01 15       	cp	r16, r1
    4cb8:	11 05       	cpc	r17, r1
    4cba:	69 f0       	breq	.+26     	; 0x4cd6 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4cbc:	e0 91 17 05 	lds	r30, 0x0517
    4cc0:	f0 91 18 05 	lds	r31, 0x0518
    4cc4:	81 a1       	lds	r24, 0x41
    4cc6:	92 a1       	lds	r25, 0x42
    4cc8:	a3 a1       	lds	r26, 0x43
    4cca:	b4 a1       	lds	r27, 0x44
    4ccc:	f8 01       	movw	r30, r16
    4cce:	80 83       	st	Z, r24
    4cd0:	91 83       	std	Z+1, r25	; 0x01
    4cd2:	a2 83       	std	Z+2, r26	; 0x02
    4cd4:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4cd6:	e0 91 17 05 	lds	r30, 0x0517
    4cda:	f0 91 18 05 	lds	r31, 0x0518
    4cde:	85 a1       	lds	r24, 0x45
    4ce0:	82 30       	cpi	r24, 0x02	; 2
    4ce2:	b1 f4       	brne	.+44     	; 0x4d10 <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4ce4:	e0 91 17 05 	lds	r30, 0x0517
    4ce8:	f0 91 18 05 	lds	r31, 0x0518
    4cec:	81 a1       	lds	r24, 0x41
    4cee:	92 a1       	lds	r25, 0x42
    4cf0:	a3 a1       	lds	r26, 0x43
    4cf2:	b4 a1       	lds	r27, 0x44
    4cf4:	80 94       	com	r8
    4cf6:	90 94       	com	r9
    4cf8:	a0 94       	com	r10
    4cfa:	b0 94       	com	r11
    4cfc:	88 22       	and	r8, r24
    4cfe:	99 22       	and	r9, r25
    4d00:	aa 22       	and	r10, r26
    4d02:	bb 22       	and	r11, r27
    4d04:	81 a2       	lds	r24, 0x91
    4d06:	92 a2       	lds	r25, 0x92
    4d08:	a3 a2       	lds	r26, 0x93
    4d0a:	b4 a2       	lds	r27, 0x94
				xReturn = pdTRUE;
    4d0c:	81 e0       	ldi	r24, 0x01	; 1
    4d0e:	01 c0       	rjmp	.+2      	; 0x4d12 <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4d10:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4d12:	e0 91 17 05 	lds	r30, 0x0517
    4d16:	f0 91 18 05 	lds	r31, 0x0518
    4d1a:	15 a2       	lds	r17, 0x95
		}
		taskEXIT_CRITICAL();
    4d1c:	0f 90       	pop	r0
    4d1e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4d20:	1f 91       	pop	r17
    4d22:	0f 91       	pop	r16
    4d24:	ff 90       	pop	r15
    4d26:	ef 90       	pop	r14
    4d28:	bf 90       	pop	r11
    4d2a:	af 90       	pop	r10
    4d2c:	9f 90       	pop	r9
    4d2e:	8f 90       	pop	r8
    4d30:	08 95       	ret

00004d32 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4d32:	0f 93       	push	r16
    4d34:	1f 93       	push	r17
    4d36:	cf 93       	push	r28
    4d38:	df 93       	push	r29
    4d3a:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    4d3c:	0f b6       	in	r0, 0x3f	; 63
    4d3e:	f8 94       	cli
    4d40:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4d42:	01 15       	cp	r16, r1
    4d44:	11 05       	cpc	r17, r1
    4d46:	49 f0       	breq	.+18     	; 0x4d5a <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4d48:	89 a1       	lds	r24, 0x49
    4d4a:	9a a1       	lds	r25, 0x4a
    4d4c:	ab a1       	lds	r26, 0x4b
    4d4e:	bc a1       	lds	r27, 0x4c
    4d50:	f8 01       	movw	r30, r16
    4d52:	80 83       	st	Z, r24
    4d54:	91 83       	std	Z+1, r25	; 0x01
    4d56:	a2 83       	std	Z+2, r26	; 0x02
    4d58:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4d5a:	3d a1       	lds	r19, 0x4d

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4d5c:	82 e0       	ldi	r24, 0x02	; 2
    4d5e:	8d a3       	lds	r24, 0x5d

			switch( eAction )
    4d60:	22 30       	cpi	r18, 0x02	; 2
    4d62:	b9 f0       	breq	.+46     	; 0x4d92 <xTaskGenericNotify+0x60>
    4d64:	23 30       	cpi	r18, 0x03	; 3
    4d66:	18 f4       	brcc	.+6      	; 0x4d6e <xTaskGenericNotify+0x3c>
    4d68:	21 30       	cpi	r18, 0x01	; 1
    4d6a:	51 f5       	brne	.+84     	; 0x4dc0 <xTaskGenericNotify+0x8e>
    4d6c:	05 c0       	rjmp	.+10     	; 0x4d78 <xTaskGenericNotify+0x46>
    4d6e:	23 30       	cpi	r18, 0x03	; 3
    4d70:	e1 f0       	breq	.+56     	; 0x4daa <xTaskGenericNotify+0x78>
    4d72:	24 30       	cpi	r18, 0x04	; 4
    4d74:	29 f5       	brne	.+74     	; 0x4dc0 <xTaskGenericNotify+0x8e>
    4d76:	1e c0       	rjmp	.+60     	; 0x4db4 <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4d78:	89 a1       	lds	r24, 0x49
    4d7a:	9a a1       	lds	r25, 0x4a
    4d7c:	ab a1       	lds	r26, 0x4b
    4d7e:	bc a1       	lds	r27, 0x4c
    4d80:	48 2b       	or	r20, r24
    4d82:	59 2b       	or	r21, r25
    4d84:	6a 2b       	or	r22, r26
    4d86:	7b 2b       	or	r23, r27
    4d88:	49 a3       	lds	r20, 0x59
    4d8a:	5a a3       	lds	r21, 0x5a
    4d8c:	6b a3       	lds	r22, 0x5b
    4d8e:	7c a3       	lds	r23, 0x5c
					break;
    4d90:	17 c0       	rjmp	.+46     	; 0x4dc0 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4d92:	89 a1       	lds	r24, 0x49
    4d94:	9a a1       	lds	r25, 0x4a
    4d96:	ab a1       	lds	r26, 0x4b
    4d98:	bc a1       	lds	r27, 0x4c
    4d9a:	01 96       	adiw	r24, 0x01	; 1
    4d9c:	a1 1d       	adc	r26, r1
    4d9e:	b1 1d       	adc	r27, r1
    4da0:	89 a3       	lds	r24, 0x59
    4da2:	9a a3       	lds	r25, 0x5a
    4da4:	ab a3       	lds	r26, 0x5b
    4da6:	bc a3       	lds	r27, 0x5c
					break;
    4da8:	0b c0       	rjmp	.+22     	; 0x4dc0 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4daa:	49 a3       	lds	r20, 0x59
    4dac:	5a a3       	lds	r21, 0x5a
    4dae:	6b a3       	lds	r22, 0x5b
    4db0:	7c a3       	lds	r23, 0x5c
					break;
    4db2:	06 c0       	rjmp	.+12     	; 0x4dc0 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4db4:	32 30       	cpi	r19, 0x02	; 2
    4db6:	71 f1       	breq	.+92     	; 0x4e14 <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4db8:	49 a3       	lds	r20, 0x59
    4dba:	5a a3       	lds	r21, 0x5a
    4dbc:	6b a3       	lds	r22, 0x5b
    4dbe:	7c a3       	lds	r23, 0x5c

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4dc0:	31 30       	cpi	r19, 0x01	; 1
    4dc2:	51 f5       	brne	.+84     	; 0x4e18 <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4dc4:	8e 01       	movw	r16, r28
    4dc6:	0e 5f       	subi	r16, 0xFE	; 254
    4dc8:	1f 4f       	sbci	r17, 0xFF	; 255
    4dca:	c8 01       	movw	r24, r16
    4dcc:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4dd0:	8e 89       	ldd	r24, Y+22	; 0x16
    4dd2:	90 91 20 05 	lds	r25, 0x0520
    4dd6:	98 17       	cp	r25, r24
    4dd8:	10 f4       	brcc	.+4      	; 0x4dde <xTaskGenericNotify+0xac>
    4dda:	80 93 20 05 	sts	0x0520, r24
    4dde:	90 e0       	ldi	r25, 0x00	; 0
    4de0:	9c 01       	movw	r18, r24
    4de2:	22 0f       	add	r18, r18
    4de4:	33 1f       	adc	r19, r19
    4de6:	22 0f       	add	r18, r18
    4de8:	33 1f       	adc	r19, r19
    4dea:	22 0f       	add	r18, r18
    4dec:	33 1f       	adc	r19, r19
    4dee:	82 0f       	add	r24, r18
    4df0:	93 1f       	adc	r25, r19
    4df2:	86 5d       	subi	r24, 0xD6	; 214
    4df4:	9a 4f       	sbci	r25, 0xFA	; 250
    4df6:	b8 01       	movw	r22, r16
    4df8:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4dfc:	e0 91 17 05 	lds	r30, 0x0517
    4e00:	f0 91 18 05 	lds	r31, 0x0518
    4e04:	9e 89       	ldd	r25, Y+22	; 0x16
    4e06:	86 89       	ldd	r24, Z+22	; 0x16
    4e08:	89 17       	cp	r24, r25
    4e0a:	40 f4       	brcc	.+16     	; 0x4e1c <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4e0c:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vPortYield>
    4e10:	81 e0       	ldi	r24, 0x01	; 1
    4e12:	05 c0       	rjmp	.+10     	; 0x4e1e <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4e14:	80 e0       	ldi	r24, 0x00	; 0
    4e16:	03 c0       	rjmp	.+6      	; 0x4e1e <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4e18:	81 e0       	ldi	r24, 0x01	; 1
    4e1a:	01 c0       	rjmp	.+2      	; 0x4e1e <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e1c:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4e1e:	0f 90       	pop	r0
    4e20:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4e22:	df 91       	pop	r29
    4e24:	cf 91       	pop	r28
    4e26:	1f 91       	pop	r17
    4e28:	0f 91       	pop	r16
    4e2a:	08 95       	ret

00004e2c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4e2c:	ef 92       	push	r14
    4e2e:	ff 92       	push	r15
    4e30:	0f 93       	push	r16
    4e32:	1f 93       	push	r17
    4e34:	cf 93       	push	r28
    4e36:	df 93       	push	r29
    4e38:	ec 01       	movw	r28, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    4e3a:	01 15       	cp	r16, r1
    4e3c:	11 05       	cpc	r17, r1
    4e3e:	49 f0       	breq	.+18     	; 0x4e52 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4e40:	89 a1       	lds	r24, 0x49
    4e42:	9a a1       	lds	r25, 0x4a
    4e44:	ab a1       	lds	r26, 0x4b
    4e46:	bc a1       	lds	r27, 0x4c
    4e48:	f8 01       	movw	r30, r16
    4e4a:	80 83       	st	Z, r24
    4e4c:	91 83       	std	Z+1, r25	; 0x01
    4e4e:	a2 83       	std	Z+2, r26	; 0x02
    4e50:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4e52:	3d a1       	lds	r19, 0x4d
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4e54:	82 e0       	ldi	r24, 0x02	; 2
    4e56:	8d a3       	lds	r24, 0x5d

			switch( eAction )
    4e58:	22 30       	cpi	r18, 0x02	; 2
    4e5a:	b9 f0       	breq	.+46     	; 0x4e8a <xTaskGenericNotifyFromISR+0x5e>
    4e5c:	23 30       	cpi	r18, 0x03	; 3
    4e5e:	18 f4       	brcc	.+6      	; 0x4e66 <xTaskGenericNotifyFromISR+0x3a>
    4e60:	21 30       	cpi	r18, 0x01	; 1
    4e62:	59 f5       	brne	.+86     	; 0x4eba <xTaskGenericNotifyFromISR+0x8e>
    4e64:	05 c0       	rjmp	.+10     	; 0x4e70 <xTaskGenericNotifyFromISR+0x44>
    4e66:	23 30       	cpi	r18, 0x03	; 3
    4e68:	e1 f0       	breq	.+56     	; 0x4ea2 <xTaskGenericNotifyFromISR+0x76>
    4e6a:	24 30       	cpi	r18, 0x04	; 4
    4e6c:	31 f5       	brne	.+76     	; 0x4eba <xTaskGenericNotifyFromISR+0x8e>
    4e6e:	1e c0       	rjmp	.+60     	; 0x4eac <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4e70:	89 a1       	lds	r24, 0x49
    4e72:	9a a1       	lds	r25, 0x4a
    4e74:	ab a1       	lds	r26, 0x4b
    4e76:	bc a1       	lds	r27, 0x4c
    4e78:	84 2b       	or	r24, r20
    4e7a:	95 2b       	or	r25, r21
    4e7c:	a6 2b       	or	r26, r22
    4e7e:	b7 2b       	or	r27, r23
    4e80:	89 a3       	lds	r24, 0x59
    4e82:	9a a3       	lds	r25, 0x5a
    4e84:	ab a3       	lds	r26, 0x5b
    4e86:	bc a3       	lds	r27, 0x5c
					break;
    4e88:	18 c0       	rjmp	.+48     	; 0x4eba <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4e8a:	89 a1       	lds	r24, 0x49
    4e8c:	9a a1       	lds	r25, 0x4a
    4e8e:	ab a1       	lds	r26, 0x4b
    4e90:	bc a1       	lds	r27, 0x4c
    4e92:	01 96       	adiw	r24, 0x01	; 1
    4e94:	a1 1d       	adc	r26, r1
    4e96:	b1 1d       	adc	r27, r1
    4e98:	89 a3       	lds	r24, 0x59
    4e9a:	9a a3       	lds	r25, 0x5a
    4e9c:	ab a3       	lds	r26, 0x5b
    4e9e:	bc a3       	lds	r27, 0x5c
					break;
    4ea0:	0c c0       	rjmp	.+24     	; 0x4eba <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4ea2:	49 a3       	lds	r20, 0x59
    4ea4:	5a a3       	lds	r21, 0x5a
    4ea6:	6b a3       	lds	r22, 0x5b
    4ea8:	7c a3       	lds	r23, 0x5c
					break;
    4eaa:	07 c0       	rjmp	.+14     	; 0x4eba <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4eac:	32 30       	cpi	r19, 0x02	; 2
    4eae:	09 f4       	brne	.+2      	; 0x4eb2 <xTaskGenericNotifyFromISR+0x86>
    4eb0:	40 c0       	rjmp	.+128    	; 0x4f32 <xTaskGenericNotifyFromISR+0x106>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4eb2:	49 a3       	lds	r20, 0x59
    4eb4:	5a a3       	lds	r21, 0x5a
    4eb6:	6b a3       	lds	r22, 0x5b
    4eb8:	7c a3       	lds	r23, 0x5c

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4eba:	31 30       	cpi	r19, 0x01	; 1
    4ebc:	e1 f5       	brne	.+120    	; 0x4f36 <xTaskGenericNotifyFromISR+0x10a>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ebe:	80 91 19 05 	lds	r24, 0x0519
    4ec2:	88 23       	and	r24, r24
    4ec4:	e9 f4       	brne	.+58     	; 0x4f00 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4ec6:	8e 01       	movw	r16, r28
    4ec8:	0e 5f       	subi	r16, 0xFE	; 254
    4eca:	1f 4f       	sbci	r17, 0xFF	; 255
    4ecc:	c8 01       	movw	r24, r16
    4ece:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4ed2:	8e 89       	ldd	r24, Y+22	; 0x16
    4ed4:	90 91 20 05 	lds	r25, 0x0520
    4ed8:	98 17       	cp	r25, r24
    4eda:	10 f4       	brcc	.+4      	; 0x4ee0 <xTaskGenericNotifyFromISR+0xb4>
    4edc:	80 93 20 05 	sts	0x0520, r24
    4ee0:	90 e0       	ldi	r25, 0x00	; 0
    4ee2:	9c 01       	movw	r18, r24
    4ee4:	22 0f       	add	r18, r18
    4ee6:	33 1f       	adc	r19, r19
    4ee8:	22 0f       	add	r18, r18
    4eea:	33 1f       	adc	r19, r19
    4eec:	22 0f       	add	r18, r18
    4eee:	33 1f       	adc	r19, r19
    4ef0:	82 0f       	add	r24, r18
    4ef2:	93 1f       	adc	r25, r19
    4ef4:	86 5d       	subi	r24, 0xD6	; 214
    4ef6:	9a 4f       	sbci	r25, 0xFA	; 250
    4ef8:	b8 01       	movw	r22, r16
    4efa:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
    4efe:	07 c0       	rjmp	.+14     	; 0x4f0e <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4f00:	be 01       	movw	r22, r28
    4f02:	64 5f       	subi	r22, 0xF4	; 244
    4f04:	7f 4f       	sbci	r23, 0xFF	; 255
    4f06:	80 e6       	ldi	r24, 0x60	; 96
    4f08:	95 e0       	ldi	r25, 0x05	; 5
    4f0a:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f0e:	e0 91 17 05 	lds	r30, 0x0517
    4f12:	f0 91 18 05 	lds	r31, 0x0518
    4f16:	9e 89       	ldd	r25, Y+22	; 0x16
    4f18:	86 89       	ldd	r24, Z+22	; 0x16
    4f1a:	89 17       	cp	r24, r25
    4f1c:	70 f4       	brcc	.+28     	; 0x4f3a <xTaskGenericNotifyFromISR+0x10e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4f1e:	e1 14       	cp	r14, r1
    4f20:	f1 04       	cpc	r15, r1
    4f22:	19 f0       	breq	.+6      	; 0x4f2a <xTaskGenericNotifyFromISR+0xfe>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4f24:	81 e0       	ldi	r24, 0x01	; 1
    4f26:	f7 01       	movw	r30, r14
    4f28:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4f2a:	81 e0       	ldi	r24, 0x01	; 1
    4f2c:	80 93 1d 05 	sts	0x051D, r24
    4f30:	05 c0       	rjmp	.+10     	; 0x4f3c <xTaskGenericNotifyFromISR+0x110>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4f32:	80 e0       	ldi	r24, 0x00	; 0
    4f34:	03 c0       	rjmp	.+6      	; 0x4f3c <xTaskGenericNotifyFromISR+0x110>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f36:	81 e0       	ldi	r24, 0x01	; 1
    4f38:	01 c0       	rjmp	.+2      	; 0x4f3c <xTaskGenericNotifyFromISR+0x110>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f3a:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    4f3c:	df 91       	pop	r29
    4f3e:	cf 91       	pop	r28
    4f40:	1f 91       	pop	r17
    4f42:	0f 91       	pop	r16
    4f44:	ff 90       	pop	r15
    4f46:	ef 90       	pop	r14
    4f48:	08 95       	ret

00004f4a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4f4a:	ef 92       	push	r14
    4f4c:	ff 92       	push	r15
    4f4e:	0f 93       	push	r16
    4f50:	1f 93       	push	r17
    4f52:	cf 93       	push	r28
    4f54:	df 93       	push	r29
    4f56:	ec 01       	movw	r28, r24
    4f58:	8b 01       	movw	r16, r22

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4f5a:	2d a1       	lds	r18, 0x4d
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4f5c:	82 e0       	ldi	r24, 0x02	; 2
    4f5e:	8d a3       	lds	r24, 0x5d

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4f60:	89 a1       	lds	r24, 0x49
    4f62:	9a a1       	lds	r25, 0x4a
    4f64:	ab a1       	lds	r26, 0x4b
    4f66:	bc a1       	lds	r27, 0x4c
    4f68:	01 96       	adiw	r24, 0x01	; 1
    4f6a:	a1 1d       	adc	r26, r1
    4f6c:	b1 1d       	adc	r27, r1
    4f6e:	89 a3       	lds	r24, 0x59
    4f70:	9a a3       	lds	r25, 0x5a
    4f72:	ab a3       	lds	r26, 0x5b
    4f74:	bc a3       	lds	r27, 0x5c

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f76:	21 30       	cpi	r18, 0x01	; 1
    4f78:	e1 f5       	brne	.+120    	; 0x4ff2 <vTaskNotifyGiveFromISR+0xa8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f7a:	80 91 19 05 	lds	r24, 0x0519
    4f7e:	88 23       	and	r24, r24
    4f80:	01 f5       	brne	.+64     	; 0x4fc2 <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f82:	ee 24       	eor	r14, r14
    4f84:	ff 24       	eor	r15, r15
    4f86:	68 94       	set
    4f88:	e1 f8       	bld	r14, 1
    4f8a:	ec 0e       	add	r14, r28
    4f8c:	fd 1e       	adc	r15, r29
    4f8e:	c7 01       	movw	r24, r14
    4f90:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4f94:	8e 89       	ldd	r24, Y+22	; 0x16
    4f96:	90 91 20 05 	lds	r25, 0x0520
    4f9a:	98 17       	cp	r25, r24
    4f9c:	10 f4       	brcc	.+4      	; 0x4fa2 <vTaskNotifyGiveFromISR+0x58>
    4f9e:	80 93 20 05 	sts	0x0520, r24
    4fa2:	90 e0       	ldi	r25, 0x00	; 0
    4fa4:	9c 01       	movw	r18, r24
    4fa6:	22 0f       	add	r18, r18
    4fa8:	33 1f       	adc	r19, r19
    4faa:	22 0f       	add	r18, r18
    4fac:	33 1f       	adc	r19, r19
    4fae:	22 0f       	add	r18, r18
    4fb0:	33 1f       	adc	r19, r19
    4fb2:	82 0f       	add	r24, r18
    4fb4:	93 1f       	adc	r25, r19
    4fb6:	86 5d       	subi	r24, 0xD6	; 214
    4fb8:	9a 4f       	sbci	r25, 0xFA	; 250
    4fba:	b7 01       	movw	r22, r14
    4fbc:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
    4fc0:	07 c0       	rjmp	.+14     	; 0x4fd0 <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4fc2:	be 01       	movw	r22, r28
    4fc4:	64 5f       	subi	r22, 0xF4	; 244
    4fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    4fc8:	80 e6       	ldi	r24, 0x60	; 96
    4fca:	95 e0       	ldi	r25, 0x05	; 5
    4fcc:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fd0:	e0 91 17 05 	lds	r30, 0x0517
    4fd4:	f0 91 18 05 	lds	r31, 0x0518
    4fd8:	9e 89       	ldd	r25, Y+22	; 0x16
    4fda:	86 89       	ldd	r24, Z+22	; 0x16
    4fdc:	89 17       	cp	r24, r25
    4fde:	48 f4       	brcc	.+18     	; 0x4ff2 <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4fe0:	01 15       	cp	r16, r1
    4fe2:	11 05       	cpc	r17, r1
    4fe4:	19 f0       	breq	.+6      	; 0x4fec <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4fe6:	81 e0       	ldi	r24, 0x01	; 1
    4fe8:	f8 01       	movw	r30, r16
    4fea:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4fec:	81 e0       	ldi	r24, 0x01	; 1
    4fee:	80 93 1d 05 	sts	0x051D, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4ff2:	df 91       	pop	r29
    4ff4:	cf 91       	pop	r28
    4ff6:	1f 91       	pop	r17
    4ff8:	0f 91       	pop	r16
    4ffa:	ff 90       	pop	r15
    4ffc:	ef 90       	pop	r14
    4ffe:	08 95       	ret

00005000 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5000:	00 97       	sbiw	r24, 0x00	; 0
    5002:	29 f4       	brne	.+10     	; 0x500e <xTaskNotifyStateClear+0xe>
    5004:	e0 91 17 05 	lds	r30, 0x0517
    5008:	f0 91 18 05 	lds	r31, 0x0518
    500c:	01 c0       	rjmp	.+2      	; 0x5010 <xTaskNotifyStateClear+0x10>
    500e:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    5010:	0f b6       	in	r0, 0x3f	; 63
    5012:	f8 94       	cli
    5014:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5016:	85 a1       	lds	r24, 0x45
    5018:	82 30       	cpi	r24, 0x02	; 2
    501a:	19 f4       	brne	.+6      	; 0x5022 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    501c:	15 a2       	lds	r17, 0x95
				xReturn = pdPASS;
    501e:	81 e0       	ldi	r24, 0x01	; 1
    5020:	01 c0       	rjmp	.+2      	; 0x5024 <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    5022:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    5024:	0f 90       	pop	r0
    5026:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    5028:	08 95       	ret

0000502a <SOS_Init>:
//static uint8_t u8_is_Started=0;
uint8_t Start_status[Buffer_Size];


ERROR_STATUS SOS_Init (const TMU_ConfigType * ConfigPtr )
{uint8_t u8_channel_ID=ConfigPtr->u8_Timer_channel;
    502a:	0f 93       	push	r16
    502c:	1f 93       	push	r17
    502e:	cf 93       	push	r28
    5030:	df 93       	push	r29
    5032:	ec 01       	movw	r28, r24
    5034:	09 81       	ldd	r16, Y+1	; 0x01
uint8_t ret=E_OK;
/*************************************************************************/
/*			Intializ the required timer identified by the user			 */
/************************************************************************/
u8_Is_Intialized++;
    5036:	80 91 76 05 	lds	r24, 0x0576
    503a:	8f 5f       	subi	r24, 0xFF	; 255
    503c:	80 93 76 05 	sts	0x0576, r24

if(ConfigPtr==NULL){ret=TMU_MODULE+NULL_PTR;}
    5040:	20 97       	sbiw	r28, 0x00	; 0
    5042:	11 f0       	breq	.+4      	; 0x5048 <SOS_Init+0x1e>
uint8_t Start_status[Buffer_Size];


ERROR_STATUS SOS_Init (const TMU_ConfigType * ConfigPtr )
{uint8_t u8_channel_ID=ConfigPtr->u8_Timer_channel;
uint8_t ret=E_OK;
    5044:	10 e0       	ldi	r17, 0x00	; 0
    5046:	01 c0       	rjmp	.+2      	; 0x504a <SOS_Init+0x20>
/*************************************************************************/
/*			Intializ the required timer identified by the user			 */
/************************************************************************/
u8_Is_Intialized++;

if(ConfigPtr==NULL){ret=TMU_MODULE+NULL_PTR;}
    5048:	1a e2       	ldi	r17, 0x2A	; 42
switch(u8_channel_ID)
    504a:	00 23       	and	r16, r16
    504c:	19 f0       	breq	.+6      	; 0x5054 <SOS_Init+0x2a>
    504e:	02 30       	cpi	r16, 0x02	; 2
    5050:	79 f4       	brne	.+30     	; 0x5070 <SOS_Init+0x46>
    5052:	07 c0       	rjmp	.+14     	; 0x5062 <SOS_Init+0x38>
{
	case TIMER_CH0:
			G_interrupt_Enable();
    5054:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
			Timer_Init(&Timer_Configuration0);
    5058:	8a ed       	ldi	r24, 0xDA	; 218
    505a:	90 e0       	ldi	r25, 0x00	; 0
    505c:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Timer_Init>
				break;
    5060:	08 c0       	rjmp	.+16     	; 0x5072 <SOS_Init+0x48>
	case TIMER_CH2:
		G_interrupt_Enable();
    5062:	0e 94 3a 07 	call	0xe74	; 0xe74 <G_interrupt_Enable>
		Timer_Init(&Timer_Configuration2);
    5066:	80 ee       	ldi	r24, 0xE0	; 224
    5068:	90 e0       	ldi	r25, 0x00	; 0
    506a:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Timer_Init>
			break;
    506e:	01 c0       	rjmp	.+2      	; 0x5072 <SOS_Init+0x48>
	default:
			ret+=E_NOK;
    5070:	1f 5f       	subi	r17, 0xFF	; 255

/*************************************************************************/
/*Intializ the required timer identified by the user using required prescaler  */
/************************************************************************/

switch(ConfigPtr->u8_resolution)
    5072:	88 81       	ld	r24, Y
    5074:	81 30       	cpi	r24, 0x01	; 1
    5076:	99 f4       	brne	.+38     	; 0x509e <SOS_Init+0x74>
{
	case TIMER_RESOLUTION_1_MS:
	{
		switch(u8_channel_ID)
    5078:	00 23       	and	r16, r16
    507a:	19 f0       	breq	.+6      	; 0x5082 <SOS_Init+0x58>
    507c:	02 30       	cpi	r16, 0x02	; 2
    507e:	69 f4       	brne	.+26     	; 0x509a <SOS_Init+0x70>
    5080:	06 c0       	rjmp	.+12     	; 0x508e <SOS_Init+0x64>
		{
			case TIMER_CH0 :
		Timer_Start(TIMER_CH0,250);
    5082:	80 e0       	ldi	r24, 0x00	; 0
    5084:	6a ef       	ldi	r22, 0xFA	; 250
    5086:	70 e0       	ldi	r23, 0x00	; 0
    5088:	0e 94 94 10 	call	0x2128	; 0x2128 <Timer_Start>
					//TCNT0=5;
					break;
    508c:	09 c0       	rjmp	.+18     	; 0x50a0 <SOS_Init+0x76>
			case TIMER_CH2 :
				Timer_Start(TIMER_CH2,14);
    508e:	82 e0       	ldi	r24, 0x02	; 2
    5090:	6e e0       	ldi	r22, 0x0E	; 14
    5092:	70 e0       	ldi	r23, 0x00	; 0
    5094:	0e 94 94 10 	call	0x2128	; 0x2128 <Timer_Start>
					break;
    5098:	03 c0       	rjmp	.+6      	; 0x50a0 <SOS_Init+0x76>
			default:
				ret+=E_NOK;
    509a:	1f 5f       	subi	r17, 0xFF	; 255
					break;
    509c:	01 c0       	rjmp	.+2      	; 0x50a0 <SOS_Init+0x76>
	}	
	
	
	
	default:
	ret+=E_NOK;
    509e:	1f 5f       	subi	r17, 0xFF	; 255

/****************************************************************************/
/*      Deal with Errors  to be returned									*/
/***************************************************************************/
return ret;
}
    50a0:	81 2f       	mov	r24, r17
    50a2:	df 91       	pop	r29
    50a4:	cf 91       	pop	r28
    50a6:	1f 91       	pop	r17
    50a8:	0f 91       	pop	r16
    50aa:	08 95       	ret

000050ac <TMU_DeInit>:
	uint8_t ret=E_OK;
	/************************************************************************************************/
	/*1    	De_intialize the timer																	*/
	/*2		make sure this function is not called unless timer was intialized before by  TMU_INIT	*/
	/************************************************************************************************/
if (u8_Is_Intialized==1)
    50ac:	80 91 76 05 	lds	r24, 0x0576
    50b0:	81 30       	cpi	r24, 0x01	; 1
    50b2:	41 f4       	brne	.+16     	; 0x50c4 <TMU_DeInit+0x18>
{/*Make the timer without a clk*/
	Timer_Init(&Timer_Deinit_Configuration0);
    50b4:	84 ed       	ldi	r24, 0xD4	; 212
    50b6:	90 e0       	ldi	r25, 0x00	; 0
    50b8:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <Timer_Init>

	u8_Is_Intialized=0;
    50bc:	10 92 76 05 	sts	0x0576, r1



ERROR_STATUS TMU_DeInit( void )
{
	uint8_t ret=E_OK;
    50c0:	80 e0       	ldi	r24, 0x00	; 0
    50c2:	08 95       	ret
{/*Make the timer without a clk*/
	Timer_Init(&Timer_Deinit_Configuration0);

	u8_Is_Intialized=0;
	
}else if(u8_Is_Intialized>1){ret+=MULTIPLE_INIT;}
    50c4:	82 30       	cpi	r24, 0x02	; 2
    50c6:	10 f0       	brcs	.+4      	; 0x50cc <TMU_DeInit+0x20>
    50c8:	86 e0       	ldi	r24, 0x06	; 6
    50ca:	08 95       	ret
	else{
	ret=E_NOK;
    50cc:	81 e0       	ldi	r24, 0x01	; 1
	}

	
return ret;	
}
    50ce:	08 95       	ret

000050d0 <SOS_Create_Task>:
	/*
	this enables interrupt and start the timer with the required configurations
	and provide the request to request buffer (ptr_to_func,delay) Dispatcher with the call back function needed(consumer)
	and make sure this function must not be excuted unless Init happened and De_init not happened
  	*/
	if(u8_Is_Intialized == 1)
    50d0:	50 91 76 05 	lds	r21, 0x0576
    50d4:	51 30       	cpi	r21, 0x01	; 1
    50d6:	99 f4       	brne	.+38     	; 0x50fe <SOS_Create_Task+0x2e>
	{
		
		
		(Buffer_Array[u8_function_index]).Fuction_consumer=Function_Consumer;
    50d8:	e4 2f       	mov	r30, r20
    50da:	f0 e0       	ldi	r31, 0x00	; 0
    50dc:	ee 0f       	add	r30, r30
    50de:	ff 1f       	adc	r31, r31
    50e0:	ee 0f       	add	r30, r30
    50e2:	ff 1f       	adc	r31, r31
    50e4:	ee 0f       	add	r30, r30
    50e6:	ff 1f       	adc	r31, r31
    50e8:	e1 54       	subi	r30, 0x41	; 65
    50ea:	fa 4f       	sbci	r31, 0xFA	; 250
    50ec:	91 83       	std	Z+1, r25	; 0x01
    50ee:	80 83       	st	Z, r24
		(Buffer_Array[u8_function_index]).preodic=u8_Preodicity;
    50f0:	65 83       	std	Z+5, r22	; 0x05
		(Buffer_Array[u8_function_index]).u16_time_delay=u16_Time_delay;
    50f2:	34 83       	std	Z+4, r19	; 0x04
    50f4:	23 83       	std	Z+3, r18	; 0x03
		(Buffer_Array[u8_function_index]).u8_flag_is_stopped=1;
    50f6:	81 e0       	ldi	r24, 0x01	; 1
    50f8:	82 83       	std	Z+2, r24	; 0x02
	
return ret;	
}

ERROR_STATUS SOS_Create_Task(ptr_to_Fun Function_Consumer,uint8_t  u8_Preodicity,uint8_t u8_function_index,uint16_t u16_Time_delay)
{uint8_t ret=E_OK;
    50fa:	80 e0       	ldi	r24, 0x00	; 0
    50fc:	08 95       	ret
		(Buffer_Array[u8_function_index]).u16_time_delay=u16_Time_delay;
		(Buffer_Array[u8_function_index]).u8_flag_is_stopped=1;
		
		
	}
	else if(u8_Is_Intialized>1){ret+=MULTIPLE_INIT;}else{
    50fe:	52 30       	cpi	r21, 0x02	; 2
    5100:	10 f0       	brcs	.+4      	; 0x5106 <SOS_Create_Task+0x36>
    5102:	86 e0       	ldi	r24, 0x06	; 6
    5104:	08 95       	ret
		ret+=NOT_INIT;
    5106:	84 e0       	ldi	r24, 0x04	; 4
	}

	return ret;
}
    5108:	08 95       	ret

0000510a <SOS_Run>:

ERROR_STATUS SOS_Run(void)
{	uint8_t ret=E_OK;
    510a:	cf 93       	push	r28
    510c:	df 93       	push	r29
	uint16_t u16_Time_needed=0;
	ptr_to_Fun Excuted;
	*//***********************************************************************/
	/*					LOOP upon Buffer Request						*/
	/*********************************************************************/
if (u8Excution_to_be_done==1)
    510e:	80 91 74 05 	lds	r24, 0x0574
    5112:	81 30       	cpi	r24, 0x01	; 1
    5114:	09 f0       	breq	.+2      	; 0x5118 <SOS_Run+0xe>
    5116:	65 c0       	rjmp	.+202    	; 0x51e2 <SOS_Run+0xd8>
{	u8Excution_to_be_done=0;
    5118:	10 92 74 05 	sts	0x0574, r1

		for (u8_FUN_index=0;u8_FUN_index<Buffer_Size;u8_FUN_index++)
    511c:	10 92 75 05 	sts	0x0575, r1
    5120:	20 e0       	ldi	r18, 0x00	; 0
	status_flag =(Buffer_Array[u8_FUN_index]).u8_flag_is_stopped;
	preodic_status_flag=(Buffer_Array[u8_FUN_index]).preodic;
*/
/****************************************************************/
/* check if the event is stopped ... do nothing*/
		if((Buffer_Array[u8_FUN_index]).u8_flag_is_stopped==0){ret=E_OK;}
    5122:	cf eb       	ldi	r28, 0xBF	; 191
    5124:	d5 e0       	ldi	r29, 0x05	; 5
    5126:	30 e0       	ldi	r19, 0x00	; 0
    5128:	f9 01       	movw	r30, r18
    512a:	ee 0f       	add	r30, r30
    512c:	ff 1f       	adc	r31, r31
    512e:	ee 0f       	add	r30, r30
    5130:	ff 1f       	adc	r31, r31
    5132:	ee 0f       	add	r30, r30
    5134:	ff 1f       	adc	r31, r31
    5136:	ec 0f       	add	r30, r28
    5138:	fd 1f       	adc	r31, r29
    513a:	82 81       	ldd	r24, Z+2	; 0x02
    513c:	88 23       	and	r24, r24
    513e:	09 f4       	brne	.+2      	; 0x5142 <SOS_Run+0x38>
    5140:	48 c0       	rjmp	.+144    	; 0x51d2 <SOS_Run+0xc8>
	/*if the timer started .. and condition met excute the consumer*/
	/***************************************************************/
		
	/********************************************/
	/*Count up when flag is set**/
	((Buffer_Array[u8_FUN_index]).u16_Counter)++;
    5142:	f9 01       	movw	r30, r18
    5144:	ee 0f       	add	r30, r30
    5146:	ff 1f       	adc	r31, r31
    5148:	ee 0f       	add	r30, r30
    514a:	ff 1f       	adc	r31, r31
    514c:	ee 0f       	add	r30, r30
    514e:	ff 1f       	adc	r31, r31
    5150:	ec 0f       	add	r30, r28
    5152:	fd 1f       	adc	r31, r29
    5154:	86 81       	ldd	r24, Z+6	; 0x06
    5156:	97 81       	ldd	r25, Z+7	; 0x07
    5158:	ac 01       	movw	r20, r24
    515a:	4f 5f       	subi	r20, 0xFF	; 255
    515c:	5f 4f       	sbci	r21, 0xFF	; 255
    515e:	57 83       	std	Z+7, r21	; 0x07
    5160:	46 83       	std	Z+6, r20	; 0x06
	/*make the flag down*/
							
			
/*	u16Excution_to_be_done=100;  ISR*/
	if(((Buffer_Array[u8_FUN_index]).u16_time_delay) == ((Buffer_Array[u8_FUN_index]).u16_Counter) )
    5162:	83 81       	ldd	r24, Z+3	; 0x03
    5164:	94 81       	ldd	r25, Z+4	; 0x04
    5166:	48 17       	cp	r20, r24
    5168:	59 07       	cpc	r21, r25
    516a:	d1 f4       	brne	.+52     	; 0x51a0 <SOS_Run+0x96>
	{
		((Buffer_Array[u8_FUN_index]).Fuction_consumer)();
    516c:	f9 01       	movw	r30, r18
    516e:	ee 0f       	add	r30, r30
    5170:	ff 1f       	adc	r31, r31
    5172:	ee 0f       	add	r30, r30
    5174:	ff 1f       	adc	r31, r31
    5176:	ee 0f       	add	r30, r30
    5178:	ff 1f       	adc	r31, r31
    517a:	ec 0f       	add	r30, r28
    517c:	fd 1f       	adc	r31, r29
    517e:	01 90       	ld	r0, Z+
    5180:	f0 81       	ld	r31, Z
    5182:	e0 2d       	mov	r30, r0
    5184:	09 95       	icall
	/******************************************/
	/*Make it zero so that it will work the next time at the required time (to stop it of ovf)*/
		(Buffer_Array[u8_FUN_index]).u16_Counter=0;
    5186:	e0 91 75 05 	lds	r30, 0x0575
    518a:	f0 e0       	ldi	r31, 0x00	; 0
    518c:	ee 0f       	add	r30, r30
    518e:	ff 1f       	adc	r31, r31
    5190:	ee 0f       	add	r30, r30
    5192:	ff 1f       	adc	r31, r31
    5194:	ee 0f       	add	r30, r30
    5196:	ff 1f       	adc	r31, r31
    5198:	ec 0f       	add	r30, r28
    519a:	fd 1f       	adc	r31, r29
    519c:	17 82       	std	Z+7, r1	; 0x07
    519e:	16 82       	std	Z+6, r1	; 0x06
		
	/*********************************************************/
	/* if not preodic increment the index after excuteing	*/
	/*********************************************************/

	if((Buffer_Array[u8_FUN_index]).preodic==0)
    51a0:	80 91 75 05 	lds	r24, 0x0575
    51a4:	90 e0       	ldi	r25, 0x00	; 0
    51a6:	fc 01       	movw	r30, r24
    51a8:	ee 0f       	add	r30, r30
    51aa:	ff 1f       	adc	r31, r31
    51ac:	ee 0f       	add	r30, r30
    51ae:	ff 1f       	adc	r31, r31
    51b0:	ee 0f       	add	r30, r30
    51b2:	ff 1f       	adc	r31, r31
    51b4:	ec 0f       	add	r30, r28
    51b6:	fd 1f       	adc	r31, r29
    51b8:	25 81       	ldd	r18, Z+5	; 0x05
    51ba:	22 23       	and	r18, r18
    51bc:	51 f4       	brne	.+20     	; 0x51d2 <SOS_Run+0xc8>
	{
		/*to make it see the next event in the next time
		Also Status_flag =1 so that this function will be stopped
		*/
		(Buffer_Array[u8_FUN_index]).u8_flag_is_stopped=0;	
    51be:	fc 01       	movw	r30, r24
    51c0:	ee 0f       	add	r30, r30
    51c2:	ff 1f       	adc	r31, r31
    51c4:	ee 0f       	add	r30, r30
    51c6:	ff 1f       	adc	r31, r31
    51c8:	ee 0f       	add	r30, r30
    51ca:	ff 1f       	adc	r31, r31
    51cc:	ec 0f       	add	r30, r28
    51ce:	fd 1f       	adc	r31, r29
    51d0:	12 82       	std	Z+2, r1	; 0x02
	/*					LOOP upon Buffer Request						*/
	/*********************************************************************/
if (u8Excution_to_be_done==1)
{	u8Excution_to_be_done=0;

		for (u8_FUN_index=0;u8_FUN_index<Buffer_Size;u8_FUN_index++)
    51d2:	20 91 75 05 	lds	r18, 0x0575
    51d6:	2f 5f       	subi	r18, 0xFF	; 255
    51d8:	20 93 75 05 	sts	0x0575, r18
    51dc:	27 30       	cpi	r18, 0x07	; 7
    51de:	08 f4       	brcc	.+2      	; 0x51e2 <SOS_Run+0xd8>
    51e0:	a2 cf       	rjmp	.-188    	; 0x5126 <SOS_Run+0x1c>

		}		
	}
}	
return ret;
}
    51e2:	80 e0       	ldi	r24, 0x00	; 0
    51e4:	df 91       	pop	r29
    51e6:	cf 91       	pop	r28
    51e8:	08 95       	ret

000051ea <TMU_Stop_Timer>:
{

	/***************************************************/
	/*     Set the stop flag							*/
	/***************************************************/
	(Buffer_Array[u8_function_index]).u8_flag_is_stopped=0;
    51ea:	e8 2f       	mov	r30, r24
    51ec:	f0 e0       	ldi	r31, 0x00	; 0
    51ee:	ee 0f       	add	r30, r30
    51f0:	ff 1f       	adc	r31, r31
    51f2:	ee 0f       	add	r30, r30
    51f4:	ff 1f       	adc	r31, r31
    51f6:	ee 0f       	add	r30, r30
    51f8:	ff 1f       	adc	r31, r31
    51fa:	e1 54       	subi	r30, 0x41	; 65
    51fc:	fa 4f       	sbci	r31, 0xFA	; 250
    51fe:	12 82       	std	Z+2, r1	; 0x02
}
    5200:	08 95       	ret

00005202 <timer_interrupt>:



void timer_interrupt(void)
{
	u8Excution_to_be_done =1;	
    5202:	81 e0       	ldi	r24, 0x01	; 1
    5204:	80 93 74 05 	sts	0x0574, r24
    5208:	08 95       	ret

0000520a <__divsf3>:
    520a:	0c d0       	rcall	.+24     	; 0x5224 <__divsf3x>
    520c:	e6 c0       	rjmp	.+460    	; 0x53da <__fp_round>
    520e:	de d0       	rcall	.+444    	; 0x53cc <__fp_pscB>
    5210:	40 f0       	brcs	.+16     	; 0x5222 <__divsf3+0x18>
    5212:	d5 d0       	rcall	.+426    	; 0x53be <__fp_pscA>
    5214:	30 f0       	brcs	.+12     	; 0x5222 <__divsf3+0x18>
    5216:	21 f4       	brne	.+8      	; 0x5220 <__divsf3+0x16>
    5218:	5f 3f       	cpi	r21, 0xFF	; 255
    521a:	19 f0       	breq	.+6      	; 0x5222 <__divsf3+0x18>
    521c:	c7 c0       	rjmp	.+398    	; 0x53ac <__fp_inf>
    521e:	51 11       	cpse	r21, r1
    5220:	10 c1       	rjmp	.+544    	; 0x5442 <__fp_szero>
    5222:	ca c0       	rjmp	.+404    	; 0x53b8 <__fp_nan>

00005224 <__divsf3x>:
    5224:	eb d0       	rcall	.+470    	; 0x53fc <__fp_split3>
    5226:	98 f3       	brcs	.-26     	; 0x520e <__divsf3+0x4>

00005228 <__divsf3_pse>:
    5228:	99 23       	and	r25, r25
    522a:	c9 f3       	breq	.-14     	; 0x521e <__divsf3+0x14>
    522c:	55 23       	and	r21, r21
    522e:	b1 f3       	breq	.-20     	; 0x521c <__divsf3+0x12>
    5230:	95 1b       	sub	r25, r21
    5232:	55 0b       	sbc	r21, r21
    5234:	bb 27       	eor	r27, r27
    5236:	aa 27       	eor	r26, r26
    5238:	62 17       	cp	r22, r18
    523a:	73 07       	cpc	r23, r19
    523c:	84 07       	cpc	r24, r20
    523e:	38 f0       	brcs	.+14     	; 0x524e <__divsf3_pse+0x26>
    5240:	9f 5f       	subi	r25, 0xFF	; 255
    5242:	5f 4f       	sbci	r21, 0xFF	; 255
    5244:	22 0f       	add	r18, r18
    5246:	33 1f       	adc	r19, r19
    5248:	44 1f       	adc	r20, r20
    524a:	aa 1f       	adc	r26, r26
    524c:	a9 f3       	breq	.-22     	; 0x5238 <__divsf3_pse+0x10>
    524e:	33 d0       	rcall	.+102    	; 0x52b6 <__divsf3_pse+0x8e>
    5250:	0e 2e       	mov	r0, r30
    5252:	3a f0       	brmi	.+14     	; 0x5262 <__divsf3_pse+0x3a>
    5254:	e0 e8       	ldi	r30, 0x80	; 128
    5256:	30 d0       	rcall	.+96     	; 0x52b8 <__divsf3_pse+0x90>
    5258:	91 50       	subi	r25, 0x01	; 1
    525a:	50 40       	sbci	r21, 0x00	; 0
    525c:	e6 95       	lsr	r30
    525e:	00 1c       	adc	r0, r0
    5260:	ca f7       	brpl	.-14     	; 0x5254 <__divsf3_pse+0x2c>
    5262:	29 d0       	rcall	.+82     	; 0x52b6 <__divsf3_pse+0x8e>
    5264:	fe 2f       	mov	r31, r30
    5266:	27 d0       	rcall	.+78     	; 0x52b6 <__divsf3_pse+0x8e>
    5268:	66 0f       	add	r22, r22
    526a:	77 1f       	adc	r23, r23
    526c:	88 1f       	adc	r24, r24
    526e:	bb 1f       	adc	r27, r27
    5270:	26 17       	cp	r18, r22
    5272:	37 07       	cpc	r19, r23
    5274:	48 07       	cpc	r20, r24
    5276:	ab 07       	cpc	r26, r27
    5278:	b0 e8       	ldi	r27, 0x80	; 128
    527a:	09 f0       	breq	.+2      	; 0x527e <__divsf3_pse+0x56>
    527c:	bb 0b       	sbc	r27, r27
    527e:	80 2d       	mov	r24, r0
    5280:	bf 01       	movw	r22, r30
    5282:	ff 27       	eor	r31, r31
    5284:	93 58       	subi	r25, 0x83	; 131
    5286:	5f 4f       	sbci	r21, 0xFF	; 255
    5288:	2a f0       	brmi	.+10     	; 0x5294 <__divsf3_pse+0x6c>
    528a:	9e 3f       	cpi	r25, 0xFE	; 254
    528c:	51 05       	cpc	r21, r1
    528e:	68 f0       	brcs	.+26     	; 0x52aa <__divsf3_pse+0x82>
    5290:	8d c0       	rjmp	.+282    	; 0x53ac <__fp_inf>
    5292:	d7 c0       	rjmp	.+430    	; 0x5442 <__fp_szero>
    5294:	5f 3f       	cpi	r21, 0xFF	; 255
    5296:	ec f3       	brlt	.-6      	; 0x5292 <__divsf3_pse+0x6a>
    5298:	98 3e       	cpi	r25, 0xE8	; 232
    529a:	dc f3       	brlt	.-10     	; 0x5292 <__divsf3_pse+0x6a>
    529c:	86 95       	lsr	r24
    529e:	77 95       	ror	r23
    52a0:	67 95       	ror	r22
    52a2:	b7 95       	ror	r27
    52a4:	f7 95       	ror	r31
    52a6:	9f 5f       	subi	r25, 0xFF	; 255
    52a8:	c9 f7       	brne	.-14     	; 0x529c <__divsf3_pse+0x74>
    52aa:	88 0f       	add	r24, r24
    52ac:	91 1d       	adc	r25, r1
    52ae:	96 95       	lsr	r25
    52b0:	87 95       	ror	r24
    52b2:	97 f9       	bld	r25, 7
    52b4:	08 95       	ret
    52b6:	e1 e0       	ldi	r30, 0x01	; 1
    52b8:	66 0f       	add	r22, r22
    52ba:	77 1f       	adc	r23, r23
    52bc:	88 1f       	adc	r24, r24
    52be:	bb 1f       	adc	r27, r27
    52c0:	62 17       	cp	r22, r18
    52c2:	73 07       	cpc	r23, r19
    52c4:	84 07       	cpc	r24, r20
    52c6:	ba 07       	cpc	r27, r26
    52c8:	20 f0       	brcs	.+8      	; 0x52d2 <__divsf3_pse+0xaa>
    52ca:	62 1b       	sub	r22, r18
    52cc:	73 0b       	sbc	r23, r19
    52ce:	84 0b       	sbc	r24, r20
    52d0:	ba 0b       	sbc	r27, r26
    52d2:	ee 1f       	adc	r30, r30
    52d4:	88 f7       	brcc	.-30     	; 0x52b8 <__divsf3_pse+0x90>
    52d6:	e0 95       	com	r30
    52d8:	08 95       	ret

000052da <__fixunssfsi>:
    52da:	98 d0       	rcall	.+304    	; 0x540c <__fp_splitA>
    52dc:	88 f0       	brcs	.+34     	; 0x5300 <__fixunssfsi+0x26>
    52de:	9f 57       	subi	r25, 0x7F	; 127
    52e0:	90 f0       	brcs	.+36     	; 0x5306 <__fixunssfsi+0x2c>
    52e2:	b9 2f       	mov	r27, r25
    52e4:	99 27       	eor	r25, r25
    52e6:	b7 51       	subi	r27, 0x17	; 23
    52e8:	a0 f0       	brcs	.+40     	; 0x5312 <__fixunssfsi+0x38>
    52ea:	d1 f0       	breq	.+52     	; 0x5320 <__fixunssfsi+0x46>
    52ec:	66 0f       	add	r22, r22
    52ee:	77 1f       	adc	r23, r23
    52f0:	88 1f       	adc	r24, r24
    52f2:	99 1f       	adc	r25, r25
    52f4:	1a f0       	brmi	.+6      	; 0x52fc <__fixunssfsi+0x22>
    52f6:	ba 95       	dec	r27
    52f8:	c9 f7       	brne	.-14     	; 0x52ec <__fixunssfsi+0x12>
    52fa:	12 c0       	rjmp	.+36     	; 0x5320 <__fixunssfsi+0x46>
    52fc:	b1 30       	cpi	r27, 0x01	; 1
    52fe:	81 f0       	breq	.+32     	; 0x5320 <__fixunssfsi+0x46>
    5300:	9f d0       	rcall	.+318    	; 0x5440 <__fp_zero>
    5302:	b1 e0       	ldi	r27, 0x01	; 1
    5304:	08 95       	ret
    5306:	9c c0       	rjmp	.+312    	; 0x5440 <__fp_zero>
    5308:	67 2f       	mov	r22, r23
    530a:	78 2f       	mov	r23, r24
    530c:	88 27       	eor	r24, r24
    530e:	b8 5f       	subi	r27, 0xF8	; 248
    5310:	39 f0       	breq	.+14     	; 0x5320 <__fixunssfsi+0x46>
    5312:	b9 3f       	cpi	r27, 0xF9	; 249
    5314:	cc f3       	brlt	.-14     	; 0x5308 <__fixunssfsi+0x2e>
    5316:	86 95       	lsr	r24
    5318:	77 95       	ror	r23
    531a:	67 95       	ror	r22
    531c:	b3 95       	inc	r27
    531e:	d9 f7       	brne	.-10     	; 0x5316 <__fixunssfsi+0x3c>
    5320:	3e f4       	brtc	.+14     	; 0x5330 <__fixunssfsi+0x56>
    5322:	90 95       	com	r25
    5324:	80 95       	com	r24
    5326:	70 95       	com	r23
    5328:	61 95       	neg	r22
    532a:	7f 4f       	sbci	r23, 0xFF	; 255
    532c:	8f 4f       	sbci	r24, 0xFF	; 255
    532e:	9f 4f       	sbci	r25, 0xFF	; 255
    5330:	08 95       	ret

00005332 <__floatunsisf>:
    5332:	e8 94       	clt
    5334:	09 c0       	rjmp	.+18     	; 0x5348 <__floatsisf+0x12>

00005336 <__floatsisf>:
    5336:	97 fb       	bst	r25, 7
    5338:	3e f4       	brtc	.+14     	; 0x5348 <__floatsisf+0x12>
    533a:	90 95       	com	r25
    533c:	80 95       	com	r24
    533e:	70 95       	com	r23
    5340:	61 95       	neg	r22
    5342:	7f 4f       	sbci	r23, 0xFF	; 255
    5344:	8f 4f       	sbci	r24, 0xFF	; 255
    5346:	9f 4f       	sbci	r25, 0xFF	; 255
    5348:	99 23       	and	r25, r25
    534a:	a9 f0       	breq	.+42     	; 0x5376 <__floatsisf+0x40>
    534c:	f9 2f       	mov	r31, r25
    534e:	96 e9       	ldi	r25, 0x96	; 150
    5350:	bb 27       	eor	r27, r27
    5352:	93 95       	inc	r25
    5354:	f6 95       	lsr	r31
    5356:	87 95       	ror	r24
    5358:	77 95       	ror	r23
    535a:	67 95       	ror	r22
    535c:	b7 95       	ror	r27
    535e:	f1 11       	cpse	r31, r1
    5360:	f8 cf       	rjmp	.-16     	; 0x5352 <__floatsisf+0x1c>
    5362:	fa f4       	brpl	.+62     	; 0x53a2 <__floatsisf+0x6c>
    5364:	bb 0f       	add	r27, r27
    5366:	11 f4       	brne	.+4      	; 0x536c <__floatsisf+0x36>
    5368:	60 ff       	sbrs	r22, 0
    536a:	1b c0       	rjmp	.+54     	; 0x53a2 <__floatsisf+0x6c>
    536c:	6f 5f       	subi	r22, 0xFF	; 255
    536e:	7f 4f       	sbci	r23, 0xFF	; 255
    5370:	8f 4f       	sbci	r24, 0xFF	; 255
    5372:	9f 4f       	sbci	r25, 0xFF	; 255
    5374:	16 c0       	rjmp	.+44     	; 0x53a2 <__floatsisf+0x6c>
    5376:	88 23       	and	r24, r24
    5378:	11 f0       	breq	.+4      	; 0x537e <__floatsisf+0x48>
    537a:	96 e9       	ldi	r25, 0x96	; 150
    537c:	11 c0       	rjmp	.+34     	; 0x53a0 <__floatsisf+0x6a>
    537e:	77 23       	and	r23, r23
    5380:	21 f0       	breq	.+8      	; 0x538a <__floatsisf+0x54>
    5382:	9e e8       	ldi	r25, 0x8E	; 142
    5384:	87 2f       	mov	r24, r23
    5386:	76 2f       	mov	r23, r22
    5388:	05 c0       	rjmp	.+10     	; 0x5394 <__floatsisf+0x5e>
    538a:	66 23       	and	r22, r22
    538c:	71 f0       	breq	.+28     	; 0x53aa <__floatsisf+0x74>
    538e:	96 e8       	ldi	r25, 0x86	; 134
    5390:	86 2f       	mov	r24, r22
    5392:	70 e0       	ldi	r23, 0x00	; 0
    5394:	60 e0       	ldi	r22, 0x00	; 0
    5396:	2a f0       	brmi	.+10     	; 0x53a2 <__floatsisf+0x6c>
    5398:	9a 95       	dec	r25
    539a:	66 0f       	add	r22, r22
    539c:	77 1f       	adc	r23, r23
    539e:	88 1f       	adc	r24, r24
    53a0:	da f7       	brpl	.-10     	; 0x5398 <__floatsisf+0x62>
    53a2:	88 0f       	add	r24, r24
    53a4:	96 95       	lsr	r25
    53a6:	87 95       	ror	r24
    53a8:	97 f9       	bld	r25, 7
    53aa:	08 95       	ret

000053ac <__fp_inf>:
    53ac:	97 f9       	bld	r25, 7
    53ae:	9f 67       	ori	r25, 0x7F	; 127
    53b0:	80 e8       	ldi	r24, 0x80	; 128
    53b2:	70 e0       	ldi	r23, 0x00	; 0
    53b4:	60 e0       	ldi	r22, 0x00	; 0
    53b6:	08 95       	ret

000053b8 <__fp_nan>:
    53b8:	9f ef       	ldi	r25, 0xFF	; 255
    53ba:	80 ec       	ldi	r24, 0xC0	; 192
    53bc:	08 95       	ret

000053be <__fp_pscA>:
    53be:	00 24       	eor	r0, r0
    53c0:	0a 94       	dec	r0
    53c2:	16 16       	cp	r1, r22
    53c4:	17 06       	cpc	r1, r23
    53c6:	18 06       	cpc	r1, r24
    53c8:	09 06       	cpc	r0, r25
    53ca:	08 95       	ret

000053cc <__fp_pscB>:
    53cc:	00 24       	eor	r0, r0
    53ce:	0a 94       	dec	r0
    53d0:	12 16       	cp	r1, r18
    53d2:	13 06       	cpc	r1, r19
    53d4:	14 06       	cpc	r1, r20
    53d6:	05 06       	cpc	r0, r21
    53d8:	08 95       	ret

000053da <__fp_round>:
    53da:	09 2e       	mov	r0, r25
    53dc:	03 94       	inc	r0
    53de:	00 0c       	add	r0, r0
    53e0:	11 f4       	brne	.+4      	; 0x53e6 <__fp_round+0xc>
    53e2:	88 23       	and	r24, r24
    53e4:	52 f0       	brmi	.+20     	; 0x53fa <__fp_round+0x20>
    53e6:	bb 0f       	add	r27, r27
    53e8:	40 f4       	brcc	.+16     	; 0x53fa <__fp_round+0x20>
    53ea:	bf 2b       	or	r27, r31
    53ec:	11 f4       	brne	.+4      	; 0x53f2 <__fp_round+0x18>
    53ee:	60 ff       	sbrs	r22, 0
    53f0:	04 c0       	rjmp	.+8      	; 0x53fa <__fp_round+0x20>
    53f2:	6f 5f       	subi	r22, 0xFF	; 255
    53f4:	7f 4f       	sbci	r23, 0xFF	; 255
    53f6:	8f 4f       	sbci	r24, 0xFF	; 255
    53f8:	9f 4f       	sbci	r25, 0xFF	; 255
    53fa:	08 95       	ret

000053fc <__fp_split3>:
    53fc:	57 fd       	sbrc	r21, 7
    53fe:	90 58       	subi	r25, 0x80	; 128
    5400:	44 0f       	add	r20, r20
    5402:	55 1f       	adc	r21, r21
    5404:	59 f0       	breq	.+22     	; 0x541c <__fp_splitA+0x10>
    5406:	5f 3f       	cpi	r21, 0xFF	; 255
    5408:	71 f0       	breq	.+28     	; 0x5426 <__fp_splitA+0x1a>
    540a:	47 95       	ror	r20

0000540c <__fp_splitA>:
    540c:	88 0f       	add	r24, r24
    540e:	97 fb       	bst	r25, 7
    5410:	99 1f       	adc	r25, r25
    5412:	61 f0       	breq	.+24     	; 0x542c <__fp_splitA+0x20>
    5414:	9f 3f       	cpi	r25, 0xFF	; 255
    5416:	79 f0       	breq	.+30     	; 0x5436 <__fp_splitA+0x2a>
    5418:	87 95       	ror	r24
    541a:	08 95       	ret
    541c:	12 16       	cp	r1, r18
    541e:	13 06       	cpc	r1, r19
    5420:	14 06       	cpc	r1, r20
    5422:	55 1f       	adc	r21, r21
    5424:	f2 cf       	rjmp	.-28     	; 0x540a <__fp_split3+0xe>
    5426:	46 95       	lsr	r20
    5428:	f1 df       	rcall	.-30     	; 0x540c <__fp_splitA>
    542a:	08 c0       	rjmp	.+16     	; 0x543c <__fp_splitA+0x30>
    542c:	16 16       	cp	r1, r22
    542e:	17 06       	cpc	r1, r23
    5430:	18 06       	cpc	r1, r24
    5432:	99 1f       	adc	r25, r25
    5434:	f1 cf       	rjmp	.-30     	; 0x5418 <__fp_splitA+0xc>
    5436:	86 95       	lsr	r24
    5438:	71 05       	cpc	r23, r1
    543a:	61 05       	cpc	r22, r1
    543c:	08 94       	sec
    543e:	08 95       	ret

00005440 <__fp_zero>:
    5440:	e8 94       	clt

00005442 <__fp_szero>:
    5442:	bb 27       	eor	r27, r27
    5444:	66 27       	eor	r22, r22
    5446:	77 27       	eor	r23, r23
    5448:	cb 01       	movw	r24, r22
    544a:	97 f9       	bld	r25, 7
    544c:	08 95       	ret

0000544e <__mulsf3>:
    544e:	0b d0       	rcall	.+22     	; 0x5466 <__mulsf3x>
    5450:	c4 cf       	rjmp	.-120    	; 0x53da <__fp_round>
    5452:	b5 df       	rcall	.-150    	; 0x53be <__fp_pscA>
    5454:	28 f0       	brcs	.+10     	; 0x5460 <__mulsf3+0x12>
    5456:	ba df       	rcall	.-140    	; 0x53cc <__fp_pscB>
    5458:	18 f0       	brcs	.+6      	; 0x5460 <__mulsf3+0x12>
    545a:	95 23       	and	r25, r21
    545c:	09 f0       	breq	.+2      	; 0x5460 <__mulsf3+0x12>
    545e:	a6 cf       	rjmp	.-180    	; 0x53ac <__fp_inf>
    5460:	ab cf       	rjmp	.-170    	; 0x53b8 <__fp_nan>
    5462:	11 24       	eor	r1, r1
    5464:	ee cf       	rjmp	.-36     	; 0x5442 <__fp_szero>

00005466 <__mulsf3x>:
    5466:	ca df       	rcall	.-108    	; 0x53fc <__fp_split3>
    5468:	a0 f3       	brcs	.-24     	; 0x5452 <__mulsf3+0x4>

0000546a <__mulsf3_pse>:
    546a:	95 9f       	mul	r25, r21
    546c:	d1 f3       	breq	.-12     	; 0x5462 <__mulsf3+0x14>
    546e:	95 0f       	add	r25, r21
    5470:	50 e0       	ldi	r21, 0x00	; 0
    5472:	55 1f       	adc	r21, r21
    5474:	62 9f       	mul	r22, r18
    5476:	f0 01       	movw	r30, r0
    5478:	72 9f       	mul	r23, r18
    547a:	bb 27       	eor	r27, r27
    547c:	f0 0d       	add	r31, r0
    547e:	b1 1d       	adc	r27, r1
    5480:	63 9f       	mul	r22, r19
    5482:	aa 27       	eor	r26, r26
    5484:	f0 0d       	add	r31, r0
    5486:	b1 1d       	adc	r27, r1
    5488:	aa 1f       	adc	r26, r26
    548a:	64 9f       	mul	r22, r20
    548c:	66 27       	eor	r22, r22
    548e:	b0 0d       	add	r27, r0
    5490:	a1 1d       	adc	r26, r1
    5492:	66 1f       	adc	r22, r22
    5494:	82 9f       	mul	r24, r18
    5496:	22 27       	eor	r18, r18
    5498:	b0 0d       	add	r27, r0
    549a:	a1 1d       	adc	r26, r1
    549c:	62 1f       	adc	r22, r18
    549e:	73 9f       	mul	r23, r19
    54a0:	b0 0d       	add	r27, r0
    54a2:	a1 1d       	adc	r26, r1
    54a4:	62 1f       	adc	r22, r18
    54a6:	83 9f       	mul	r24, r19
    54a8:	a0 0d       	add	r26, r0
    54aa:	61 1d       	adc	r22, r1
    54ac:	22 1f       	adc	r18, r18
    54ae:	74 9f       	mul	r23, r20
    54b0:	33 27       	eor	r19, r19
    54b2:	a0 0d       	add	r26, r0
    54b4:	61 1d       	adc	r22, r1
    54b6:	23 1f       	adc	r18, r19
    54b8:	84 9f       	mul	r24, r20
    54ba:	60 0d       	add	r22, r0
    54bc:	21 1d       	adc	r18, r1
    54be:	82 2f       	mov	r24, r18
    54c0:	76 2f       	mov	r23, r22
    54c2:	6a 2f       	mov	r22, r26
    54c4:	11 24       	eor	r1, r1
    54c6:	9f 57       	subi	r25, 0x7F	; 127
    54c8:	50 40       	sbci	r21, 0x00	; 0
    54ca:	8a f0       	brmi	.+34     	; 0x54ee <__mulsf3_pse+0x84>
    54cc:	e1 f0       	breq	.+56     	; 0x5506 <__mulsf3_pse+0x9c>
    54ce:	88 23       	and	r24, r24
    54d0:	4a f0       	brmi	.+18     	; 0x54e4 <__mulsf3_pse+0x7a>
    54d2:	ee 0f       	add	r30, r30
    54d4:	ff 1f       	adc	r31, r31
    54d6:	bb 1f       	adc	r27, r27
    54d8:	66 1f       	adc	r22, r22
    54da:	77 1f       	adc	r23, r23
    54dc:	88 1f       	adc	r24, r24
    54de:	91 50       	subi	r25, 0x01	; 1
    54e0:	50 40       	sbci	r21, 0x00	; 0
    54e2:	a9 f7       	brne	.-22     	; 0x54ce <__mulsf3_pse+0x64>
    54e4:	9e 3f       	cpi	r25, 0xFE	; 254
    54e6:	51 05       	cpc	r21, r1
    54e8:	70 f0       	brcs	.+28     	; 0x5506 <__mulsf3_pse+0x9c>
    54ea:	60 cf       	rjmp	.-320    	; 0x53ac <__fp_inf>
    54ec:	aa cf       	rjmp	.-172    	; 0x5442 <__fp_szero>
    54ee:	5f 3f       	cpi	r21, 0xFF	; 255
    54f0:	ec f3       	brlt	.-6      	; 0x54ec <__mulsf3_pse+0x82>
    54f2:	98 3e       	cpi	r25, 0xE8	; 232
    54f4:	dc f3       	brlt	.-10     	; 0x54ec <__mulsf3_pse+0x82>
    54f6:	86 95       	lsr	r24
    54f8:	77 95       	ror	r23
    54fa:	67 95       	ror	r22
    54fc:	b7 95       	ror	r27
    54fe:	f7 95       	ror	r31
    5500:	e7 95       	ror	r30
    5502:	9f 5f       	subi	r25, 0xFF	; 255
    5504:	c1 f7       	brne	.-16     	; 0x54f6 <__mulsf3_pse+0x8c>
    5506:	fe 2b       	or	r31, r30
    5508:	88 0f       	add	r24, r24
    550a:	91 1d       	adc	r25, r1
    550c:	96 95       	lsr	r25
    550e:	87 95       	ror	r24
    5510:	97 f9       	bld	r25, 7
    5512:	08 95       	ret

00005514 <__mulsi3>:
    5514:	62 9f       	mul	r22, r18
    5516:	d0 01       	movw	r26, r0
    5518:	73 9f       	mul	r23, r19
    551a:	f0 01       	movw	r30, r0
    551c:	82 9f       	mul	r24, r18
    551e:	e0 0d       	add	r30, r0
    5520:	f1 1d       	adc	r31, r1
    5522:	64 9f       	mul	r22, r20
    5524:	e0 0d       	add	r30, r0
    5526:	f1 1d       	adc	r31, r1
    5528:	92 9f       	mul	r25, r18
    552a:	f0 0d       	add	r31, r0
    552c:	83 9f       	mul	r24, r19
    552e:	f0 0d       	add	r31, r0
    5530:	74 9f       	mul	r23, r20
    5532:	f0 0d       	add	r31, r0
    5534:	65 9f       	mul	r22, r21
    5536:	f0 0d       	add	r31, r0
    5538:	99 27       	eor	r25, r25
    553a:	72 9f       	mul	r23, r18
    553c:	b0 0d       	add	r27, r0
    553e:	e1 1d       	adc	r30, r1
    5540:	f9 1f       	adc	r31, r25
    5542:	63 9f       	mul	r22, r19
    5544:	b0 0d       	add	r27, r0
    5546:	e1 1d       	adc	r30, r1
    5548:	f9 1f       	adc	r31, r25
    554a:	bd 01       	movw	r22, r26
    554c:	cf 01       	movw	r24, r30
    554e:	11 24       	eor	r1, r1
    5550:	08 95       	ret

00005552 <__udivmodhi4>:
    5552:	aa 1b       	sub	r26, r26
    5554:	bb 1b       	sub	r27, r27
    5556:	51 e1       	ldi	r21, 0x11	; 17
    5558:	07 c0       	rjmp	.+14     	; 0x5568 <__udivmodhi4_ep>

0000555a <__udivmodhi4_loop>:
    555a:	aa 1f       	adc	r26, r26
    555c:	bb 1f       	adc	r27, r27
    555e:	a6 17       	cp	r26, r22
    5560:	b7 07       	cpc	r27, r23
    5562:	10 f0       	brcs	.+4      	; 0x5568 <__udivmodhi4_ep>
    5564:	a6 1b       	sub	r26, r22
    5566:	b7 0b       	sbc	r27, r23

00005568 <__udivmodhi4_ep>:
    5568:	88 1f       	adc	r24, r24
    556a:	99 1f       	adc	r25, r25
    556c:	5a 95       	dec	r21
    556e:	a9 f7       	brne	.-22     	; 0x555a <__udivmodhi4_loop>
    5570:	80 95       	com	r24
    5572:	90 95       	com	r25
    5574:	bc 01       	movw	r22, r24
    5576:	cd 01       	movw	r24, r26
    5578:	08 95       	ret

0000557a <__udivmodsi4>:
    557a:	a1 e2       	ldi	r26, 0x21	; 33
    557c:	1a 2e       	mov	r1, r26
    557e:	aa 1b       	sub	r26, r26
    5580:	bb 1b       	sub	r27, r27
    5582:	fd 01       	movw	r30, r26
    5584:	0d c0       	rjmp	.+26     	; 0x55a0 <__udivmodsi4_ep>

00005586 <__udivmodsi4_loop>:
    5586:	aa 1f       	adc	r26, r26
    5588:	bb 1f       	adc	r27, r27
    558a:	ee 1f       	adc	r30, r30
    558c:	ff 1f       	adc	r31, r31
    558e:	a2 17       	cp	r26, r18
    5590:	b3 07       	cpc	r27, r19
    5592:	e4 07       	cpc	r30, r20
    5594:	f5 07       	cpc	r31, r21
    5596:	20 f0       	brcs	.+8      	; 0x55a0 <__udivmodsi4_ep>
    5598:	a2 1b       	sub	r26, r18
    559a:	b3 0b       	sbc	r27, r19
    559c:	e4 0b       	sbc	r30, r20
    559e:	f5 0b       	sbc	r31, r21

000055a0 <__udivmodsi4_ep>:
    55a0:	66 1f       	adc	r22, r22
    55a2:	77 1f       	adc	r23, r23
    55a4:	88 1f       	adc	r24, r24
    55a6:	99 1f       	adc	r25, r25
    55a8:	1a 94       	dec	r1
    55aa:	69 f7       	brne	.-38     	; 0x5586 <__udivmodsi4_loop>
    55ac:	60 95       	com	r22
    55ae:	70 95       	com	r23
    55b0:	80 95       	com	r24
    55b2:	90 95       	com	r25
    55b4:	9b 01       	movw	r18, r22
    55b6:	ac 01       	movw	r20, r24
    55b8:	bd 01       	movw	r22, r26
    55ba:	cf 01       	movw	r24, r30
    55bc:	08 95       	ret

000055be <memcpy>:
    55be:	fb 01       	movw	r30, r22
    55c0:	dc 01       	movw	r26, r24
    55c2:	02 c0       	rjmp	.+4      	; 0x55c8 <memcpy+0xa>
    55c4:	01 90       	ld	r0, Z+
    55c6:	0d 92       	st	X+, r0
    55c8:	41 50       	subi	r20, 0x01	; 1
    55ca:	50 40       	sbci	r21, 0x00	; 0
    55cc:	d8 f7       	brcc	.-10     	; 0x55c4 <memcpy+0x6>
    55ce:	08 95       	ret

000055d0 <_exit>:
    55d0:	f8 94       	cli

000055d2 <__stop_program>:
    55d2:	ff cf       	rjmp	.-2      	; 0x55d2 <__stop_program>
